{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { DEFAULT_VALID_COLOR, DIALECT, HIGHLIGHT_OPACITY, HIGHLIGHT_STROKEWIDTH } from '../../util/Constants';\nimport InternalEvent from '../event/InternalEvent';\nimport Rectangle from '../geometry/Rectangle';\n/**\n * A helper class to highlight cells. Here is an example for a given cell.\n *\n * ```javascript\n * var highlight = new mxCellHighlight(graph, '#ff0000', 2);\n * highlight.highlight(graph.view.getState(cell)));\n * ```\n */\nclass CellHighlight {\n  constructor(graph, highlightColor, strokeWidth, dashed) {\n    this.strokeWidth = 0;\n    this.dashed = false;\n    this.opacity = 100;\n    this.shape = null;\n    /**\n     * Specifies if the highlights should appear on top of everything else in the overlay pane.\n     * @default false\n     */\n    this.keepOnTop = false;\n    /**\n     * Reference to the {@link CellState}.\n     * @default null\n     */\n    this.state = null;\n    /**\n     * Specifies the spacing between the highlight for vertices and the vertex.\n     * @default 2\n     */\n    this.spacing = 2;\n    this.graph = graph;\n    this.highlightColor = highlightColor ?? DEFAULT_VALID_COLOR;\n    this.strokeWidth = strokeWidth ?? HIGHLIGHT_STROKEWIDTH;\n    this.dashed = dashed ?? false;\n    this.opacity = HIGHLIGHT_OPACITY;\n    // Updates the marker if the graph changes\n    this.repaintHandler = () => {\n      // Updates reference to state\n      if (this.state) {\n        const tmp = this.graph.view.getState(this.state.cell);\n        if (!tmp) {\n          this.hide();\n        } else {\n          this.state = tmp;\n          this.repaint();\n        }\n      }\n    };\n    this.graph.getView().addListener(InternalEvent.SCALE, this.repaintHandler);\n    this.graph.getView().addListener(InternalEvent.TRANSLATE, this.repaintHandler);\n    this.graph.getView().addListener(InternalEvent.SCALE_AND_TRANSLATE, this.repaintHandler);\n    this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.repaintHandler);\n    // Hides the marker if the current root changes\n    this.resetHandler = () => {\n      this.hide();\n    };\n    this.graph.getView().addListener(InternalEvent.DOWN, this.resetHandler);\n    this.graph.getView().addListener(InternalEvent.UP, this.resetHandler);\n  }\n  /**\n   * Sets the color of the rectangle used to highlight drop targets.\n   *\n   * @param {string} color - String that represents the new highlight color.\n   */\n  setHighlightColor(color) {\n    this.highlightColor = color;\n    if (this.shape) {\n      this.shape.stroke = color;\n    }\n  }\n  /**\n   * Creates and returns the highlight shape for the given state.\n   */\n  drawHighlight() {\n    this.shape = this.createShape();\n    this.repaint();\n    if (this.shape) {\n      const node = this.shape.node;\n      if (!this.keepOnTop && node?.parentNode?.firstChild !== node && node.parentNode) {\n        node.parentNode.insertBefore(node, node.parentNode.firstChild);\n      }\n    }\n  }\n  /**\n   * Creates and returns the highlight shape for the given state.\n   */\n  createShape() {\n    if (!this.state) return null;\n    const shape = this.graph.cellRenderer.createShape(this.state);\n    shape.svgStrokeTolerance = this.graph.getEventTolerance();\n    shape.points = this.state.absolutePoints;\n    shape.apply(this.state);\n    shape.stroke = this.highlightColor;\n    shape.opacity = this.opacity;\n    shape.isDashed = this.dashed;\n    shape.isShadow = false;\n    shape.dialect = DIALECT.SVG;\n    shape.init(this.graph.getView().getOverlayPane());\n    InternalEvent.redirectMouseEvents(shape.node, this.graph, this.state);\n    if (this.graph.dialect !== DIALECT.SVG) {\n      shape.pointerEvents = false;\n    } else {\n      shape.svgPointerEvents = 'stroke';\n    }\n    return shape;\n  }\n  /**\n   * Updates the highlight after a change of the model or view.\n   */\n  getStrokeWidth(state = null) {\n    return this.strokeWidth;\n  }\n  /**\n   * Updates the highlight after a change of the model or view.\n   */\n  repaint() {\n    if (this.state && this.shape) {\n      this.shape.scale = this.state.view.scale;\n      if (this.state.cell.isEdge()) {\n        this.shape.strokeWidth = this.getStrokeWidth();\n        this.shape.points = this.state.absolutePoints;\n        this.shape.outline = false;\n      } else {\n        this.shape.bounds = new Rectangle(this.state.x - this.spacing, this.state.y - this.spacing, this.state.width + 2 * this.spacing, this.state.height + 2 * this.spacing);\n        this.shape.rotation = this.state.style.rotation ?? 0;\n        this.shape.strokeWidth = this.getStrokeWidth() / this.state.view.scale;\n        this.shape.outline = true;\n      }\n      // Uses cursor from shape in highlight\n      if (this.state.shape) {\n        this.shape.setCursor(this.state.shape.getCursor());\n      }\n      this.shape.redraw();\n    }\n  }\n  /**\n   * Resets the state of the cell marker.\n   */\n  hide() {\n    this.highlight(null);\n  }\n  /**\n   * Marks the {@link arkedState} and fires a {@link ark} event.\n   */\n  highlight(state = null) {\n    if (this.state !== state) {\n      if (this.shape) {\n        this.shape.destroy();\n        this.shape = null;\n      }\n      this.state = state;\n      if (this.state) {\n        this.drawHighlight();\n      }\n    }\n  }\n  /**\n   * Returns true if this highlight is at the given position.\n   */\n  isHighlightAt(x, y) {\n    let hit = false;\n    if (this.shape && document.elementFromPoint) {\n      let elt = document.elementFromPoint(x, y);\n      while (elt) {\n        if (elt === this.shape.node) {\n          hit = true;\n          break;\n        }\n        elt = elt.parentNode;\n      }\n    }\n    return hit;\n  }\n  /**\n   * Destroys the handler and all its resources and DOM nodes.\n   */\n  destroy() {\n    const graph = this.graph;\n    graph.getView().removeListener(this.resetHandler);\n    graph.getView().removeListener(this.repaintHandler);\n    graph.getDataModel().removeListener(this.repaintHandler);\n    if (this.shape) {\n      this.shape.destroy();\n      this.shape = null;\n    }\n  }\n}\nexport default CellHighlight;","map":{"version":3,"names":["DEFAULT_VALID_COLOR","DIALECT","HIGHLIGHT_OPACITY","HIGHLIGHT_STROKEWIDTH","InternalEvent","Rectangle","CellHighlight","constructor","graph","highlightColor","strokeWidth","dashed","opacity","shape","keepOnTop","state","spacing","repaintHandler","tmp","view","getState","cell","hide","repaint","getView","addListener","SCALE","TRANSLATE","SCALE_AND_TRANSLATE","getDataModel","CHANGE","resetHandler","DOWN","UP","setHighlightColor","color","stroke","drawHighlight","createShape","node","parentNode","firstChild","insertBefore","cellRenderer","svgStrokeTolerance","getEventTolerance","points","absolutePoints","apply","isDashed","isShadow","dialect","SVG","init","getOverlayPane","redirectMouseEvents","pointerEvents","svgPointerEvents","getStrokeWidth","scale","isEdge","outline","bounds","x","y","width","height","rotation","style","setCursor","getCursor","redraw","highlight","destroy","isHighlightAt","hit","document","elementFromPoint","elt","removeListener"],"sources":["D:/OSPanel/domains/old/react/react-intro-main/node_modules/@maxgraph/core/dist/view/cell/CellHighlight.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { DEFAULT_VALID_COLOR, DIALECT, HIGHLIGHT_OPACITY, HIGHLIGHT_STROKEWIDTH, } from '../../util/Constants';\nimport InternalEvent from '../event/InternalEvent';\nimport Rectangle from '../geometry/Rectangle';\n/**\n * A helper class to highlight cells. Here is an example for a given cell.\n *\n * ```javascript\n * var highlight = new mxCellHighlight(graph, '#ff0000', 2);\n * highlight.highlight(graph.view.getState(cell)));\n * ```\n */\nclass CellHighlight {\n    constructor(graph, highlightColor, strokeWidth, dashed) {\n        this.strokeWidth = 0;\n        this.dashed = false;\n        this.opacity = 100;\n        this.shape = null;\n        /**\n         * Specifies if the highlights should appear on top of everything else in the overlay pane.\n         * @default false\n         */\n        this.keepOnTop = false;\n        /**\n         * Reference to the {@link CellState}.\n         * @default null\n         */\n        this.state = null;\n        /**\n         * Specifies the spacing between the highlight for vertices and the vertex.\n         * @default 2\n         */\n        this.spacing = 2;\n        this.graph = graph;\n        this.highlightColor = highlightColor ?? DEFAULT_VALID_COLOR;\n        this.strokeWidth = strokeWidth ?? HIGHLIGHT_STROKEWIDTH;\n        this.dashed = dashed ?? false;\n        this.opacity = HIGHLIGHT_OPACITY;\n        // Updates the marker if the graph changes\n        this.repaintHandler = () => {\n            // Updates reference to state\n            if (this.state) {\n                const tmp = this.graph.view.getState(this.state.cell);\n                if (!tmp) {\n                    this.hide();\n                }\n                else {\n                    this.state = tmp;\n                    this.repaint();\n                }\n            }\n        };\n        this.graph.getView().addListener(InternalEvent.SCALE, this.repaintHandler);\n        this.graph.getView().addListener(InternalEvent.TRANSLATE, this.repaintHandler);\n        this.graph\n            .getView()\n            .addListener(InternalEvent.SCALE_AND_TRANSLATE, this.repaintHandler);\n        this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.repaintHandler);\n        // Hides the marker if the current root changes\n        this.resetHandler = () => {\n            this.hide();\n        };\n        this.graph.getView().addListener(InternalEvent.DOWN, this.resetHandler);\n        this.graph.getView().addListener(InternalEvent.UP, this.resetHandler);\n    }\n    /**\n     * Sets the color of the rectangle used to highlight drop targets.\n     *\n     * @param {string} color - String that represents the new highlight color.\n     */\n    setHighlightColor(color) {\n        this.highlightColor = color;\n        if (this.shape) {\n            this.shape.stroke = color;\n        }\n    }\n    /**\n     * Creates and returns the highlight shape for the given state.\n     */\n    drawHighlight() {\n        this.shape = this.createShape();\n        this.repaint();\n        if (this.shape) {\n            const node = this.shape.node;\n            if (!this.keepOnTop && node?.parentNode?.firstChild !== node && node.parentNode) {\n                node.parentNode.insertBefore(node, node.parentNode.firstChild);\n            }\n        }\n    }\n    /**\n     * Creates and returns the highlight shape for the given state.\n     */\n    createShape() {\n        if (!this.state)\n            return null;\n        const shape = this.graph.cellRenderer.createShape(this.state);\n        shape.svgStrokeTolerance = this.graph.getEventTolerance();\n        shape.points = this.state.absolutePoints;\n        shape.apply(this.state);\n        shape.stroke = this.highlightColor;\n        shape.opacity = this.opacity;\n        shape.isDashed = this.dashed;\n        shape.isShadow = false;\n        shape.dialect = DIALECT.SVG;\n        shape.init(this.graph.getView().getOverlayPane());\n        InternalEvent.redirectMouseEvents(shape.node, this.graph, this.state);\n        if (this.graph.dialect !== DIALECT.SVG) {\n            shape.pointerEvents = false;\n        }\n        else {\n            shape.svgPointerEvents = 'stroke';\n        }\n        return shape;\n    }\n    /**\n     * Updates the highlight after a change of the model or view.\n     */\n    getStrokeWidth(state = null) {\n        return this.strokeWidth;\n    }\n    /**\n     * Updates the highlight after a change of the model or view.\n     */\n    repaint() {\n        if (this.state && this.shape) {\n            this.shape.scale = this.state.view.scale;\n            if (this.state.cell.isEdge()) {\n                this.shape.strokeWidth = this.getStrokeWidth();\n                this.shape.points = this.state.absolutePoints;\n                this.shape.outline = false;\n            }\n            else {\n                this.shape.bounds = new Rectangle(this.state.x - this.spacing, this.state.y - this.spacing, this.state.width + 2 * this.spacing, this.state.height + 2 * this.spacing);\n                this.shape.rotation = this.state.style.rotation ?? 0;\n                this.shape.strokeWidth = this.getStrokeWidth() / this.state.view.scale;\n                this.shape.outline = true;\n            }\n            // Uses cursor from shape in highlight\n            if (this.state.shape) {\n                this.shape.setCursor(this.state.shape.getCursor());\n            }\n            this.shape.redraw();\n        }\n    }\n    /**\n     * Resets the state of the cell marker.\n     */\n    hide() {\n        this.highlight(null);\n    }\n    /**\n     * Marks the {@link arkedState} and fires a {@link ark} event.\n     */\n    highlight(state = null) {\n        if (this.state !== state) {\n            if (this.shape) {\n                this.shape.destroy();\n                this.shape = null;\n            }\n            this.state = state;\n            if (this.state) {\n                this.drawHighlight();\n            }\n        }\n    }\n    /**\n     * Returns true if this highlight is at the given position.\n     */\n    isHighlightAt(x, y) {\n        let hit = false;\n        if (this.shape && document.elementFromPoint) {\n            let elt = document.elementFromPoint(x, y);\n            while (elt) {\n                if (elt === this.shape.node) {\n                    hit = true;\n                    break;\n                }\n                elt = elt.parentNode;\n            }\n        }\n        return hit;\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes.\n     */\n    destroy() {\n        const graph = this.graph;\n        graph.getView().removeListener(this.resetHandler);\n        graph.getView().removeListener(this.repaintHandler);\n        graph.getDataModel().removeListener(this.repaintHandler);\n        if (this.shape) {\n            this.shape.destroy();\n            this.shape = null;\n        }\n    }\n}\nexport default CellHighlight;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,mBAAmB,EAAEC,OAAO,EAAEC,iBAAiB,EAAEC,qBAAqB,QAAS,sBAAsB;AAC9G,OAAOC,aAAa,MAAM,wBAAwB;AAClD,OAAOC,SAAS,MAAM,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,aAAa,CAAC;EAChBC,WAAWA,CAACC,KAAK,EAAEC,cAAc,EAAEC,WAAW,EAAEC,MAAM,EAAE;IACpD,IAAI,CAACD,WAAW,GAAG,CAAC;IACpB,IAAI,CAACC,MAAM,GAAG,KAAK;IACnB,IAAI,CAACC,OAAO,GAAG,GAAG;IAClB,IAAI,CAACC,KAAK,GAAG,IAAI;IACjB;AACR;AACA;AACA;IACQ,IAAI,CAACC,SAAS,GAAG,KAAK;IACtB;AACR;AACA;AACA;IACQ,IAAI,CAACC,KAAK,GAAG,IAAI;IACjB;AACR;AACA;AACA;IACQ,IAAI,CAACC,OAAO,GAAG,CAAC;IAChB,IAAI,CAACR,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,cAAc,GAAGA,cAAc,IAAIT,mBAAmB;IAC3D,IAAI,CAACU,WAAW,GAAGA,WAAW,IAAIP,qBAAqB;IACvD,IAAI,CAACQ,MAAM,GAAGA,MAAM,IAAI,KAAK;IAC7B,IAAI,CAACC,OAAO,GAAGV,iBAAiB;IAChC;IACA,IAAI,CAACe,cAAc,GAAG,MAAM;MACxB;MACA,IAAI,IAAI,CAACF,KAAK,EAAE;QACZ,MAAMG,GAAG,GAAG,IAAI,CAACV,KAAK,CAACW,IAAI,CAACC,QAAQ,CAAC,IAAI,CAACL,KAAK,CAACM,IAAI,CAAC;QACrD,IAAI,CAACH,GAAG,EAAE;UACN,IAAI,CAACI,IAAI,CAAC,CAAC;QACf,CAAC,MACI;UACD,IAAI,CAACP,KAAK,GAAGG,GAAG;UAChB,IAAI,CAACK,OAAO,CAAC,CAAC;QAClB;MACJ;IACJ,CAAC;IACD,IAAI,CAACf,KAAK,CAACgB,OAAO,CAAC,CAAC,CAACC,WAAW,CAACrB,aAAa,CAACsB,KAAK,EAAE,IAAI,CAACT,cAAc,CAAC;IAC1E,IAAI,CAACT,KAAK,CAACgB,OAAO,CAAC,CAAC,CAACC,WAAW,CAACrB,aAAa,CAACuB,SAAS,EAAE,IAAI,CAACV,cAAc,CAAC;IAC9E,IAAI,CAACT,KAAK,CACLgB,OAAO,CAAC,CAAC,CACTC,WAAW,CAACrB,aAAa,CAACwB,mBAAmB,EAAE,IAAI,CAACX,cAAc,CAAC;IACxE,IAAI,CAACT,KAAK,CAACqB,YAAY,CAAC,CAAC,CAACJ,WAAW,CAACrB,aAAa,CAAC0B,MAAM,EAAE,IAAI,CAACb,cAAc,CAAC;IAChF;IACA,IAAI,CAACc,YAAY,GAAG,MAAM;MACtB,IAAI,CAACT,IAAI,CAAC,CAAC;IACf,CAAC;IACD,IAAI,CAACd,KAAK,CAACgB,OAAO,CAAC,CAAC,CAACC,WAAW,CAACrB,aAAa,CAAC4B,IAAI,EAAE,IAAI,CAACD,YAAY,CAAC;IACvE,IAAI,CAACvB,KAAK,CAACgB,OAAO,CAAC,CAAC,CAACC,WAAW,CAACrB,aAAa,CAAC6B,EAAE,EAAE,IAAI,CAACF,YAAY,CAAC;EACzE;EACA;AACJ;AACA;AACA;AACA;EACIG,iBAAiBA,CAACC,KAAK,EAAE;IACrB,IAAI,CAAC1B,cAAc,GAAG0B,KAAK;IAC3B,IAAI,IAAI,CAACtB,KAAK,EAAE;MACZ,IAAI,CAACA,KAAK,CAACuB,MAAM,GAAGD,KAAK;IAC7B;EACJ;EACA;AACJ;AACA;EACIE,aAAaA,CAAA,EAAG;IACZ,IAAI,CAACxB,KAAK,GAAG,IAAI,CAACyB,WAAW,CAAC,CAAC;IAC/B,IAAI,CAACf,OAAO,CAAC,CAAC;IACd,IAAI,IAAI,CAACV,KAAK,EAAE;MACZ,MAAM0B,IAAI,GAAG,IAAI,CAAC1B,KAAK,CAAC0B,IAAI;MAC5B,IAAI,CAAC,IAAI,CAACzB,SAAS,IAAIyB,IAAI,EAAEC,UAAU,EAAEC,UAAU,KAAKF,IAAI,IAAIA,IAAI,CAACC,UAAU,EAAE;QAC7ED,IAAI,CAACC,UAAU,CAACE,YAAY,CAACH,IAAI,EAAEA,IAAI,CAACC,UAAU,CAACC,UAAU,CAAC;MAClE;IACJ;EACJ;EACA;AACJ;AACA;EACIH,WAAWA,CAAA,EAAG;IACV,IAAI,CAAC,IAAI,CAACvB,KAAK,EACX,OAAO,IAAI;IACf,MAAMF,KAAK,GAAG,IAAI,CAACL,KAAK,CAACmC,YAAY,CAACL,WAAW,CAAC,IAAI,CAACvB,KAAK,CAAC;IAC7DF,KAAK,CAAC+B,kBAAkB,GAAG,IAAI,CAACpC,KAAK,CAACqC,iBAAiB,CAAC,CAAC;IACzDhC,KAAK,CAACiC,MAAM,GAAG,IAAI,CAAC/B,KAAK,CAACgC,cAAc;IACxClC,KAAK,CAACmC,KAAK,CAAC,IAAI,CAACjC,KAAK,CAAC;IACvBF,KAAK,CAACuB,MAAM,GAAG,IAAI,CAAC3B,cAAc;IAClCI,KAAK,CAACD,OAAO,GAAG,IAAI,CAACA,OAAO;IAC5BC,KAAK,CAACoC,QAAQ,GAAG,IAAI,CAACtC,MAAM;IAC5BE,KAAK,CAACqC,QAAQ,GAAG,KAAK;IACtBrC,KAAK,CAACsC,OAAO,GAAGlD,OAAO,CAACmD,GAAG;IAC3BvC,KAAK,CAACwC,IAAI,CAAC,IAAI,CAAC7C,KAAK,CAACgB,OAAO,CAAC,CAAC,CAAC8B,cAAc,CAAC,CAAC,CAAC;IACjDlD,aAAa,CAACmD,mBAAmB,CAAC1C,KAAK,CAAC0B,IAAI,EAAE,IAAI,CAAC/B,KAAK,EAAE,IAAI,CAACO,KAAK,CAAC;IACrE,IAAI,IAAI,CAACP,KAAK,CAAC2C,OAAO,KAAKlD,OAAO,CAACmD,GAAG,EAAE;MACpCvC,KAAK,CAAC2C,aAAa,GAAG,KAAK;IAC/B,CAAC,MACI;MACD3C,KAAK,CAAC4C,gBAAgB,GAAG,QAAQ;IACrC;IACA,OAAO5C,KAAK;EAChB;EACA;AACJ;AACA;EACI6C,cAAcA,CAAC3C,KAAK,GAAG,IAAI,EAAE;IACzB,OAAO,IAAI,CAACL,WAAW;EAC3B;EACA;AACJ;AACA;EACIa,OAAOA,CAAA,EAAG;IACN,IAAI,IAAI,CAACR,KAAK,IAAI,IAAI,CAACF,KAAK,EAAE;MAC1B,IAAI,CAACA,KAAK,CAAC8C,KAAK,GAAG,IAAI,CAAC5C,KAAK,CAACI,IAAI,CAACwC,KAAK;MACxC,IAAI,IAAI,CAAC5C,KAAK,CAACM,IAAI,CAACuC,MAAM,CAAC,CAAC,EAAE;QAC1B,IAAI,CAAC/C,KAAK,CAACH,WAAW,GAAG,IAAI,CAACgD,cAAc,CAAC,CAAC;QAC9C,IAAI,CAAC7C,KAAK,CAACiC,MAAM,GAAG,IAAI,CAAC/B,KAAK,CAACgC,cAAc;QAC7C,IAAI,CAAClC,KAAK,CAACgD,OAAO,GAAG,KAAK;MAC9B,CAAC,MACI;QACD,IAAI,CAAChD,KAAK,CAACiD,MAAM,GAAG,IAAIzD,SAAS,CAAC,IAAI,CAACU,KAAK,CAACgD,CAAC,GAAG,IAAI,CAAC/C,OAAO,EAAE,IAAI,CAACD,KAAK,CAACiD,CAAC,GAAG,IAAI,CAAChD,OAAO,EAAE,IAAI,CAACD,KAAK,CAACkD,KAAK,GAAG,CAAC,GAAG,IAAI,CAACjD,OAAO,EAAE,IAAI,CAACD,KAAK,CAACmD,MAAM,GAAG,CAAC,GAAG,IAAI,CAAClD,OAAO,CAAC;QACtK,IAAI,CAACH,KAAK,CAACsD,QAAQ,GAAG,IAAI,CAACpD,KAAK,CAACqD,KAAK,CAACD,QAAQ,IAAI,CAAC;QACpD,IAAI,CAACtD,KAAK,CAACH,WAAW,GAAG,IAAI,CAACgD,cAAc,CAAC,CAAC,GAAG,IAAI,CAAC3C,KAAK,CAACI,IAAI,CAACwC,KAAK;QACtE,IAAI,CAAC9C,KAAK,CAACgD,OAAO,GAAG,IAAI;MAC7B;MACA;MACA,IAAI,IAAI,CAAC9C,KAAK,CAACF,KAAK,EAAE;QAClB,IAAI,CAACA,KAAK,CAACwD,SAAS,CAAC,IAAI,CAACtD,KAAK,CAACF,KAAK,CAACyD,SAAS,CAAC,CAAC,CAAC;MACtD;MACA,IAAI,CAACzD,KAAK,CAAC0D,MAAM,CAAC,CAAC;IACvB;EACJ;EACA;AACJ;AACA;EACIjD,IAAIA,CAAA,EAAG;IACH,IAAI,CAACkD,SAAS,CAAC,IAAI,CAAC;EACxB;EACA;AACJ;AACA;EACIA,SAASA,CAACzD,KAAK,GAAG,IAAI,EAAE;IACpB,IAAI,IAAI,CAACA,KAAK,KAAKA,KAAK,EAAE;MACtB,IAAI,IAAI,CAACF,KAAK,EAAE;QACZ,IAAI,CAACA,KAAK,CAAC4D,OAAO,CAAC,CAAC;QACpB,IAAI,CAAC5D,KAAK,GAAG,IAAI;MACrB;MACA,IAAI,CAACE,KAAK,GAAGA,KAAK;MAClB,IAAI,IAAI,CAACA,KAAK,EAAE;QACZ,IAAI,CAACsB,aAAa,CAAC,CAAC;MACxB;IACJ;EACJ;EACA;AACJ;AACA;EACIqC,aAAaA,CAACX,CAAC,EAAEC,CAAC,EAAE;IAChB,IAAIW,GAAG,GAAG,KAAK;IACf,IAAI,IAAI,CAAC9D,KAAK,IAAI+D,QAAQ,CAACC,gBAAgB,EAAE;MACzC,IAAIC,GAAG,GAAGF,QAAQ,CAACC,gBAAgB,CAACd,CAAC,EAAEC,CAAC,CAAC;MACzC,OAAOc,GAAG,EAAE;QACR,IAAIA,GAAG,KAAK,IAAI,CAACjE,KAAK,CAAC0B,IAAI,EAAE;UACzBoC,GAAG,GAAG,IAAI;UACV;QACJ;QACAG,GAAG,GAAGA,GAAG,CAACtC,UAAU;MACxB;IACJ;IACA,OAAOmC,GAAG;EACd;EACA;AACJ;AACA;EACIF,OAAOA,CAAA,EAAG;IACN,MAAMjE,KAAK,GAAG,IAAI,CAACA,KAAK;IACxBA,KAAK,CAACgB,OAAO,CAAC,CAAC,CAACuD,cAAc,CAAC,IAAI,CAAChD,YAAY,CAAC;IACjDvB,KAAK,CAACgB,OAAO,CAAC,CAAC,CAACuD,cAAc,CAAC,IAAI,CAAC9D,cAAc,CAAC;IACnDT,KAAK,CAACqB,YAAY,CAAC,CAAC,CAACkD,cAAc,CAAC,IAAI,CAAC9D,cAAc,CAAC;IACxD,IAAI,IAAI,CAACJ,KAAK,EAAE;MACZ,IAAI,CAACA,KAAK,CAAC4D,OAAO,CAAC,CAAC;MACpB,IAAI,CAAC5D,KAAK,GAAG,IAAI;IACrB;EACJ;AACJ;AACA,eAAeP,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}