{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../geometry/Point';\nimport GraphLayout from './GraphLayout';\nimport ObjectIdentity from '../../util/ObjectIdentity';\n/**\n * Extends {@link GraphLayout} for arranging parallel edges. This layout works\n * on edges for all pairs of vertices where there is more than one edge\n * connecting the latter.\n *\n * Example:\n *\n * ```javascript\n * let layout = new mxParallelEdgeLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * ```\n *\n * To run the layout for the parallel edges of a changed edge only, the\n * following code can be used.\n *\n * ```javascript\n * let layout = new mxParallelEdgeLayout(graph);\n *\n * graph.addListener(mxEvent.CELL_CONNECTED, (sender, evt)=>\n * {\n *   let model = graph.getDataModel();\n *   let edge = evt.getProperty('edge');\n *   let src = model.getTerminal(edge, true);\n *   let trg = model.getTerminal(edge, false);\n *\n *   layout.isEdgeIgnored = (edge2)=>\n *   {\n *     var src2 = model.getTerminal(edge2, true);\n *     var trg2 = model.getTerminal(edge2, false);\n *\n *     return !(model.isEdge(edge2) && ((src == src2 && trg == trg2) || (src == trg2 && trg == src2)));\n *   };\n *\n *   layout.execute(graph.getDefaultParent());\n * });\n * ```\n *\n * Constructor: mxParallelEdgeLayout\n *\n * Constructs a new parallel edge layout for the specified graph.\n */\nclass ParallelEdgeLayout extends GraphLayout {\n  constructor(graph) {\n    super(graph);\n    /**\n     * Defines the spacing between the parallels. Default is 20.\n     */\n    this.spacing = 20;\n    /**\n     * Specifies if only overlapping edges should be considered\n     * parallel. Default is false.\n     */\n    this.checkOverlap = false;\n  }\n  /**\n   * Implements {@link GraphLayout#execute}.\n   */\n  execute(parent, cells = null) {\n    const lookup = this.findParallels(parent, cells);\n    this.graph.batchUpdate(() => {\n      for (const i in lookup) {\n        const parallels = lookup[i];\n        if (parallels.length > 1) {\n          this.layout(parallels);\n        }\n      }\n    });\n  }\n  /**\n   * Finds the parallel edges in the given parent.\n   */\n  findParallels(parent, cells = null) {\n    const lookup = [];\n    const addCell = cell => {\n      if (!this.isEdgeIgnored(cell)) {\n        const id = this.getEdgeId(cell);\n        if (id != null) {\n          if (lookup[id] == null) {\n            lookup[id] = [];\n          }\n          lookup[id].push(cell);\n        }\n      }\n    };\n    if (cells != null) {\n      for (let i = 0; i < cells.length; i += 1) {\n        addCell(cells[i]);\n      }\n    } else {\n      const model = this.graph.getDataModel();\n      const childCount = parent.getChildCount();\n      for (let i = 0; i < childCount; i += 1) {\n        addCell(parent.getChildAt(i));\n      }\n    }\n    return lookup;\n  }\n  /**\n   * Returns a unique ID for the given edge. The id is independent of the\n   * edge direction and is built using the visible terminal of the given\n   * edge.\n   */\n  getEdgeId(edge) {\n    const view = this.graph.getView();\n    // Cannot used cached visible terminal because this could be triggered in BEFORE_UNDO\n    let src = view.getVisibleTerminal(edge, true);\n    let trg = view.getVisibleTerminal(edge, false);\n    let pts = '';\n    if (src != null && trg != null) {\n      src = ObjectIdentity.get(src);\n      trg = ObjectIdentity.get(trg);\n      if (this.checkOverlap) {\n        const state = this.graph.view.getState(edge);\n        if (state != null && state.absolutePoints != null) {\n          const tmp = [];\n          for (let i = 0; i < state.absolutePoints.length; i += 1) {\n            const pt = state.absolutePoints[i];\n            if (pt != null) {\n              tmp.push(pt.x, pt.y);\n            }\n          }\n          pts = tmp.join(',');\n        }\n      }\n      return (src > trg ? `${trg}-${src}` : `${src}-${trg}`) + pts;\n    }\n    return null;\n  }\n  /**\n   * Lays out the parallel edges in the given array.\n   */\n  layout(parallels) {\n    const edge = parallels[0];\n    const view = this.graph.getView();\n    const model = this.graph.getDataModel();\n    const src = view.getVisibleTerminal(edge, true).getGeometry();\n    const trg = view.getVisibleTerminal(edge, false).getGeometry();\n    let x0;\n    let y0;\n    // Routes multiple loops\n    if (src === trg) {\n      x0 = src.x + src.width + this.spacing;\n      y0 = src.y + src.height / 2;\n      for (let i = 0; i < parallels.length; i += 1) {\n        this.route(parallels[i], x0, y0);\n        x0 += this.spacing;\n      }\n    } else if (src != null && trg != null) {\n      // Routes parallel edges\n      const scx = src.x + src.width / 2;\n      const scy = src.y + src.height / 2;\n      const tcx = trg.x + trg.width / 2;\n      const tcy = trg.y + trg.height / 2;\n      const dx = tcx - scx;\n      const dy = tcy - scy;\n      const len = Math.sqrt(dx * dx + dy * dy);\n      if (len > 0) {\n        x0 = scx + dx / 2;\n        y0 = scy + dy / 2;\n        const nx = dy * this.spacing / len;\n        const ny = dx * this.spacing / len;\n        x0 += nx * (parallels.length - 1) / 2;\n        y0 -= ny * (parallels.length - 1) / 2;\n        for (let i = 0; i < parallels.length; i += 1) {\n          this.route(parallels[i], x0, y0);\n          x0 -= nx;\n          y0 += ny;\n        }\n      }\n    }\n  }\n  /**\n   * Routes the given edge via the given point.\n   */\n  route(edge, x, y) {\n    if (this.graph.isCellMovable(edge)) {\n      this.setEdgePoints(edge, [new Point(x, y)]);\n    }\n  }\n}\nexport default ParallelEdgeLayout;","map":{"version":3,"names":["Point","GraphLayout","ObjectIdentity","ParallelEdgeLayout","constructor","graph","spacing","checkOverlap","execute","parent","cells","lookup","findParallels","batchUpdate","i","parallels","length","layout","addCell","cell","isEdgeIgnored","id","getEdgeId","push","model","getDataModel","childCount","getChildCount","getChildAt","edge","view","getView","src","getVisibleTerminal","trg","pts","get","state","getState","absolutePoints","tmp","pt","x","y","join","getGeometry","x0","y0","width","height","route","scx","scy","tcx","tcy","dx","dy","len","Math","sqrt","nx","ny","isCellMovable","setEdgePoints"],"sources":["D:/OSPanel/domains/old/react/react-intro/node_modules/@maxgraph/core/dist/view/layout/ParallelEdgeLayout.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../geometry/Point';\nimport GraphLayout from './GraphLayout';\nimport ObjectIdentity from '../../util/ObjectIdentity';\n/**\n * Extends {@link GraphLayout} for arranging parallel edges. This layout works\n * on edges for all pairs of vertices where there is more than one edge\n * connecting the latter.\n *\n * Example:\n *\n * ```javascript\n * let layout = new mxParallelEdgeLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * ```\n *\n * To run the layout for the parallel edges of a changed edge only, the\n * following code can be used.\n *\n * ```javascript\n * let layout = new mxParallelEdgeLayout(graph);\n *\n * graph.addListener(mxEvent.CELL_CONNECTED, (sender, evt)=>\n * {\n *   let model = graph.getDataModel();\n *   let edge = evt.getProperty('edge');\n *   let src = model.getTerminal(edge, true);\n *   let trg = model.getTerminal(edge, false);\n *\n *   layout.isEdgeIgnored = (edge2)=>\n *   {\n *     var src2 = model.getTerminal(edge2, true);\n *     var trg2 = model.getTerminal(edge2, false);\n *\n *     return !(model.isEdge(edge2) && ((src == src2 && trg == trg2) || (src == trg2 && trg == src2)));\n *   };\n *\n *   layout.execute(graph.getDefaultParent());\n * });\n * ```\n *\n * Constructor: mxParallelEdgeLayout\n *\n * Constructs a new parallel edge layout for the specified graph.\n */\nclass ParallelEdgeLayout extends GraphLayout {\n    constructor(graph) {\n        super(graph);\n        /**\n         * Defines the spacing between the parallels. Default is 20.\n         */\n        this.spacing = 20;\n        /**\n         * Specifies if only overlapping edges should be considered\n         * parallel. Default is false.\n         */\n        this.checkOverlap = false;\n    }\n    /**\n     * Implements {@link GraphLayout#execute}.\n     */\n    execute(parent, cells = null) {\n        const lookup = this.findParallels(parent, cells);\n        this.graph.batchUpdate(() => {\n            for (const i in lookup) {\n                const parallels = lookup[i];\n                if (parallels.length > 1) {\n                    this.layout(parallels);\n                }\n            }\n        });\n    }\n    /**\n     * Finds the parallel edges in the given parent.\n     */\n    findParallels(parent, cells = null) {\n        const lookup = [];\n        const addCell = (cell) => {\n            if (!this.isEdgeIgnored(cell)) {\n                const id = this.getEdgeId(cell);\n                if (id != null) {\n                    if (lookup[id] == null) {\n                        lookup[id] = [];\n                    }\n                    lookup[id].push(cell);\n                }\n            }\n        };\n        if (cells != null) {\n            for (let i = 0; i < cells.length; i += 1) {\n                addCell(cells[i]);\n            }\n        }\n        else {\n            const model = this.graph.getDataModel();\n            const childCount = parent.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                addCell(parent.getChildAt(i));\n            }\n        }\n        return lookup;\n    }\n    /**\n     * Returns a unique ID for the given edge. The id is independent of the\n     * edge direction and is built using the visible terminal of the given\n     * edge.\n     */\n    getEdgeId(edge) {\n        const view = this.graph.getView();\n        // Cannot used cached visible terminal because this could be triggered in BEFORE_UNDO\n        let src = view.getVisibleTerminal(edge, true);\n        let trg = view.getVisibleTerminal(edge, false);\n        let pts = '';\n        if (src != null && trg != null) {\n            src = ObjectIdentity.get(src);\n            trg = ObjectIdentity.get(trg);\n            if (this.checkOverlap) {\n                const state = this.graph.view.getState(edge);\n                if (state != null && state.absolutePoints != null) {\n                    const tmp = [];\n                    for (let i = 0; i < state.absolutePoints.length; i += 1) {\n                        const pt = state.absolutePoints[i];\n                        if (pt != null) {\n                            tmp.push(pt.x, pt.y);\n                        }\n                    }\n                    pts = tmp.join(',');\n                }\n            }\n            return (src > trg ? `${trg}-${src}` : `${src}-${trg}`) + pts;\n        }\n        return null;\n    }\n    /**\n     * Lays out the parallel edges in the given array.\n     */\n    layout(parallels) {\n        const edge = parallels[0];\n        const view = this.graph.getView();\n        const model = this.graph.getDataModel();\n        const src = view.getVisibleTerminal(edge, true).getGeometry();\n        const trg = view.getVisibleTerminal(edge, false).getGeometry();\n        let x0;\n        let y0;\n        // Routes multiple loops\n        if (src === trg) {\n            x0 = src.x + src.width + this.spacing;\n            y0 = src.y + src.height / 2;\n            for (let i = 0; i < parallels.length; i += 1) {\n                this.route(parallels[i], x0, y0);\n                x0 += this.spacing;\n            }\n        }\n        else if (src != null && trg != null) {\n            // Routes parallel edges\n            const scx = src.x + src.width / 2;\n            const scy = src.y + src.height / 2;\n            const tcx = trg.x + trg.width / 2;\n            const tcy = trg.y + trg.height / 2;\n            const dx = tcx - scx;\n            const dy = tcy - scy;\n            const len = Math.sqrt(dx * dx + dy * dy);\n            if (len > 0) {\n                x0 = scx + dx / 2;\n                y0 = scy + dy / 2;\n                const nx = (dy * this.spacing) / len;\n                const ny = (dx * this.spacing) / len;\n                x0 += (nx * (parallels.length - 1)) / 2;\n                y0 -= (ny * (parallels.length - 1)) / 2;\n                for (let i = 0; i < parallels.length; i += 1) {\n                    this.route(parallels[i], x0, y0);\n                    x0 -= nx;\n                    y0 += ny;\n                }\n            }\n        }\n    }\n    /**\n     * Routes the given edge via the given point.\n     */\n    route(edge, x, y) {\n        if (this.graph.isCellMovable(edge)) {\n            this.setEdgePoints(edge, [new Point(x, y)]);\n        }\n    }\n}\nexport default ParallelEdgeLayout;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}