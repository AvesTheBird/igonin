{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isHTMLElement } from '../../../../base/browser/dom.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { isMarkdownString } from '../../../../base/common/htmlContent.js';\nimport { isFunction, isString } from '../../../../base/common/types.js';\nimport { localize } from '../../../../nls.js';\nexport class ManagedHoverWidget {\n  constructor(hoverDelegate, target, fadeInAnimation) {\n    this.hoverDelegate = hoverDelegate;\n    this.target = target;\n    this.fadeInAnimation = fadeInAnimation;\n  }\n  async update(content, focus, options) {\n    if (this._cancellationTokenSource) {\n      // there's an computation ongoing, cancel it\n      this._cancellationTokenSource.dispose(true);\n      this._cancellationTokenSource = undefined;\n    }\n    if (this.isDisposed) {\n      return;\n    }\n    let resolvedContent;\n    if (content === undefined || isString(content) || isHTMLElement(content)) {\n      resolvedContent = content;\n    } else if (!isFunction(content.markdown)) {\n      var _content$markdown;\n      resolvedContent = (_content$markdown = content.markdown) !== null && _content$markdown !== void 0 ? _content$markdown : content.markdownNotSupportedFallback;\n    } else {\n      // compute the content, potentially long-running\n      // show 'Loading' if no hover is up yet\n      if (!this._hoverWidget) {\n        this.show(localize('iconLabel.loading', \"Loading...\"), focus, options);\n      }\n      // compute the content\n      this._cancellationTokenSource = new CancellationTokenSource();\n      const token = this._cancellationTokenSource.token;\n      resolvedContent = await content.markdown(token);\n      if (resolvedContent === undefined) {\n        resolvedContent = content.markdownNotSupportedFallback;\n      }\n      if (this.isDisposed || token.isCancellationRequested) {\n        // either the widget has been closed in the meantime\n        // or there has been a new call to `update`\n        return;\n      }\n    }\n    this.show(resolvedContent, focus, options);\n  }\n  show(content, focus, options) {\n    const oldHoverWidget = this._hoverWidget;\n    if (this.hasContent(content)) {\n      var _options$appearance;\n      const hoverOptions = {\n        content,\n        target: this.target,\n        actions: options === null || options === void 0 ? void 0 : options.actions,\n        linkHandler: options === null || options === void 0 ? void 0 : options.linkHandler,\n        trapFocus: options === null || options === void 0 ? void 0 : options.trapFocus,\n        appearance: {\n          showPointer: this.hoverDelegate.placement === 'element',\n          skipFadeInAnimation: !this.fadeInAnimation || !!oldHoverWidget,\n          // do not fade in if the hover is already showing\n          showHoverHint: options === null || options === void 0 || (_options$appearance = options.appearance) === null || _options$appearance === void 0 ? void 0 : _options$appearance.showHoverHint\n        },\n        position: {\n          hoverPosition: 2 /* HoverPosition.BELOW */\n        }\n      };\n      this._hoverWidget = this.hoverDelegate.showHover(hoverOptions, focus);\n    }\n    oldHoverWidget === null || oldHoverWidget === void 0 || oldHoverWidget.dispose();\n  }\n  hasContent(content) {\n    if (!content) {\n      return false;\n    }\n    if (isMarkdownString(content)) {\n      return !!content.value;\n    }\n    return true;\n  }\n  get isDisposed() {\n    var _this$_hoverWidget;\n    return (_this$_hoverWidget = this._hoverWidget) === null || _this$_hoverWidget === void 0 ? void 0 : _this$_hoverWidget.isDisposed;\n  }\n  dispose() {\n    var _this$_hoverWidget2, _this$_cancellationTo;\n    (_this$_hoverWidget2 = this._hoverWidget) === null || _this$_hoverWidget2 === void 0 || _this$_hoverWidget2.dispose();\n    (_this$_cancellationTo = this._cancellationTokenSource) === null || _this$_cancellationTo === void 0 || _this$_cancellationTo.dispose(true);\n    this._cancellationTokenSource = undefined;\n  }\n}","map":{"version":3,"names":["isHTMLElement","CancellationTokenSource","isMarkdownString","isFunction","isString","localize","ManagedHoverWidget","constructor","hoverDelegate","target","fadeInAnimation","update","content","focus","options","_cancellationTokenSource","dispose","undefined","isDisposed","resolvedContent","markdown","_content$markdown","markdownNotSupportedFallback","_hoverWidget","show","token","isCancellationRequested","oldHoverWidget","hasContent","_options$appearance","hoverOptions","actions","linkHandler","trapFocus","appearance","showPointer","placement","skipFadeInAnimation","showHoverHint","position","hoverPosition","showHover","value","_this$_hoverWidget","_this$_hoverWidget2","_this$_cancellationTo"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/editor/browser/services/hoverService/updatableHoverWidget.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isHTMLElement } from '../../../../base/browser/dom.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { isMarkdownString } from '../../../../base/common/htmlContent.js';\nimport { isFunction, isString } from '../../../../base/common/types.js';\nimport { localize } from '../../../../nls.js';\nexport class ManagedHoverWidget {\n    constructor(hoverDelegate, target, fadeInAnimation) {\n        this.hoverDelegate = hoverDelegate;\n        this.target = target;\n        this.fadeInAnimation = fadeInAnimation;\n    }\n    async update(content, focus, options) {\n        if (this._cancellationTokenSource) {\n            // there's an computation ongoing, cancel it\n            this._cancellationTokenSource.dispose(true);\n            this._cancellationTokenSource = undefined;\n        }\n        if (this.isDisposed) {\n            return;\n        }\n        let resolvedContent;\n        if (content === undefined || isString(content) || isHTMLElement(content)) {\n            resolvedContent = content;\n        }\n        else if (!isFunction(content.markdown)) {\n            resolvedContent = content.markdown ?? content.markdownNotSupportedFallback;\n        }\n        else {\n            // compute the content, potentially long-running\n            // show 'Loading' if no hover is up yet\n            if (!this._hoverWidget) {\n                this.show(localize('iconLabel.loading', \"Loading...\"), focus, options);\n            }\n            // compute the content\n            this._cancellationTokenSource = new CancellationTokenSource();\n            const token = this._cancellationTokenSource.token;\n            resolvedContent = await content.markdown(token);\n            if (resolvedContent === undefined) {\n                resolvedContent = content.markdownNotSupportedFallback;\n            }\n            if (this.isDisposed || token.isCancellationRequested) {\n                // either the widget has been closed in the meantime\n                // or there has been a new call to `update`\n                return;\n            }\n        }\n        this.show(resolvedContent, focus, options);\n    }\n    show(content, focus, options) {\n        const oldHoverWidget = this._hoverWidget;\n        if (this.hasContent(content)) {\n            const hoverOptions = {\n                content,\n                target: this.target,\n                actions: options?.actions,\n                linkHandler: options?.linkHandler,\n                trapFocus: options?.trapFocus,\n                appearance: {\n                    showPointer: this.hoverDelegate.placement === 'element',\n                    skipFadeInAnimation: !this.fadeInAnimation || !!oldHoverWidget, // do not fade in if the hover is already showing\n                    showHoverHint: options?.appearance?.showHoverHint,\n                },\n                position: {\n                    hoverPosition: 2 /* HoverPosition.BELOW */,\n                },\n            };\n            this._hoverWidget = this.hoverDelegate.showHover(hoverOptions, focus);\n        }\n        oldHoverWidget?.dispose();\n    }\n    hasContent(content) {\n        if (!content) {\n            return false;\n        }\n        if (isMarkdownString(content)) {\n            return !!content.value;\n        }\n        return true;\n    }\n    get isDisposed() {\n        return this._hoverWidget?.isDisposed;\n    }\n    dispose() {\n        this._hoverWidget?.dispose();\n        this._cancellationTokenSource?.dispose(true);\n        this._cancellationTokenSource = undefined;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}