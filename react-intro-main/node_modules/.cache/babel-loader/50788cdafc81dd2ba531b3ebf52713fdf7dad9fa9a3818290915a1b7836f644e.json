{"ast":null,"code":"/*\nCopyright 2023-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport CodecRegistry from '../CodecRegistry';\nimport ObjectCodec from '../ObjectCodec';\nimport Cell from '../../view/cell/Cell';\nimport { NODETYPE } from '../../util/Constants';\nimport { importNode } from '../../util/domUtils';\nimport { removeWhitespace } from '../../util/StringUtils';\n/**\n * Codec for {@link Cell}s.\n *\n * This class is created and registered dynamically at load time and used implicitly via {@link Codec} and the {@link CodecRegistry}.\n *\n * Transient Fields:\n *\n * - children\n * - edges\n * - overlays\n * - mxTransient\n *\n * Reference Fields:\n *\n * - parent\n * - source\n * - target\n *\n * Transient fields can be added using the following code: `CodecRegistry.getCodec(Cell).exclude.push('name_of_field');`\n *\n * To subclass {@link Cell}, replace the template and add an alias as follows:\n *\n * ```javascript\n * // Given 'CustomCell' extends 'Cell'\n * CodecRegistry.getCodec(Cell).template = new CustomCell();\n * CodecRegistry.addAlias('CustomCell', 'Cell');\n * ```\n */\nexport class CellCodec extends ObjectCodec {\n  constructor() {\n    super(new Cell(), ['children', 'edges', 'overlays', 'mxTransient'], ['parent', 'source', 'target']);\n    this.setName('Cell');\n  }\n  /**\n   * Returns `true` since this is a cell codec.\n   */\n  isCellCodec() {\n    return true;\n  }\n  /**\n   * Overridden to disable conversion of value to number.\n   */\n  isNumericAttribute(dec, attr, obj) {\n    return attr.nodeName !== 'value' && super.isNumericAttribute(dec, attr, obj);\n  }\n  /**\n   * Excludes user objects that are XML nodes.\n   */\n  isExcluded(obj, attr, value, isWrite) {\n    return super.isExcluded(obj, attr, value, isWrite) || isWrite && attr === 'value' && value.nodeType === NODETYPE.ELEMENT;\n  }\n  /**\n   * Encodes a {@link Cell} and wraps the XML up inside the XML of the user object (inversion).\n   */\n  afterEncode(enc, obj, node) {\n    if (obj.value != null && obj.value.nodeType === NODETYPE.ELEMENT) {\n      // Wraps the graphical annotation up in the user object (inversion)\n      // by putting the result of the default encoding into a clone of the\n      // user object (node type 1) and returning this cloned user object.\n      const tmp = node;\n      node = importNode(enc.document, obj.value, true);\n      node.appendChild(tmp);\n      // Moves the id attribute to the outermost XML node, namely the\n      // node which denotes the object boundaries in the file.\n      const id = tmp.getAttribute('id');\n      node.setAttribute('id', String(id));\n      tmp.removeAttribute('id');\n    }\n    return node;\n  }\n  /**\n   * Decodes an {@link Cell} and uses the enclosing XML node as the user object for the cell (inversion).\n   */\n  beforeDecode(dec, node, obj) {\n    let inner = node.cloneNode(true);\n    const classname = this.getName();\n    if (node.nodeName !== classname) {\n      // Passes the inner graphical annotation node to the\n      // object codec for further processing of the cell.\n      const tmp = node.getElementsByTagName(classname)[0];\n      if (tmp != null && tmp.parentNode === node) {\n        removeWhitespace(tmp, true);\n        removeWhitespace(tmp, false);\n        tmp.parentNode.removeChild(tmp);\n        inner = tmp;\n      } else {\n        inner = null;\n      }\n      // Creates the user object out of the XML node\n      obj.value = node.cloneNode(true);\n      const id = obj.value.getAttribute('id');\n      if (id != null) {\n        obj.setId(id);\n        obj.value.removeAttribute('id');\n      }\n    } else {\n      // Uses ID from XML file as ID for cell in model\n      obj.setId(node.getAttribute('id'));\n    }\n    // Preprocesses and removes all Id-references in order to use the\n    // correct encoder (this) for the known references to cells (all).\n    if (inner != null) {\n      for (let i = 0; i < this.idrefs.length; i += 1) {\n        const attr = this.idrefs[i];\n        const ref = inner.getAttribute(attr);\n        if (ref != null) {\n          inner.removeAttribute(attr);\n          let object = dec.objects[ref] || dec.lookup(ref);\n          if (object == null) {\n            // Needs to decode forward reference\n            const element = dec.getElementById(ref);\n            if (element != null) {\n              const decoder = CodecRegistry.codecs[element.nodeName] || this;\n              object = decoder.decode(dec, element);\n            }\n          }\n          // @ts-ignore dynamic assignment was in original implementation\n          obj[attr] = object;\n        }\n      }\n    }\n    return inner;\n  }\n}","map":{"version":3,"names":["CodecRegistry","ObjectCodec","Cell","NODETYPE","importNode","removeWhitespace","CellCodec","constructor","setName","isCellCodec","isNumericAttribute","dec","attr","obj","nodeName","isExcluded","value","isWrite","nodeType","ELEMENT","afterEncode","enc","node","tmp","document","appendChild","id","getAttribute","setAttribute","String","removeAttribute","beforeDecode","inner","cloneNode","classname","getName","getElementsByTagName","parentNode","removeChild","setId","i","idrefs","length","ref","object","objects","lookup","element","getElementById","decoder","codecs","decode"],"sources":["D:/ospanel/domains/old/react/react-intro-main/node_modules/@maxgraph/core/dist/serialization/codecs/CellCodec.js"],"sourcesContent":["/*\nCopyright 2023-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport CodecRegistry from '../CodecRegistry';\nimport ObjectCodec from '../ObjectCodec';\nimport Cell from '../../view/cell/Cell';\nimport { NODETYPE } from '../../util/Constants';\nimport { importNode } from '../../util/domUtils';\nimport { removeWhitespace } from '../../util/StringUtils';\n/**\n * Codec for {@link Cell}s.\n *\n * This class is created and registered dynamically at load time and used implicitly via {@link Codec} and the {@link CodecRegistry}.\n *\n * Transient Fields:\n *\n * - children\n * - edges\n * - overlays\n * - mxTransient\n *\n * Reference Fields:\n *\n * - parent\n * - source\n * - target\n *\n * Transient fields can be added using the following code: `CodecRegistry.getCodec(Cell).exclude.push('name_of_field');`\n *\n * To subclass {@link Cell}, replace the template and add an alias as follows:\n *\n * ```javascript\n * // Given 'CustomCell' extends 'Cell'\n * CodecRegistry.getCodec(Cell).template = new CustomCell();\n * CodecRegistry.addAlias('CustomCell', 'Cell');\n * ```\n */\nexport class CellCodec extends ObjectCodec {\n    constructor() {\n        super(new Cell(), ['children', 'edges', 'overlays', 'mxTransient'], ['parent', 'source', 'target']);\n        this.setName('Cell');\n    }\n    /**\n     * Returns `true` since this is a cell codec.\n     */\n    isCellCodec() {\n        return true;\n    }\n    /**\n     * Overridden to disable conversion of value to number.\n     */\n    isNumericAttribute(dec, attr, obj) {\n        return attr.nodeName !== 'value' && super.isNumericAttribute(dec, attr, obj);\n    }\n    /**\n     * Excludes user objects that are XML nodes.\n     */\n    isExcluded(obj, attr, value, isWrite) {\n        return (super.isExcluded(obj, attr, value, isWrite) ||\n            (isWrite && attr === 'value' && value.nodeType === NODETYPE.ELEMENT));\n    }\n    /**\n     * Encodes a {@link Cell} and wraps the XML up inside the XML of the user object (inversion).\n     */\n    afterEncode(enc, obj, node) {\n        if (obj.value != null && obj.value.nodeType === NODETYPE.ELEMENT) {\n            // Wraps the graphical annotation up in the user object (inversion)\n            // by putting the result of the default encoding into a clone of the\n            // user object (node type 1) and returning this cloned user object.\n            const tmp = node;\n            node = importNode(enc.document, obj.value, true);\n            node.appendChild(tmp);\n            // Moves the id attribute to the outermost XML node, namely the\n            // node which denotes the object boundaries in the file.\n            const id = tmp.getAttribute('id');\n            node.setAttribute('id', String(id));\n            tmp.removeAttribute('id');\n        }\n        return node;\n    }\n    /**\n     * Decodes an {@link Cell} and uses the enclosing XML node as the user object for the cell (inversion).\n     */\n    beforeDecode(dec, node, obj) {\n        let inner = node.cloneNode(true);\n        const classname = this.getName();\n        if (node.nodeName !== classname) {\n            // Passes the inner graphical annotation node to the\n            // object codec for further processing of the cell.\n            const tmp = node.getElementsByTagName(classname)[0];\n            if (tmp != null && tmp.parentNode === node) {\n                removeWhitespace(tmp, true);\n                removeWhitespace(tmp, false);\n                tmp.parentNode.removeChild(tmp);\n                inner = tmp;\n            }\n            else {\n                inner = null;\n            }\n            // Creates the user object out of the XML node\n            obj.value = node.cloneNode(true);\n            const id = obj.value.getAttribute('id');\n            if (id != null) {\n                obj.setId(id);\n                obj.value.removeAttribute('id');\n            }\n        }\n        else {\n            // Uses ID from XML file as ID for cell in model\n            obj.setId(node.getAttribute('id'));\n        }\n        // Preprocesses and removes all Id-references in order to use the\n        // correct encoder (this) for the known references to cells (all).\n        if (inner != null) {\n            for (let i = 0; i < this.idrefs.length; i += 1) {\n                const attr = this.idrefs[i];\n                const ref = inner.getAttribute(attr);\n                if (ref != null) {\n                    inner.removeAttribute(attr);\n                    let object = dec.objects[ref] || dec.lookup(ref);\n                    if (object == null) {\n                        // Needs to decode forward reference\n                        const element = dec.getElementById(ref);\n                        if (element != null) {\n                            const decoder = CodecRegistry.codecs[element.nodeName] || this;\n                            object = decoder.decode(dec, element);\n                        }\n                    }\n                    // @ts-ignore dynamic assignment was in original implementation\n                    obj[attr] = object;\n                }\n            }\n        }\n        return inner;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}