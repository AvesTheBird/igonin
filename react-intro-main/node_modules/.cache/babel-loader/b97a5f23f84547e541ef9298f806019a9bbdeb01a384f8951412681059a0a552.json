{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectIdentity from '../util/ObjectIdentity';\nimport MaxLog from '../gui/MaxLog';\nimport Geometry from '../view/geometry/Geometry';\nimport Point from '../view/geometry/Point';\nimport { NODETYPE } from '../util/Constants';\nimport { isInteger, isNumeric } from '../util/mathUtils';\nimport { getTextContent } from '../util/domUtils';\nimport { load } from '../util/MaxXmlRequest';\n/**\n * Generic codec for JavaScript objects that implements a mapping between\n * JavaScript objects and XML nodes that maps each field or element to an\n * attribute or child node, and vice versa.\n *\n * ### Atomic Values\n *\n * Consider the following example.\n *\n * ```javascript\n * const obj = new Object();\n * obj.foo = \"Foo\";\n * obj.bar = \"Bar\";\n * ```\n *\n * This object is encoded into an XML node using the following.\n *\n * ```javascript\n * const enc = new Codec();\n * const node = enc.encode(obj);\n * ```\n *\n * The output of the encoding may be viewed using {@link MaxLog} as follows.\n *\n * ```javascript\n * MaxLog.show();\n * MaxLog.debug(mxUtils.getPrettyXml(node));\n * ```\n *\n * Finally, the result of the encoding looks as follows.\n *\n * ```javascript\n * <Object foo=\"Foo\" bar=\"Bar\"/>\n * ```\n *\n * In the above output, the foo and bar fields have been mapped to attributes\n * with the same names, and the name of the constructor was used for the\n * node name.\n *\n * ### Booleans\n *\n * Since booleans are numbers in JavaScript, all boolean values are encoded\n * into 1 for true and 0 for false. The decoder also accepts the string true\n * and false for boolean values.\n *\n * ### Objects\n *\n * The above scheme is applied to all atomic fields, that is, to all non-object\n * fields of an object. For object fields, a child node is created with a\n * special attribute that contains the field name. This special attribute is\n * called \"as\" and hence, as is a reserved word that should not be used for a\n * field name.\n *\n * Consider the following example where foo is an object and bar is an atomic\n * property of foo.\n *\n * ```javascript\n * const obj = {foo: {bar: \"Bar\"}};\n * ```\n *\n * This will be mapped to the following XML structure by ObjectCodec.\n *\n * ```javascript\n * <Object>\n *   <Object bar=\"Bar\" as=\"foo\"/>\n * </Object>\n * ```\n *\n * In the above output, the inner Object node contains the as-attribute that\n * specifies the field name in the enclosing object. That is, the field foo was\n * mapped to a child node with an as-attribute that has the value foo.\n *\n * ### Arrays\n *\n * Arrays are special objects that are either associative, in which case each\n * key, value pair is treated like a field where the key is the field name, or\n * they are a sequence of atomic values and objects, which is mapped to a\n * sequence of child nodes. For object elements, the above scheme is applied\n * without the use of the special as-attribute for creating each child. For\n * atomic elements, a special add-node is created with the value stored in the\n * value-attribute.\n *\n * For example, the following array contains one atomic value and one object\n * with a field called bar. Furthermore it contains two associative entries\n * called bar with an atomic value, and foo with an object value.\n *\n * ```javascript\n * const obj = [\"Bar\", {bar: \"Bar\"}];\n * obj[\"bar\"] = \"Bar\";\n * obj[\"foo\"] = {bar: \"Bar\"};\n * ```\n *\n * This array is represented by the following XML nodes.\n *\n * ```javascript\n * <Array bar=\"Bar\">\n *   <add value=\"Bar\"/>\n *   <Object bar=\"Bar\"/>\n *   <Object bar=\"Bar\" as=\"foo\"/>\n * </Array>\n * ```\n *\n * The Array node name is the name of the constructor. The additional\n * as-attribute in the last child contains the key of the associative entry,\n * whereas the second last child is part of the array sequence and does not\n * have an as-attribute.\n *\n * ### References\n *\n * Objects may be represented as child nodes or attributes with ID values,\n * which are used to lookup the object in a table within {@link Codec}. The\n * {@link isReference} function is in charge of deciding if a specific field should\n * be encoded as a reference or not. Its default implementation returns true if\n * the field name is in {@link idrefs}, an array of strings that is used to configure\n * the {@link ObjectCodec}.\n *\n * Using this approach, the mapping does not guarantee that the referenced\n * object itself exists in the document. The fields that are encoded as\n * references must be carefully chosen to make sure all referenced objects\n * exist in the document, or may be resolved by some other means if necessary.\n *\n * For example, in the case of the graph model all cells are stored in a tree\n * whose root is referenced by the model's root field. A tree is a structure\n * that is well suited for an XML representation, however, the additional edges\n * in the graph model have a reference to a source and target cell, which are\n * also contained in the tree. To handle this case, the source and target cell\n * of an edge are treated as references, whereas the children are treated as\n * objects. Since all cells are contained in the tree and no edge references a\n * source or target outside the tree, this setup makes sure all referenced\n * objects are contained in the document.\n *\n * In the case of a tree structure we must further avoid infinite recursion by\n * ignoring the parent reference of each child. This is done by returning true\n * in {@link isExcluded}, whose default implementation uses the array of excluded\n * fieldnames passed to the ObjectCodec constructor.\n *\n * References are only used for cells in mxGraph. For defining other\n * referencable object types, the codec must be able to work out the ID of an\n * object. This is done by implementing {@link Codec.reference}. For decoding a\n * reference, the XML node with the respective id-attribute is fetched from the\n * document, decoded, and stored in a lookup table for later reference. For\n * looking up external objects, {@link Codec.lookup} may be implemented.\n *\n * ### Expressions\n *\n * For decoding JavaScript expressions, the add-node may be used with a text\n * content that contains the JavaScript expression. For example, the following\n * creates a field called foo in the enclosing object and assigns it the value\n * of {@link Constants.ALIGN.LEFT}.\n *\n * ```javascript\n * <Object>\n *   <add as=\"foo\">Constants.ALIGN.LEFT</add>\n * </Object>\n * ```\n *\n * The resulting object has a field called foo with the value \"left\". Its XML\n * representation looks as follows.\n *\n * ```javascript\n * <Object foo=\"left\"/>\n * ```\n *\n * This means the expression is evaluated at decoding time and the result of\n * the evaluation is stored in the respective field. Valid expressions are all\n * JavaScript expressions, including function definitions, which are mapped to\n * functions on the resulting object.\n *\n * Expressions are only evaluated if {@link allowEval} is true.\n */\nclass ObjectCodec {\n  constructor(template, exclude = [], idrefs = [], mapping = {}) {\n    this.template = template;\n    this.exclude = exclude;\n    this.idrefs = idrefs;\n    this.mapping = mapping;\n    this.reverse = {};\n    for (const i in this.mapping) {\n      this.reverse[this.mapping[i]] = i;\n    }\n  }\n  /**\n   * Returns the name used for the node names and lookup of the codec when\n   * classes are encoded and nodes are decoded. For classes to work with\n   * this the codec registry automatically adds an alias for the classname\n   * if that is different from what this returns.\n   *\n   * The default implementation returns the classname of the template class if no name is set.\n   */\n  getName() {\n    return this.name ?? this.template.constructor.name;\n  }\n  setName(name) {\n    this.name = name;\n  }\n  /**\n   * Returns a new instance of the template for this codec.\n   */\n  cloneTemplate() {\n    return new this.template.constructor();\n  }\n  /**\n   * Returns the field name for the given attribute name.\n   * Looks up the value in the {@link reverse} mapping or returns\n   * the input if there is no reverse mapping for the\n   * given name.\n   */\n  getFieldName(attributename) {\n    if (attributename != null) {\n      const mapped = this.reverse[attributename];\n      if (mapped != null) {\n        attributename = mapped;\n      }\n    }\n    return attributename;\n  }\n  /**\n   * Returns the attribute name for the given field name.\n   * Looks up the value in the {@link mapping} or returns\n   * the input if there is no mapping for the\n   * given name.\n   */\n  getAttributeName(fieldname) {\n    if (fieldname != null) {\n      const mapped = this.mapping[fieldname];\n      if (mapped != null) {\n        fieldname = mapped;\n      }\n    }\n    return fieldname;\n  }\n  /**\n   * Returns true if the given attribute is to be ignored by the codec. This\n   * implementation returns true if the given field name is in {@link exclude} or\n   * if the field name equals {@link ObjectIdentity.FIELD_NAME}.\n   *\n   * @param obj Object instance that contains the field.\n   * @param attr Fieldname of the field.\n   * @param value Value of the field.\n   * @param write Boolean indicating if the field is being encoded or decoded.\n   * Write is true if the field is being encoded, else it is being decoded.\n   */\n  isExcluded(obj, attr, value, write) {\n    return attr == ObjectIdentity.FIELD_NAME || this.exclude.indexOf(attr) >= 0;\n  }\n  /**\n   * Returns true if the given field name is to be treated\n   * as a textual reference (ID). This implementation returns\n   * true if the given field name is in {@link idrefs}.\n   *\n   * @param obj Object instance that contains the field.\n   * @param attr Field name of the field.\n   * @param value Value of the field.\n   * @param write Boolean indicating if the field is being encoded or decoded.\n   * Write is true if the field is being encoded, else it is being decoded.\n   */\n  isReference(obj, attr, value, write) {\n    return this.idrefs.indexOf(attr) >= 0;\n  }\n  /**\n   * Encodes the specified object and returns a node\n   * representing then given object. Calls {@link beforeEncode}\n   * after creating the node and {@link afterEncode} with the\n   * resulting node after processing.\n   *\n   * Enc is a reference to the calling encoder. It is used\n   * to encode complex objects and create references.\n   *\n   * This implementation encodes all variables of an\n   * object according to the following rules:\n   *\n   * - If the variable name is in {@link exclude} then it is ignored.\n   * - If the variable name is in {@link idrefs} then {@link Codec.getId}\n   * is used to replace the object with its ID.\n   * - The variable name is mapped using {@link mapping}.\n   * - If obj is an array and the variable name is numeric\n   * (ie. an index) then it is not encoded.\n   * - If the value is an object, then the codec is used to\n   * create a child node with the variable name encoded into\n   * the \"as\" attribute.\n   * - Else, if {@link encodeDefaults} is true or the value differs\n   * from the template value, then ...\n   * - ... if obj is not an array, then the value is mapped to\n   * an attribute.\n   * - ... else if obj is an array, the value is mapped to an\n   * add child with a value attribute or a text child node,\n   * if the value is a function.\n   *\n   * If no ID exists for a variable in {@link idrefs} or if an object\n   * cannot be encoded, a warning is issued using {@link MaxLog.warn}.\n   *\n   * Returns the resulting XML node that represents the given\n   * object.\n   *\n   * @param enc {@link Codec} that controls the encoding process.\n   * @param obj Object to be encoded.\n   */\n  encode(enc, obj) {\n    const node = enc.document.createElement(this.getName());\n    obj = this.beforeEncode(enc, obj, node);\n    this.encodeObject(enc, obj, node);\n    return this.afterEncode(enc, obj, node);\n  }\n  /**\n   * Encodes the value of each member in then given obj into the given node using\n   * {@link encodeValue}.\n   *\n   * @param enc {@link Codec} that controls the encoding process.\n   * @param obj Object to be encoded.\n   * @param node XML node that contains the encoded object.\n   */\n  encodeObject(enc, obj, node) {\n    enc.setAttribute(node, 'id', enc.getId(obj));\n    for (const i in obj) {\n      let name = i;\n      const value = obj[name];\n      if (value != null && !this.isExcluded(obj, name, value, true)) {\n        if (isInteger(name)) {\n          name = null;\n        }\n        this.encodeValue(enc, obj, name, value, node);\n      }\n    }\n  }\n  /**\n   * Converts the given value according to the mappings\n   * and id-refs in this codec and uses {@link writeAttribute}\n   * to write the attribute into the given node.\n   *\n   * @param enc {@link Codec} that controls the encoding process.\n   * @param obj Object whose property is going to be encoded.\n   * @param name XML node that contains the encoded object.\n   * @param value Value of the property to be encoded.\n   * @param node XML node that contains the encoded object.\n   */\n  encodeValue(enc, obj, name, value, node) {\n    if (value != null) {\n      // TODO: What is the case where `name` can be `null`? =========================================================================\n      if (name != null && this.isReference(obj, name, value, true)) {\n        const tmp = enc.getId(value);\n        if (tmp == null) {\n          MaxLog.warn(`ObjectCodec.encode: No ID for ${this.getName()}.${name}=${value}`);\n          return; // exit\n        }\n        value = tmp;\n      }\n      // Checks if the value is a default value and\n      // the name is correct\n      if (name == null || enc.encodeDefaults || this.template[name] != value) {\n        name = this.getAttributeName(name);\n        this.writeAttribute(enc, obj, name, value, node);\n      }\n    }\n  }\n  /**\n   * Writes the given value into node using {@link writePrimitiveAttribute}\n   * or {@link writeComplexAttribute} depending on the type of the value.\n   */\n  writeAttribute(enc, obj, name, value, node) {\n    if (typeof value !== 'object' /* primitive type */) {\n      this.writePrimitiveAttribute(enc, obj, name, value, node);\n    } /* complex type */else {\n      this.writeComplexAttribute(enc, obj, name, value, node);\n    }\n  }\n  /**\n   * Writes the given value as an attribute of the given node.\n   */\n  writePrimitiveAttribute(enc, obj, name, value, node) {\n    value = this.convertAttributeToXml(enc, obj, name, value, node); // TODO: params don't seem to match - is this a bug? ===================================\n    if (name == null) {\n      const child = enc.document.createElement('add');\n      if (typeof value === 'function') {\n        child.appendChild(enc.document.createTextNode(value));\n      } else {\n        enc.setAttribute(child, 'value', value);\n      }\n      node.appendChild(child);\n    } else if (typeof value !== 'function') {\n      enc.setAttribute(node, name, value);\n    }\n  }\n  /**\n   * Writes the given value as a child node of the given node.\n   */\n  writeComplexAttribute(enc, obj, name, value, node) {\n    const child = enc.encode(value);\n    if (child != null) {\n      if (name != null) {\n        child.setAttribute('as', name);\n      }\n      node.appendChild(child);\n    } else {\n      MaxLog.warn(`ObjectCodec.encode: No node for ${this.getName()}.${name}: ${value}`);\n    }\n  }\n  /**\n   * Converts true to \"1\" and false to \"0\" is {@link isBooleanAttribute} returns true.\n   * All other values are not converted.\n   *\n   * @param enc {@link Codec} that controls the encoding process.\n   * @param obj Objec to convert the attribute for.\n   * @param name Name of the attribute to be converted.\n   * @param value Value to be converted.\n   */\n  convertAttributeToXml(enc, obj, name, value, node) {\n    // Makes sure to encode boolean values as numeric values\n    if (this.isBooleanAttribute(enc, obj, name, value)) {\n      // Checks if the value is true (do not use the value as is, because\n      // this would check if the value is not null, so 0 would be true)\n      value = value == true ? '1' : '0';\n    }\n    return value;\n  }\n  /**\n   * Returns true if the given object attribute is a boolean value.\n   *\n   * @param enc {@link Codec} that controls the encoding process.\n   * @param obj Object to convert the attribute for.\n   * @param name Name of the attribute to be converted.\n   * @param value Value of the attribute to be converted.\n   */\n  isBooleanAttribute(enc, obj, name, value) {\n    return typeof value.length === 'undefined' && (value == true || value == false);\n  }\n  /**\n   * Converts booleans and numeric values to the respective types. Values are\n   * numeric if {@link isNumericAttribute} returns true.\n   *\n   * @param dec {@link Codec} that controls the decoding process.\n   * @param attr XML attribute to be converted.\n   * @param obj Objec to convert the attribute for.\n   */\n  convertAttributeFromXml(dec, attr, obj) {\n    let {\n      value\n    } = attr;\n    if (this.isNumericAttribute(dec, attr, obj)) {\n      value = parseFloat(value);\n      if (Number.isNaN(value) || !Number.isFinite(value)) {\n        value = 0;\n      }\n    }\n    return value;\n  }\n  /**\n   * Returns true if the given XML attribute is or should be a numeric value.\n   *\n   * @param dec {@link Codec} that controls the decoding process.\n   * @param attr XML attribute to be converted.\n   * @param obj Object to convert the attribute for.\n   */\n  isNumericAttribute(dec, attr, obj) {\n    // Handles known numeric attributes for generic objects\n    return obj.constructor === Geometry && (attr.name === 'x' || attr.name === 'y' || attr.name === 'width' || attr.name === 'height') || obj.constructor === Point && (attr.name === 'x' || attr.name === 'y') || isNumeric(attr.value);\n  }\n  /**\n   * Hook for subclassers to pre-process the object before\n   * encoding. This returns the input object. The return\n   * value of this function is used in {@link encode} to perform\n   * the default encoding into the given node.\n   *\n   * @param enc {@link Codec} that controls the encoding process.\n   * @param obj Object to be encoded.\n   * @param node XML node to encode the object into.\n   */\n  beforeEncode(enc, obj, node) {\n    return obj;\n  }\n  /**\n   * Hook for subclassers to post-process the node\n   * for the given object after encoding and return the\n   * post-processed node. This implementation returns\n   * the input node. The return value of this method\n   * is returned to the encoder from {@link encode}.\n   *\n   * @param enc {@link Codec} that controls the encoding process.\n   * @param obj Object to be encoded.\n   * @param node XML node that represents the default encoding.\n   */\n  afterEncode(enc, obj, node) {\n    return node;\n  }\n  /**\n   * Parses the given node into the object or returns a new object\n   * representing the given node.\n   *\n   * Dec is a reference to the calling decoder. It is used to decode\n   * complex objects and resolve references.\n   *\n   * If a node has an id attribute then the object cache is checked for the\n   * object. If the object is not yet in the cache then it is constructed\n   * using the constructor of {@link template} and cached in {@link Codec.objects}.\n   *\n   * This implementation decodes all attributes and childs of a node\n   * according to the following rules:\n   *\n   * - If the variable name is in {@link exclude} or if the attribute name is \"id\"\n   * or \"as\" then it is ignored.\n   * - If the variable name is in {@link idrefs} then {@link Codec.getObject} is used\n   * to replace the reference with an object.\n   * - The variable name is mapped using a reverse {@link mapping}.\n   * - If the value has a child node, then the codec is used to create a\n   * child object with the variable name taken from the \"as\" attribute.\n   * - If the object is an array and the variable name is empty then the\n   * value or child object is appended to the array.\n   * - If an add child has no value or the object is not an array then\n   * the child text content is evaluated using {@link eval}.\n   *\n   * For add nodes where the object is not an array and the variable name\n   * is defined, the default mechanism is used, allowing to override/add\n   * methods as follows:\n   *\n   * ```javascript\n   * <Object>\n   *   <add as=\"hello\"><![CDATA[\n   *     function(arg1) {\n   *       mxUtils.alert('Hello '+arg1);\n   *     }\n   *   ]]></add>\n   * </Object>\n   * ```\n   *\n   * If no object exists for an ID in {@link idrefs} a warning is issued\n   * using {@link MaxLog.warn}.\n   *\n   * Returns the resulting object that represents the given XML node\n   * or the object given to the method as the into parameter.\n   *\n   * @param dec {@link Codec} that controls the decoding process.\n   * @param node XML node to be decoded.\n   * @param into Optional object to encode the node into.\n   */\n  decode(dec, node, into) {\n    const id = node.getAttribute('id');\n    let obj = dec.objects[id];\n    if (obj == null) {\n      obj = into || this.cloneTemplate();\n      if (id != null) {\n        dec.putObject(id, obj);\n      }\n    }\n    const _node = this.beforeDecode(dec, node, obj);\n    this.decodeNode(dec, _node, obj);\n    return this.afterDecode(dec, _node, obj);\n  }\n  /**\n   * Calls {@link decodeAttributes} and {@link decodeChildren} for the given node.\n   *\n   * @param dec {@link Codec} that controls the decoding process.\n   * @param node XML node to be decoded.\n   * @param obj Objec to encode the node into.\n   */\n  decodeNode(dec, node, obj) {\n    if (node != null) {\n      this.decodeAttributes(dec, node, obj);\n      this.decodeChildren(dec, node, obj);\n    }\n  }\n  /**\n   * Decodes all attributes of the given node using {@link decodeAttribute}.\n   *\n   * @param dec {@link Codec} that controls the decoding process.\n   * @param node XML node to be decoded.\n   * @param obj Object to encode the node into.\n   */\n  decodeAttributes(dec, node, obj) {\n    const attrs = node.attributes;\n    if (attrs != null) {\n      for (let i = 0; i < attrs.length; i += 1) {\n        this.decodeAttribute(dec, attrs[i], obj);\n      }\n    }\n  }\n  /**\n   * Returns true if the given attribute should be ignored. This implementation\n   * returns true if the attribute name is \"as\" or \"id\".\n   *\n   * @param dec {@link Codec} that controls the decoding process.\n   * @param attr XML attribute to be decoded.\n   * @param obj Objec to encode the attribute into.\n   */\n  isIgnoredAttribute(dec, attr, obj) {\n    return attr.nodeName === 'as' || attr.nodeName === 'id';\n  }\n  /**\n   * Reads the given attribute into the specified object.\n   *\n   * @param dec {@link Codec} that controls the decoding process.\n   * @param attr XML attribute to be decoded.\n   * @param obj Objec to encode the attribute into.\n   */\n  decodeAttribute(dec, attr, obj) {\n    if (!this.isIgnoredAttribute(dec, attr, obj)) {\n      const name = attr.nodeName;\n      // Converts the string true and false to their boolean values.\n      // This may require an additional check on the obj to see if\n      // the existing field is a boolean value or uninitialized, in\n      // which case we may want to convert true and false to a string.\n      let value = this.convertAttributeFromXml(dec, attr, obj);\n      const fieldname = this.getFieldName(name);\n      if (this.isReference(obj, fieldname, value, false)) {\n        const tmp = dec.getObject(value);\n        if (tmp == null) {\n          MaxLog.warn(`ObjectCodec.decode: No object for ${this.getName()}.${name}=${value}`);\n          return; // exit\n        }\n        value = tmp;\n      }\n      if (!this.isExcluded(obj, name, value, false)) {\n        obj[name] = value;\n      }\n    }\n  }\n  /**\n   * Decodes all children of the given node using {@link decodeChild}.\n   *\n   * @param dec {@link Codec} that controls the decoding process.\n   * @param node XML node to be decoded.\n   * @param obj Objec to encode the node into.\n   */\n  decodeChildren(dec, node, obj) {\n    let child = node.firstChild;\n    while (child != null) {\n      const tmp = child.nextSibling;\n      if (child.nodeType === NODETYPE.ELEMENT && !this.processInclude(dec, child, obj)) {\n        this.decodeChild(dec, child, obj);\n      }\n      child = tmp;\n    }\n  }\n  /**\n   * Reads the specified child into the given object.\n   *\n   * @param dec {@link Codec} that controls the decoding process.\n   * @param child XML child element to be decoded.\n   * @param obj Objec to encode the node into.\n   */\n  decodeChild(dec, child, obj) {\n    const fieldname = this.getFieldName(child.getAttribute('as'));\n    if (fieldname == null || !this.isExcluded(obj, fieldname, child, false)) {\n      const template = this.getFieldTemplate(obj, fieldname, child);\n      let value = null;\n      if (child.nodeName === 'add') {\n        value = child.getAttribute('value');\n        if (value == null && ObjectCodec.allowEval) {\n          value = eval(getTextContent(child));\n        }\n      } else {\n        value = dec.decode(child, template);\n      }\n      try {\n        this.addObjectValue(obj, fieldname, value, template);\n      } catch (e) {\n        throw new Error(`${e.message} for ${child.nodeName}`);\n      }\n    }\n  }\n  /**\n   * Returns the template instance for the given field. This returns the\n   * value of the field, null if the value is an array or an empty collection\n   * if the value is a collection. The value is then used to populate the\n   * field for a new instance. For strongly typed languages it may be\n   * required to override this to return the correct collection instance\n   * based on the encoded child.\n   */\n  getFieldTemplate(obj, fieldname, child) {\n    let template = obj[fieldname];\n    // Non-empty arrays are replaced completely\n    if (template instanceof Array && template.length > 0) {\n      template = null;\n    }\n    return template;\n  }\n  /**\n   * Sets the decoded child node as a value of the given object. If the\n   * object is a map, then the value is added with the given field name as a\n   * key. If the field name is not empty, then setFieldValue is called or\n   * else, if the object is a collection, the value is added to the\n   * collection. For strongly typed languages it may be required to\n   * override this with the correct code to add an entry to an object.\n   */\n  addObjectValue(obj, fieldname, value, template) {\n    if (value != null && value !== template) {\n      if (fieldname != null && fieldname.length > 0) {\n        obj[fieldname] = value;\n      } else {\n        obj.push(value);\n      }\n    }\n  }\n  /**\n   * Returns true if the given node is an include directive and\n   * executes the include by decoding the XML document. Returns\n   * false if the given node is not an include directive.\n   *\n   * @param dec {@link Codec} that controls the encoding/decoding process.\n   * @param node XML node to be checked.\n   * @param into Optional object to pass-thru to the codec.\n   */\n  processInclude(dec, node, into) {\n    if (node.nodeName === 'include') {\n      const name = node.getAttribute('name');\n      if (name != null) {\n        try {\n          const xml = load(name).getDocumentElement();\n          if (xml != null) {\n            dec.decode(xml, into);\n          }\n        } catch (e) {\n          // ignore\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Hook for subclassers to pre-process the node for\n   * the specified object and return the node to be\n   * used for further processing by {@link decode}.\n   * The object is created based on the template in the\n   * calling method and is never null. This implementation\n   * returns the input node. The return value of this\n   * function is used in {@link decode} to perform\n   * the default decoding into the given object.\n   *\n   * @param dec {@link Codec} that controls the decoding process.\n   * @param node XML node to be decoded.\n   * @param obj Object to encode the node into.\n   */\n  beforeDecode(dec, node, obj) {\n    return node;\n  }\n  /**\n   * Hook for subclassers to post-process the object after\n   * decoding. This implementation returns the given object\n   * without any changes. The return value of this method\n   * is returned to the decoder from {@link decode}.\n   *\n   * @param dec {@link Codec} that controls the encoding process.\n   * @param node XML node to be decoded.\n   * @param obj Object that represents the default decoding.\n   */\n  afterDecode(dec, node, obj) {\n    return obj;\n  }\n}\n/**\n * Static global switch that specifies if expressions in arrays are allowed.\n *\n * **NOTE**: Enabling this carries a possible security risk.\n * @default false\n */\nObjectCodec.allowEval = false;\nexport default ObjectCodec;","map":{"version":3,"names":["ObjectIdentity","MaxLog","Geometry","Point","NODETYPE","isInteger","isNumeric","getTextContent","load","ObjectCodec","constructor","template","exclude","idrefs","mapping","reverse","i","getName","name","setName","cloneTemplate","getFieldName","attributename","mapped","getAttributeName","fieldname","isExcluded","obj","attr","value","write","FIELD_NAME","indexOf","isReference","encode","enc","node","document","createElement","beforeEncode","encodeObject","afterEncode","setAttribute","getId","encodeValue","tmp","warn","encodeDefaults","writeAttribute","writePrimitiveAttribute","writeComplexAttribute","convertAttributeToXml","child","appendChild","createTextNode","isBooleanAttribute","length","convertAttributeFromXml","dec","isNumericAttribute","parseFloat","Number","isNaN","isFinite","decode","into","id","getAttribute","objects","putObject","_node","beforeDecode","decodeNode","afterDecode","decodeAttributes","decodeChildren","attrs","attributes","decodeAttribute","isIgnoredAttribute","nodeName","getObject","firstChild","nextSibling","nodeType","ELEMENT","processInclude","decodeChild","getFieldTemplate","allowEval","eval","addObjectValue","e","Error","message","Array","push","xml","getDocumentElement"],"sources":["D:/OSPanel/domains/проекты open server/old/react/react-intro-main/node_modules/@maxgraph/core/dist/serialization/ObjectCodec.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectIdentity from '../util/ObjectIdentity';\nimport MaxLog from '../gui/MaxLog';\nimport Geometry from '../view/geometry/Geometry';\nimport Point from '../view/geometry/Point';\nimport { NODETYPE } from '../util/Constants';\nimport { isInteger, isNumeric } from '../util/mathUtils';\nimport { getTextContent } from '../util/domUtils';\nimport { load } from '../util/MaxXmlRequest';\n/**\n * Generic codec for JavaScript objects that implements a mapping between\n * JavaScript objects and XML nodes that maps each field or element to an\n * attribute or child node, and vice versa.\n *\n * ### Atomic Values\n *\n * Consider the following example.\n *\n * ```javascript\n * const obj = new Object();\n * obj.foo = \"Foo\";\n * obj.bar = \"Bar\";\n * ```\n *\n * This object is encoded into an XML node using the following.\n *\n * ```javascript\n * const enc = new Codec();\n * const node = enc.encode(obj);\n * ```\n *\n * The output of the encoding may be viewed using {@link MaxLog} as follows.\n *\n * ```javascript\n * MaxLog.show();\n * MaxLog.debug(mxUtils.getPrettyXml(node));\n * ```\n *\n * Finally, the result of the encoding looks as follows.\n *\n * ```javascript\n * <Object foo=\"Foo\" bar=\"Bar\"/>\n * ```\n *\n * In the above output, the foo and bar fields have been mapped to attributes\n * with the same names, and the name of the constructor was used for the\n * node name.\n *\n * ### Booleans\n *\n * Since booleans are numbers in JavaScript, all boolean values are encoded\n * into 1 for true and 0 for false. The decoder also accepts the string true\n * and false for boolean values.\n *\n * ### Objects\n *\n * The above scheme is applied to all atomic fields, that is, to all non-object\n * fields of an object. For object fields, a child node is created with a\n * special attribute that contains the field name. This special attribute is\n * called \"as\" and hence, as is a reserved word that should not be used for a\n * field name.\n *\n * Consider the following example where foo is an object and bar is an atomic\n * property of foo.\n *\n * ```javascript\n * const obj = {foo: {bar: \"Bar\"}};\n * ```\n *\n * This will be mapped to the following XML structure by ObjectCodec.\n *\n * ```javascript\n * <Object>\n *   <Object bar=\"Bar\" as=\"foo\"/>\n * </Object>\n * ```\n *\n * In the above output, the inner Object node contains the as-attribute that\n * specifies the field name in the enclosing object. That is, the field foo was\n * mapped to a child node with an as-attribute that has the value foo.\n *\n * ### Arrays\n *\n * Arrays are special objects that are either associative, in which case each\n * key, value pair is treated like a field where the key is the field name, or\n * they are a sequence of atomic values and objects, which is mapped to a\n * sequence of child nodes. For object elements, the above scheme is applied\n * without the use of the special as-attribute for creating each child. For\n * atomic elements, a special add-node is created with the value stored in the\n * value-attribute.\n *\n * For example, the following array contains one atomic value and one object\n * with a field called bar. Furthermore it contains two associative entries\n * called bar with an atomic value, and foo with an object value.\n *\n * ```javascript\n * const obj = [\"Bar\", {bar: \"Bar\"}];\n * obj[\"bar\"] = \"Bar\";\n * obj[\"foo\"] = {bar: \"Bar\"};\n * ```\n *\n * This array is represented by the following XML nodes.\n *\n * ```javascript\n * <Array bar=\"Bar\">\n *   <add value=\"Bar\"/>\n *   <Object bar=\"Bar\"/>\n *   <Object bar=\"Bar\" as=\"foo\"/>\n * </Array>\n * ```\n *\n * The Array node name is the name of the constructor. The additional\n * as-attribute in the last child contains the key of the associative entry,\n * whereas the second last child is part of the array sequence and does not\n * have an as-attribute.\n *\n * ### References\n *\n * Objects may be represented as child nodes or attributes with ID values,\n * which are used to lookup the object in a table within {@link Codec}. The\n * {@link isReference} function is in charge of deciding if a specific field should\n * be encoded as a reference or not. Its default implementation returns true if\n * the field name is in {@link idrefs}, an array of strings that is used to configure\n * the {@link ObjectCodec}.\n *\n * Using this approach, the mapping does not guarantee that the referenced\n * object itself exists in the document. The fields that are encoded as\n * references must be carefully chosen to make sure all referenced objects\n * exist in the document, or may be resolved by some other means if necessary.\n *\n * For example, in the case of the graph model all cells are stored in a tree\n * whose root is referenced by the model's root field. A tree is a structure\n * that is well suited for an XML representation, however, the additional edges\n * in the graph model have a reference to a source and target cell, which are\n * also contained in the tree. To handle this case, the source and target cell\n * of an edge are treated as references, whereas the children are treated as\n * objects. Since all cells are contained in the tree and no edge references a\n * source or target outside the tree, this setup makes sure all referenced\n * objects are contained in the document.\n *\n * In the case of a tree structure we must further avoid infinite recursion by\n * ignoring the parent reference of each child. This is done by returning true\n * in {@link isExcluded}, whose default implementation uses the array of excluded\n * fieldnames passed to the ObjectCodec constructor.\n *\n * References are only used for cells in mxGraph. For defining other\n * referencable object types, the codec must be able to work out the ID of an\n * object. This is done by implementing {@link Codec.reference}. For decoding a\n * reference, the XML node with the respective id-attribute is fetched from the\n * document, decoded, and stored in a lookup table for later reference. For\n * looking up external objects, {@link Codec.lookup} may be implemented.\n *\n * ### Expressions\n *\n * For decoding JavaScript expressions, the add-node may be used with a text\n * content that contains the JavaScript expression. For example, the following\n * creates a field called foo in the enclosing object and assigns it the value\n * of {@link Constants.ALIGN.LEFT}.\n *\n * ```javascript\n * <Object>\n *   <add as=\"foo\">Constants.ALIGN.LEFT</add>\n * </Object>\n * ```\n *\n * The resulting object has a field called foo with the value \"left\". Its XML\n * representation looks as follows.\n *\n * ```javascript\n * <Object foo=\"left\"/>\n * ```\n *\n * This means the expression is evaluated at decoding time and the result of\n * the evaluation is stored in the respective field. Valid expressions are all\n * JavaScript expressions, including function definitions, which are mapped to\n * functions on the resulting object.\n *\n * Expressions are only evaluated if {@link allowEval} is true.\n */\nclass ObjectCodec {\n    constructor(template, exclude = [], idrefs = [], mapping = {}) {\n        this.template = template;\n        this.exclude = exclude;\n        this.idrefs = idrefs;\n        this.mapping = mapping;\n        this.reverse = {};\n        for (const i in this.mapping) {\n            this.reverse[this.mapping[i]] = i;\n        }\n    }\n    /**\n     * Returns the name used for the node names and lookup of the codec when\n     * classes are encoded and nodes are decoded. For classes to work with\n     * this the codec registry automatically adds an alias for the classname\n     * if that is different from what this returns.\n     *\n     * The default implementation returns the classname of the template class if no name is set.\n     */\n    getName() {\n        return this.name ?? this.template.constructor.name;\n    }\n    setName(name) {\n        this.name = name;\n    }\n    /**\n     * Returns a new instance of the template for this codec.\n     */\n    cloneTemplate() {\n        return new this.template.constructor();\n    }\n    /**\n     * Returns the field name for the given attribute name.\n     * Looks up the value in the {@link reverse} mapping or returns\n     * the input if there is no reverse mapping for the\n     * given name.\n     */\n    getFieldName(attributename) {\n        if (attributename != null) {\n            const mapped = this.reverse[attributename];\n            if (mapped != null) {\n                attributename = mapped;\n            }\n        }\n        return attributename;\n    }\n    /**\n     * Returns the attribute name for the given field name.\n     * Looks up the value in the {@link mapping} or returns\n     * the input if there is no mapping for the\n     * given name.\n     */\n    getAttributeName(fieldname) {\n        if (fieldname != null) {\n            const mapped = this.mapping[fieldname];\n            if (mapped != null) {\n                fieldname = mapped;\n            }\n        }\n        return fieldname;\n    }\n    /**\n     * Returns true if the given attribute is to be ignored by the codec. This\n     * implementation returns true if the given field name is in {@link exclude} or\n     * if the field name equals {@link ObjectIdentity.FIELD_NAME}.\n     *\n     * @param obj Object instance that contains the field.\n     * @param attr Fieldname of the field.\n     * @param value Value of the field.\n     * @param write Boolean indicating if the field is being encoded or decoded.\n     * Write is true if the field is being encoded, else it is being decoded.\n     */\n    isExcluded(obj, attr, value, write) {\n        return attr == ObjectIdentity.FIELD_NAME || this.exclude.indexOf(attr) >= 0;\n    }\n    /**\n     * Returns true if the given field name is to be treated\n     * as a textual reference (ID). This implementation returns\n     * true if the given field name is in {@link idrefs}.\n     *\n     * @param obj Object instance that contains the field.\n     * @param attr Field name of the field.\n     * @param value Value of the field.\n     * @param write Boolean indicating if the field is being encoded or decoded.\n     * Write is true if the field is being encoded, else it is being decoded.\n     */\n    isReference(obj, attr, value, write) {\n        return this.idrefs.indexOf(attr) >= 0;\n    }\n    /**\n     * Encodes the specified object and returns a node\n     * representing then given object. Calls {@link beforeEncode}\n     * after creating the node and {@link afterEncode} with the\n     * resulting node after processing.\n     *\n     * Enc is a reference to the calling encoder. It is used\n     * to encode complex objects and create references.\n     *\n     * This implementation encodes all variables of an\n     * object according to the following rules:\n     *\n     * - If the variable name is in {@link exclude} then it is ignored.\n     * - If the variable name is in {@link idrefs} then {@link Codec.getId}\n     * is used to replace the object with its ID.\n     * - The variable name is mapped using {@link mapping}.\n     * - If obj is an array and the variable name is numeric\n     * (ie. an index) then it is not encoded.\n     * - If the value is an object, then the codec is used to\n     * create a child node with the variable name encoded into\n     * the \"as\" attribute.\n     * - Else, if {@link encodeDefaults} is true or the value differs\n     * from the template value, then ...\n     * - ... if obj is not an array, then the value is mapped to\n     * an attribute.\n     * - ... else if obj is an array, the value is mapped to an\n     * add child with a value attribute or a text child node,\n     * if the value is a function.\n     *\n     * If no ID exists for a variable in {@link idrefs} or if an object\n     * cannot be encoded, a warning is issued using {@link MaxLog.warn}.\n     *\n     * Returns the resulting XML node that represents the given\n     * object.\n     *\n     * @param enc {@link Codec} that controls the encoding process.\n     * @param obj Object to be encoded.\n     */\n    encode(enc, obj) {\n        const node = enc.document.createElement(this.getName());\n        obj = this.beforeEncode(enc, obj, node);\n        this.encodeObject(enc, obj, node);\n        return this.afterEncode(enc, obj, node);\n    }\n    /**\n     * Encodes the value of each member in then given obj into the given node using\n     * {@link encodeValue}.\n     *\n     * @param enc {@link Codec} that controls the encoding process.\n     * @param obj Object to be encoded.\n     * @param node XML node that contains the encoded object.\n     */\n    encodeObject(enc, obj, node) {\n        enc.setAttribute(node, 'id', enc.getId(obj));\n        for (const i in obj) {\n            let name = i;\n            const value = obj[name];\n            if (value != null && !this.isExcluded(obj, name, value, true)) {\n                if (isInteger(name)) {\n                    name = null;\n                }\n                this.encodeValue(enc, obj, name, value, node);\n            }\n        }\n    }\n    /**\n     * Converts the given value according to the mappings\n     * and id-refs in this codec and uses {@link writeAttribute}\n     * to write the attribute into the given node.\n     *\n     * @param enc {@link Codec} that controls the encoding process.\n     * @param obj Object whose property is going to be encoded.\n     * @param name XML node that contains the encoded object.\n     * @param value Value of the property to be encoded.\n     * @param node XML node that contains the encoded object.\n     */\n    encodeValue(enc, obj, name, value, node) {\n        if (value != null) {\n            // TODO: What is the case where `name` can be `null`? =========================================================================\n            if (name != null && this.isReference(obj, name, value, true)) {\n                const tmp = enc.getId(value);\n                if (tmp == null) {\n                    MaxLog.warn(`ObjectCodec.encode: No ID for ${this.getName()}.${name}=${value}`);\n                    return; // exit\n                }\n                value = tmp;\n            }\n            // Checks if the value is a default value and\n            // the name is correct\n            if (name == null || enc.encodeDefaults || this.template[name] != value) {\n                name = this.getAttributeName(name);\n                this.writeAttribute(enc, obj, name, value, node);\n            }\n        }\n    }\n    /**\n     * Writes the given value into node using {@link writePrimitiveAttribute}\n     * or {@link writeComplexAttribute} depending on the type of the value.\n     */\n    writeAttribute(enc, obj, name, value, node) {\n        if (typeof value !== 'object' /* primitive type */) {\n            this.writePrimitiveAttribute(enc, obj, name, value, node);\n        } /* complex type */\n        else {\n            this.writeComplexAttribute(enc, obj, name, value, node);\n        }\n    }\n    /**\n     * Writes the given value as an attribute of the given node.\n     */\n    writePrimitiveAttribute(enc, obj, name, value, node) {\n        value = this.convertAttributeToXml(enc, obj, name, value, node); // TODO: params don't seem to match - is this a bug? ===================================\n        if (name == null) {\n            const child = enc.document.createElement('add');\n            if (typeof value === 'function') {\n                child.appendChild(enc.document.createTextNode(value));\n            }\n            else {\n                enc.setAttribute(child, 'value', value);\n            }\n            node.appendChild(child);\n        }\n        else if (typeof value !== 'function') {\n            enc.setAttribute(node, name, value);\n        }\n    }\n    /**\n     * Writes the given value as a child node of the given node.\n     */\n    writeComplexAttribute(enc, obj, name, value, node) {\n        const child = enc.encode(value);\n        if (child != null) {\n            if (name != null) {\n                child.setAttribute('as', name);\n            }\n            node.appendChild(child);\n        }\n        else {\n            MaxLog.warn(`ObjectCodec.encode: No node for ${this.getName()}.${name}: ${value}`);\n        }\n    }\n    /**\n     * Converts true to \"1\" and false to \"0\" is {@link isBooleanAttribute} returns true.\n     * All other values are not converted.\n     *\n     * @param enc {@link Codec} that controls the encoding process.\n     * @param obj Objec to convert the attribute for.\n     * @param name Name of the attribute to be converted.\n     * @param value Value to be converted.\n     */\n    convertAttributeToXml(enc, obj, name, value, node) {\n        // Makes sure to encode boolean values as numeric values\n        if (this.isBooleanAttribute(enc, obj, name, value)) {\n            // Checks if the value is true (do not use the value as is, because\n            // this would check if the value is not null, so 0 would be true)\n            value = value == true ? '1' : '0';\n        }\n        return value;\n    }\n    /**\n     * Returns true if the given object attribute is a boolean value.\n     *\n     * @param enc {@link Codec} that controls the encoding process.\n     * @param obj Object to convert the attribute for.\n     * @param name Name of the attribute to be converted.\n     * @param value Value of the attribute to be converted.\n     */\n    isBooleanAttribute(enc, obj, name, value) {\n        return typeof value.length === 'undefined' && (value == true || value == false);\n    }\n    /**\n     * Converts booleans and numeric values to the respective types. Values are\n     * numeric if {@link isNumericAttribute} returns true.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param attr XML attribute to be converted.\n     * @param obj Objec to convert the attribute for.\n     */\n    convertAttributeFromXml(dec, attr, obj) {\n        let { value } = attr;\n        if (this.isNumericAttribute(dec, attr, obj)) {\n            value = parseFloat(value);\n            if (Number.isNaN(value) || !Number.isFinite(value)) {\n                value = 0;\n            }\n        }\n        return value;\n    }\n    /**\n     * Returns true if the given XML attribute is or should be a numeric value.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param attr XML attribute to be converted.\n     * @param obj Object to convert the attribute for.\n     */\n    isNumericAttribute(dec, attr, obj) {\n        // Handles known numeric attributes for generic objects\n        return ((obj.constructor === Geometry &&\n            (attr.name === 'x' ||\n                attr.name === 'y' ||\n                attr.name === 'width' ||\n                attr.name === 'height')) ||\n            (obj.constructor === Point && (attr.name === 'x' || attr.name === 'y')) ||\n            isNumeric(attr.value));\n    }\n    /**\n     * Hook for subclassers to pre-process the object before\n     * encoding. This returns the input object. The return\n     * value of this function is used in {@link encode} to perform\n     * the default encoding into the given node.\n     *\n     * @param enc {@link Codec} that controls the encoding process.\n     * @param obj Object to be encoded.\n     * @param node XML node to encode the object into.\n     */\n    beforeEncode(enc, obj, node) {\n        return obj;\n    }\n    /**\n     * Hook for subclassers to post-process the node\n     * for the given object after encoding and return the\n     * post-processed node. This implementation returns\n     * the input node. The return value of this method\n     * is returned to the encoder from {@link encode}.\n     *\n     * @param enc {@link Codec} that controls the encoding process.\n     * @param obj Object to be encoded.\n     * @param node XML node that represents the default encoding.\n     */\n    afterEncode(enc, obj, node) {\n        return node;\n    }\n    /**\n     * Parses the given node into the object or returns a new object\n     * representing the given node.\n     *\n     * Dec is a reference to the calling decoder. It is used to decode\n     * complex objects and resolve references.\n     *\n     * If a node has an id attribute then the object cache is checked for the\n     * object. If the object is not yet in the cache then it is constructed\n     * using the constructor of {@link template} and cached in {@link Codec.objects}.\n     *\n     * This implementation decodes all attributes and childs of a node\n     * according to the following rules:\n     *\n     * - If the variable name is in {@link exclude} or if the attribute name is \"id\"\n     * or \"as\" then it is ignored.\n     * - If the variable name is in {@link idrefs} then {@link Codec.getObject} is used\n     * to replace the reference with an object.\n     * - The variable name is mapped using a reverse {@link mapping}.\n     * - If the value has a child node, then the codec is used to create a\n     * child object with the variable name taken from the \"as\" attribute.\n     * - If the object is an array and the variable name is empty then the\n     * value or child object is appended to the array.\n     * - If an add child has no value or the object is not an array then\n     * the child text content is evaluated using {@link eval}.\n     *\n     * For add nodes where the object is not an array and the variable name\n     * is defined, the default mechanism is used, allowing to override/add\n     * methods as follows:\n     *\n     * ```javascript\n     * <Object>\n     *   <add as=\"hello\"><![CDATA[\n     *     function(arg1) {\n     *       mxUtils.alert('Hello '+arg1);\n     *     }\n     *   ]]></add>\n     * </Object>\n     * ```\n     *\n     * If no object exists for an ID in {@link idrefs} a warning is issued\n     * using {@link MaxLog.warn}.\n     *\n     * Returns the resulting object that represents the given XML node\n     * or the object given to the method as the into parameter.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param node XML node to be decoded.\n     * @param into Optional object to encode the node into.\n     */\n    decode(dec, node, into) {\n        const id = node.getAttribute('id');\n        let obj = dec.objects[id];\n        if (obj == null) {\n            obj = into || this.cloneTemplate();\n            if (id != null) {\n                dec.putObject(id, obj);\n            }\n        }\n        const _node = this.beforeDecode(dec, node, obj);\n        this.decodeNode(dec, _node, obj);\n        return this.afterDecode(dec, _node, obj);\n    }\n    /**\n     * Calls {@link decodeAttributes} and {@link decodeChildren} for the given node.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param node XML node to be decoded.\n     * @param obj Objec to encode the node into.\n     */\n    decodeNode(dec, node, obj) {\n        if (node != null) {\n            this.decodeAttributes(dec, node, obj);\n            this.decodeChildren(dec, node, obj);\n        }\n    }\n    /**\n     * Decodes all attributes of the given node using {@link decodeAttribute}.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param node XML node to be decoded.\n     * @param obj Object to encode the node into.\n     */\n    decodeAttributes(dec, node, obj) {\n        const attrs = node.attributes;\n        if (attrs != null) {\n            for (let i = 0; i < attrs.length; i += 1) {\n                this.decodeAttribute(dec, attrs[i], obj);\n            }\n        }\n    }\n    /**\n     * Returns true if the given attribute should be ignored. This implementation\n     * returns true if the attribute name is \"as\" or \"id\".\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param attr XML attribute to be decoded.\n     * @param obj Objec to encode the attribute into.\n     */\n    isIgnoredAttribute(dec, attr, obj) {\n        return attr.nodeName === 'as' || attr.nodeName === 'id';\n    }\n    /**\n     * Reads the given attribute into the specified object.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param attr XML attribute to be decoded.\n     * @param obj Objec to encode the attribute into.\n     */\n    decodeAttribute(dec, attr, obj) {\n        if (!this.isIgnoredAttribute(dec, attr, obj)) {\n            const name = attr.nodeName;\n            // Converts the string true and false to their boolean values.\n            // This may require an additional check on the obj to see if\n            // the existing field is a boolean value or uninitialized, in\n            // which case we may want to convert true and false to a string.\n            let value = this.convertAttributeFromXml(dec, attr, obj);\n            const fieldname = this.getFieldName(name);\n            if (this.isReference(obj, fieldname, value, false)) {\n                const tmp = dec.getObject(value);\n                if (tmp == null) {\n                    MaxLog.warn(`ObjectCodec.decode: No object for ${this.getName()}.${name}=${value}`);\n                    return; // exit\n                }\n                value = tmp;\n            }\n            if (!this.isExcluded(obj, name, value, false)) {\n                obj[name] = value;\n            }\n        }\n    }\n    /**\n     * Decodes all children of the given node using {@link decodeChild}.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param node XML node to be decoded.\n     * @param obj Objec to encode the node into.\n     */\n    decodeChildren(dec, node, obj) {\n        let child = node.firstChild;\n        while (child != null) {\n            const tmp = child.nextSibling;\n            if (child.nodeType === NODETYPE.ELEMENT && !this.processInclude(dec, child, obj)) {\n                this.decodeChild(dec, child, obj);\n            }\n            child = tmp;\n        }\n    }\n    /**\n     * Reads the specified child into the given object.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param child XML child element to be decoded.\n     * @param obj Objec to encode the node into.\n     */\n    decodeChild(dec, child, obj) {\n        const fieldname = this.getFieldName(child.getAttribute('as'));\n        if (fieldname == null || !this.isExcluded(obj, fieldname, child, false)) {\n            const template = this.getFieldTemplate(obj, fieldname, child);\n            let value = null;\n            if (child.nodeName === 'add') {\n                value = child.getAttribute('value');\n                if (value == null && ObjectCodec.allowEval) {\n                    value = eval(getTextContent(child));\n                }\n            }\n            else {\n                value = dec.decode(child, template);\n            }\n            try {\n                this.addObjectValue(obj, fieldname, value, template);\n            }\n            catch (e) {\n                throw new Error(`${e.message} for ${child.nodeName}`);\n            }\n        }\n    }\n    /**\n     * Returns the template instance for the given field. This returns the\n     * value of the field, null if the value is an array or an empty collection\n     * if the value is a collection. The value is then used to populate the\n     * field for a new instance. For strongly typed languages it may be\n     * required to override this to return the correct collection instance\n     * based on the encoded child.\n     */\n    getFieldTemplate(obj, fieldname, child) {\n        let template = obj[fieldname];\n        // Non-empty arrays are replaced completely\n        if (template instanceof Array && template.length > 0) {\n            template = null;\n        }\n        return template;\n    }\n    /**\n     * Sets the decoded child node as a value of the given object. If the\n     * object is a map, then the value is added with the given field name as a\n     * key. If the field name is not empty, then setFieldValue is called or\n     * else, if the object is a collection, the value is added to the\n     * collection. For strongly typed languages it may be required to\n     * override this with the correct code to add an entry to an object.\n     */\n    addObjectValue(obj, fieldname, value, template) {\n        if (value != null && value !== template) {\n            if (fieldname != null && fieldname.length > 0) {\n                obj[fieldname] = value;\n            }\n            else {\n                obj.push(value);\n            }\n        }\n    }\n    /**\n     * Returns true if the given node is an include directive and\n     * executes the include by decoding the XML document. Returns\n     * false if the given node is not an include directive.\n     *\n     * @param dec {@link Codec} that controls the encoding/decoding process.\n     * @param node XML node to be checked.\n     * @param into Optional object to pass-thru to the codec.\n     */\n    processInclude(dec, node, into) {\n        if (node.nodeName === 'include') {\n            const name = node.getAttribute('name');\n            if (name != null) {\n                try {\n                    const xml = load(name).getDocumentElement();\n                    if (xml != null) {\n                        dec.decode(xml, into);\n                    }\n                }\n                catch (e) {\n                    // ignore\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Hook for subclassers to pre-process the node for\n     * the specified object and return the node to be\n     * used for further processing by {@link decode}.\n     * The object is created based on the template in the\n     * calling method and is never null. This implementation\n     * returns the input node. The return value of this\n     * function is used in {@link decode} to perform\n     * the default decoding into the given object.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param node XML node to be decoded.\n     * @param obj Object to encode the node into.\n     */\n    beforeDecode(dec, node, obj) {\n        return node;\n    }\n    /**\n     * Hook for subclassers to post-process the object after\n     * decoding. This implementation returns the given object\n     * without any changes. The return value of this method\n     * is returned to the decoder from {@link decode}.\n     *\n     * @param dec {@link Codec} that controls the encoding process.\n     * @param node XML node to be decoded.\n     * @param obj Object that represents the default decoding.\n     */\n    afterDecode(dec, node, obj) {\n        return obj;\n    }\n}\n/**\n * Static global switch that specifies if expressions in arrays are allowed.\n *\n * **NOTE**: Enabling this carries a possible security risk.\n * @default false\n */\nObjectCodec.allowEval = false;\nexport default ObjectCodec;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,cAAc,MAAM,wBAAwB;AACnD,OAAOC,MAAM,MAAM,eAAe;AAClC,OAAOC,QAAQ,MAAM,2BAA2B;AAChD,OAAOC,KAAK,MAAM,wBAAwB;AAC1C,SAASC,QAAQ,QAAQ,mBAAmB;AAC5C,SAASC,SAAS,EAAEC,SAAS,QAAQ,mBAAmB;AACxD,SAASC,cAAc,QAAQ,kBAAkB;AACjD,SAASC,IAAI,QAAQ,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,WAAW,CAAC;EAC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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}