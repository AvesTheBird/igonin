{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Event } from '../event.js';\nimport { DisposableStore, toDisposable } from '../lifecycle.js';\nimport { BaseObservable, ConvenientObservable, _setKeepObserved, _setRecomputeInitiallyAndOnChange, subtransaction, transaction } from './base.js';\nimport { DebugNameData } from './debugName.js';\nimport { derived, derivedOpts } from './derived.js';\nimport { getLogger } from './logging.js';\nimport { strictEquals } from '../equals.js';\n/**\n * Represents an efficient observable whose value never changes.\n */\nexport function constObservable(value) {\n  return new ConstObservable(value);\n}\nclass ConstObservable extends ConvenientObservable {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  get debugName() {\n    return this.toString();\n  }\n  get() {\n    return this.value;\n  }\n  addObserver(observer) {\n    // NO OP\n  }\n  removeObserver(observer) {\n    // NO OP\n  }\n  toString() {\n    return \"Const: \".concat(this.value);\n  }\n}\nexport function observableFromEvent() {\n  let owner;\n  let event;\n  let getValue;\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  if (args.length === 3) {\n    [owner, event, getValue] = args;\n  } else {\n    [event, getValue] = args;\n  }\n  return new FromEventObservable(new DebugNameData(owner, undefined, getValue), event, getValue, () => FromEventObservable.globalTransaction, strictEquals);\n}\nexport function observableFromEventOpts(options, event, getValue) {\n  var _options$debugReferen, _options$equalsFn;\n  return new FromEventObservable(new DebugNameData(options.owner, options.debugName, (_options$debugReferen = options.debugReferenceFn) !== null && _options$debugReferen !== void 0 ? _options$debugReferen : getValue), event, getValue, () => FromEventObservable.globalTransaction, (_options$equalsFn = options.equalsFn) !== null && _options$equalsFn !== void 0 ? _options$equalsFn : strictEquals);\n}\nexport class FromEventObservable extends BaseObservable {\n  constructor(_debugNameData, event, _getValue, _getTransaction, _equalityComparator) {\n    super();\n    this._debugNameData = _debugNameData;\n    this.event = event;\n    this._getValue = _getValue;\n    this._getTransaction = _getTransaction;\n    this._equalityComparator = _equalityComparator;\n    this.hasValue = false;\n    this.handleEvent = args => {\n      const newValue = this._getValue(args);\n      const oldValue = this.value;\n      const didChange = !this.hasValue || !this._equalityComparator(oldValue, newValue);\n      let didRunTransaction = false;\n      if (didChange) {\n        this.value = newValue;\n        if (this.hasValue) {\n          didRunTransaction = true;\n          subtransaction(this._getTransaction(), tx => {\n            var _getLogger;\n            (_getLogger = getLogger()) === null || _getLogger === void 0 || _getLogger.handleFromEventObservableTriggered(this, {\n              oldValue,\n              newValue,\n              change: undefined,\n              didChange,\n              hadValue: this.hasValue\n            });\n            for (const o of this.observers) {\n              tx.updateObserver(o, this);\n              o.handleChange(this, undefined);\n            }\n          }, () => {\n            const name = this.getDebugName();\n            return 'Event fired' + (name ? \": \".concat(name) : '');\n          });\n        }\n        this.hasValue = true;\n      }\n      if (!didRunTransaction) {\n        var _getLogger2;\n        (_getLogger2 = getLogger()) === null || _getLogger2 === void 0 || _getLogger2.handleFromEventObservableTriggered(this, {\n          oldValue,\n          newValue,\n          change: undefined,\n          didChange,\n          hadValue: this.hasValue\n        });\n      }\n    };\n  }\n  getDebugName() {\n    return this._debugNameData.getDebugName(this);\n  }\n  get debugName() {\n    const name = this.getDebugName();\n    return 'From Event' + (name ? \": \".concat(name) : '');\n  }\n  onFirstObserverAdded() {\n    this.subscription = this.event(this.handleEvent);\n  }\n  onLastObserverRemoved() {\n    this.subscription.dispose();\n    this.subscription = undefined;\n    this.hasValue = false;\n    this.value = undefined;\n  }\n  get() {\n    if (this.subscription) {\n      if (!this.hasValue) {\n        this.handleEvent(undefined);\n      }\n      return this.value;\n    } else {\n      // no cache, as there are no subscribers to keep it updated\n      const value = this._getValue(undefined);\n      return value;\n    }\n  }\n}\n(function (observableFromEvent) {\n  observableFromEvent.Observer = FromEventObservable;\n  function batchEventsGlobally(tx, fn) {\n    let didSet = false;\n    if (FromEventObservable.globalTransaction === undefined) {\n      FromEventObservable.globalTransaction = tx;\n      didSet = true;\n    }\n    try {\n      fn();\n    } finally {\n      if (didSet) {\n        FromEventObservable.globalTransaction = undefined;\n      }\n    }\n  }\n  observableFromEvent.batchEventsGlobally = batchEventsGlobally;\n})(observableFromEvent || (observableFromEvent = {}));\nexport function observableSignalFromEvent(debugName, event) {\n  return new FromEventObservableSignal(debugName, event);\n}\nclass FromEventObservableSignal extends BaseObservable {\n  constructor(debugName, event) {\n    super();\n    this.debugName = debugName;\n    this.event = event;\n    this.handleEvent = () => {\n      transaction(tx => {\n        for (const o of this.observers) {\n          tx.updateObserver(o, this);\n          o.handleChange(this, undefined);\n        }\n      }, () => this.debugName);\n    };\n  }\n  onFirstObserverAdded() {\n    this.subscription = this.event(this.handleEvent);\n  }\n  onLastObserverRemoved() {\n    this.subscription.dispose();\n    this.subscription = undefined;\n  }\n  get() {\n    // NO OP\n  }\n}\nexport function observableSignal(debugNameOrOwner) {\n  if (typeof debugNameOrOwner === 'string') {\n    return new ObservableSignal(debugNameOrOwner);\n  } else {\n    return new ObservableSignal(undefined, debugNameOrOwner);\n  }\n}\nclass ObservableSignal extends BaseObservable {\n  get debugName() {\n    var _DebugNameData$getDeb;\n    return (_DebugNameData$getDeb = new DebugNameData(this._owner, this._debugName, undefined).getDebugName(this)) !== null && _DebugNameData$getDeb !== void 0 ? _DebugNameData$getDeb : 'Observable Signal';\n  }\n  toString() {\n    return this.debugName;\n  }\n  constructor(_debugName, _owner) {\n    super();\n    this._debugName = _debugName;\n    this._owner = _owner;\n  }\n  trigger(tx, change) {\n    if (!tx) {\n      transaction(tx => {\n        this.trigger(tx, change);\n      }, () => \"Trigger signal \".concat(this.debugName));\n      return;\n    }\n    for (const o of this.observers) {\n      tx.updateObserver(o, this);\n      o.handleChange(this, change);\n    }\n  }\n  get() {\n    // NO OP\n  }\n}\n/**\n * This makes sure the observable is being observed and keeps its cache alive.\n */\nexport function keepObserved(observable) {\n  const o = new KeepAliveObserver(false, undefined);\n  observable.addObserver(o);\n  return toDisposable(() => {\n    observable.removeObserver(o);\n  });\n}\n_setKeepObserved(keepObserved);\n/**\n * This converts the given observable into an autorun.\n */\nexport function recomputeInitiallyAndOnChange(observable, handleValue) {\n  const o = new KeepAliveObserver(true, handleValue);\n  observable.addObserver(o);\n  if (handleValue) {\n    handleValue(observable.get());\n  } else {\n    observable.reportChanges();\n  }\n  return toDisposable(() => {\n    observable.removeObserver(o);\n  });\n}\n_setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange);\nexport class KeepAliveObserver {\n  constructor(_forceRecompute, _handleValue) {\n    this._forceRecompute = _forceRecompute;\n    this._handleValue = _handleValue;\n    this._counter = 0;\n  }\n  beginUpdate(observable) {\n    this._counter++;\n  }\n  endUpdate(observable) {\n    this._counter--;\n    if (this._counter === 0 && this._forceRecompute) {\n      if (this._handleValue) {\n        this._handleValue(observable.get());\n      } else {\n        observable.reportChanges();\n      }\n    }\n  }\n  handlePossibleChange(observable) {\n    // NO OP\n  }\n  handleChange(observable, change) {\n    // NO OP\n  }\n}\nexport function derivedObservableWithCache(owner, computeFn) {\n  let lastValue = undefined;\n  const observable = derivedOpts({\n    owner,\n    debugReferenceFn: computeFn\n  }, reader => {\n    lastValue = computeFn(reader, lastValue);\n    return lastValue;\n  });\n  return observable;\n}\nexport function derivedObservableWithWritableCache(owner, computeFn) {\n  let lastValue = undefined;\n  const onChange = observableSignal('derivedObservableWithWritableCache');\n  const observable = derived(owner, reader => {\n    onChange.read(reader);\n    lastValue = computeFn(reader, lastValue);\n    return lastValue;\n  });\n  return Object.assign(observable, {\n    clearCache: tx => {\n      lastValue = undefined;\n      onChange.trigger(tx);\n    },\n    setCache: (newValue, tx) => {\n      lastValue = newValue;\n      onChange.trigger(tx);\n    }\n  });\n}\n/**\n * When the items array changes, referential equal items are not mapped again.\n */\nexport function mapObservableArrayCached(owner, items, map, keySelector) {\n  let m = new ArrayMap(map, keySelector);\n  const self = derivedOpts({\n    debugReferenceFn: map,\n    owner,\n    onLastObserverRemoved: () => {\n      m.dispose();\n      m = new ArrayMap(map);\n    }\n  }, reader => {\n    m.setItems(items.read(reader));\n    return m.getItems();\n  });\n  return self;\n}\nclass ArrayMap {\n  constructor(_map, _keySelector) {\n    this._map = _map;\n    this._keySelector = _keySelector;\n    this._cache = new Map();\n    this._items = [];\n  }\n  dispose() {\n    this._cache.forEach(entry => entry.store.dispose());\n    this._cache.clear();\n  }\n  setItems(items) {\n    const newItems = [];\n    const itemsToRemove = new Set(this._cache.keys());\n    for (const item of items) {\n      const key = this._keySelector ? this._keySelector(item) : item;\n      let entry = this._cache.get(key);\n      if (!entry) {\n        const store = new DisposableStore();\n        const out = this._map(item, store);\n        entry = {\n          out,\n          store\n        };\n        this._cache.set(key, entry);\n      } else {\n        itemsToRemove.delete(key);\n      }\n      newItems.push(entry.out);\n    }\n    for (const item of itemsToRemove) {\n      const entry = this._cache.get(item);\n      entry.store.dispose();\n      this._cache.delete(item);\n    }\n    this._items = newItems;\n  }\n  getItems() {\n    return this._items;\n  }\n}\nexport class ValueWithChangeEventFromObservable {\n  constructor(observable) {\n    this.observable = observable;\n  }\n  get onDidChange() {\n    return Event.fromObservableLight(this.observable);\n  }\n  get value() {\n    return this.observable.get();\n  }\n}\nexport function observableFromValueWithChangeEvent(owner, value) {\n  if (value instanceof ValueWithChangeEventFromObservable) {\n    return value.observable;\n  }\n  return observableFromEvent(owner, value.onDidChange, () => value.value);\n}\n/**\n * Works like a derived.\n * However, if the value is not undefined, it is cached and will not be recomputed anymore.\n * In that case, the derived will unsubscribe from its dependencies.\n*/\nexport function derivedConstOnceDefined(owner, fn) {\n  return derivedObservableWithCache(owner, (reader, lastValue) => lastValue !== null && lastValue !== void 0 ? lastValue : fn(reader));\n}","map":{"version":3,"names":["Event","DisposableStore","toDisposable","BaseObservable","ConvenientObservable","_setKeepObserved","_setRecomputeInitiallyAndOnChange","subtransaction","transaction","DebugNameData","derived","derivedOpts","getLogger","strictEquals","constObservable","value","ConstObservable","constructor","debugName","toString","get","addObserver","observer","removeObserver","concat","observableFromEvent","owner","event","getValue","_len","arguments","length","args","Array","_key","FromEventObservable","undefined","globalTransaction","observableFromEventOpts","options","_options$debugReferen","_options$equalsFn","debugReferenceFn","equalsFn","_debugNameData","_getValue","_getTransaction","_equalityComparator","hasValue","handleEvent","newValue","oldValue","didChange","didRunTransaction","tx","_getLogger","handleFromEventObservableTriggered","change","hadValue","o","observers","updateObserver","handleChange","name","getDebugName","_getLogger2","onFirstObserverAdded","subscription","onLastObserverRemoved","dispose","Observer","batchEventsGlobally","fn","didSet","observableSignalFromEvent","FromEventObservableSignal","observableSignal","debugNameOrOwner","ObservableSignal","_DebugNameData$getDeb","_owner","_debugName","trigger","keepObserved","observable","KeepAliveObserver","recomputeInitiallyAndOnChange","handleValue","reportChanges","_forceRecompute","_handleValue","_counter","beginUpdate","endUpdate","handlePossibleChange","derivedObservableWithCache","computeFn","lastValue","reader","derivedObservableWithWritableCache","onChange","read","Object","assign","clearCache","setCache","mapObservableArrayCached","items","map","keySelector","m","ArrayMap","self","setItems","getItems","_map","_keySelector","_cache","Map","_items","forEach","entry","store","clear","newItems","itemsToRemove","Set","keys","item","key","out","set","delete","push","ValueWithChangeEventFromObservable","onDidChange","fromObservableLight","observableFromValueWithChangeEvent","derivedConstOnceDefined"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Event } from '../event.js';\nimport { DisposableStore, toDisposable } from '../lifecycle.js';\nimport { BaseObservable, ConvenientObservable, _setKeepObserved, _setRecomputeInitiallyAndOnChange, subtransaction, transaction } from './base.js';\nimport { DebugNameData } from './debugName.js';\nimport { derived, derivedOpts } from './derived.js';\nimport { getLogger } from './logging.js';\nimport { strictEquals } from '../equals.js';\n/**\n * Represents an efficient observable whose value never changes.\n */\nexport function constObservable(value) {\n    return new ConstObservable(value);\n}\nclass ConstObservable extends ConvenientObservable {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    get debugName() {\n        return this.toString();\n    }\n    get() {\n        return this.value;\n    }\n    addObserver(observer) {\n        // NO OP\n    }\n    removeObserver(observer) {\n        // NO OP\n    }\n    toString() {\n        return `Const: ${this.value}`;\n    }\n}\nexport function observableFromEvent(...args) {\n    let owner;\n    let event;\n    let getValue;\n    if (args.length === 3) {\n        [owner, event, getValue] = args;\n    }\n    else {\n        [event, getValue] = args;\n    }\n    return new FromEventObservable(new DebugNameData(owner, undefined, getValue), event, getValue, () => FromEventObservable.globalTransaction, strictEquals);\n}\nexport function observableFromEventOpts(options, event, getValue) {\n    return new FromEventObservable(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? getValue), event, getValue, () => FromEventObservable.globalTransaction, options.equalsFn ?? strictEquals);\n}\nexport class FromEventObservable extends BaseObservable {\n    constructor(_debugNameData, event, _getValue, _getTransaction, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this.event = event;\n        this._getValue = _getValue;\n        this._getTransaction = _getTransaction;\n        this._equalityComparator = _equalityComparator;\n        this.hasValue = false;\n        this.handleEvent = (args) => {\n            const newValue = this._getValue(args);\n            const oldValue = this.value;\n            const didChange = !this.hasValue || !(this._equalityComparator(oldValue, newValue));\n            let didRunTransaction = false;\n            if (didChange) {\n                this.value = newValue;\n                if (this.hasValue) {\n                    didRunTransaction = true;\n                    subtransaction(this._getTransaction(), (tx) => {\n                        getLogger()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n                        for (const o of this.observers) {\n                            tx.updateObserver(o, this);\n                            o.handleChange(this, undefined);\n                        }\n                    }, () => {\n                        const name = this.getDebugName();\n                        return 'Event fired' + (name ? `: ${name}` : '');\n                    });\n                }\n                this.hasValue = true;\n            }\n            if (!didRunTransaction) {\n                getLogger()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n            }\n        };\n    }\n    getDebugName() {\n        return this._debugNameData.getDebugName(this);\n    }\n    get debugName() {\n        const name = this.getDebugName();\n        return 'From Event' + (name ? `: ${name}` : '');\n    }\n    onFirstObserverAdded() {\n        this.subscription = this.event(this.handleEvent);\n    }\n    onLastObserverRemoved() {\n        this.subscription.dispose();\n        this.subscription = undefined;\n        this.hasValue = false;\n        this.value = undefined;\n    }\n    get() {\n        if (this.subscription) {\n            if (!this.hasValue) {\n                this.handleEvent(undefined);\n            }\n            return this.value;\n        }\n        else {\n            // no cache, as there are no subscribers to keep it updated\n            const value = this._getValue(undefined);\n            return value;\n        }\n    }\n}\n(function (observableFromEvent) {\n    observableFromEvent.Observer = FromEventObservable;\n    function batchEventsGlobally(tx, fn) {\n        let didSet = false;\n        if (FromEventObservable.globalTransaction === undefined) {\n            FromEventObservable.globalTransaction = tx;\n            didSet = true;\n        }\n        try {\n            fn();\n        }\n        finally {\n            if (didSet) {\n                FromEventObservable.globalTransaction = undefined;\n            }\n        }\n    }\n    observableFromEvent.batchEventsGlobally = batchEventsGlobally;\n})(observableFromEvent || (observableFromEvent = {}));\nexport function observableSignalFromEvent(debugName, event) {\n    return new FromEventObservableSignal(debugName, event);\n}\nclass FromEventObservableSignal extends BaseObservable {\n    constructor(debugName, event) {\n        super();\n        this.debugName = debugName;\n        this.event = event;\n        this.handleEvent = () => {\n            transaction((tx) => {\n                for (const o of this.observers) {\n                    tx.updateObserver(o, this);\n                    o.handleChange(this, undefined);\n                }\n            }, () => this.debugName);\n        };\n    }\n    onFirstObserverAdded() {\n        this.subscription = this.event(this.handleEvent);\n    }\n    onLastObserverRemoved() {\n        this.subscription.dispose();\n        this.subscription = undefined;\n    }\n    get() {\n        // NO OP\n    }\n}\nexport function observableSignal(debugNameOrOwner) {\n    if (typeof debugNameOrOwner === 'string') {\n        return new ObservableSignal(debugNameOrOwner);\n    }\n    else {\n        return new ObservableSignal(undefined, debugNameOrOwner);\n    }\n}\nclass ObservableSignal extends BaseObservable {\n    get debugName() {\n        return new DebugNameData(this._owner, this._debugName, undefined).getDebugName(this) ?? 'Observable Signal';\n    }\n    toString() {\n        return this.debugName;\n    }\n    constructor(_debugName, _owner) {\n        super();\n        this._debugName = _debugName;\n        this._owner = _owner;\n    }\n    trigger(tx, change) {\n        if (!tx) {\n            transaction(tx => {\n                this.trigger(tx, change);\n            }, () => `Trigger signal ${this.debugName}`);\n            return;\n        }\n        for (const o of this.observers) {\n            tx.updateObserver(o, this);\n            o.handleChange(this, change);\n        }\n    }\n    get() {\n        // NO OP\n    }\n}\n/**\n * This makes sure the observable is being observed and keeps its cache alive.\n */\nexport function keepObserved(observable) {\n    const o = new KeepAliveObserver(false, undefined);\n    observable.addObserver(o);\n    return toDisposable(() => {\n        observable.removeObserver(o);\n    });\n}\n_setKeepObserved(keepObserved);\n/**\n * This converts the given observable into an autorun.\n */\nexport function recomputeInitiallyAndOnChange(observable, handleValue) {\n    const o = new KeepAliveObserver(true, handleValue);\n    observable.addObserver(o);\n    if (handleValue) {\n        handleValue(observable.get());\n    }\n    else {\n        observable.reportChanges();\n    }\n    return toDisposable(() => {\n        observable.removeObserver(o);\n    });\n}\n_setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange);\nexport class KeepAliveObserver {\n    constructor(_forceRecompute, _handleValue) {\n        this._forceRecompute = _forceRecompute;\n        this._handleValue = _handleValue;\n        this._counter = 0;\n    }\n    beginUpdate(observable) {\n        this._counter++;\n    }\n    endUpdate(observable) {\n        this._counter--;\n        if (this._counter === 0 && this._forceRecompute) {\n            if (this._handleValue) {\n                this._handleValue(observable.get());\n            }\n            else {\n                observable.reportChanges();\n            }\n        }\n    }\n    handlePossibleChange(observable) {\n        // NO OP\n    }\n    handleChange(observable, change) {\n        // NO OP\n    }\n}\nexport function derivedObservableWithCache(owner, computeFn) {\n    let lastValue = undefined;\n    const observable = derivedOpts({ owner, debugReferenceFn: computeFn }, reader => {\n        lastValue = computeFn(reader, lastValue);\n        return lastValue;\n    });\n    return observable;\n}\nexport function derivedObservableWithWritableCache(owner, computeFn) {\n    let lastValue = undefined;\n    const onChange = observableSignal('derivedObservableWithWritableCache');\n    const observable = derived(owner, reader => {\n        onChange.read(reader);\n        lastValue = computeFn(reader, lastValue);\n        return lastValue;\n    });\n    return Object.assign(observable, {\n        clearCache: (tx) => {\n            lastValue = undefined;\n            onChange.trigger(tx);\n        },\n        setCache: (newValue, tx) => {\n            lastValue = newValue;\n            onChange.trigger(tx);\n        }\n    });\n}\n/**\n * When the items array changes, referential equal items are not mapped again.\n */\nexport function mapObservableArrayCached(owner, items, map, keySelector) {\n    let m = new ArrayMap(map, keySelector);\n    const self = derivedOpts({\n        debugReferenceFn: map,\n        owner,\n        onLastObserverRemoved: () => {\n            m.dispose();\n            m = new ArrayMap(map);\n        }\n    }, (reader) => {\n        m.setItems(items.read(reader));\n        return m.getItems();\n    });\n    return self;\n}\nclass ArrayMap {\n    constructor(_map, _keySelector) {\n        this._map = _map;\n        this._keySelector = _keySelector;\n        this._cache = new Map();\n        this._items = [];\n    }\n    dispose() {\n        this._cache.forEach(entry => entry.store.dispose());\n        this._cache.clear();\n    }\n    setItems(items) {\n        const newItems = [];\n        const itemsToRemove = new Set(this._cache.keys());\n        for (const item of items) {\n            const key = this._keySelector ? this._keySelector(item) : item;\n            let entry = this._cache.get(key);\n            if (!entry) {\n                const store = new DisposableStore();\n                const out = this._map(item, store);\n                entry = { out, store };\n                this._cache.set(key, entry);\n            }\n            else {\n                itemsToRemove.delete(key);\n            }\n            newItems.push(entry.out);\n        }\n        for (const item of itemsToRemove) {\n            const entry = this._cache.get(item);\n            entry.store.dispose();\n            this._cache.delete(item);\n        }\n        this._items = newItems;\n    }\n    getItems() {\n        return this._items;\n    }\n}\nexport class ValueWithChangeEventFromObservable {\n    constructor(observable) {\n        this.observable = observable;\n    }\n    get onDidChange() {\n        return Event.fromObservableLight(this.observable);\n    }\n    get value() {\n        return this.observable.get();\n    }\n}\nexport function observableFromValueWithChangeEvent(owner, value) {\n    if (value instanceof ValueWithChangeEventFromObservable) {\n        return value.observable;\n    }\n    return observableFromEvent(owner, value.onDidChange, () => value.value);\n}\n/**\n * Works like a derived.\n * However, if the value is not undefined, it is cached and will not be recomputed anymore.\n * In that case, the derived will unsubscribe from its dependencies.\n*/\nexport function derivedConstOnceDefined(owner, fn) {\n    return derivedObservableWithCache(owner, (reader, lastValue) => lastValue ?? fn(reader));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}