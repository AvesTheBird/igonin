{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Disposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { autorun, autorunWithStore, derived, observableSignal, observableSignalFromEvent, observableValue, transaction, waitForState } from '../../../../base/common/observable.js';\nimport { IDiffProviderFactoryService } from './diffProviderFactoryService.js';\nimport { filterWithPrevious } from './utils.js';\nimport { readHotReloadableExport } from '../../../../base/common/hotReloadHelpers.js';\nimport { LineRange, LineRangeSet } from '../../../common/core/lineRange.js';\nimport { DefaultLinesDiffComputer } from '../../../common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js';\nimport { DetailedLineRangeMapping, LineRangeMapping, RangeMapping } from '../../../common/diff/rangeMapping.js';\nimport { TextEditInfo } from '../../../common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js';\nimport { combineTextEditInfos } from '../../../common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js';\nimport { optimizeSequenceDiffs } from '../../../common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js';\nimport { isDefined } from '../../../../base/common/types.js';\nimport { groupAdjacentBy } from '../../../../base/common/arrays.js';\nimport { softAssert } from '../../../../base/common/assert.js';\nlet DiffEditorViewModel = class DiffEditorViewModel extends Disposable {\n  setActiveMovedText(movedText) {\n    this._activeMovedText.set(movedText, undefined);\n  }\n  constructor(model, _options, _diffProviderFactoryService) {\n    super();\n    this.model = model;\n    this._options = _options;\n    this._diffProviderFactoryService = _diffProviderFactoryService;\n    this._isDiffUpToDate = observableValue(this, false);\n    this.isDiffUpToDate = this._isDiffUpToDate;\n    this._diff = observableValue(this, undefined);\n    this.diff = this._diff;\n    this._unchangedRegions = observableValue(this, undefined);\n    this.unchangedRegions = derived(this, r => {\n      if (this._options.hideUnchangedRegions.read(r)) {\n        var _this$_unchangedRegio, _this$_unchangedRegio2;\n        return (_this$_unchangedRegio = (_this$_unchangedRegio2 = this._unchangedRegions.read(r)) === null || _this$_unchangedRegio2 === void 0 ? void 0 : _this$_unchangedRegio2.regions) !== null && _this$_unchangedRegio !== void 0 ? _this$_unchangedRegio : [];\n      } else {\n        // Reset state\n        transaction(tx => {\n          for (const r of ((_this$_unchangedRegio3 = this._unchangedRegions.get()) === null || _this$_unchangedRegio3 === void 0 ? void 0 : _this$_unchangedRegio3.regions) || []) {\n            var _this$_unchangedRegio3;\n            r.collapseAll(tx);\n          }\n        });\n        return [];\n      }\n    });\n    this.movedTextToCompare = observableValue(this, undefined);\n    this._activeMovedText = observableValue(this, undefined);\n    this._hoveredMovedText = observableValue(this, undefined);\n    this.activeMovedText = derived(this, r => {\n      var _ref, _this$movedTextToComp;\n      return (_ref = (_this$movedTextToComp = this.movedTextToCompare.read(r)) !== null && _this$movedTextToComp !== void 0 ? _this$movedTextToComp : this._hoveredMovedText.read(r)) !== null && _ref !== void 0 ? _ref : this._activeMovedText.read(r);\n    });\n    this._cancellationTokenSource = new CancellationTokenSource();\n    this._diffProvider = derived(this, reader => {\n      const diffProvider = this._diffProviderFactoryService.createDiffProvider({\n        diffAlgorithm: this._options.diffAlgorithm.read(reader)\n      });\n      const onChangeSignal = observableSignalFromEvent('onDidChange', diffProvider.onDidChange);\n      return {\n        diffProvider,\n        onChangeSignal\n      };\n    });\n    this._register(toDisposable(() => this._cancellationTokenSource.cancel()));\n    const contentChangedSignal = observableSignal('contentChangedSignal');\n    const debouncer = this._register(new RunOnceScheduler(() => contentChangedSignal.trigger(undefined), 200));\n    this._register(autorun(reader => {\n      /** @description collapse touching unchanged ranges */\n      const lastUnchangedRegions = this._unchangedRegions.read(reader);\n      if (!lastUnchangedRegions || lastUnchangedRegions.regions.some(r => r.isDragged.read(reader))) {\n        return;\n      }\n      const lastUnchangedRegionsOrigRanges = lastUnchangedRegions.originalDecorationIds.map(id => model.original.getDecorationRange(id)).map(r => r ? LineRange.fromRangeInclusive(r) : undefined);\n      const lastUnchangedRegionsModRanges = lastUnchangedRegions.modifiedDecorationIds.map(id => model.modified.getDecorationRange(id)).map(r => r ? LineRange.fromRangeInclusive(r) : undefined);\n      const updatedLastUnchangedRegions = lastUnchangedRegions.regions.map((r, idx) => !lastUnchangedRegionsOrigRanges[idx] || !lastUnchangedRegionsModRanges[idx] ? undefined : new UnchangedRegion(lastUnchangedRegionsOrigRanges[idx].startLineNumber, lastUnchangedRegionsModRanges[idx].startLineNumber, lastUnchangedRegionsOrigRanges[idx].length, r.visibleLineCountTop.read(reader), r.visibleLineCountBottom.read(reader))).filter(isDefined);\n      const newRanges = [];\n      let didChange = false;\n      for (const touching of groupAdjacentBy(updatedLastUnchangedRegions, (a, b) => a.getHiddenModifiedRange(reader).endLineNumberExclusive === b.getHiddenModifiedRange(reader).startLineNumber)) {\n        if (touching.length > 1) {\n          didChange = true;\n          const sumLineCount = touching.reduce((sum, r) => sum + r.lineCount, 0);\n          const r = new UnchangedRegion(touching[0].originalLineNumber, touching[0].modifiedLineNumber, sumLineCount, touching[0].visibleLineCountTop.get(), touching[touching.length - 1].visibleLineCountBottom.get());\n          newRanges.push(r);\n        } else {\n          newRanges.push(touching[0]);\n        }\n      }\n      if (didChange) {\n        const originalDecorationIds = model.original.deltaDecorations(lastUnchangedRegions.originalDecorationIds, newRanges.map(r => ({\n          range: r.originalUnchangedRange.toInclusiveRange(),\n          options: {\n            description: 'unchanged'\n          }\n        })));\n        const modifiedDecorationIds = model.modified.deltaDecorations(lastUnchangedRegions.modifiedDecorationIds, newRanges.map(r => ({\n          range: r.modifiedUnchangedRange.toInclusiveRange(),\n          options: {\n            description: 'unchanged'\n          }\n        })));\n        transaction(tx => {\n          this._unchangedRegions.set({\n            regions: newRanges,\n            originalDecorationIds,\n            modifiedDecorationIds\n          }, tx);\n        });\n      }\n    }));\n    const updateUnchangedRegions = (result, tx, reader) => {\n      const newUnchangedRegions = UnchangedRegion.fromDiffs(result.changes, model.original.getLineCount(), model.modified.getLineCount(), this._options.hideUnchangedRegionsMinimumLineCount.read(reader), this._options.hideUnchangedRegionsContextLineCount.read(reader));\n      // Transfer state from cur state\n      let visibleRegions = undefined;\n      const lastUnchangedRegions = this._unchangedRegions.get();\n      if (lastUnchangedRegions) {\n        const lastUnchangedRegionsOrigRanges = lastUnchangedRegions.originalDecorationIds.map(id => model.original.getDecorationRange(id)).map(r => r ? LineRange.fromRangeInclusive(r) : undefined);\n        const lastUnchangedRegionsModRanges = lastUnchangedRegions.modifiedDecorationIds.map(id => model.modified.getDecorationRange(id)).map(r => r ? LineRange.fromRangeInclusive(r) : undefined);\n        const updatedLastUnchangedRegions = filterWithPrevious(lastUnchangedRegions.regions.map((r, idx) => {\n          if (!lastUnchangedRegionsOrigRanges[idx] || !lastUnchangedRegionsModRanges[idx]) {\n            return undefined;\n          }\n          const length = lastUnchangedRegionsOrigRanges[idx].length;\n          return new UnchangedRegion(lastUnchangedRegionsOrigRanges[idx].startLineNumber, lastUnchangedRegionsModRanges[idx].startLineNumber, length,\n          // The visible area can shrink by edits -> we have to account for this\n          Math.min(r.visibleLineCountTop.get(), length), Math.min(r.visibleLineCountBottom.get(), length - r.visibleLineCountTop.get()));\n        }).filter(isDefined), (cur, prev) => !prev || cur.modifiedLineNumber >= prev.modifiedLineNumber + prev.lineCount && cur.originalLineNumber >= prev.originalLineNumber + prev.lineCount);\n        let hiddenRegions = updatedLastUnchangedRegions.map(r => new LineRangeMapping(r.getHiddenOriginalRange(reader), r.getHiddenModifiedRange(reader)));\n        hiddenRegions = LineRangeMapping.clip(hiddenRegions, LineRange.ofLength(1, model.original.getLineCount()), LineRange.ofLength(1, model.modified.getLineCount()));\n        visibleRegions = LineRangeMapping.inverse(hiddenRegions, model.original.getLineCount(), model.modified.getLineCount());\n      }\n      const newUnchangedRegions2 = [];\n      if (visibleRegions) {\n        for (const r of newUnchangedRegions) {\n          const intersecting = visibleRegions.filter(f => f.original.intersectsStrict(r.originalUnchangedRange) && f.modified.intersectsStrict(r.modifiedUnchangedRange));\n          newUnchangedRegions2.push(...r.setVisibleRanges(intersecting, tx));\n        }\n      } else {\n        newUnchangedRegions2.push(...newUnchangedRegions);\n      }\n      const originalDecorationIds = model.original.deltaDecorations((lastUnchangedRegions === null || lastUnchangedRegions === void 0 ? void 0 : lastUnchangedRegions.originalDecorationIds) || [], newUnchangedRegions2.map(r => ({\n        range: r.originalUnchangedRange.toInclusiveRange(),\n        options: {\n          description: 'unchanged'\n        }\n      })));\n      const modifiedDecorationIds = model.modified.deltaDecorations((lastUnchangedRegions === null || lastUnchangedRegions === void 0 ? void 0 : lastUnchangedRegions.modifiedDecorationIds) || [], newUnchangedRegions2.map(r => ({\n        range: r.modifiedUnchangedRange.toInclusiveRange(),\n        options: {\n          description: 'unchanged'\n        }\n      })));\n      this._unchangedRegions.set({\n        regions: newUnchangedRegions2,\n        originalDecorationIds,\n        modifiedDecorationIds\n      }, tx);\n    };\n    this._register(model.modified.onDidChangeContent(e => {\n      const diff = this._diff.get();\n      if (diff) {\n        const textEdits = TextEditInfo.fromModelContentChanges(e.changes);\n        const result = applyModifiedEdits(this._lastDiff, textEdits, model.original, model.modified);\n        if (result) {\n          this._lastDiff = result;\n          transaction(tx => {\n            this._diff.set(DiffState.fromDiffResult(this._lastDiff), tx);\n            updateUnchangedRegions(result, tx);\n            const currentSyncedMovedText = this.movedTextToCompare.get();\n            this.movedTextToCompare.set(currentSyncedMovedText ? this._lastDiff.moves.find(m => m.lineRangeMapping.modified.intersect(currentSyncedMovedText.lineRangeMapping.modified)) : undefined, tx);\n          });\n        }\n      }\n      this._isDiffUpToDate.set(false, undefined);\n      debouncer.schedule();\n    }));\n    this._register(model.original.onDidChangeContent(e => {\n      const diff = this._diff.get();\n      if (diff) {\n        const textEdits = TextEditInfo.fromModelContentChanges(e.changes);\n        const result = applyOriginalEdits(this._lastDiff, textEdits, model.original, model.modified);\n        if (result) {\n          this._lastDiff = result;\n          transaction(tx => {\n            this._diff.set(DiffState.fromDiffResult(this._lastDiff), tx);\n            updateUnchangedRegions(result, tx);\n            const currentSyncedMovedText = this.movedTextToCompare.get();\n            this.movedTextToCompare.set(currentSyncedMovedText ? this._lastDiff.moves.find(m => m.lineRangeMapping.modified.intersect(currentSyncedMovedText.lineRangeMapping.modified)) : undefined, tx);\n          });\n        }\n      }\n      this._isDiffUpToDate.set(false, undefined);\n      debouncer.schedule();\n    }));\n    this._register(autorunWithStore(async (reader, store) => {\n      var _applyOriginalEdits, _applyModifiedEdits;\n      /** @description compute diff */\n      // So that they get recomputed when these settings change\n      this._options.hideUnchangedRegionsMinimumLineCount.read(reader);\n      this._options.hideUnchangedRegionsContextLineCount.read(reader);\n      debouncer.cancel();\n      contentChangedSignal.read(reader);\n      const documentDiffProvider = this._diffProvider.read(reader);\n      documentDiffProvider.onChangeSignal.read(reader);\n      readHotReloadableExport(DefaultLinesDiffComputer, reader);\n      readHotReloadableExport(optimizeSequenceDiffs, reader);\n      this._isDiffUpToDate.set(false, undefined);\n      let originalTextEditInfos = [];\n      store.add(model.original.onDidChangeContent(e => {\n        const edits = TextEditInfo.fromModelContentChanges(e.changes);\n        originalTextEditInfos = combineTextEditInfos(originalTextEditInfos, edits);\n      }));\n      let modifiedTextEditInfos = [];\n      store.add(model.modified.onDidChangeContent(e => {\n        const edits = TextEditInfo.fromModelContentChanges(e.changes);\n        modifiedTextEditInfos = combineTextEditInfos(modifiedTextEditInfos, edits);\n      }));\n      let result = await documentDiffProvider.diffProvider.computeDiff(model.original, model.modified, {\n        ignoreTrimWhitespace: this._options.ignoreTrimWhitespace.read(reader),\n        maxComputationTimeMs: this._options.maxComputationTimeMs.read(reader),\n        computeMoves: this._options.showMoves.read(reader)\n      }, this._cancellationTokenSource.token);\n      if (this._cancellationTokenSource.token.isCancellationRequested) {\n        return;\n      }\n      if (model.original.isDisposed() || model.modified.isDisposed()) {\n        // TODO@hediet fishy?\n        return;\n      }\n      result = normalizeDocumentDiff(result, model.original, model.modified);\n      result = (_applyOriginalEdits = applyOriginalEdits(result, originalTextEditInfos, model.original, model.modified)) !== null && _applyOriginalEdits !== void 0 ? _applyOriginalEdits : result;\n      result = (_applyModifiedEdits = applyModifiedEdits(result, modifiedTextEditInfos, model.original, model.modified)) !== null && _applyModifiedEdits !== void 0 ? _applyModifiedEdits : result;\n      transaction(tx => {\n        /** @description write diff result */\n        updateUnchangedRegions(result, tx);\n        this._lastDiff = result;\n        const state = DiffState.fromDiffResult(result);\n        this._diff.set(state, tx);\n        this._isDiffUpToDate.set(true, tx);\n        const currentSyncedMovedText = this.movedTextToCompare.get();\n        this.movedTextToCompare.set(currentSyncedMovedText ? this._lastDiff.moves.find(m => m.lineRangeMapping.modified.intersect(currentSyncedMovedText.lineRangeMapping.modified)) : undefined, tx);\n      });\n    }));\n  }\n  ensureModifiedLineIsVisible(lineNumber, preference, tx) {\n    var _this$diff$get, _this$_unchangedRegio4;\n    if (((_this$diff$get = this.diff.get()) === null || _this$diff$get === void 0 ? void 0 : _this$diff$get.mappings.length) === 0) {\n      return;\n    }\n    const unchangedRegions = ((_this$_unchangedRegio4 = this._unchangedRegions.get()) === null || _this$_unchangedRegio4 === void 0 ? void 0 : _this$_unchangedRegio4.regions) || [];\n    for (const r of unchangedRegions) {\n      if (r.getHiddenModifiedRange(undefined).contains(lineNumber)) {\n        r.showModifiedLine(lineNumber, preference, tx);\n        return;\n      }\n    }\n  }\n  ensureOriginalLineIsVisible(lineNumber, preference, tx) {\n    var _this$diff$get2, _this$_unchangedRegio5;\n    if (((_this$diff$get2 = this.diff.get()) === null || _this$diff$get2 === void 0 ? void 0 : _this$diff$get2.mappings.length) === 0) {\n      return;\n    }\n    const unchangedRegions = ((_this$_unchangedRegio5 = this._unchangedRegions.get()) === null || _this$_unchangedRegio5 === void 0 ? void 0 : _this$_unchangedRegio5.regions) || [];\n    for (const r of unchangedRegions) {\n      if (r.getHiddenOriginalRange(undefined).contains(lineNumber)) {\n        r.showOriginalLine(lineNumber, preference, tx);\n        return;\n      }\n    }\n  }\n  async waitForDiff() {\n    await waitForState(this.isDiffUpToDate, s => s);\n  }\n  serializeState() {\n    const regions = this._unchangedRegions.get();\n    return {\n      collapsedRegions: regions === null || regions === void 0 ? void 0 : regions.regions.map(r => ({\n        range: r.getHiddenModifiedRange(undefined).serialize()\n      }))\n    };\n  }\n  restoreSerializedState(state) {\n    var _state$collapsedRegio;\n    const ranges = (_state$collapsedRegio = state.collapsedRegions) === null || _state$collapsedRegio === void 0 ? void 0 : _state$collapsedRegio.map(r => LineRange.deserialize(r.range));\n    const regions = this._unchangedRegions.get();\n    if (!regions || !ranges) {\n      return;\n    }\n    transaction(tx => {\n      for (const r of regions.regions) {\n        for (const range of ranges) {\n          if (r.modifiedUnchangedRange.intersect(range)) {\n            r.setHiddenModifiedRange(range, tx);\n            break;\n          }\n        }\n      }\n    });\n  }\n};\nDiffEditorViewModel = __decorate([__param(2, IDiffProviderFactoryService)], DiffEditorViewModel);\nexport { DiffEditorViewModel };\nfunction normalizeDocumentDiff(diff, original, modified) {\n  return {\n    changes: diff.changes.map(c => new DetailedLineRangeMapping(c.original, c.modified, c.innerChanges ? c.innerChanges.map(i => normalizeRangeMapping(i, original, modified)) : undefined)),\n    moves: diff.moves,\n    identical: diff.identical,\n    quitEarly: diff.quitEarly\n  };\n}\nfunction normalizeRangeMapping(rangeMapping, original, modified) {\n  let originalRange = rangeMapping.originalRange;\n  let modifiedRange = rangeMapping.modifiedRange;\n  if (originalRange.startColumn === 1 && modifiedRange.startColumn === 1 && (originalRange.endColumn !== 1 || modifiedRange.endColumn !== 1) && originalRange.endColumn === original.getLineMaxColumn(originalRange.endLineNumber) && modifiedRange.endColumn === modified.getLineMaxColumn(modifiedRange.endLineNumber) && originalRange.endLineNumber < original.getLineCount() && modifiedRange.endLineNumber < modified.getLineCount()) {\n    originalRange = originalRange.setEndPosition(originalRange.endLineNumber + 1, 1);\n    modifiedRange = modifiedRange.setEndPosition(modifiedRange.endLineNumber + 1, 1);\n  }\n  return new RangeMapping(originalRange, modifiedRange);\n}\nexport class DiffState {\n  static fromDiffResult(result) {\n    return new DiffState(result.changes.map(c => new DiffMapping(c)), result.moves || [], result.identical, result.quitEarly);\n  }\n  constructor(mappings, movedTexts, identical, quitEarly) {\n    this.mappings = mappings;\n    this.movedTexts = movedTexts;\n    this.identical = identical;\n    this.quitEarly = quitEarly;\n  }\n}\nexport class DiffMapping {\n  constructor(lineRangeMapping) {\n    this.lineRangeMapping = lineRangeMapping;\n    /*\n    readonly movedTo: MovedText | undefined,\n    readonly movedFrom: MovedText | undefined,\n     if (movedTo) {\n        assertFn(() =>\n            movedTo.lineRangeMapping.modifiedRange.equals(lineRangeMapping.modifiedRange)\n            && lineRangeMapping.originalRange.isEmpty\n            && !movedFrom\n        );\n    } else if (movedFrom) {\n        assertFn(() =>\n            movedFrom.lineRangeMapping.originalRange.equals(lineRangeMapping.originalRange)\n            && lineRangeMapping.modifiedRange.isEmpty\n            && !movedTo\n        );\n    }\n    */\n  }\n}\nexport class UnchangedRegion {\n  static fromDiffs(changes, originalLineCount, modifiedLineCount, minHiddenLineCount, minContext) {\n    const inversedMappings = DetailedLineRangeMapping.inverse(changes, originalLineCount, modifiedLineCount);\n    const result = [];\n    for (const mapping of inversedMappings) {\n      let origStart = mapping.original.startLineNumber;\n      let modStart = mapping.modified.startLineNumber;\n      let length = mapping.original.length;\n      const atStart = origStart === 1 && modStart === 1;\n      const atEnd = origStart + length === originalLineCount + 1 && modStart + length === modifiedLineCount + 1;\n      if ((atStart || atEnd) && length >= minContext + minHiddenLineCount) {\n        if (atStart && !atEnd) {\n          length -= minContext;\n        }\n        if (atEnd && !atStart) {\n          origStart += minContext;\n          modStart += minContext;\n          length -= minContext;\n        }\n        result.push(new UnchangedRegion(origStart, modStart, length, 0, 0));\n      } else if (length >= minContext * 2 + minHiddenLineCount) {\n        origStart += minContext;\n        modStart += minContext;\n        length -= minContext * 2;\n        result.push(new UnchangedRegion(origStart, modStart, length, 0, 0));\n      }\n    }\n    return result;\n  }\n  get originalUnchangedRange() {\n    return LineRange.ofLength(this.originalLineNumber, this.lineCount);\n  }\n  get modifiedUnchangedRange() {\n    return LineRange.ofLength(this.modifiedLineNumber, this.lineCount);\n  }\n  constructor(originalLineNumber, modifiedLineNumber, lineCount, visibleLineCountTop, visibleLineCountBottom) {\n    this.originalLineNumber = originalLineNumber;\n    this.modifiedLineNumber = modifiedLineNumber;\n    this.lineCount = lineCount;\n    this._visibleLineCountTop = observableValue(this, 0);\n    this.visibleLineCountTop = this._visibleLineCountTop;\n    this._visibleLineCountBottom = observableValue(this, 0);\n    this.visibleLineCountBottom = this._visibleLineCountBottom;\n    this._shouldHideControls = derived(this, reader => /** @description isVisible */this.visibleLineCountTop.read(reader) + this.visibleLineCountBottom.read(reader) === this.lineCount && !this.isDragged.read(reader));\n    this.isDragged = observableValue(this, undefined);\n    const visibleLineCountTop2 = Math.max(Math.min(visibleLineCountTop, this.lineCount), 0);\n    const visibleLineCountBottom2 = Math.max(Math.min(visibleLineCountBottom, this.lineCount - visibleLineCountTop), 0);\n    softAssert(visibleLineCountTop === visibleLineCountTop2);\n    softAssert(visibleLineCountBottom === visibleLineCountBottom2);\n    this._visibleLineCountTop.set(visibleLineCountTop2, undefined);\n    this._visibleLineCountBottom.set(visibleLineCountBottom2, undefined);\n  }\n  setVisibleRanges(visibleRanges, tx) {\n    const result = [];\n    const hiddenModified = new LineRangeSet(visibleRanges.map(r => r.modified)).subtractFrom(this.modifiedUnchangedRange);\n    let originalStartLineNumber = this.originalLineNumber;\n    let modifiedStartLineNumber = this.modifiedLineNumber;\n    const modifiedEndLineNumberEx = this.modifiedLineNumber + this.lineCount;\n    if (hiddenModified.ranges.length === 0) {\n      this.showAll(tx);\n      result.push(this);\n    } else {\n      let i = 0;\n      for (const r of hiddenModified.ranges) {\n        const isLast = i === hiddenModified.ranges.length - 1;\n        i++;\n        const length = (isLast ? modifiedEndLineNumberEx : r.endLineNumberExclusive) - modifiedStartLineNumber;\n        const newR = new UnchangedRegion(originalStartLineNumber, modifiedStartLineNumber, length, 0, 0);\n        newR.setHiddenModifiedRange(r, tx);\n        result.push(newR);\n        originalStartLineNumber = newR.originalUnchangedRange.endLineNumberExclusive;\n        modifiedStartLineNumber = newR.modifiedUnchangedRange.endLineNumberExclusive;\n      }\n    }\n    return result;\n  }\n  shouldHideControls(reader) {\n    return this._shouldHideControls.read(reader);\n  }\n  getHiddenOriginalRange(reader) {\n    return LineRange.ofLength(this.originalLineNumber + this._visibleLineCountTop.read(reader), this.lineCount - this._visibleLineCountTop.read(reader) - this._visibleLineCountBottom.read(reader));\n  }\n  getHiddenModifiedRange(reader) {\n    return LineRange.ofLength(this.modifiedLineNumber + this._visibleLineCountTop.read(reader), this.lineCount - this._visibleLineCountTop.read(reader) - this._visibleLineCountBottom.read(reader));\n  }\n  setHiddenModifiedRange(range, tx) {\n    const visibleLineCountTop = range.startLineNumber - this.modifiedLineNumber;\n    const visibleLineCountBottom = this.modifiedLineNumber + this.lineCount - range.endLineNumberExclusive;\n    this.setState(visibleLineCountTop, visibleLineCountBottom, tx);\n  }\n  getMaxVisibleLineCountTop() {\n    return this.lineCount - this._visibleLineCountBottom.get();\n  }\n  getMaxVisibleLineCountBottom() {\n    return this.lineCount - this._visibleLineCountTop.get();\n  }\n  showMoreAbove() {\n    let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    let tx = arguments.length > 1 ? arguments[1] : undefined;\n    const maxVisibleLineCountTop = this.getMaxVisibleLineCountTop();\n    this._visibleLineCountTop.set(Math.min(this._visibleLineCountTop.get() + count, maxVisibleLineCountTop), tx);\n  }\n  showMoreBelow() {\n    let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    let tx = arguments.length > 1 ? arguments[1] : undefined;\n    const maxVisibleLineCountBottom = this.lineCount - this._visibleLineCountTop.get();\n    this._visibleLineCountBottom.set(Math.min(this._visibleLineCountBottom.get() + count, maxVisibleLineCountBottom), tx);\n  }\n  showAll(tx) {\n    this._visibleLineCountBottom.set(this.lineCount - this._visibleLineCountTop.get(), tx);\n  }\n  showModifiedLine(lineNumber, preference, tx) {\n    const top = lineNumber + 1 - (this.modifiedLineNumber + this._visibleLineCountTop.get());\n    const bottom = this.modifiedLineNumber - this._visibleLineCountBottom.get() + this.lineCount - lineNumber;\n    if (preference === 0 /* RevealPreference.FromCloserSide */ && top < bottom || preference === 1 /* RevealPreference.FromTop */) {\n      this._visibleLineCountTop.set(this._visibleLineCountTop.get() + top, tx);\n    } else {\n      this._visibleLineCountBottom.set(this._visibleLineCountBottom.get() + bottom, tx);\n    }\n  }\n  showOriginalLine(lineNumber, preference, tx) {\n    const top = lineNumber - this.originalLineNumber;\n    const bottom = this.originalLineNumber + this.lineCount - lineNumber;\n    if (preference === 0 /* RevealPreference.FromCloserSide */ && top < bottom || preference === 1 /* RevealPreference.FromTop */) {\n      this._visibleLineCountTop.set(Math.min(this._visibleLineCountTop.get() + bottom - top, this.getMaxVisibleLineCountTop()), tx);\n    } else {\n      this._visibleLineCountBottom.set(Math.min(this._visibleLineCountBottom.get() + top - bottom, this.getMaxVisibleLineCountBottom()), tx);\n    }\n  }\n  collapseAll(tx) {\n    this._visibleLineCountTop.set(0, tx);\n    this._visibleLineCountBottom.set(0, tx);\n  }\n  setState(visibleLineCountTop, visibleLineCountBottom, tx) {\n    visibleLineCountTop = Math.max(Math.min(visibleLineCountTop, this.lineCount), 0);\n    visibleLineCountBottom = Math.max(Math.min(visibleLineCountBottom, this.lineCount - visibleLineCountTop), 0);\n    this._visibleLineCountTop.set(visibleLineCountTop, tx);\n    this._visibleLineCountBottom.set(visibleLineCountBottom, tx);\n  }\n}\nfunction applyOriginalEdits(diff, textEdits, originalTextModel, modifiedTextModel) {\n  return undefined;\n  /*\n  TODO@hediet\n  if (textEdits.length === 0) {\n      return diff;\n  }\n   const diff2 = flip(diff);\n  const diff3 = applyModifiedEdits(diff2, textEdits, modifiedTextModel, originalTextModel);\n  if (!diff3) {\n      return undefined;\n  }\n  return flip(diff3);*/\n}\n/*\nfunction flip(diff: IDocumentDiff): IDocumentDiff {\n    return {\n        changes: diff.changes.map(c => c.flip()),\n        moves: diff.moves.map(m => m.flip()),\n        identical: diff.identical,\n        quitEarly: diff.quitEarly,\n    };\n}\n*/\nfunction applyModifiedEdits(diff, textEdits, originalTextModel, modifiedTextModel) {\n  return undefined;\n  /*\n  TODO@hediet\n  if (textEdits.length === 0) {\n      return diff;\n  }\n  if (diff.changes.some(c => !c.innerChanges) || diff.moves.length > 0) {\n      // TODO support these cases\n      return undefined;\n  }\n   const changes = applyModifiedEditsToLineRangeMappings(diff.changes, textEdits, originalTextModel, modifiedTextModel);\n   const moves = diff.moves.map(m => {\n      const newModifiedRange = applyEditToLineRange(m.lineRangeMapping.modified, textEdits);\n      return newModifiedRange ? new MovedText(\n          new SimpleLineRangeMapping(m.lineRangeMapping.original, newModifiedRange),\n          applyModifiedEditsToLineRangeMappings(m.changes, textEdits, originalTextModel, modifiedTextModel),\n      ) : undefined;\n  }).filter(isDefined);\n   return {\n      identical: false,\n      quitEarly: false,\n      changes,\n      moves,\n  };*/\n}\n/*\nfunction applyEditToLineRange(range: LineRange, textEdits: TextEditInfo[]): LineRange | undefined {\n    let rangeStartLineNumber = range.startLineNumber;\n    let rangeEndLineNumberEx = range.endLineNumberExclusive;\n\n    for (let i = textEdits.length - 1; i >= 0; i--) {\n        const textEdit = textEdits[i];\n        const textEditStartLineNumber = lengthGetLineCount(textEdit.startOffset) + 1;\n        const textEditEndLineNumber = lengthGetLineCount(textEdit.endOffset) + 1;\n        const newLengthLineCount = lengthGetLineCount(textEdit.newLength);\n        const delta = newLengthLineCount - (textEditEndLineNumber - textEditStartLineNumber);\n\n        if (textEditEndLineNumber < rangeStartLineNumber) {\n            // the text edit is before us\n            rangeStartLineNumber += delta;\n            rangeEndLineNumberEx += delta;\n        } else if (textEditStartLineNumber > rangeEndLineNumberEx) {\n            // the text edit is after us\n            // NOOP\n        } else if (textEditStartLineNumber < rangeStartLineNumber && rangeEndLineNumberEx < textEditEndLineNumber) {\n            // the range is fully contained in the text edit\n            return undefined;\n        } else if (textEditStartLineNumber < rangeStartLineNumber && textEditEndLineNumber <= rangeEndLineNumberEx) {\n            // the text edit ends inside our range\n            rangeStartLineNumber = textEditEndLineNumber + 1;\n            rangeStartLineNumber += delta;\n            rangeEndLineNumberEx += delta;\n        } else if (rangeStartLineNumber <= textEditStartLineNumber && textEditEndLineNumber < rangeStartLineNumber) {\n            // the text edit starts inside our range\n            rangeEndLineNumberEx = textEditStartLineNumber;\n        } else {\n            rangeEndLineNumberEx += delta;\n        }\n    }\n\n    return new LineRange(rangeStartLineNumber, rangeEndLineNumberEx);\n}\n\nfunction applyModifiedEditsToLineRangeMappings(changes: readonly LineRangeMapping[], textEdits: TextEditInfo[], originalTextModel: ITextModel, modifiedTextModel: ITextModel): LineRangeMapping[] {\n    const diffTextEdits = changes.flatMap(c => c.innerChanges!.map(c => new TextEditInfo(\n        positionToLength(c.originalRange.getStartPosition()),\n        positionToLength(c.originalRange.getEndPosition()),\n        lengthOfRange(c.modifiedRange).toLength(),\n    )));\n\n    const combined = combineTextEditInfos(diffTextEdits, textEdits);\n\n    let lastOriginalEndOffset = lengthZero;\n    let lastModifiedEndOffset = lengthZero;\n    const rangeMappings = combined.map(c => {\n        const modifiedStartOffset = lengthAdd(lastModifiedEndOffset, lengthDiffNonNegative(lastOriginalEndOffset, c.startOffset));\n        lastOriginalEndOffset = c.endOffset;\n        lastModifiedEndOffset = lengthAdd(modifiedStartOffset, c.newLength);\n\n        return new RangeMapping(\n            Range.fromPositions(lengthToPosition(c.startOffset), lengthToPosition(c.endOffset)),\n            Range.fromPositions(lengthToPosition(modifiedStartOffset), lengthToPosition(lastModifiedEndOffset)),\n        );\n    });\n\n    const newChanges = lineRangeMappingFromRangeMappings(\n        rangeMappings,\n        originalTextModel.getLinesContent(),\n        modifiedTextModel.getLinesContent(),\n    );\n    return newChanges;\n}\n*/","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","RunOnceScheduler","CancellationTokenSource","Disposable","toDisposable","autorun","autorunWithStore","derived","observableSignal","observableSignalFromEvent","observableValue","transaction","waitForState","IDiffProviderFactoryService","filterWithPrevious","readHotReloadableExport","LineRange","LineRangeSet","DefaultLinesDiffComputer","DetailedLineRangeMapping","LineRangeMapping","RangeMapping","TextEditInfo","combineTextEditInfos","optimizeSequenceDiffs","isDefined","groupAdjacentBy","softAssert","DiffEditorViewModel","setActiveMovedText","movedText","_activeMovedText","set","undefined","constructor","model","_options","_diffProviderFactoryService","_isDiffUpToDate","isDiffUpToDate","_diff","diff","_unchangedRegions","unchangedRegions","hideUnchangedRegions","read","_this$_unchangedRegio","_this$_unchangedRegio2","regions","tx","_this$_unchangedRegio3","get","collapseAll","movedTextToCompare","_hoveredMovedText","activeMovedText","_ref","_this$movedTextToComp","_cancellationTokenSource","_diffProvider","reader","diffProvider","createDiffProvider","diffAlgorithm","onChangeSignal","onDidChange","_register","cancel","contentChangedSignal","debouncer","trigger","lastUnchangedRegions","some","isDragged","lastUnchangedRegionsOrigRanges","originalDecorationIds","map","id","original","getDecorationRange","fromRangeInclusive","lastUnchangedRegionsModRanges","modifiedDecorationIds","modified","updatedLastUnchangedRegions","idx","UnchangedRegion","startLineNumber","visibleLineCountTop","visibleLineCountBottom","filter","newRanges","didChange","touching","a","b","getHiddenModifiedRange","endLineNumberExclusive","sumLineCount","reduce","sum","lineCount","originalLineNumber","modifiedLineNumber","push","deltaDecorations","range","originalUnchangedRange","toInclusiveRange","options","description","modifiedUnchangedRange","updateUnchangedRegions","result","newUnchangedRegions","fromDiffs","changes","getLineCount","hideUnchangedRegionsMinimumLineCount","hideUnchangedRegionsContextLineCount","visibleRegions","Math","min","cur","prev","hiddenRegions","getHiddenOriginalRange","clip","ofLength","inverse","newUnchangedRegions2","intersecting","f","intersectsStrict","setVisibleRanges","onDidChangeContent","e","textEdits","fromModelContentChanges","applyModifiedEdits","_lastDiff","DiffState","fromDiffResult","currentSyncedMovedText","moves","find","m","lineRangeMapping","intersect","schedule","applyOriginalEdits","store","_applyOriginalEdits","_applyModifiedEdits","documentDiffProvider","originalTextEditInfos","add","edits","modifiedTextEditInfos","computeDiff","ignoreTrimWhitespace","maxComputationTimeMs","computeMoves","showMoves","token","isCancellationRequested","isDisposed","normalizeDocumentDiff","state","ensureModifiedLineIsVisible","lineNumber","preference","_this$diff$get","_this$_unchangedRegio4","mappings","contains","showModifiedLine","ensureOriginalLineIsVisible","_this$diff$get2","_this$_unchangedRegio5","showOriginalLine","waitForDiff","s","serializeState","collapsedRegions","serialize","restoreSerializedState","_state$collapsedRegio","ranges","deserialize","setHiddenModifiedRange","innerChanges","normalizeRangeMapping","identical","quitEarly","rangeMapping","originalRange","modifiedRange","startColumn","endColumn","getLineMaxColumn","endLineNumber","setEndPosition","DiffMapping","movedTexts","originalLineCount","modifiedLineCount","minHiddenLineCount","minContext","inversedMappings","mapping","origStart","modStart","atStart","atEnd","_visibleLineCountTop","_visibleLineCountBottom","_shouldHideControls","visibleLineCountTop2","max","visibleLineCountBottom2","visibleRanges","hiddenModified","subtractFrom","originalStartLineNumber","modifiedStartLineNumber","modifiedEndLineNumberEx","showAll","isLast","newR","shouldHideControls","setState","getMaxVisibleLineCountTop","getMaxVisibleLineCountBottom","showMoreAbove","count","maxVisibleLineCountTop","showMoreBelow","maxVisibleLineCountBottom","top","bottom","originalTextModel","modifiedTextModel"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/diffEditorViewModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Disposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { autorun, autorunWithStore, derived, observableSignal, observableSignalFromEvent, observableValue, transaction, waitForState } from '../../../../base/common/observable.js';\nimport { IDiffProviderFactoryService } from './diffProviderFactoryService.js';\nimport { filterWithPrevious } from './utils.js';\nimport { readHotReloadableExport } from '../../../../base/common/hotReloadHelpers.js';\nimport { LineRange, LineRangeSet } from '../../../common/core/lineRange.js';\nimport { DefaultLinesDiffComputer } from '../../../common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js';\nimport { DetailedLineRangeMapping, LineRangeMapping, RangeMapping } from '../../../common/diff/rangeMapping.js';\nimport { TextEditInfo } from '../../../common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js';\nimport { combineTextEditInfos } from '../../../common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js';\nimport { optimizeSequenceDiffs } from '../../../common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js';\nimport { isDefined } from '../../../../base/common/types.js';\nimport { groupAdjacentBy } from '../../../../base/common/arrays.js';\nimport { softAssert } from '../../../../base/common/assert.js';\nlet DiffEditorViewModel = class DiffEditorViewModel extends Disposable {\n    setActiveMovedText(movedText) {\n        this._activeMovedText.set(movedText, undefined);\n    }\n    constructor(model, _options, _diffProviderFactoryService) {\n        super();\n        this.model = model;\n        this._options = _options;\n        this._diffProviderFactoryService = _diffProviderFactoryService;\n        this._isDiffUpToDate = observableValue(this, false);\n        this.isDiffUpToDate = this._isDiffUpToDate;\n        this._diff = observableValue(this, undefined);\n        this.diff = this._diff;\n        this._unchangedRegions = observableValue(this, undefined);\n        this.unchangedRegions = derived(this, r => {\n            if (this._options.hideUnchangedRegions.read(r)) {\n                return this._unchangedRegions.read(r)?.regions ?? [];\n            }\n            else {\n                // Reset state\n                transaction(tx => {\n                    for (const r of this._unchangedRegions.get()?.regions || []) {\n                        r.collapseAll(tx);\n                    }\n                });\n                return [];\n            }\n        });\n        this.movedTextToCompare = observableValue(this, undefined);\n        this._activeMovedText = observableValue(this, undefined);\n        this._hoveredMovedText = observableValue(this, undefined);\n        this.activeMovedText = derived(this, r => this.movedTextToCompare.read(r) ?? this._hoveredMovedText.read(r) ?? this._activeMovedText.read(r));\n        this._cancellationTokenSource = new CancellationTokenSource();\n        this._diffProvider = derived(this, reader => {\n            const diffProvider = this._diffProviderFactoryService.createDiffProvider({\n                diffAlgorithm: this._options.diffAlgorithm.read(reader)\n            });\n            const onChangeSignal = observableSignalFromEvent('onDidChange', diffProvider.onDidChange);\n            return {\n                diffProvider,\n                onChangeSignal,\n            };\n        });\n        this._register(toDisposable(() => this._cancellationTokenSource.cancel()));\n        const contentChangedSignal = observableSignal('contentChangedSignal');\n        const debouncer = this._register(new RunOnceScheduler(() => contentChangedSignal.trigger(undefined), 200));\n        this._register(autorun(reader => {\n            /** @description collapse touching unchanged ranges */\n            const lastUnchangedRegions = this._unchangedRegions.read(reader);\n            if (!lastUnchangedRegions || lastUnchangedRegions.regions.some(r => r.isDragged.read(reader))) {\n                return;\n            }\n            const lastUnchangedRegionsOrigRanges = lastUnchangedRegions.originalDecorationIds\n                .map(id => model.original.getDecorationRange(id))\n                .map(r => r ? LineRange.fromRangeInclusive(r) : undefined);\n            const lastUnchangedRegionsModRanges = lastUnchangedRegions.modifiedDecorationIds\n                .map(id => model.modified.getDecorationRange(id))\n                .map(r => r ? LineRange.fromRangeInclusive(r) : undefined);\n            const updatedLastUnchangedRegions = lastUnchangedRegions.regions.map((r, idx) => (!lastUnchangedRegionsOrigRanges[idx] || !lastUnchangedRegionsModRanges[idx]) ? undefined :\n                new UnchangedRegion(lastUnchangedRegionsOrigRanges[idx].startLineNumber, lastUnchangedRegionsModRanges[idx].startLineNumber, lastUnchangedRegionsOrigRanges[idx].length, r.visibleLineCountTop.read(reader), r.visibleLineCountBottom.read(reader))).filter(isDefined);\n            const newRanges = [];\n            let didChange = false;\n            for (const touching of groupAdjacentBy(updatedLastUnchangedRegions, (a, b) => a.getHiddenModifiedRange(reader).endLineNumberExclusive === b.getHiddenModifiedRange(reader).startLineNumber)) {\n                if (touching.length > 1) {\n                    didChange = true;\n                    const sumLineCount = touching.reduce((sum, r) => sum + r.lineCount, 0);\n                    const r = new UnchangedRegion(touching[0].originalLineNumber, touching[0].modifiedLineNumber, sumLineCount, touching[0].visibleLineCountTop.get(), touching[touching.length - 1].visibleLineCountBottom.get());\n                    newRanges.push(r);\n                }\n                else {\n                    newRanges.push(touching[0]);\n                }\n            }\n            if (didChange) {\n                const originalDecorationIds = model.original.deltaDecorations(lastUnchangedRegions.originalDecorationIds, newRanges.map(r => ({ range: r.originalUnchangedRange.toInclusiveRange(), options: { description: 'unchanged' } })));\n                const modifiedDecorationIds = model.modified.deltaDecorations(lastUnchangedRegions.modifiedDecorationIds, newRanges.map(r => ({ range: r.modifiedUnchangedRange.toInclusiveRange(), options: { description: 'unchanged' } })));\n                transaction(tx => {\n                    this._unchangedRegions.set({\n                        regions: newRanges,\n                        originalDecorationIds,\n                        modifiedDecorationIds\n                    }, tx);\n                });\n            }\n        }));\n        const updateUnchangedRegions = (result, tx, reader) => {\n            const newUnchangedRegions = UnchangedRegion.fromDiffs(result.changes, model.original.getLineCount(), model.modified.getLineCount(), this._options.hideUnchangedRegionsMinimumLineCount.read(reader), this._options.hideUnchangedRegionsContextLineCount.read(reader));\n            // Transfer state from cur state\n            let visibleRegions = undefined;\n            const lastUnchangedRegions = this._unchangedRegions.get();\n            if (lastUnchangedRegions) {\n                const lastUnchangedRegionsOrigRanges = lastUnchangedRegions.originalDecorationIds\n                    .map(id => model.original.getDecorationRange(id))\n                    .map(r => r ? LineRange.fromRangeInclusive(r) : undefined);\n                const lastUnchangedRegionsModRanges = lastUnchangedRegions.modifiedDecorationIds\n                    .map(id => model.modified.getDecorationRange(id))\n                    .map(r => r ? LineRange.fromRangeInclusive(r) : undefined);\n                const updatedLastUnchangedRegions = filterWithPrevious(lastUnchangedRegions.regions\n                    .map((r, idx) => {\n                    if (!lastUnchangedRegionsOrigRanges[idx] || !lastUnchangedRegionsModRanges[idx]) {\n                        return undefined;\n                    }\n                    const length = lastUnchangedRegionsOrigRanges[idx].length;\n                    return new UnchangedRegion(lastUnchangedRegionsOrigRanges[idx].startLineNumber, lastUnchangedRegionsModRanges[idx].startLineNumber, length, \n                    // The visible area can shrink by edits -> we have to account for this\n                    Math.min(r.visibleLineCountTop.get(), length), Math.min(r.visibleLineCountBottom.get(), length - r.visibleLineCountTop.get()));\n                }).filter(isDefined), (cur, prev) => !prev || (cur.modifiedLineNumber >= prev.modifiedLineNumber + prev.lineCount && cur.originalLineNumber >= prev.originalLineNumber + prev.lineCount));\n                let hiddenRegions = updatedLastUnchangedRegions.map(r => new LineRangeMapping(r.getHiddenOriginalRange(reader), r.getHiddenModifiedRange(reader)));\n                hiddenRegions = LineRangeMapping.clip(hiddenRegions, LineRange.ofLength(1, model.original.getLineCount()), LineRange.ofLength(1, model.modified.getLineCount()));\n                visibleRegions = LineRangeMapping.inverse(hiddenRegions, model.original.getLineCount(), model.modified.getLineCount());\n            }\n            const newUnchangedRegions2 = [];\n            if (visibleRegions) {\n                for (const r of newUnchangedRegions) {\n                    const intersecting = visibleRegions.filter(f => f.original.intersectsStrict(r.originalUnchangedRange) && f.modified.intersectsStrict(r.modifiedUnchangedRange));\n                    newUnchangedRegions2.push(...r.setVisibleRanges(intersecting, tx));\n                }\n            }\n            else {\n                newUnchangedRegions2.push(...newUnchangedRegions);\n            }\n            const originalDecorationIds = model.original.deltaDecorations(lastUnchangedRegions?.originalDecorationIds || [], newUnchangedRegions2.map(r => ({ range: r.originalUnchangedRange.toInclusiveRange(), options: { description: 'unchanged' } })));\n            const modifiedDecorationIds = model.modified.deltaDecorations(lastUnchangedRegions?.modifiedDecorationIds || [], newUnchangedRegions2.map(r => ({ range: r.modifiedUnchangedRange.toInclusiveRange(), options: { description: 'unchanged' } })));\n            this._unchangedRegions.set({\n                regions: newUnchangedRegions2,\n                originalDecorationIds,\n                modifiedDecorationIds\n            }, tx);\n        };\n        this._register(model.modified.onDidChangeContent((e) => {\n            const diff = this._diff.get();\n            if (diff) {\n                const textEdits = TextEditInfo.fromModelContentChanges(e.changes);\n                const result = applyModifiedEdits(this._lastDiff, textEdits, model.original, model.modified);\n                if (result) {\n                    this._lastDiff = result;\n                    transaction(tx => {\n                        this._diff.set(DiffState.fromDiffResult(this._lastDiff), tx);\n                        updateUnchangedRegions(result, tx);\n                        const currentSyncedMovedText = this.movedTextToCompare.get();\n                        this.movedTextToCompare.set(currentSyncedMovedText ? this._lastDiff.moves.find(m => m.lineRangeMapping.modified.intersect(currentSyncedMovedText.lineRangeMapping.modified)) : undefined, tx);\n                    });\n                }\n            }\n            this._isDiffUpToDate.set(false, undefined);\n            debouncer.schedule();\n        }));\n        this._register(model.original.onDidChangeContent((e) => {\n            const diff = this._diff.get();\n            if (diff) {\n                const textEdits = TextEditInfo.fromModelContentChanges(e.changes);\n                const result = applyOriginalEdits(this._lastDiff, textEdits, model.original, model.modified);\n                if (result) {\n                    this._lastDiff = result;\n                    transaction(tx => {\n                        this._diff.set(DiffState.fromDiffResult(this._lastDiff), tx);\n                        updateUnchangedRegions(result, tx);\n                        const currentSyncedMovedText = this.movedTextToCompare.get();\n                        this.movedTextToCompare.set(currentSyncedMovedText ? this._lastDiff.moves.find(m => m.lineRangeMapping.modified.intersect(currentSyncedMovedText.lineRangeMapping.modified)) : undefined, tx);\n                    });\n                }\n            }\n            this._isDiffUpToDate.set(false, undefined);\n            debouncer.schedule();\n        }));\n        this._register(autorunWithStore(async (reader, store) => {\n            /** @description compute diff */\n            // So that they get recomputed when these settings change\n            this._options.hideUnchangedRegionsMinimumLineCount.read(reader);\n            this._options.hideUnchangedRegionsContextLineCount.read(reader);\n            debouncer.cancel();\n            contentChangedSignal.read(reader);\n            const documentDiffProvider = this._diffProvider.read(reader);\n            documentDiffProvider.onChangeSignal.read(reader);\n            readHotReloadableExport(DefaultLinesDiffComputer, reader);\n            readHotReloadableExport(optimizeSequenceDiffs, reader);\n            this._isDiffUpToDate.set(false, undefined);\n            let originalTextEditInfos = [];\n            store.add(model.original.onDidChangeContent((e) => {\n                const edits = TextEditInfo.fromModelContentChanges(e.changes);\n                originalTextEditInfos = combineTextEditInfos(originalTextEditInfos, edits);\n            }));\n            let modifiedTextEditInfos = [];\n            store.add(model.modified.onDidChangeContent((e) => {\n                const edits = TextEditInfo.fromModelContentChanges(e.changes);\n                modifiedTextEditInfos = combineTextEditInfos(modifiedTextEditInfos, edits);\n            }));\n            let result = await documentDiffProvider.diffProvider.computeDiff(model.original, model.modified, {\n                ignoreTrimWhitespace: this._options.ignoreTrimWhitespace.read(reader),\n                maxComputationTimeMs: this._options.maxComputationTimeMs.read(reader),\n                computeMoves: this._options.showMoves.read(reader),\n            }, this._cancellationTokenSource.token);\n            if (this._cancellationTokenSource.token.isCancellationRequested) {\n                return;\n            }\n            if (model.original.isDisposed() || model.modified.isDisposed()) {\n                // TODO@hediet fishy?\n                return;\n            }\n            result = normalizeDocumentDiff(result, model.original, model.modified);\n            result = applyOriginalEdits(result, originalTextEditInfos, model.original, model.modified) ?? result;\n            result = applyModifiedEdits(result, modifiedTextEditInfos, model.original, model.modified) ?? result;\n            transaction(tx => {\n                /** @description write diff result */\n                updateUnchangedRegions(result, tx);\n                this._lastDiff = result;\n                const state = DiffState.fromDiffResult(result);\n                this._diff.set(state, tx);\n                this._isDiffUpToDate.set(true, tx);\n                const currentSyncedMovedText = this.movedTextToCompare.get();\n                this.movedTextToCompare.set(currentSyncedMovedText ? this._lastDiff.moves.find(m => m.lineRangeMapping.modified.intersect(currentSyncedMovedText.lineRangeMapping.modified)) : undefined, tx);\n            });\n        }));\n    }\n    ensureModifiedLineIsVisible(lineNumber, preference, tx) {\n        if (this.diff.get()?.mappings.length === 0) {\n            return;\n        }\n        const unchangedRegions = this._unchangedRegions.get()?.regions || [];\n        for (const r of unchangedRegions) {\n            if (r.getHiddenModifiedRange(undefined).contains(lineNumber)) {\n                r.showModifiedLine(lineNumber, preference, tx);\n                return;\n            }\n        }\n    }\n    ensureOriginalLineIsVisible(lineNumber, preference, tx) {\n        if (this.diff.get()?.mappings.length === 0) {\n            return;\n        }\n        const unchangedRegions = this._unchangedRegions.get()?.regions || [];\n        for (const r of unchangedRegions) {\n            if (r.getHiddenOriginalRange(undefined).contains(lineNumber)) {\n                r.showOriginalLine(lineNumber, preference, tx);\n                return;\n            }\n        }\n    }\n    async waitForDiff() {\n        await waitForState(this.isDiffUpToDate, s => s);\n    }\n    serializeState() {\n        const regions = this._unchangedRegions.get();\n        return {\n            collapsedRegions: regions?.regions.map(r => ({ range: r.getHiddenModifiedRange(undefined).serialize() }))\n        };\n    }\n    restoreSerializedState(state) {\n        const ranges = state.collapsedRegions?.map(r => LineRange.deserialize(r.range));\n        const regions = this._unchangedRegions.get();\n        if (!regions || !ranges) {\n            return;\n        }\n        transaction(tx => {\n            for (const r of regions.regions) {\n                for (const range of ranges) {\n                    if (r.modifiedUnchangedRange.intersect(range)) {\n                        r.setHiddenModifiedRange(range, tx);\n                        break;\n                    }\n                }\n            }\n        });\n    }\n};\nDiffEditorViewModel = __decorate([\n    __param(2, IDiffProviderFactoryService)\n], DiffEditorViewModel);\nexport { DiffEditorViewModel };\nfunction normalizeDocumentDiff(diff, original, modified) {\n    return {\n        changes: diff.changes.map(c => new DetailedLineRangeMapping(c.original, c.modified, c.innerChanges ? c.innerChanges.map(i => normalizeRangeMapping(i, original, modified)) : undefined)),\n        moves: diff.moves,\n        identical: diff.identical,\n        quitEarly: diff.quitEarly,\n    };\n}\nfunction normalizeRangeMapping(rangeMapping, original, modified) {\n    let originalRange = rangeMapping.originalRange;\n    let modifiedRange = rangeMapping.modifiedRange;\n    if (originalRange.startColumn === 1 && modifiedRange.startColumn === 1 &&\n        (originalRange.endColumn !== 1 || modifiedRange.endColumn !== 1) &&\n        originalRange.endColumn === original.getLineMaxColumn(originalRange.endLineNumber)\n        && modifiedRange.endColumn === modified.getLineMaxColumn(modifiedRange.endLineNumber)\n        && originalRange.endLineNumber < original.getLineCount()\n        && modifiedRange.endLineNumber < modified.getLineCount()) {\n        originalRange = originalRange.setEndPosition(originalRange.endLineNumber + 1, 1);\n        modifiedRange = modifiedRange.setEndPosition(modifiedRange.endLineNumber + 1, 1);\n    }\n    return new RangeMapping(originalRange, modifiedRange);\n}\nexport class DiffState {\n    static fromDiffResult(result) {\n        return new DiffState(result.changes.map(c => new DiffMapping(c)), result.moves || [], result.identical, result.quitEarly);\n    }\n    constructor(mappings, movedTexts, identical, quitEarly) {\n        this.mappings = mappings;\n        this.movedTexts = movedTexts;\n        this.identical = identical;\n        this.quitEarly = quitEarly;\n    }\n}\nexport class DiffMapping {\n    constructor(lineRangeMapping) {\n        this.lineRangeMapping = lineRangeMapping;\n        /*\n        readonly movedTo: MovedText | undefined,\n        readonly movedFrom: MovedText | undefined,\n\n        if (movedTo) {\n            assertFn(() =>\n                movedTo.lineRangeMapping.modifiedRange.equals(lineRangeMapping.modifiedRange)\n                && lineRangeMapping.originalRange.isEmpty\n                && !movedFrom\n            );\n        } else if (movedFrom) {\n            assertFn(() =>\n                movedFrom.lineRangeMapping.originalRange.equals(lineRangeMapping.originalRange)\n                && lineRangeMapping.modifiedRange.isEmpty\n                && !movedTo\n            );\n        }\n        */\n    }\n}\nexport class UnchangedRegion {\n    static fromDiffs(changes, originalLineCount, modifiedLineCount, minHiddenLineCount, minContext) {\n        const inversedMappings = DetailedLineRangeMapping.inverse(changes, originalLineCount, modifiedLineCount);\n        const result = [];\n        for (const mapping of inversedMappings) {\n            let origStart = mapping.original.startLineNumber;\n            let modStart = mapping.modified.startLineNumber;\n            let length = mapping.original.length;\n            const atStart = origStart === 1 && modStart === 1;\n            const atEnd = origStart + length === originalLineCount + 1 && modStart + length === modifiedLineCount + 1;\n            if ((atStart || atEnd) && length >= minContext + minHiddenLineCount) {\n                if (atStart && !atEnd) {\n                    length -= minContext;\n                }\n                if (atEnd && !atStart) {\n                    origStart += minContext;\n                    modStart += minContext;\n                    length -= minContext;\n                }\n                result.push(new UnchangedRegion(origStart, modStart, length, 0, 0));\n            }\n            else if (length >= minContext * 2 + minHiddenLineCount) {\n                origStart += minContext;\n                modStart += minContext;\n                length -= minContext * 2;\n                result.push(new UnchangedRegion(origStart, modStart, length, 0, 0));\n            }\n        }\n        return result;\n    }\n    get originalUnchangedRange() {\n        return LineRange.ofLength(this.originalLineNumber, this.lineCount);\n    }\n    get modifiedUnchangedRange() {\n        return LineRange.ofLength(this.modifiedLineNumber, this.lineCount);\n    }\n    constructor(originalLineNumber, modifiedLineNumber, lineCount, visibleLineCountTop, visibleLineCountBottom) {\n        this.originalLineNumber = originalLineNumber;\n        this.modifiedLineNumber = modifiedLineNumber;\n        this.lineCount = lineCount;\n        this._visibleLineCountTop = observableValue(this, 0);\n        this.visibleLineCountTop = this._visibleLineCountTop;\n        this._visibleLineCountBottom = observableValue(this, 0);\n        this.visibleLineCountBottom = this._visibleLineCountBottom;\n        this._shouldHideControls = derived(this, reader => /** @description isVisible */ this.visibleLineCountTop.read(reader) + this.visibleLineCountBottom.read(reader) === this.lineCount && !this.isDragged.read(reader));\n        this.isDragged = observableValue(this, undefined);\n        const visibleLineCountTop2 = Math.max(Math.min(visibleLineCountTop, this.lineCount), 0);\n        const visibleLineCountBottom2 = Math.max(Math.min(visibleLineCountBottom, this.lineCount - visibleLineCountTop), 0);\n        softAssert(visibleLineCountTop === visibleLineCountTop2);\n        softAssert(visibleLineCountBottom === visibleLineCountBottom2);\n        this._visibleLineCountTop.set(visibleLineCountTop2, undefined);\n        this._visibleLineCountBottom.set(visibleLineCountBottom2, undefined);\n    }\n    setVisibleRanges(visibleRanges, tx) {\n        const result = [];\n        const hiddenModified = new LineRangeSet(visibleRanges.map(r => r.modified)).subtractFrom(this.modifiedUnchangedRange);\n        let originalStartLineNumber = this.originalLineNumber;\n        let modifiedStartLineNumber = this.modifiedLineNumber;\n        const modifiedEndLineNumberEx = this.modifiedLineNumber + this.lineCount;\n        if (hiddenModified.ranges.length === 0) {\n            this.showAll(tx);\n            result.push(this);\n        }\n        else {\n            let i = 0;\n            for (const r of hiddenModified.ranges) {\n                const isLast = i === hiddenModified.ranges.length - 1;\n                i++;\n                const length = (isLast ? modifiedEndLineNumberEx : r.endLineNumberExclusive) - modifiedStartLineNumber;\n                const newR = new UnchangedRegion(originalStartLineNumber, modifiedStartLineNumber, length, 0, 0);\n                newR.setHiddenModifiedRange(r, tx);\n                result.push(newR);\n                originalStartLineNumber = newR.originalUnchangedRange.endLineNumberExclusive;\n                modifiedStartLineNumber = newR.modifiedUnchangedRange.endLineNumberExclusive;\n            }\n        }\n        return result;\n    }\n    shouldHideControls(reader) {\n        return this._shouldHideControls.read(reader);\n    }\n    getHiddenOriginalRange(reader) {\n        return LineRange.ofLength(this.originalLineNumber + this._visibleLineCountTop.read(reader), this.lineCount - this._visibleLineCountTop.read(reader) - this._visibleLineCountBottom.read(reader));\n    }\n    getHiddenModifiedRange(reader) {\n        return LineRange.ofLength(this.modifiedLineNumber + this._visibleLineCountTop.read(reader), this.lineCount - this._visibleLineCountTop.read(reader) - this._visibleLineCountBottom.read(reader));\n    }\n    setHiddenModifiedRange(range, tx) {\n        const visibleLineCountTop = range.startLineNumber - this.modifiedLineNumber;\n        const visibleLineCountBottom = (this.modifiedLineNumber + this.lineCount) - range.endLineNumberExclusive;\n        this.setState(visibleLineCountTop, visibleLineCountBottom, tx);\n    }\n    getMaxVisibleLineCountTop() {\n        return this.lineCount - this._visibleLineCountBottom.get();\n    }\n    getMaxVisibleLineCountBottom() {\n        return this.lineCount - this._visibleLineCountTop.get();\n    }\n    showMoreAbove(count = 10, tx) {\n        const maxVisibleLineCountTop = this.getMaxVisibleLineCountTop();\n        this._visibleLineCountTop.set(Math.min(this._visibleLineCountTop.get() + count, maxVisibleLineCountTop), tx);\n    }\n    showMoreBelow(count = 10, tx) {\n        const maxVisibleLineCountBottom = this.lineCount - this._visibleLineCountTop.get();\n        this._visibleLineCountBottom.set(Math.min(this._visibleLineCountBottom.get() + count, maxVisibleLineCountBottom), tx);\n    }\n    showAll(tx) {\n        this._visibleLineCountBottom.set(this.lineCount - this._visibleLineCountTop.get(), tx);\n    }\n    showModifiedLine(lineNumber, preference, tx) {\n        const top = lineNumber + 1 - (this.modifiedLineNumber + this._visibleLineCountTop.get());\n        const bottom = (this.modifiedLineNumber - this._visibleLineCountBottom.get() + this.lineCount) - lineNumber;\n        if (preference === 0 /* RevealPreference.FromCloserSide */ && top < bottom || preference === 1 /* RevealPreference.FromTop */) {\n            this._visibleLineCountTop.set(this._visibleLineCountTop.get() + top, tx);\n        }\n        else {\n            this._visibleLineCountBottom.set(this._visibleLineCountBottom.get() + bottom, tx);\n        }\n    }\n    showOriginalLine(lineNumber, preference, tx) {\n        const top = lineNumber - this.originalLineNumber;\n        const bottom = (this.originalLineNumber + this.lineCount) - lineNumber;\n        if (preference === 0 /* RevealPreference.FromCloserSide */ && top < bottom || preference === 1 /* RevealPreference.FromTop */) {\n            this._visibleLineCountTop.set(Math.min(this._visibleLineCountTop.get() + bottom - top, this.getMaxVisibleLineCountTop()), tx);\n        }\n        else {\n            this._visibleLineCountBottom.set(Math.min(this._visibleLineCountBottom.get() + top - bottom, this.getMaxVisibleLineCountBottom()), tx);\n        }\n    }\n    collapseAll(tx) {\n        this._visibleLineCountTop.set(0, tx);\n        this._visibleLineCountBottom.set(0, tx);\n    }\n    setState(visibleLineCountTop, visibleLineCountBottom, tx) {\n        visibleLineCountTop = Math.max(Math.min(visibleLineCountTop, this.lineCount), 0);\n        visibleLineCountBottom = Math.max(Math.min(visibleLineCountBottom, this.lineCount - visibleLineCountTop), 0);\n        this._visibleLineCountTop.set(visibleLineCountTop, tx);\n        this._visibleLineCountBottom.set(visibleLineCountBottom, tx);\n    }\n}\nfunction applyOriginalEdits(diff, textEdits, originalTextModel, modifiedTextModel) {\n    return undefined;\n    /*\n    TODO@hediet\n    if (textEdits.length === 0) {\n        return diff;\n    }\n\n    const diff2 = flip(diff);\n    const diff3 = applyModifiedEdits(diff2, textEdits, modifiedTextModel, originalTextModel);\n    if (!diff3) {\n        return undefined;\n    }\n    return flip(diff3);*/\n}\n/*\nfunction flip(diff: IDocumentDiff): IDocumentDiff {\n    return {\n        changes: diff.changes.map(c => c.flip()),\n        moves: diff.moves.map(m => m.flip()),\n        identical: diff.identical,\n        quitEarly: diff.quitEarly,\n    };\n}\n*/\nfunction applyModifiedEdits(diff, textEdits, originalTextModel, modifiedTextModel) {\n    return undefined;\n    /*\n    TODO@hediet\n    if (textEdits.length === 0) {\n        return diff;\n    }\n    if (diff.changes.some(c => !c.innerChanges) || diff.moves.length > 0) {\n        // TODO support these cases\n        return undefined;\n    }\n\n    const changes = applyModifiedEditsToLineRangeMappings(diff.changes, textEdits, originalTextModel, modifiedTextModel);\n\n    const moves = diff.moves.map(m => {\n        const newModifiedRange = applyEditToLineRange(m.lineRangeMapping.modified, textEdits);\n        return newModifiedRange ? new MovedText(\n            new SimpleLineRangeMapping(m.lineRangeMapping.original, newModifiedRange),\n            applyModifiedEditsToLineRangeMappings(m.changes, textEdits, originalTextModel, modifiedTextModel),\n        ) : undefined;\n    }).filter(isDefined);\n\n    return {\n        identical: false,\n        quitEarly: false,\n        changes,\n        moves,\n    };*/\n}\n/*\nfunction applyEditToLineRange(range: LineRange, textEdits: TextEditInfo[]): LineRange | undefined {\n    let rangeStartLineNumber = range.startLineNumber;\n    let rangeEndLineNumberEx = range.endLineNumberExclusive;\n\n    for (let i = textEdits.length - 1; i >= 0; i--) {\n        const textEdit = textEdits[i];\n        const textEditStartLineNumber = lengthGetLineCount(textEdit.startOffset) + 1;\n        const textEditEndLineNumber = lengthGetLineCount(textEdit.endOffset) + 1;\n        const newLengthLineCount = lengthGetLineCount(textEdit.newLength);\n        const delta = newLengthLineCount - (textEditEndLineNumber - textEditStartLineNumber);\n\n        if (textEditEndLineNumber < rangeStartLineNumber) {\n            // the text edit is before us\n            rangeStartLineNumber += delta;\n            rangeEndLineNumberEx += delta;\n        } else if (textEditStartLineNumber > rangeEndLineNumberEx) {\n            // the text edit is after us\n            // NOOP\n        } else if (textEditStartLineNumber < rangeStartLineNumber && rangeEndLineNumberEx < textEditEndLineNumber) {\n            // the range is fully contained in the text edit\n            return undefined;\n        } else if (textEditStartLineNumber < rangeStartLineNumber && textEditEndLineNumber <= rangeEndLineNumberEx) {\n            // the text edit ends inside our range\n            rangeStartLineNumber = textEditEndLineNumber + 1;\n            rangeStartLineNumber += delta;\n            rangeEndLineNumberEx += delta;\n        } else if (rangeStartLineNumber <= textEditStartLineNumber && textEditEndLineNumber < rangeStartLineNumber) {\n            // the text edit starts inside our range\n            rangeEndLineNumberEx = textEditStartLineNumber;\n        } else {\n            rangeEndLineNumberEx += delta;\n        }\n    }\n\n    return new LineRange(rangeStartLineNumber, rangeEndLineNumberEx);\n}\n\nfunction applyModifiedEditsToLineRangeMappings(changes: readonly LineRangeMapping[], textEdits: TextEditInfo[], originalTextModel: ITextModel, modifiedTextModel: ITextModel): LineRangeMapping[] {\n    const diffTextEdits = changes.flatMap(c => c.innerChanges!.map(c => new TextEditInfo(\n        positionToLength(c.originalRange.getStartPosition()),\n        positionToLength(c.originalRange.getEndPosition()),\n        lengthOfRange(c.modifiedRange).toLength(),\n    )));\n\n    const combined = combineTextEditInfos(diffTextEdits, textEdits);\n\n    let lastOriginalEndOffset = lengthZero;\n    let lastModifiedEndOffset = lengthZero;\n    const rangeMappings = combined.map(c => {\n        const modifiedStartOffset = lengthAdd(lastModifiedEndOffset, lengthDiffNonNegative(lastOriginalEndOffset, c.startOffset));\n        lastOriginalEndOffset = c.endOffset;\n        lastModifiedEndOffset = lengthAdd(modifiedStartOffset, c.newLength);\n\n        return new RangeMapping(\n            Range.fromPositions(lengthToPosition(c.startOffset), lengthToPosition(c.endOffset)),\n            Range.fromPositions(lengthToPosition(modifiedStartOffset), lengthToPosition(lastModifiedEndOffset)),\n        );\n    });\n\n    const newChanges = lineRangeMappingFromRangeMappings(\n        rangeMappings,\n        originalTextModel.getLinesContent(),\n        modifiedTextModel.getLinesContent(),\n    );\n    return newChanges;\n}\n*/\n"],"mappings":"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AAG,CAAC,CAAC,EAAEiB,EAAE,CAAC;IACpC,IAAI,CAACuK,uBAAuB,CAACxL,GAAG,CAAC,CAAC,EAAEiB,EAAE,CAAC;EAC3C;EACAsL,QAAQA,CAAC/I,mBAAmB,EAAEC,sBAAsB,EAAExC,EAAE,EAAE;IACtDuC,mBAAmB,GAAGiC,IAAI,CAACkG,GAAG,CAAClG,IAAI,CAACC,GAAG,CAAClC,mBAAmB,EAAE,IAAI,CAACa,SAAS,CAAC,EAAE,CAAC,CAAC;IAChFZ,sBAAsB,GAAGgC,IAAI,CAACkG,GAAG,CAAClG,IAAI,CAACC,GAAG,CAACjC,sBAAsB,EAAE,IAAI,CAACY,SAAS,GAAGb,mBAAmB,CAAC,EAAE,CAAC,CAAC;IAC5G,IAAI,CAAC+H,oBAAoB,CAACvL,GAAG,CAACwD,mBAAmB,EAAEvC,EAAE,CAAC;IACtD,IAAI,CAACuK,uBAAuB,CAACxL,GAAG,CAACyD,sBAAsB,EAAExC,EAAE,CAAC;EAChE;AACJ;AACA,SAASqG,kBAAkBA,CAAC7G,IAAI,EAAEgG,SAAS,EAAEwG,iBAAiB,EAAEC,iBAAiB,EAAE;EAC/E,OAAOjN,SAAS;EAChB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS0G,kBAAkBA,CAAClG,IAAI,EAAEgG,SAAS,EAAEwG,iBAAiB,EAAEC,iBAAiB,EAAE;EAC/E,OAAOjN,SAAS;EAChB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}