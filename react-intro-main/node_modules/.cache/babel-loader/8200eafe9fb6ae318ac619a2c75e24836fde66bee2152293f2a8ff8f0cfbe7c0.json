{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport GraphLayout from './GraphLayout';\nimport { getValue } from '../../util/Utils';\nimport { getNumber } from '../../util/StringUtils';\nimport { DEFAULT_STARTSIZE } from '../../util/Constants';\nimport Geometry from '../geometry/Geometry';\n/**\n * Extends {@link GraphLayout} to create a horizontal or vertical stack of the\n * child vertices. The children do not need to be connected for this layout\n * to work.\n *\n * Example:\n *\n * ```javascript\n * let layout = new mxStackLayout(graph, true);\n * layout.execute(graph.getDefaultParent());\n * ```\n *\n * Constructor: mxStackLayout\n *\n * Constructs a new stack layout layout for the specified graph,\n * spacing, orientation and offset.\n */\nclass StackLayout extends GraphLayout {\n  constructor(graph, horizontal = null, spacing = null, x0 = null, y0 = null, border = null) {\n    super(graph);\n    /**\n     * Border to be added if fill is true.\n     */\n    this.border = 0;\n    /**\n     * Top margin for the child area.\n     */\n    this.marginTop = 0;\n    /**\n     * Top margin for the child area.\n     */\n    this.marginLeft = 0;\n    /**\n     * Top margin for the child area.\n     */\n    this.marginRight = 0;\n    /**\n     * Top margin for the child area.\n     */\n    this.marginBottom = 0;\n    /**\n     * Boolean indicating if the location of the first cell should be kept, that is, it will not be moved to x0 or y0.\n     */\n    this.keepFirstLocation = false;\n    /**\n     * Boolean indicating if dimension should be changed to fill out the parent cell.\n     */\n    this.fill = false;\n    /**\n     * If the parent should be resized to match the width/height of the stack.\n     */\n    this.resizeParent = false;\n    /**\n     * Use maximum of existing value and new value for resize of parent.\n     */\n    this.resizeParentMax = false;\n    /**\n     * If the last element should be resized to fill out the parent.\n     */\n    this.resizeLast = false;\n    /**\n     * Value at which a new column or row should be created.\n     */\n    this.wrap = null;\n    /**\n     * If the strokeWidth should be ignored.\n     */\n    this.borderCollapse = true;\n    /**\n     * If gaps should be allowed in the stack.\n     */\n    this.allowGaps = false;\n    /**\n     * Grid size for alignment of position and size.\n     */\n    this.gridSize = 0;\n    this.horizontal = horizontal != null ? horizontal : true;\n    this.spacing = spacing != null ? spacing : 0;\n    this.x0 = x0 != null ? x0 : 0;\n    this.y0 = y0 != null ? y0 : 0;\n    this.border = border != null ? border : 0;\n  }\n  /**\n   * Returns horizontal.\n   */\n  isHorizontal() {\n    return this.horizontal;\n  }\n  /**\n   * Implements mxGraphLayout.moveCell.\n   */\n  moveCell(cell, x, y) {\n    const model = this.graph.getDataModel();\n    const parent = cell.getParent();\n    const horizontal = this.isHorizontal();\n    if (cell != null && parent != null) {\n      let i = 0;\n      let last = 0;\n      const childCount = parent.getChildCount();\n      let value = horizontal ? x : y;\n      const pstate = this.graph.getView().getState(parent);\n      if (pstate != null) {\n        value -= horizontal ? pstate.x : pstate.y;\n      }\n      value /= this.graph.view.scale;\n      for (i = 0; i < childCount; i += 1) {\n        const child = parent.getChildAt(i);\n        if (child !== cell) {\n          const bounds = child.getGeometry();\n          if (bounds != null) {\n            const tmp = horizontal ? bounds.x + bounds.width / 2 : bounds.y + bounds.height / 2;\n            if (last <= value && tmp > value) {\n              break;\n            }\n            last = tmp;\n          }\n        }\n      }\n      // Changes child order in parent\n      let idx = parent.getIndex(cell);\n      idx = Math.max(0, i - (i > idx ? 1 : 0));\n      model.add(parent, cell, idx);\n    }\n  }\n  /**\n   * Returns the size for the parent container or the size of the graph container if the parent is a layer or the root of the model.\n   */\n  getParentSize(parent) {\n    const model = this.graph.getDataModel();\n    let pgeo = parent.getGeometry();\n    // Handles special case where the parent is either a layer with no\n    // geometry or the current root of the view in which case the size\n    // of the graph's container will be used.\n    if (this.graph.container != null && (pgeo == null && model.isLayer(parent) || parent === this.graph.getView().currentRoot)) {\n      const width = this.graph.container.offsetWidth - 1;\n      const height = this.graph.container.offsetHeight - 1;\n      pgeo = new Geometry(0, 0, width, height);\n    }\n    return pgeo;\n  }\n  /**\n   * Returns the cells to be layouted.\n   */\n  getLayoutCells(parent) {\n    const model = this.graph.getDataModel();\n    const childCount = parent.getChildCount();\n    const cells = [];\n    for (let i = 0; i < childCount; i += 1) {\n      const child = parent.getChildAt(i);\n      if (!this.isVertexIgnored(child) && this.isVertexMovable(child)) {\n        cells.push(child);\n      }\n    }\n    if (this.allowGaps) {\n      cells.sort((c1, c2) => {\n        const geo1 = c1.getGeometry();\n        const geo2 = c2.getGeometry();\n        return this.horizontal ? geo1.x === geo2.x ? 0 : geo1.x > geo2.x && geo2.x > 0 ? 1 : -1 : geo1.y === geo2.y ? 0 : geo1.y > geo2.y && geo2.y > 0 ? 1 : -1;\n      });\n    }\n    return cells;\n  }\n  /**\n   * Snaps the given value to the grid size.\n   */\n  snap(value) {\n    if (this.gridSize != null && this.gridSize > 0) {\n      value = Math.max(value, this.gridSize);\n      if (value / this.gridSize > 1) {\n        const mod = value % this.gridSize;\n        value += mod > this.gridSize / 2 ? this.gridSize - mod : -mod;\n      }\n    }\n    return value;\n  }\n  /**\n   * Implements mxGraphLayout.execute.\n   */\n  execute(parent) {\n    if (parent != null) {\n      const pgeo = this.getParentSize(parent);\n      const horizontal = this.isHorizontal();\n      const model = this.graph.getDataModel();\n      let fillValue = null;\n      if (pgeo != null) {\n        fillValue = horizontal ? pgeo.height - this.marginTop - this.marginBottom : pgeo.width - this.marginLeft - this.marginRight;\n        fillValue -= 2 * this.border;\n      }\n      let x0 = this.x0 + this.border + this.marginLeft;\n      let y0 = this.y0 + this.border + this.marginTop;\n      // Handles swimlane start size\n      if (this.graph.isSwimlane(parent)) {\n        // Uses computed style to get latest\n        const style = this.graph.getCellStyle(parent);\n        let start = getNumber(style, 'startSize', DEFAULT_STARTSIZE);\n        const horz = getValue(style, 'horizontal', true) == 1;\n        if (pgeo != null) {\n          if (horz) {\n            start = Math.min(start, pgeo.height);\n          } else {\n            start = Math.min(start, pgeo.width);\n          }\n        }\n        if (horizontal === horz && fillValue != null) {\n          fillValue -= start;\n        }\n        if (horz) {\n          y0 += start;\n        } else {\n          x0 += start;\n        }\n      }\n      model.beginUpdate();\n      try {\n        let tmp = 0;\n        let last = null;\n        let lastValue = 0;\n        let lastChild = null;\n        const cells = this.getLayoutCells(parent);\n        for (let i = 0; i < cells.length; i += 1) {\n          const child = cells[i];\n          let geo = child.getGeometry();\n          if (geo != null) {\n            geo = geo.clone();\n            if (this.wrap != null && last != null) {\n              if (horizontal && last.x + last.width + geo.width + 2 * this.spacing > this.wrap || !horizontal && last.y + last.height + geo.height + 2 * this.spacing > this.wrap) {\n                last = null;\n                if (horizontal) {\n                  y0 += tmp + this.spacing;\n                } else {\n                  x0 += tmp + this.spacing;\n                }\n                tmp = 0;\n              }\n            }\n            tmp = Math.max(tmp, horizontal ? geo.height : geo.width);\n            let sw = 0;\n            if (!this.borderCollapse) {\n              const childStyle = this.graph.getCellStyle(child);\n              sw = getNumber(childStyle, 'strokeWidth', 1);\n            }\n            if (last != null) {\n              const temp = lastValue + this.spacing + Math.floor(sw / 2);\n              if (horizontal) {\n                geo.x = this.snap((this.allowGaps ? Math.max(temp, geo.x) : temp) - this.marginLeft) + this.marginLeft;\n              } else {\n                geo.y = this.snap((this.allowGaps ? Math.max(temp, geo.y) : temp) - this.marginTop) + this.marginTop;\n              }\n            } else if (!this.keepFirstLocation) {\n              if (horizontal) {\n                geo.x = this.allowGaps && geo.x > x0 ? Math.max(this.snap(geo.x - this.marginLeft) + this.marginLeft, x0) : x0;\n              } else {\n                geo.y = this.allowGaps && geo.y > y0 ? Math.max(this.snap(geo.y - this.marginTop) + this.marginTop, y0) : y0;\n              }\n            }\n            if (horizontal) {\n              geo.y = y0;\n            } else {\n              geo.x = x0;\n            }\n            if (this.fill && fillValue != null) {\n              if (horizontal) {\n                geo.height = fillValue;\n              } else {\n                geo.width = fillValue;\n              }\n            }\n            if (horizontal) {\n              geo.width = this.snap(geo.width);\n            } else {\n              geo.height = this.snap(geo.height);\n            }\n            this.setChildGeometry(child, geo);\n            lastChild = child;\n            last = geo;\n            if (horizontal) {\n              lastValue = last.x + last.width + Math.floor(sw / 2);\n            } else {\n              lastValue = last.y + last.height + Math.floor(sw / 2);\n            }\n          }\n        }\n        if (this.resizeParent && pgeo != null && last != null && !parent.isCollapsed()) {\n          this.updateParentGeometry(parent, pgeo, last);\n        } else if (this.resizeLast && pgeo != null && last != null && lastChild != null) {\n          if (horizontal) {\n            last.width = pgeo.width - last.x - this.spacing - this.marginRight - this.marginLeft;\n          } else {\n            last.height = pgeo.height - last.y - this.spacing - this.marginBottom;\n          }\n          this.setChildGeometry(lastChild, last);\n        }\n      } finally {\n        model.endUpdate();\n      }\n    }\n  }\n  /**\n   * Sets the specific geometry to the given child cell.\n   *\n   * @param child The given child of <Cell>.\n   * @param geo The specific geometry of {@link Geometry}.\n   */\n  setChildGeometry(child, geo) {\n    const geo2 = child.getGeometry();\n    if (geo2 == null || geo.x !== geo2.x || geo.y !== geo2.y || geo.width !== geo2.width || geo.height !== geo2.height) {\n      this.graph.getDataModel().setGeometry(child, geo);\n    }\n  }\n  /**\n   * Updates the geometry of the given parent cell.\n   *\n   * @param parent The given parent of <Cell>.\n   * @param pgeo The new {@link Geometry} for parent.\n   * @param last The last {@link Geometry}.\n   */\n  updateParentGeometry(parent, pgeo, last) {\n    const horizontal = this.isHorizontal();\n    const model = this.graph.getDataModel();\n    const pgeo2 = pgeo.clone();\n    if (horizontal) {\n      const tmp = last.x + last.width + this.marginRight + this.border;\n      if (this.resizeParentMax) {\n        pgeo2.width = Math.max(pgeo2.width, tmp);\n      } else {\n        pgeo2.width = tmp;\n      }\n    } else {\n      const tmp = last.y + last.height + this.marginBottom + this.border;\n      if (this.resizeParentMax) {\n        pgeo2.height = Math.max(pgeo2.height, tmp);\n      } else {\n        pgeo2.height = tmp;\n      }\n    }\n    if (pgeo.x !== pgeo2.x || pgeo.y !== pgeo2.y || pgeo.width !== pgeo2.width || pgeo.height !== pgeo2.height) {\n      model.setGeometry(parent, pgeo2);\n    }\n  }\n}\nexport default StackLayout;","map":{"version":3,"names":["GraphLayout","getValue","getNumber","DEFAULT_STARTSIZE","Geometry","StackLayout","constructor","graph","horizontal","spacing","x0","y0","border","marginTop","marginLeft","marginRight","marginBottom","keepFirstLocation","fill","resizeParent","resizeParentMax","resizeLast","wrap","borderCollapse","allowGaps","gridSize","isHorizontal","moveCell","cell","x","y","model","getDataModel","parent","getParent","i","last","childCount","getChildCount","value","pstate","getView","getState","view","scale","child","getChildAt","bounds","getGeometry","tmp","width","height","idx","getIndex","Math","max","add","getParentSize","pgeo","container","isLayer","currentRoot","offsetWidth","offsetHeight","getLayoutCells","cells","isVertexIgnored","isVertexMovable","push","sort","c1","c2","geo1","geo2","snap","mod","execute","fillValue","isSwimlane","style","getCellStyle","start","horz","min","beginUpdate","lastValue","lastChild","length","geo","clone","sw","childStyle","temp","floor","setChildGeometry","isCollapsed","updateParentGeometry","endUpdate","setGeometry","pgeo2"],"sources":["D:/OSPanel/domains/проекты open server/old/react/react-intro-main/node_modules/@maxgraph/core/dist/view/layout/StackLayout.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport GraphLayout from './GraphLayout';\nimport { getValue } from '../../util/Utils';\nimport { getNumber } from '../../util/StringUtils';\nimport { DEFAULT_STARTSIZE } from '../../util/Constants';\nimport Geometry from '../geometry/Geometry';\n/**\n * Extends {@link GraphLayout} to create a horizontal or vertical stack of the\n * child vertices. The children do not need to be connected for this layout\n * to work.\n *\n * Example:\n *\n * ```javascript\n * let layout = new mxStackLayout(graph, true);\n * layout.execute(graph.getDefaultParent());\n * ```\n *\n * Constructor: mxStackLayout\n *\n * Constructs a new stack layout layout for the specified graph,\n * spacing, orientation and offset.\n */\nclass StackLayout extends GraphLayout {\n    constructor(graph, horizontal = null, spacing = null, x0 = null, y0 = null, border = null) {\n        super(graph);\n        /**\n         * Border to be added if fill is true.\n         */\n        this.border = 0;\n        /**\n         * Top margin for the child area.\n         */\n        this.marginTop = 0;\n        /**\n         * Top margin for the child area.\n         */\n        this.marginLeft = 0;\n        /**\n         * Top margin for the child area.\n         */\n        this.marginRight = 0;\n        /**\n         * Top margin for the child area.\n         */\n        this.marginBottom = 0;\n        /**\n         * Boolean indicating if the location of the first cell should be kept, that is, it will not be moved to x0 or y0.\n         */\n        this.keepFirstLocation = false;\n        /**\n         * Boolean indicating if dimension should be changed to fill out the parent cell.\n         */\n        this.fill = false;\n        /**\n         * If the parent should be resized to match the width/height of the stack.\n         */\n        this.resizeParent = false;\n        /**\n         * Use maximum of existing value and new value for resize of parent.\n         */\n        this.resizeParentMax = false;\n        /**\n         * If the last element should be resized to fill out the parent.\n         */\n        this.resizeLast = false;\n        /**\n         * Value at which a new column or row should be created.\n         */\n        this.wrap = null;\n        /**\n         * If the strokeWidth should be ignored.\n         */\n        this.borderCollapse = true;\n        /**\n         * If gaps should be allowed in the stack.\n         */\n        this.allowGaps = false;\n        /**\n         * Grid size for alignment of position and size.\n         */\n        this.gridSize = 0;\n        this.horizontal = horizontal != null ? horizontal : true;\n        this.spacing = spacing != null ? spacing : 0;\n        this.x0 = x0 != null ? x0 : 0;\n        this.y0 = y0 != null ? y0 : 0;\n        this.border = border != null ? border : 0;\n    }\n    /**\n     * Returns horizontal.\n     */\n    isHorizontal() {\n        return this.horizontal;\n    }\n    /**\n     * Implements mxGraphLayout.moveCell.\n     */\n    moveCell(cell, x, y) {\n        const model = this.graph.getDataModel();\n        const parent = cell.getParent();\n        const horizontal = this.isHorizontal();\n        if (cell != null && parent != null) {\n            let i = 0;\n            let last = 0;\n            const childCount = parent.getChildCount();\n            let value = horizontal ? x : y;\n            const pstate = this.graph.getView().getState(parent);\n            if (pstate != null) {\n                value -= horizontal ? pstate.x : pstate.y;\n            }\n            value /= this.graph.view.scale;\n            for (i = 0; i < childCount; i += 1) {\n                const child = parent.getChildAt(i);\n                if (child !== cell) {\n                    const bounds = child.getGeometry();\n                    if (bounds != null) {\n                        const tmp = horizontal\n                            ? bounds.x + bounds.width / 2\n                            : bounds.y + bounds.height / 2;\n                        if (last <= value && tmp > value) {\n                            break;\n                        }\n                        last = tmp;\n                    }\n                }\n            }\n            // Changes child order in parent\n            let idx = parent.getIndex(cell);\n            idx = Math.max(0, i - (i > idx ? 1 : 0));\n            model.add(parent, cell, idx);\n        }\n    }\n    /**\n     * Returns the size for the parent container or the size of the graph container if the parent is a layer or the root of the model.\n     */\n    getParentSize(parent) {\n        const model = this.graph.getDataModel();\n        let pgeo = parent.getGeometry();\n        // Handles special case where the parent is either a layer with no\n        // geometry or the current root of the view in which case the size\n        // of the graph's container will be used.\n        if (this.graph.container != null &&\n            ((pgeo == null && model.isLayer(parent)) ||\n                parent === this.graph.getView().currentRoot)) {\n            const width = this.graph.container.offsetWidth - 1;\n            const height = this.graph.container.offsetHeight - 1;\n            pgeo = new Geometry(0, 0, width, height);\n        }\n        return pgeo;\n    }\n    /**\n     * Returns the cells to be layouted.\n     */\n    getLayoutCells(parent) {\n        const model = this.graph.getDataModel();\n        const childCount = parent.getChildCount();\n        const cells = [];\n        for (let i = 0; i < childCount; i += 1) {\n            const child = parent.getChildAt(i);\n            if (!this.isVertexIgnored(child) && this.isVertexMovable(child)) {\n                cells.push(child);\n            }\n        }\n        if (this.allowGaps) {\n            cells.sort((c1, c2) => {\n                const geo1 = c1.getGeometry();\n                const geo2 = c2.getGeometry();\n                return this.horizontal\n                    ? geo1.x === geo2.x\n                        ? 0\n                        : geo1.x > geo2.x && geo2.x > 0\n                            ? 1\n                            : -1\n                    : geo1.y === geo2.y\n                        ? 0\n                        : geo1.y > geo2.y && geo2.y > 0\n                            ? 1\n                            : -1;\n            });\n        }\n        return cells;\n    }\n    /**\n     * Snaps the given value to the grid size.\n     */\n    snap(value) {\n        if (this.gridSize != null && this.gridSize > 0) {\n            value = Math.max(value, this.gridSize);\n            if (value / this.gridSize > 1) {\n                const mod = value % this.gridSize;\n                value += mod > this.gridSize / 2 ? this.gridSize - mod : -mod;\n            }\n        }\n        return value;\n    }\n    /**\n     * Implements mxGraphLayout.execute.\n     */\n    execute(parent) {\n        if (parent != null) {\n            const pgeo = this.getParentSize(parent);\n            const horizontal = this.isHorizontal();\n            const model = this.graph.getDataModel();\n            let fillValue = null;\n            if (pgeo != null) {\n                fillValue = horizontal\n                    ? pgeo.height - this.marginTop - this.marginBottom\n                    : pgeo.width - this.marginLeft - this.marginRight;\n                fillValue -= 2 * this.border;\n            }\n            let x0 = this.x0 + this.border + this.marginLeft;\n            let y0 = this.y0 + this.border + this.marginTop;\n            // Handles swimlane start size\n            if (this.graph.isSwimlane(parent)) {\n                // Uses computed style to get latest\n                const style = this.graph.getCellStyle(parent);\n                let start = getNumber(style, 'startSize', DEFAULT_STARTSIZE);\n                const horz = getValue(style, 'horizontal', true) == 1;\n                if (pgeo != null) {\n                    if (horz) {\n                        start = Math.min(start, pgeo.height);\n                    }\n                    else {\n                        start = Math.min(start, pgeo.width);\n                    }\n                }\n                if (horizontal === horz && fillValue != null) {\n                    fillValue -= start;\n                }\n                if (horz) {\n                    y0 += start;\n                }\n                else {\n                    x0 += start;\n                }\n            }\n            model.beginUpdate();\n            try {\n                let tmp = 0;\n                let last = null;\n                let lastValue = 0;\n                let lastChild = null;\n                const cells = this.getLayoutCells(parent);\n                for (let i = 0; i < cells.length; i += 1) {\n                    const child = cells[i];\n                    let geo = child.getGeometry();\n                    if (geo != null) {\n                        geo = geo.clone();\n                        if (this.wrap != null && last != null) {\n                            if ((horizontal &&\n                                last.x + last.width + geo.width + 2 * this.spacing > this.wrap) ||\n                                (!horizontal &&\n                                    last.y + last.height + geo.height + 2 * this.spacing > this.wrap)) {\n                                last = null;\n                                if (horizontal) {\n                                    y0 += tmp + this.spacing;\n                                }\n                                else {\n                                    x0 += tmp + this.spacing;\n                                }\n                                tmp = 0;\n                            }\n                        }\n                        tmp = Math.max(tmp, horizontal ? geo.height : geo.width);\n                        let sw = 0;\n                        if (!this.borderCollapse) {\n                            const childStyle = this.graph.getCellStyle(child);\n                            sw = getNumber(childStyle, 'strokeWidth', 1);\n                        }\n                        if (last != null) {\n                            const temp = lastValue + this.spacing + Math.floor(sw / 2);\n                            if (horizontal) {\n                                geo.x =\n                                    this.snap((this.allowGaps ? Math.max(temp, geo.x) : temp) - this.marginLeft) + this.marginLeft;\n                            }\n                            else {\n                                geo.y =\n                                    this.snap((this.allowGaps ? Math.max(temp, geo.y) : temp) - this.marginTop) + this.marginTop;\n                            }\n                        }\n                        else if (!this.keepFirstLocation) {\n                            if (horizontal) {\n                                geo.x =\n                                    this.allowGaps && geo.x > x0\n                                        ? Math.max(this.snap(geo.x - this.marginLeft) + this.marginLeft, x0)\n                                        : x0;\n                            }\n                            else {\n                                geo.y =\n                                    this.allowGaps && geo.y > y0\n                                        ? Math.max(this.snap(geo.y - this.marginTop) + this.marginTop, y0)\n                                        : y0;\n                            }\n                        }\n                        if (horizontal) {\n                            geo.y = y0;\n                        }\n                        else {\n                            geo.x = x0;\n                        }\n                        if (this.fill && fillValue != null) {\n                            if (horizontal) {\n                                geo.height = fillValue;\n                            }\n                            else {\n                                geo.width = fillValue;\n                            }\n                        }\n                        if (horizontal) {\n                            geo.width = this.snap(geo.width);\n                        }\n                        else {\n                            geo.height = this.snap(geo.height);\n                        }\n                        this.setChildGeometry(child, geo);\n                        lastChild = child;\n                        last = geo;\n                        if (horizontal) {\n                            lastValue = last.x + last.width + Math.floor(sw / 2);\n                        }\n                        else {\n                            lastValue = last.y + last.height + Math.floor(sw / 2);\n                        }\n                    }\n                }\n                if (this.resizeParent && pgeo != null && last != null && !parent.isCollapsed()) {\n                    this.updateParentGeometry(parent, pgeo, last);\n                }\n                else if (this.resizeLast && pgeo != null && last != null && lastChild != null) {\n                    if (horizontal) {\n                        last.width =\n                            pgeo.width - last.x - this.spacing - this.marginRight - this.marginLeft;\n                    }\n                    else {\n                        last.height = pgeo.height - last.y - this.spacing - this.marginBottom;\n                    }\n                    this.setChildGeometry(lastChild, last);\n                }\n            }\n            finally {\n                model.endUpdate();\n            }\n        }\n    }\n    /**\n     * Sets the specific geometry to the given child cell.\n     *\n     * @param child The given child of <Cell>.\n     * @param geo The specific geometry of {@link Geometry}.\n     */\n    setChildGeometry(child, geo) {\n        const geo2 = child.getGeometry();\n        if (geo2 == null ||\n            geo.x !== geo2.x ||\n            geo.y !== geo2.y ||\n            geo.width !== geo2.width ||\n            geo.height !== geo2.height) {\n            this.graph.getDataModel().setGeometry(child, geo);\n        }\n    }\n    /**\n     * Updates the geometry of the given parent cell.\n     *\n     * @param parent The given parent of <Cell>.\n     * @param pgeo The new {@link Geometry} for parent.\n     * @param last The last {@link Geometry}.\n     */\n    updateParentGeometry(parent, pgeo, last) {\n        const horizontal = this.isHorizontal();\n        const model = this.graph.getDataModel();\n        const pgeo2 = pgeo.clone();\n        if (horizontal) {\n            const tmp = last.x + last.width + this.marginRight + this.border;\n            if (this.resizeParentMax) {\n                pgeo2.width = Math.max(pgeo2.width, tmp);\n            }\n            else {\n                pgeo2.width = tmp;\n            }\n        }\n        else {\n            const tmp = last.y + last.height + this.marginBottom + this.border;\n            if (this.resizeParentMax) {\n                pgeo2.height = Math.max(pgeo2.height, tmp);\n            }\n            else {\n                pgeo2.height = tmp;\n            }\n        }\n        if (pgeo.x !== pgeo2.x ||\n            pgeo.y !== pgeo2.y ||\n            pgeo.width !== pgeo2.width ||\n            pgeo.height !== pgeo2.height) {\n            model.setGeometry(parent, pgeo2);\n        }\n    }\n}\nexport default StackLayout;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}