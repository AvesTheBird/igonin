{"ast":null,"code":"var _AbstractCommandsQuickAccessProvider, _CommandsHistory;\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar AbstractCommandsQuickAccessProvider_1, CommandsHistory_1;\nimport { toErrorMessage } from '../../../base/common/errorMessage.js';\nimport { isCancellationError } from '../../../base/common/errors.js';\nimport { matchesContiguousSubString, matchesPrefix, matchesWords, or } from '../../../base/common/filters.js';\nimport { createSingleCallFunction } from '../../../base/common/functional.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { LRUCache } from '../../../base/common/map.js';\nimport { TfIdfCalculator, normalizeTfIdfScores } from '../../../base/common/tfIdf.js';\nimport { localize } from '../../../nls.js';\nimport { ICommandService } from '../../commands/common/commands.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { IDialogService } from '../../dialogs/common/dialogs.js';\nimport { IInstantiationService } from '../../instantiation/common/instantiation.js';\nimport { IKeybindingService } from '../../keybinding/common/keybinding.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { PickerQuickAccessProvider } from './pickerQuickAccess.js';\nimport { IStorageService, WillSaveStateReason } from '../../storage/common/storage.js';\nimport { ITelemetryService } from '../../telemetry/common/telemetry.js';\nlet AbstractCommandsQuickAccessProvider = (_AbstractCommandsQuickAccessProvider = class AbstractCommandsQuickAccessProvider extends PickerQuickAccessProvider {\n  constructor(options, instantiationService, keybindingService, commandService, telemetryService, dialogService) {\n    super(AbstractCommandsQuickAccessProvider_1.PREFIX, options);\n    this.instantiationService = instantiationService;\n    this.keybindingService = keybindingService;\n    this.commandService = commandService;\n    this.telemetryService = telemetryService;\n    this.dialogService = dialogService;\n    this.commandsHistory = this._register(this.instantiationService.createInstance(CommandsHistory));\n    this.options = options;\n  }\n  async _getPicks(filter, _disposables, token, runOptions) {\n    // Ask subclass for all command picks\n    const allCommandPicks = await this.getCommandPicks(token);\n    if (token.isCancellationRequested) {\n      return [];\n    }\n    const runTfidf = createSingleCallFunction(() => {\n      const tfidf = new TfIdfCalculator();\n      tfidf.updateDocuments(allCommandPicks.map(commandPick => ({\n        key: commandPick.commandId,\n        textChunks: [this.getTfIdfChunk(commandPick)]\n      })));\n      const result = tfidf.calculateScores(filter, token);\n      return normalizeTfIdfScores(result).filter(score => score.score > AbstractCommandsQuickAccessProvider_1.TFIDF_THRESHOLD).slice(0, AbstractCommandsQuickAccessProvider_1.TFIDF_MAX_RESULTS);\n    });\n    // Filter\n    const filteredCommandPicks = [];\n    for (const commandPick of allCommandPicks) {\n      var _AbstractCommandsQuic, _AbstractCommandsQuic2;\n      const labelHighlights = (_AbstractCommandsQuic = AbstractCommandsQuickAccessProvider_1.WORD_FILTER(filter, commandPick.label)) !== null && _AbstractCommandsQuic !== void 0 ? _AbstractCommandsQuic : undefined;\n      const aliasHighlights = commandPick.commandAlias ? (_AbstractCommandsQuic2 = AbstractCommandsQuickAccessProvider_1.WORD_FILTER(filter, commandPick.commandAlias)) !== null && _AbstractCommandsQuic2 !== void 0 ? _AbstractCommandsQuic2 : undefined : undefined;\n      // Add if matching in label or alias\n      if (labelHighlights || aliasHighlights) {\n        commandPick.highlights = {\n          label: labelHighlights,\n          detail: this.options.showAlias ? aliasHighlights : undefined\n        };\n        filteredCommandPicks.push(commandPick);\n      }\n      // Also add if we have a 100% command ID match\n      else if (filter === commandPick.commandId) {\n        filteredCommandPicks.push(commandPick);\n      }\n      // Handle tf-idf scoring for the rest if there's a filter\n      else if (filter.length >= 3) {\n        const tfidf = runTfidf();\n        if (token.isCancellationRequested) {\n          return [];\n        }\n        // Add if we have a tf-idf score\n        const tfidfScore = tfidf.find(score => score.key === commandPick.commandId);\n        if (tfidfScore) {\n          commandPick.tfIdfScore = tfidfScore.score;\n          filteredCommandPicks.push(commandPick);\n        }\n      }\n    }\n    // Add description to commands that have duplicate labels\n    const mapLabelToCommand = new Map();\n    for (const commandPick of filteredCommandPicks) {\n      const existingCommandForLabel = mapLabelToCommand.get(commandPick.label);\n      if (existingCommandForLabel) {\n        commandPick.description = commandPick.commandId;\n        existingCommandForLabel.description = existingCommandForLabel.commandId;\n      } else {\n        mapLabelToCommand.set(commandPick.label, commandPick);\n      }\n    }\n    // Sort by MRU order and fallback to name otherwise\n    filteredCommandPicks.sort((commandPickA, commandPickB) => {\n      // If a result came from tf-idf, we want to put that towards the bottom\n      if (commandPickA.tfIdfScore && commandPickB.tfIdfScore) {\n        if (commandPickA.tfIdfScore === commandPickB.tfIdfScore) {\n          return commandPickA.label.localeCompare(commandPickB.label); // prefer lexicographically smaller command\n        }\n        return commandPickB.tfIdfScore - commandPickA.tfIdfScore; // prefer higher tf-idf score\n      } else if (commandPickA.tfIdfScore) {\n        return 1; // first command has a score but other doesn't so other wins\n      } else if (commandPickB.tfIdfScore) {\n        return -1; // other command has a score but first doesn't so first wins\n      }\n      const commandACounter = this.commandsHistory.peek(commandPickA.commandId);\n      const commandBCounter = this.commandsHistory.peek(commandPickB.commandId);\n      if (commandACounter && commandBCounter) {\n        return commandACounter > commandBCounter ? -1 : 1; // use more recently used command before older\n      }\n      if (commandACounter) {\n        return -1; // first command was used, so it wins over the non used one\n      }\n      if (commandBCounter) {\n        return 1; // other command was used so it wins over the command\n      }\n      if (this.options.suggestedCommandIds) {\n        const commandASuggestion = this.options.suggestedCommandIds.has(commandPickA.commandId);\n        const commandBSuggestion = this.options.suggestedCommandIds.has(commandPickB.commandId);\n        if (commandASuggestion && commandBSuggestion) {\n          return 0; // honor the order of the array\n        }\n        if (commandASuggestion) {\n          return -1; // first command was suggested, so it wins over the non suggested one\n        }\n        if (commandBSuggestion) {\n          return 1; // other command was suggested so it wins over the command\n        }\n      }\n      // both commands were never used, so we sort by name\n      return commandPickA.label.localeCompare(commandPickB.label);\n    });\n    const commandPicks = [];\n    let addOtherSeparator = false;\n    let addSuggestedSeparator = true;\n    let addCommonlyUsedSeparator = !!this.options.suggestedCommandIds;\n    for (let i = 0; i < filteredCommandPicks.length; i++) {\n      var _this$options$suggest, _this$options$suggest2;\n      const commandPick = filteredCommandPicks[i];\n      // Separator: recently used\n      if (i === 0 && this.commandsHistory.peek(commandPick.commandId)) {\n        commandPicks.push({\n          type: 'separator',\n          label: localize('recentlyUsed', \"recently used\")\n        });\n        addOtherSeparator = true;\n      }\n      if (addSuggestedSeparator && commandPick.tfIdfScore !== undefined) {\n        commandPicks.push({\n          type: 'separator',\n          label: localize('suggested', \"similar commands\")\n        });\n        addSuggestedSeparator = false;\n      }\n      // Separator: commonly used\n      if (addCommonlyUsedSeparator && commandPick.tfIdfScore === undefined && !this.commandsHistory.peek(commandPick.commandId) && (_this$options$suggest = this.options.suggestedCommandIds) !== null && _this$options$suggest !== void 0 && _this$options$suggest.has(commandPick.commandId)) {\n        commandPicks.push({\n          type: 'separator',\n          label: localize('commonlyUsed', \"commonly used\")\n        });\n        addOtherSeparator = true;\n        addCommonlyUsedSeparator = false;\n      }\n      // Separator: other commands\n      if (addOtherSeparator && commandPick.tfIdfScore === undefined && !this.commandsHistory.peek(commandPick.commandId) && !((_this$options$suggest2 = this.options.suggestedCommandIds) !== null && _this$options$suggest2 !== void 0 && _this$options$suggest2.has(commandPick.commandId))) {\n        commandPicks.push({\n          type: 'separator',\n          label: localize('morecCommands', \"other commands\")\n        });\n        addOtherSeparator = false;\n      }\n      // Command\n      commandPicks.push(this.toCommandPick(commandPick, runOptions));\n    }\n    if (!this.hasAdditionalCommandPicks(filter, token)) {\n      return commandPicks;\n    }\n    return {\n      picks: commandPicks,\n      additionalPicks: (async _commandPicks$ => {\n        const additionalCommandPicks = await this.getAdditionalCommandPicks(allCommandPicks, filteredCommandPicks, filter, token);\n        if (token.isCancellationRequested) {\n          return [];\n        }\n        const commandPicks = additionalCommandPicks.map(commandPick => this.toCommandPick(commandPick, runOptions));\n        // Basically, if we haven't already added a separator, we add one before the additional picks so long\n        // as one hasn't been added to the start of the array.\n        if (addSuggestedSeparator && ((_commandPicks$ = commandPicks[0]) === null || _commandPicks$ === void 0 ? void 0 : _commandPicks$.type) !== 'separator') {\n          commandPicks.unshift({\n            type: 'separator',\n            label: localize('suggested', \"similar commands\")\n          });\n        }\n        return commandPicks;\n      })()\n    };\n  }\n  toCommandPick(commandPick, runOptions) {\n    if (commandPick.type === 'separator') {\n      return commandPick;\n    }\n    const keybinding = this.keybindingService.lookupKeybinding(commandPick.commandId);\n    const ariaLabel = keybinding ? localize('commandPickAriaLabelWithKeybinding', \"{0}, {1}\", commandPick.label, keybinding.getAriaLabel()) : commandPick.label;\n    return {\n      ...commandPick,\n      ariaLabel,\n      detail: this.options.showAlias && commandPick.commandAlias !== commandPick.label ? commandPick.commandAlias : undefined,\n      keybinding,\n      accept: async () => {\n        var _runOptions$from;\n        // Add to history\n        this.commandsHistory.push(commandPick.commandId);\n        // Telementry\n        this.telemetryService.publicLog2('workbenchActionExecuted', {\n          id: commandPick.commandId,\n          from: (_runOptions$from = runOptions === null || runOptions === void 0 ? void 0 : runOptions.from) !== null && _runOptions$from !== void 0 ? _runOptions$from : 'quick open'\n        });\n        // Run\n        try {\n          var _commandPick$args;\n          (_commandPick$args = commandPick.args) !== null && _commandPick$args !== void 0 && _commandPick$args.length ? await this.commandService.executeCommand(commandPick.commandId, ...commandPick.args) : await this.commandService.executeCommand(commandPick.commandId);\n        } catch (error) {\n          if (!isCancellationError(error)) {\n            this.dialogService.error(localize('canNotRun', \"Command '{0}' resulted in an error\", commandPick.label), toErrorMessage(error));\n          }\n        }\n      }\n    };\n  }\n  // TF-IDF string to be indexed\n  getTfIdfChunk(_ref) {\n    let {\n      label,\n      commandAlias,\n      commandDescription\n    } = _ref;\n    let chunk = label;\n    if (commandAlias && commandAlias !== label) {\n      chunk += \" - \".concat(commandAlias);\n    }\n    if (commandDescription && commandDescription.value !== label) {\n      // If the original is the same as the value, don't add it\n      chunk += \" - \".concat(commandDescription.value === commandDescription.original ? commandDescription.value : \"\".concat(commandDescription.value, \" (\").concat(commandDescription.original, \")\"));\n    }\n    return chunk;\n  }\n}, AbstractCommandsQuickAccessProvider_1 = _AbstractCommandsQuickAccessProvider, _AbstractCommandsQuickAccessProvider.PREFIX = '>', _AbstractCommandsQuickAccessProvider.TFIDF_THRESHOLD = 0.5, _AbstractCommandsQuickAccessProvider.TFIDF_MAX_RESULTS = 5, _AbstractCommandsQuickAccessProvider.WORD_FILTER = or(matchesPrefix, matchesWords, matchesContiguousSubString), _AbstractCommandsQuickAccessProvider);\nAbstractCommandsQuickAccessProvider = AbstractCommandsQuickAccessProvider_1 = __decorate([__param(1, IInstantiationService), __param(2, IKeybindingService), __param(3, ICommandService), __param(4, ITelemetryService), __param(5, IDialogService)], AbstractCommandsQuickAccessProvider);\nexport { AbstractCommandsQuickAccessProvider };\nlet CommandsHistory = (_CommandsHistory = class CommandsHistory extends Disposable {\n  constructor(storageService, configurationService, logService) {\n    super();\n    this.storageService = storageService;\n    this.configurationService = configurationService;\n    this.logService = logService;\n    this.configuredCommandsHistoryLength = 0;\n    this.updateConfiguration();\n    this.load();\n    this.registerListeners();\n  }\n  registerListeners() {\n    this._register(this.configurationService.onDidChangeConfiguration(e => this.updateConfiguration(e)));\n    this._register(this.storageService.onWillSaveState(e => {\n      if (e.reason === WillSaveStateReason.SHUTDOWN) {\n        // Commands history is very dynamic and so we limit impact\n        // on storage to only save on shutdown. This helps reduce\n        // the overhead of syncing this data across machines.\n        this.saveState();\n      }\n    }));\n  }\n  updateConfiguration(e) {\n    if (e && !e.affectsConfiguration('workbench.commandPalette.history')) {\n      return;\n    }\n    this.configuredCommandsHistoryLength = CommandsHistory_1.getConfiguredCommandHistoryLength(this.configurationService);\n    if (CommandsHistory_1.cache && CommandsHistory_1.cache.limit !== this.configuredCommandsHistoryLength) {\n      CommandsHistory_1.cache.limit = this.configuredCommandsHistoryLength;\n      CommandsHistory_1.hasChanges = true;\n    }\n  }\n  load() {\n    const raw = this.storageService.get(CommandsHistory_1.PREF_KEY_CACHE, 0 /* StorageScope.PROFILE */);\n    let serializedCache;\n    if (raw) {\n      try {\n        serializedCache = JSON.parse(raw);\n      } catch (error) {\n        this.logService.error(\"[CommandsHistory] invalid data: \".concat(error));\n      }\n    }\n    const cache = CommandsHistory_1.cache = new LRUCache(this.configuredCommandsHistoryLength, 1);\n    if (serializedCache) {\n      let entries;\n      if (serializedCache.usesLRU) {\n        entries = serializedCache.entries;\n      } else {\n        entries = serializedCache.entries.sort((a, b) => a.value - b.value);\n      }\n      entries.forEach(entry => cache.set(entry.key, entry.value));\n    }\n    CommandsHistory_1.counter = this.storageService.getNumber(CommandsHistory_1.PREF_KEY_COUNTER, 0 /* StorageScope.PROFILE */, CommandsHistory_1.counter);\n  }\n  push(commandId) {\n    if (!CommandsHistory_1.cache) {\n      return;\n    }\n    CommandsHistory_1.cache.set(commandId, CommandsHistory_1.counter++); // set counter to command\n    CommandsHistory_1.hasChanges = true;\n  }\n  peek(commandId) {\n    var _CommandsHistory_1$ca;\n    return (_CommandsHistory_1$ca = CommandsHistory_1.cache) === null || _CommandsHistory_1$ca === void 0 ? void 0 : _CommandsHistory_1$ca.peek(commandId);\n  }\n  saveState() {\n    if (!CommandsHistory_1.cache) {\n      return;\n    }\n    if (!CommandsHistory_1.hasChanges) {\n      return;\n    }\n    const serializedCache = {\n      usesLRU: true,\n      entries: []\n    };\n    CommandsHistory_1.cache.forEach((value, key) => serializedCache.entries.push({\n      key,\n      value\n    }));\n    this.storageService.store(CommandsHistory_1.PREF_KEY_CACHE, JSON.stringify(serializedCache), 0 /* StorageScope.PROFILE */, 0 /* StorageTarget.USER */);\n    this.storageService.store(CommandsHistory_1.PREF_KEY_COUNTER, CommandsHistory_1.counter, 0 /* StorageScope.PROFILE */, 0 /* StorageTarget.USER */);\n    CommandsHistory_1.hasChanges = false;\n  }\n  static getConfiguredCommandHistoryLength(configurationService) {\n    var _config$workbench;\n    const config = configurationService.getValue();\n    const configuredCommandHistoryLength = (_config$workbench = config.workbench) === null || _config$workbench === void 0 || (_config$workbench = _config$workbench.commandPalette) === null || _config$workbench === void 0 ? void 0 : _config$workbench.history;\n    if (typeof configuredCommandHistoryLength === 'number') {\n      return configuredCommandHistoryLength;\n    }\n    return CommandsHistory_1.DEFAULT_COMMANDS_HISTORY_LENGTH;\n  }\n}, CommandsHistory_1 = _CommandsHistory, _CommandsHistory.DEFAULT_COMMANDS_HISTORY_LENGTH = 50, _CommandsHistory.PREF_KEY_CACHE = 'commandPalette.mru.cache', _CommandsHistory.PREF_KEY_COUNTER = 'commandPalette.mru.counter', _CommandsHistory.counter = 1, _CommandsHistory.hasChanges = false, _CommandsHistory);\nCommandsHistory = CommandsHistory_1 = __decorate([__param(0, IStorageService), __param(1, IConfigurationService), __param(2, ILogService)], CommandsHistory);\nexport { CommandsHistory };","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","AbstractCommandsQuickAccessProvider_1","CommandsHistory_1","toErrorMessage","isCancellationError","matchesContiguousSubString","matchesPrefix","matchesWords","or","createSingleCallFunction","Disposable","LRUCache","TfIdfCalculator","normalizeTfIdfScores","localize","ICommandService","IConfigurationService","IDialogService","IInstantiationService","IKeybindingService","ILogService","PickerQuickAccessProvider","IStorageService","WillSaveStateReason","ITelemetryService","AbstractCommandsQuickAccessProvider","_AbstractCommandsQuickAccessProvider","constructor","options","instantiationService","keybindingService","commandService","telemetryService","dialogService","PREFIX","commandsHistory","_register","createInstance","CommandsHistory","_getPicks","filter","_disposables","token","runOptions","allCommandPicks","getCommandPicks","isCancellationRequested","runTfidf","tfidf","updateDocuments","map","commandPick","commandId","textChunks","getTfIdfChunk","result","calculateScores","score","TFIDF_THRESHOLD","slice","TFIDF_MAX_RESULTS","filteredCommandPicks","_AbstractCommandsQuic","_AbstractCommandsQuic2","labelHighlights","WORD_FILTER","label","undefined","aliasHighlights","commandAlias","highlights","detail","showAlias","push","tfidfScore","find","tfIdfScore","mapLabelToCommand","Map","existingCommandForLabel","get","description","set","sort","commandPickA","commandPickB","localeCompare","commandACounter","peek","commandBCounter","suggestedCommandIds","commandASuggestion","has","commandBSuggestion","commandPicks","addOtherSeparator","addSuggestedSeparator","addCommonlyUsedSeparator","_this$options$suggest","_this$options$suggest2","type","toCommandPick","hasAdditionalCommandPicks","picks","additionalPicks","_commandPicks$","additionalCommandPicks","getAdditionalCommandPicks","unshift","keybinding","lookupKeybinding","ariaLabel","getAriaLabel","accept","_runOptions$from","publicLog2","id","from","_commandPick$args","args","executeCommand","error","_ref","commandDescription","chunk","concat","value","original","_CommandsHistory","storageService","configurationService","logService","configuredCommandsHistoryLength","updateConfiguration","load","registerListeners","onDidChangeConfiguration","e","onWillSaveState","reason","SHUTDOWN","saveState","affectsConfiguration","getConfiguredCommandHistoryLength","cache","limit","hasChanges","raw","PREF_KEY_CACHE","serializedCache","JSON","parse","entries","usesLRU","a","b","forEach","entry","counter","getNumber","PREF_KEY_COUNTER","_CommandsHistory_1$ca","store","stringify","_config$workbench","config","getValue","configuredCommandHistoryLength","workbench","commandPalette","history","DEFAULT_COMMANDS_HISTORY_LENGTH"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/platform/quickinput/browser/commandsQuickAccess.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar AbstractCommandsQuickAccessProvider_1, CommandsHistory_1;\nimport { toErrorMessage } from '../../../base/common/errorMessage.js';\nimport { isCancellationError } from '../../../base/common/errors.js';\nimport { matchesContiguousSubString, matchesPrefix, matchesWords, or } from '../../../base/common/filters.js';\nimport { createSingleCallFunction } from '../../../base/common/functional.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { LRUCache } from '../../../base/common/map.js';\nimport { TfIdfCalculator, normalizeTfIdfScores } from '../../../base/common/tfIdf.js';\nimport { localize } from '../../../nls.js';\nimport { ICommandService } from '../../commands/common/commands.js';\nimport { IConfigurationService } from '../../configuration/common/configuration.js';\nimport { IDialogService } from '../../dialogs/common/dialogs.js';\nimport { IInstantiationService } from '../../instantiation/common/instantiation.js';\nimport { IKeybindingService } from '../../keybinding/common/keybinding.js';\nimport { ILogService } from '../../log/common/log.js';\nimport { PickerQuickAccessProvider } from './pickerQuickAccess.js';\nimport { IStorageService, WillSaveStateReason } from '../../storage/common/storage.js';\nimport { ITelemetryService } from '../../telemetry/common/telemetry.js';\nlet AbstractCommandsQuickAccessProvider = class AbstractCommandsQuickAccessProvider extends PickerQuickAccessProvider {\n    static { AbstractCommandsQuickAccessProvider_1 = this; }\n    static { this.PREFIX = '>'; }\n    static { this.TFIDF_THRESHOLD = 0.5; }\n    static { this.TFIDF_MAX_RESULTS = 5; }\n    static { this.WORD_FILTER = or(matchesPrefix, matchesWords, matchesContiguousSubString); }\n    constructor(options, instantiationService, keybindingService, commandService, telemetryService, dialogService) {\n        super(AbstractCommandsQuickAccessProvider_1.PREFIX, options);\n        this.instantiationService = instantiationService;\n        this.keybindingService = keybindingService;\n        this.commandService = commandService;\n        this.telemetryService = telemetryService;\n        this.dialogService = dialogService;\n        this.commandsHistory = this._register(this.instantiationService.createInstance(CommandsHistory));\n        this.options = options;\n    }\n    async _getPicks(filter, _disposables, token, runOptions) {\n        // Ask subclass for all command picks\n        const allCommandPicks = await this.getCommandPicks(token);\n        if (token.isCancellationRequested) {\n            return [];\n        }\n        const runTfidf = createSingleCallFunction(() => {\n            const tfidf = new TfIdfCalculator();\n            tfidf.updateDocuments(allCommandPicks.map(commandPick => ({\n                key: commandPick.commandId,\n                textChunks: [this.getTfIdfChunk(commandPick)]\n            })));\n            const result = tfidf.calculateScores(filter, token);\n            return normalizeTfIdfScores(result)\n                .filter(score => score.score > AbstractCommandsQuickAccessProvider_1.TFIDF_THRESHOLD)\n                .slice(0, AbstractCommandsQuickAccessProvider_1.TFIDF_MAX_RESULTS);\n        });\n        // Filter\n        const filteredCommandPicks = [];\n        for (const commandPick of allCommandPicks) {\n            const labelHighlights = AbstractCommandsQuickAccessProvider_1.WORD_FILTER(filter, commandPick.label) ?? undefined;\n            const aliasHighlights = commandPick.commandAlias ? AbstractCommandsQuickAccessProvider_1.WORD_FILTER(filter, commandPick.commandAlias) ?? undefined : undefined;\n            // Add if matching in label or alias\n            if (labelHighlights || aliasHighlights) {\n                commandPick.highlights = {\n                    label: labelHighlights,\n                    detail: this.options.showAlias ? aliasHighlights : undefined\n                };\n                filteredCommandPicks.push(commandPick);\n            }\n            // Also add if we have a 100% command ID match\n            else if (filter === commandPick.commandId) {\n                filteredCommandPicks.push(commandPick);\n            }\n            // Handle tf-idf scoring for the rest if there's a filter\n            else if (filter.length >= 3) {\n                const tfidf = runTfidf();\n                if (token.isCancellationRequested) {\n                    return [];\n                }\n                // Add if we have a tf-idf score\n                const tfidfScore = tfidf.find(score => score.key === commandPick.commandId);\n                if (tfidfScore) {\n                    commandPick.tfIdfScore = tfidfScore.score;\n                    filteredCommandPicks.push(commandPick);\n                }\n            }\n        }\n        // Add description to commands that have duplicate labels\n        const mapLabelToCommand = new Map();\n        for (const commandPick of filteredCommandPicks) {\n            const existingCommandForLabel = mapLabelToCommand.get(commandPick.label);\n            if (existingCommandForLabel) {\n                commandPick.description = commandPick.commandId;\n                existingCommandForLabel.description = existingCommandForLabel.commandId;\n            }\n            else {\n                mapLabelToCommand.set(commandPick.label, commandPick);\n            }\n        }\n        // Sort by MRU order and fallback to name otherwise\n        filteredCommandPicks.sort((commandPickA, commandPickB) => {\n            // If a result came from tf-idf, we want to put that towards the bottom\n            if (commandPickA.tfIdfScore && commandPickB.tfIdfScore) {\n                if (commandPickA.tfIdfScore === commandPickB.tfIdfScore) {\n                    return commandPickA.label.localeCompare(commandPickB.label); // prefer lexicographically smaller command\n                }\n                return commandPickB.tfIdfScore - commandPickA.tfIdfScore; // prefer higher tf-idf score\n            }\n            else if (commandPickA.tfIdfScore) {\n                return 1; // first command has a score but other doesn't so other wins\n            }\n            else if (commandPickB.tfIdfScore) {\n                return -1; // other command has a score but first doesn't so first wins\n            }\n            const commandACounter = this.commandsHistory.peek(commandPickA.commandId);\n            const commandBCounter = this.commandsHistory.peek(commandPickB.commandId);\n            if (commandACounter && commandBCounter) {\n                return commandACounter > commandBCounter ? -1 : 1; // use more recently used command before older\n            }\n            if (commandACounter) {\n                return -1; // first command was used, so it wins over the non used one\n            }\n            if (commandBCounter) {\n                return 1; // other command was used so it wins over the command\n            }\n            if (this.options.suggestedCommandIds) {\n                const commandASuggestion = this.options.suggestedCommandIds.has(commandPickA.commandId);\n                const commandBSuggestion = this.options.suggestedCommandIds.has(commandPickB.commandId);\n                if (commandASuggestion && commandBSuggestion) {\n                    return 0; // honor the order of the array\n                }\n                if (commandASuggestion) {\n                    return -1; // first command was suggested, so it wins over the non suggested one\n                }\n                if (commandBSuggestion) {\n                    return 1; // other command was suggested so it wins over the command\n                }\n            }\n            // both commands were never used, so we sort by name\n            return commandPickA.label.localeCompare(commandPickB.label);\n        });\n        const commandPicks = [];\n        let addOtherSeparator = false;\n        let addSuggestedSeparator = true;\n        let addCommonlyUsedSeparator = !!this.options.suggestedCommandIds;\n        for (let i = 0; i < filteredCommandPicks.length; i++) {\n            const commandPick = filteredCommandPicks[i];\n            // Separator: recently used\n            if (i === 0 && this.commandsHistory.peek(commandPick.commandId)) {\n                commandPicks.push({ type: 'separator', label: localize('recentlyUsed', \"recently used\") });\n                addOtherSeparator = true;\n            }\n            if (addSuggestedSeparator && commandPick.tfIdfScore !== undefined) {\n                commandPicks.push({ type: 'separator', label: localize('suggested', \"similar commands\") });\n                addSuggestedSeparator = false;\n            }\n            // Separator: commonly used\n            if (addCommonlyUsedSeparator && commandPick.tfIdfScore === undefined && !this.commandsHistory.peek(commandPick.commandId) && this.options.suggestedCommandIds?.has(commandPick.commandId)) {\n                commandPicks.push({ type: 'separator', label: localize('commonlyUsed', \"commonly used\") });\n                addOtherSeparator = true;\n                addCommonlyUsedSeparator = false;\n            }\n            // Separator: other commands\n            if (addOtherSeparator && commandPick.tfIdfScore === undefined && !this.commandsHistory.peek(commandPick.commandId) && !this.options.suggestedCommandIds?.has(commandPick.commandId)) {\n                commandPicks.push({ type: 'separator', label: localize('morecCommands', \"other commands\") });\n                addOtherSeparator = false;\n            }\n            // Command\n            commandPicks.push(this.toCommandPick(commandPick, runOptions));\n        }\n        if (!this.hasAdditionalCommandPicks(filter, token)) {\n            return commandPicks;\n        }\n        return {\n            picks: commandPicks,\n            additionalPicks: (async () => {\n                const additionalCommandPicks = await this.getAdditionalCommandPicks(allCommandPicks, filteredCommandPicks, filter, token);\n                if (token.isCancellationRequested) {\n                    return [];\n                }\n                const commandPicks = additionalCommandPicks.map(commandPick => this.toCommandPick(commandPick, runOptions));\n                // Basically, if we haven't already added a separator, we add one before the additional picks so long\n                // as one hasn't been added to the start of the array.\n                if (addSuggestedSeparator && commandPicks[0]?.type !== 'separator') {\n                    commandPicks.unshift({ type: 'separator', label: localize('suggested', \"similar commands\") });\n                }\n                return commandPicks;\n            })()\n        };\n    }\n    toCommandPick(commandPick, runOptions) {\n        if (commandPick.type === 'separator') {\n            return commandPick;\n        }\n        const keybinding = this.keybindingService.lookupKeybinding(commandPick.commandId);\n        const ariaLabel = keybinding ?\n            localize('commandPickAriaLabelWithKeybinding', \"{0}, {1}\", commandPick.label, keybinding.getAriaLabel()) :\n            commandPick.label;\n        return {\n            ...commandPick,\n            ariaLabel,\n            detail: this.options.showAlias && commandPick.commandAlias !== commandPick.label ? commandPick.commandAlias : undefined,\n            keybinding,\n            accept: async () => {\n                // Add to history\n                this.commandsHistory.push(commandPick.commandId);\n                // Telementry\n                this.telemetryService.publicLog2('workbenchActionExecuted', {\n                    id: commandPick.commandId,\n                    from: runOptions?.from ?? 'quick open'\n                });\n                // Run\n                try {\n                    commandPick.args?.length\n                        ? await this.commandService.executeCommand(commandPick.commandId, ...commandPick.args)\n                        : await this.commandService.executeCommand(commandPick.commandId);\n                }\n                catch (error) {\n                    if (!isCancellationError(error)) {\n                        this.dialogService.error(localize('canNotRun', \"Command '{0}' resulted in an error\", commandPick.label), toErrorMessage(error));\n                    }\n                }\n            }\n        };\n    }\n    // TF-IDF string to be indexed\n    getTfIdfChunk({ label, commandAlias, commandDescription }) {\n        let chunk = label;\n        if (commandAlias && commandAlias !== label) {\n            chunk += ` - ${commandAlias}`;\n        }\n        if (commandDescription && commandDescription.value !== label) {\n            // If the original is the same as the value, don't add it\n            chunk += ` - ${commandDescription.value === commandDescription.original ? commandDescription.value : `${commandDescription.value} (${commandDescription.original})`}`;\n        }\n        return chunk;\n    }\n};\nAbstractCommandsQuickAccessProvider = AbstractCommandsQuickAccessProvider_1 = __decorate([\n    __param(1, IInstantiationService),\n    __param(2, IKeybindingService),\n    __param(3, ICommandService),\n    __param(4, ITelemetryService),\n    __param(5, IDialogService)\n], AbstractCommandsQuickAccessProvider);\nexport { AbstractCommandsQuickAccessProvider };\nlet CommandsHistory = class CommandsHistory extends Disposable {\n    static { CommandsHistory_1 = this; }\n    static { this.DEFAULT_COMMANDS_HISTORY_LENGTH = 50; }\n    static { this.PREF_KEY_CACHE = 'commandPalette.mru.cache'; }\n    static { this.PREF_KEY_COUNTER = 'commandPalette.mru.counter'; }\n    static { this.counter = 1; }\n    static { this.hasChanges = false; }\n    constructor(storageService, configurationService, logService) {\n        super();\n        this.storageService = storageService;\n        this.configurationService = configurationService;\n        this.logService = logService;\n        this.configuredCommandsHistoryLength = 0;\n        this.updateConfiguration();\n        this.load();\n        this.registerListeners();\n    }\n    registerListeners() {\n        this._register(this.configurationService.onDidChangeConfiguration(e => this.updateConfiguration(e)));\n        this._register(this.storageService.onWillSaveState(e => {\n            if (e.reason === WillSaveStateReason.SHUTDOWN) {\n                // Commands history is very dynamic and so we limit impact\n                // on storage to only save on shutdown. This helps reduce\n                // the overhead of syncing this data across machines.\n                this.saveState();\n            }\n        }));\n    }\n    updateConfiguration(e) {\n        if (e && !e.affectsConfiguration('workbench.commandPalette.history')) {\n            return;\n        }\n        this.configuredCommandsHistoryLength = CommandsHistory_1.getConfiguredCommandHistoryLength(this.configurationService);\n        if (CommandsHistory_1.cache && CommandsHistory_1.cache.limit !== this.configuredCommandsHistoryLength) {\n            CommandsHistory_1.cache.limit = this.configuredCommandsHistoryLength;\n            CommandsHistory_1.hasChanges = true;\n        }\n    }\n    load() {\n        const raw = this.storageService.get(CommandsHistory_1.PREF_KEY_CACHE, 0 /* StorageScope.PROFILE */);\n        let serializedCache;\n        if (raw) {\n            try {\n                serializedCache = JSON.parse(raw);\n            }\n            catch (error) {\n                this.logService.error(`[CommandsHistory] invalid data: ${error}`);\n            }\n        }\n        const cache = CommandsHistory_1.cache = new LRUCache(this.configuredCommandsHistoryLength, 1);\n        if (serializedCache) {\n            let entries;\n            if (serializedCache.usesLRU) {\n                entries = serializedCache.entries;\n            }\n            else {\n                entries = serializedCache.entries.sort((a, b) => a.value - b.value);\n            }\n            entries.forEach(entry => cache.set(entry.key, entry.value));\n        }\n        CommandsHistory_1.counter = this.storageService.getNumber(CommandsHistory_1.PREF_KEY_COUNTER, 0 /* StorageScope.PROFILE */, CommandsHistory_1.counter);\n    }\n    push(commandId) {\n        if (!CommandsHistory_1.cache) {\n            return;\n        }\n        CommandsHistory_1.cache.set(commandId, CommandsHistory_1.counter++); // set counter to command\n        CommandsHistory_1.hasChanges = true;\n    }\n    peek(commandId) {\n        return CommandsHistory_1.cache?.peek(commandId);\n    }\n    saveState() {\n        if (!CommandsHistory_1.cache) {\n            return;\n        }\n        if (!CommandsHistory_1.hasChanges) {\n            return;\n        }\n        const serializedCache = { usesLRU: true, entries: [] };\n        CommandsHistory_1.cache.forEach((value, key) => serializedCache.entries.push({ key, value }));\n        this.storageService.store(CommandsHistory_1.PREF_KEY_CACHE, JSON.stringify(serializedCache), 0 /* StorageScope.PROFILE */, 0 /* StorageTarget.USER */);\n        this.storageService.store(CommandsHistory_1.PREF_KEY_COUNTER, CommandsHistory_1.counter, 0 /* StorageScope.PROFILE */, 0 /* StorageTarget.USER */);\n        CommandsHistory_1.hasChanges = false;\n    }\n    static getConfiguredCommandHistoryLength(configurationService) {\n        const config = configurationService.getValue();\n        const configuredCommandHistoryLength = config.workbench?.commandPalette?.history;\n        if (typeof configuredCommandHistoryLength === 'number') {\n            return configuredCommandHistoryLength;\n        }\n        return CommandsHistory_1.DEFAULT_COMMANDS_HISTORY_LENGTH;\n    }\n};\nCommandsHistory = CommandsHistory_1 = __decorate([\n    __param(0, IStorageService),\n    __param(1, IConfigurationService),\n    __param(2, ILogService)\n], CommandsHistory);\nexport { CommandsHistory };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}