{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { NODETYPE } from './Constants';\n/**\n * Returns the text content of the specified node.\n *\n * @param elems DOM nodes to return the text for.\n */\nexport const extractTextWithWhitespace = elems => {\n  // Known block elements for handling linefeeds (list is not complete)\n  const blocks = ['BLOCKQUOTE', 'DIV', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'OL', 'P', 'PRE', 'TABLE', 'UL'];\n  const ret = [];\n  function doExtract(elts) {\n    // Single break should be ignored\n    if (elts.length == 1 && (elts[0].nodeName == 'BR' || elts[0].innerHTML == '\\n')) {\n      return;\n    }\n    for (let i = 0; i < elts.length; i += 1) {\n      const elem = elts[i];\n      // DIV with a br or linefeed forces a linefeed\n      if (elem.nodeName == 'BR' || elem.innerHTML == '\\n' || (elts.length == 1 || i == 0) && elem.nodeName == 'DIV' && elem.innerHTML.toLowerCase() == '<br>') {\n        ret.push('\\n');\n      } else {\n        if (elem.nodeType === 3 || elem.nodeType === 4) {\n          if (elem.nodeValue && elem.nodeValue.length > 0) {\n            ret.push(elem.nodeValue);\n          }\n        } else if (elem.nodeType !== 8 && elem.childNodes.length > 0) {\n          doExtract(Array.from(elem.childNodes));\n        }\n        if (i < elts.length - 1 && blocks.indexOf(elts[i + 1].nodeName) >= 0) {\n          ret.push('\\n');\n        }\n      }\n    }\n  }\n  doExtract(elems);\n  return ret.join('');\n};\n/**\n * Returns the text content of the specified node.\n *\n * @param node DOM node to return the text content for.\n */\nexport const getTextContent = node => {\n  return node != null && node.textContent ? node.textContent : '';\n};\n/**\n * Sets the text content of the specified node.\n *\n * @param node DOM node to set the text content for.\n * @param text String that represents the text content.\n */\nexport const setTextContent = (node, text) => {\n  if ('innerText' in node) {\n    node.innerText = text;\n  } else {\n    node.textContent = text;\n  }\n};\n/**\n * Returns the inner HTML for the given node as a string or an empty string\n * if no node was specified. The inner HTML is the text representing all\n * children of the node, but not the node itself.\n *\n * @param node DOM node to return the inner HTML for.\n */\nexport const getInnerHtml = node => {\n  if (node != null) {\n    const serializer = new XMLSerializer();\n    return serializer.serializeToString(node);\n  }\n  return '';\n};\n/**\n * Returns the outer HTML for the given node as a string or an empty\n * string if no node was specified. The outer HTML is the text representing\n * all children of the node including the node itself.\n *\n * @param node DOM node to return the outer HTML for.\n */\nexport const getOuterHtml = node => {\n  if (node != null) {\n    const serializer = new XMLSerializer();\n    return serializer.serializeToString(node);\n  }\n  return '';\n};\n/**\n * Creates a text node for the given string and appends it to the given\n * parent. Returns the text node.\n *\n * @param parent DOM node to append the text node to.\n * @param text String representing the text to be added.\n */\nexport const write = (parent, text) => {\n  const doc = parent.ownerDocument;\n  const node = doc.createTextNode(text);\n  if (parent != null) {\n    parent.appendChild(node);\n  }\n  return node;\n};\n/**\n * Creates a text node for the given string and appends it to the given\n * parent with an additional linefeed. Returns the text node.\n *\n * @param parent DOM node to append the text node to.\n * @param text String representing the text to be added.\n */\nexport const writeln = (parent, text) => {\n  const doc = parent.ownerDocument;\n  const node = doc.createTextNode(text);\n  if (parent != null) {\n    parent.appendChild(node);\n    parent.appendChild(document.createElement('br'));\n  }\n  return node;\n};\n/**\n * Appends a linebreak to the given parent and returns the linebreak.\n *\n * @param parent DOM node to append the linebreak to.\n */\nexport const br = (parent, count = 1) => {\n  let br = null;\n  for (let i = 0; i < count; i += 1) {\n    if (parent != null) {\n      br = parent.ownerDocument.createElement('br');\n      parent.appendChild(br);\n    }\n  }\n  return br;\n};\n/**\n * Appends a new paragraph with the given text to the specified parent and\n * returns the paragraph.\n *\n * @param parent DOM node to append the text node to.\n * @param text String representing the text for the new paragraph.\n */\nexport const para = (parent, text) => {\n  const p = document.createElement('p');\n  write(p, text);\n  if (parent != null) {\n    parent.appendChild(p);\n  }\n  return p;\n};\n/**\n * Returns true if the given value is an XML node with the node name\n * and if the optional attribute has the specified value.\n *\n * This implementation assumes that the given value is a DOM node if the\n * nodeType property is numeric, that is, if isNaN returns false for\n * value.nodeType.\n *\n * @param value Object that should be examined as a node.\n * @param nodeName String that specifies the node name.\n * @param attributeName Optional attribute name to check.\n * @param attributeValue Optional attribute value to check.\n */\nexport const isNode = (value, nodeName = null, attributeName, attributeValue) => {\n  if (value != null && !isNaN(value.nodeType) && (nodeName == null || value.nodeName.toLowerCase() == nodeName.toLowerCase())) {\n    return attributeName == null || value.getAttribute(attributeName) == attributeValue;\n  }\n  return false;\n};\n/**\n * Returns true if the given ancestor is an ancestor of the\n * given DOM node in the DOM. This also returns true if the\n * child is the ancestor.\n *\n * @param ancestor DOM node that represents the ancestor.\n * @param child DOM node that represents the child.\n */\nexport const isAncestorNode = (ancestor, child) => {\n  let parent = child;\n  while (parent != null) {\n    if (parent === ancestor) {\n      return true;\n    }\n    parent = parent.parentNode;\n  }\n  return false;\n};\n/**\n * Returns an array of child nodes that are of the given node type.\n *\n * @param node Parent DOM node to return the children from.\n * @param nodeType Optional node type to return. Default is\n * {@link Constants#NODETYPE_ELEMENT}.\n */\nexport const getChildNodes = (node, nodeType = NODETYPE.ELEMENT) => {\n  nodeType = nodeType || NODETYPE.ELEMENT;\n  const children = [];\n  let tmp = node.firstChild;\n  while (tmp != null) {\n    if (tmp.nodeType === nodeType) {\n      children.push(tmp);\n    }\n    tmp = tmp.nextSibling;\n  }\n  return children;\n};\n/**\n * Cross browser implementation for document.importNode. Uses document.importNode\n * in all browsers but IE, where the node is cloned by creating a new node and\n * copying all attributes and children into it using importNode, recursively.\n *\n * @param doc Document to import the node into.\n * @param node Node to be imported.\n * @param allChildren If all children should be imported.\n */\nexport const importNode = (doc, node, allChildren) => {\n  return doc.importNode(node, allChildren);\n};\n/**\n * Full DOM API implementation for importNode without using importNode API call.\n *\n * @param doc Document to import the node into.\n * @param node Node to be imported.\n * @param allChildren If all children should be imported.\n */\nexport const importNodeImplementation = (doc, node, allChildren) => {\n  switch (node.nodeType) {\n    case 1 /* element */:\n      {\n        const newNode = doc.createElement(node.nodeName);\n        if (node.attributes && node.attributes.length > 0) {\n          for (let i = 0; i < node.attributes.length; i += 1) {\n            newNode.setAttribute(node.attributes[i].nodeName, node.getAttribute(node.attributes[i].nodeName));\n          }\n        }\n        if (allChildren && node.childNodes && node.childNodes.length > 0) {\n          for (let i = 0; i < node.childNodes.length; i += 1) {\n            newNode.appendChild(importNodeImplementation(doc, node.childNodes[i], allChildren));\n          }\n        }\n        return newNode;\n        break;\n      }\n    case 3: /* text */\n    case 4: /* cdata-section */\n    case 8 /* comment */:\n      {\n        return doc.createTextNode(node.nodeValue || '');\n        break;\n      }\n  }\n};\n/**\n * Clears the current selection in the page.\n */\nexport const clearSelection = () => {\n  // @ts-ignore\n  const sel = window.getSelection ? window.getSelection() : document.selection;\n  if (sel) {\n    if (sel.removeAllRanges) {\n      sel.removeAllRanges();\n    } else if (sel.empty) {\n      sel.empty();\n    }\n  }\n};\n/**\n * Creates and returns an image (IMG node) or VML image (v:image) in IE6 in\n * quirks mode.\n *\n * @param src URL that points to the image to be displayed.\n */\nexport const createImage = src => {\n  let imageNode = null;\n  imageNode = document.createElement('img');\n  imageNode.setAttribute('src', src);\n  imageNode.setAttribute('border', '0');\n  return imageNode;\n};\n/**\n * Adds a link node to the head of the document.\n *\n * The charset is hardcoded to `UTF-8` and the type is `text/css`.\n *\n * @param rel String that represents the rel attribute of the link node.\n * @param href String that represents the href attribute of the link node.\n * @param doc Optional parent document of the link node.\n * @param id unique id for the link element to check if it already exists\n */\nexport const addLinkToHead = (rel, href, doc = null, id = null) => {\n  doc = doc || document;\n  // Workaround for Operation Aborted in IE6 if base tag is used in head\n  const link = doc.createElement('link');\n  link.setAttribute('rel', rel);\n  link.setAttribute('href', href);\n  link.setAttribute('charset', 'UTF-8');\n  link.setAttribute('type', 'text/css');\n  if (id) {\n    link.setAttribute('id', id);\n  }\n  const head = doc.getElementsByTagName('head')[0];\n  head.appendChild(link);\n};","map":{"version":3,"names":["NODETYPE","extractTextWithWhitespace","elems","blocks","ret","doExtract","elts","length","nodeName","innerHTML","i","elem","toLowerCase","push","nodeType","nodeValue","childNodes","Array","from","indexOf","join","getTextContent","node","textContent","setTextContent","text","innerText","getInnerHtml","serializer","XMLSerializer","serializeToString","getOuterHtml","write","parent","doc","ownerDocument","createTextNode","appendChild","writeln","document","createElement","br","count","para","p","isNode","value","attributeName","attributeValue","isNaN","getAttribute","isAncestorNode","ancestor","child","parentNode","getChildNodes","ELEMENT","children","tmp","firstChild","nextSibling","importNode","allChildren","importNodeImplementation","newNode","attributes","setAttribute","clearSelection","sel","window","getSelection","selection","removeAllRanges","empty","createImage","src","imageNode","addLinkToHead","rel","href","id","link","head","getElementsByTagName"],"sources":["D:/OSPanel/domains/old/react/react-intro-main/node_modules/@maxgraph/core/dist/util/domUtils.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { NODETYPE } from './Constants';\n/**\n * Returns the text content of the specified node.\n *\n * @param elems DOM nodes to return the text for.\n */\nexport const extractTextWithWhitespace = (elems) => {\n    // Known block elements for handling linefeeds (list is not complete)\n    const blocks = [\n        'BLOCKQUOTE',\n        'DIV',\n        'H1',\n        'H2',\n        'H3',\n        'H4',\n        'H5',\n        'H6',\n        'OL',\n        'P',\n        'PRE',\n        'TABLE',\n        'UL',\n    ];\n    const ret = [];\n    function doExtract(elts) {\n        // Single break should be ignored\n        if (elts.length == 1 && (elts[0].nodeName == 'BR' || elts[0].innerHTML == '\\n')) {\n            return;\n        }\n        for (let i = 0; i < elts.length; i += 1) {\n            const elem = elts[i];\n            // DIV with a br or linefeed forces a linefeed\n            if (elem.nodeName == 'BR' ||\n                elem.innerHTML == '\\n' ||\n                ((elts.length == 1 || i == 0) &&\n                    elem.nodeName == 'DIV' &&\n                    elem.innerHTML.toLowerCase() == '<br>')) {\n                ret.push('\\n');\n            }\n            else {\n                if (elem.nodeType === 3 || elem.nodeType === 4) {\n                    if (elem.nodeValue && elem.nodeValue.length > 0) {\n                        ret.push(elem.nodeValue);\n                    }\n                }\n                else if (elem.nodeType !== 8 && elem.childNodes.length > 0) {\n                    doExtract(Array.from(elem.childNodes));\n                }\n                if (i < elts.length - 1 && blocks.indexOf(elts[i + 1].nodeName) >= 0) {\n                    ret.push('\\n');\n                }\n            }\n        }\n    }\n    doExtract(elems);\n    return ret.join('');\n};\n/**\n * Returns the text content of the specified node.\n *\n * @param node DOM node to return the text content for.\n */\nexport const getTextContent = (node) => {\n    return node != null && node.textContent ? node.textContent : '';\n};\n/**\n * Sets the text content of the specified node.\n *\n * @param node DOM node to set the text content for.\n * @param text String that represents the text content.\n */\nexport const setTextContent = (node, text) => {\n    if ('innerText' in node) {\n        node.innerText = text;\n    }\n    else {\n        node.textContent = text;\n    }\n};\n/**\n * Returns the inner HTML for the given node as a string or an empty string\n * if no node was specified. The inner HTML is the text representing all\n * children of the node, but not the node itself.\n *\n * @param node DOM node to return the inner HTML for.\n */\nexport const getInnerHtml = (node) => {\n    if (node != null) {\n        const serializer = new XMLSerializer();\n        return serializer.serializeToString(node);\n    }\n    return '';\n};\n/**\n * Returns the outer HTML for the given node as a string or an empty\n * string if no node was specified. The outer HTML is the text representing\n * all children of the node including the node itself.\n *\n * @param node DOM node to return the outer HTML for.\n */\nexport const getOuterHtml = (node) => {\n    if (node != null) {\n        const serializer = new XMLSerializer();\n        return serializer.serializeToString(node);\n    }\n    return '';\n};\n/**\n * Creates a text node for the given string and appends it to the given\n * parent. Returns the text node.\n *\n * @param parent DOM node to append the text node to.\n * @param text String representing the text to be added.\n */\nexport const write = (parent, text) => {\n    const doc = parent.ownerDocument;\n    const node = doc.createTextNode(text);\n    if (parent != null) {\n        parent.appendChild(node);\n    }\n    return node;\n};\n/**\n * Creates a text node for the given string and appends it to the given\n * parent with an additional linefeed. Returns the text node.\n *\n * @param parent DOM node to append the text node to.\n * @param text String representing the text to be added.\n */\nexport const writeln = (parent, text) => {\n    const doc = parent.ownerDocument;\n    const node = doc.createTextNode(text);\n    if (parent != null) {\n        parent.appendChild(node);\n        parent.appendChild(document.createElement('br'));\n    }\n    return node;\n};\n/**\n * Appends a linebreak to the given parent and returns the linebreak.\n *\n * @param parent DOM node to append the linebreak to.\n */\nexport const br = (parent, count = 1) => {\n    let br = null;\n    for (let i = 0; i < count; i += 1) {\n        if (parent != null) {\n            br = parent.ownerDocument.createElement('br');\n            parent.appendChild(br);\n        }\n    }\n    return br;\n};\n/**\n * Appends a new paragraph with the given text to the specified parent and\n * returns the paragraph.\n *\n * @param parent DOM node to append the text node to.\n * @param text String representing the text for the new paragraph.\n */\nexport const para = (parent, text) => {\n    const p = document.createElement('p');\n    write(p, text);\n    if (parent != null) {\n        parent.appendChild(p);\n    }\n    return p;\n};\n/**\n * Returns true if the given value is an XML node with the node name\n * and if the optional attribute has the specified value.\n *\n * This implementation assumes that the given value is a DOM node if the\n * nodeType property is numeric, that is, if isNaN returns false for\n * value.nodeType.\n *\n * @param value Object that should be examined as a node.\n * @param nodeName String that specifies the node name.\n * @param attributeName Optional attribute name to check.\n * @param attributeValue Optional attribute value to check.\n */\nexport const isNode = (value, nodeName = null, attributeName, attributeValue) => {\n    if (value != null &&\n        !isNaN(value.nodeType) &&\n        (nodeName == null || value.nodeName.toLowerCase() == nodeName.toLowerCase())) {\n        return attributeName == null || value.getAttribute(attributeName) == attributeValue;\n    }\n    return false;\n};\n/**\n * Returns true if the given ancestor is an ancestor of the\n * given DOM node in the DOM. This also returns true if the\n * child is the ancestor.\n *\n * @param ancestor DOM node that represents the ancestor.\n * @param child DOM node that represents the child.\n */\nexport const isAncestorNode = (ancestor, child) => {\n    let parent = child;\n    while (parent != null) {\n        if (parent === ancestor) {\n            return true;\n        }\n        parent = parent.parentNode;\n    }\n    return false;\n};\n/**\n * Returns an array of child nodes that are of the given node type.\n *\n * @param node Parent DOM node to return the children from.\n * @param nodeType Optional node type to return. Default is\n * {@link Constants#NODETYPE_ELEMENT}.\n */\nexport const getChildNodes = (node, nodeType = NODETYPE.ELEMENT) => {\n    nodeType = nodeType || NODETYPE.ELEMENT;\n    const children = [];\n    let tmp = node.firstChild;\n    while (tmp != null) {\n        if (tmp.nodeType === nodeType) {\n            children.push(tmp);\n        }\n        tmp = tmp.nextSibling;\n    }\n    return children;\n};\n/**\n * Cross browser implementation for document.importNode. Uses document.importNode\n * in all browsers but IE, where the node is cloned by creating a new node and\n * copying all attributes and children into it using importNode, recursively.\n *\n * @param doc Document to import the node into.\n * @param node Node to be imported.\n * @param allChildren If all children should be imported.\n */\nexport const importNode = (doc, node, allChildren) => {\n    return doc.importNode(node, allChildren);\n};\n/**\n * Full DOM API implementation for importNode without using importNode API call.\n *\n * @param doc Document to import the node into.\n * @param node Node to be imported.\n * @param allChildren If all children should be imported.\n */\nexport const importNodeImplementation = (doc, node, allChildren) => {\n    switch (node.nodeType) {\n        case 1 /* element */: {\n            const newNode = doc.createElement(node.nodeName);\n            if (node.attributes && node.attributes.length > 0) {\n                for (let i = 0; i < node.attributes.length; i += 1) {\n                    newNode.setAttribute(node.attributes[i].nodeName, node.getAttribute(node.attributes[i].nodeName));\n                }\n            }\n            if (allChildren && node.childNodes && node.childNodes.length > 0) {\n                for (let i = 0; i < node.childNodes.length; i += 1) {\n                    newNode.appendChild(importNodeImplementation(doc, node.childNodes[i], allChildren));\n                }\n            }\n            return newNode;\n            break;\n        }\n        case 3: /* text */\n        case 4: /* cdata-section */\n        case 8 /* comment */: {\n            return doc.createTextNode(node.nodeValue || '');\n            break;\n        }\n    }\n};\n/**\n * Clears the current selection in the page.\n */\nexport const clearSelection = () => {\n    // @ts-ignore\n    const sel = window.getSelection ? window.getSelection() : document.selection;\n    if (sel) {\n        if (sel.removeAllRanges) {\n            sel.removeAllRanges();\n        }\n        else if (sel.empty) {\n            sel.empty();\n        }\n    }\n};\n/**\n * Creates and returns an image (IMG node) or VML image (v:image) in IE6 in\n * quirks mode.\n *\n * @param src URL that points to the image to be displayed.\n */\nexport const createImage = (src) => {\n    let imageNode = null;\n    imageNode = document.createElement('img');\n    imageNode.setAttribute('src', src);\n    imageNode.setAttribute('border', '0');\n    return imageNode;\n};\n/**\n * Adds a link node to the head of the document.\n *\n * The charset is hardcoded to `UTF-8` and the type is `text/css`.\n *\n * @param rel String that represents the rel attribute of the link node.\n * @param href String that represents the href attribute of the link node.\n * @param doc Optional parent document of the link node.\n * @param id unique id for the link element to check if it already exists\n */\nexport const addLinkToHead = (rel, href, doc = null, id = null) => {\n    doc = doc || document;\n    // Workaround for Operation Aborted in IE6 if base tag is used in head\n    const link = doc.createElement('link');\n    link.setAttribute('rel', rel);\n    link.setAttribute('href', href);\n    link.setAttribute('charset', 'UTF-8');\n    link.setAttribute('type', 'text/css');\n    if (id) {\n        link.setAttribute('id', id);\n    }\n    const head = doc.getElementsByTagName('head')[0];\n    head.appendChild(link);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}