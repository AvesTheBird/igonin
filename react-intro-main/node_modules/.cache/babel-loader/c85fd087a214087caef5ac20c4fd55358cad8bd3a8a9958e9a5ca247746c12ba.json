{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from './Point';\nimport Rectangle from './Rectangle';\nimport { getRotatedPoint, toRadians } from '../../util/mathUtils';\nimport { equalPoints } from '../../util/arrayUtils';\nimport { clone } from '../../util/cloneUtils';\n/**\n * @class Geometry\n *\n * @extends {Rectangle}\n *\n * For vertices, the geometry consists of the x- and y-location, and the width\n * and height. For edges, the geometry consists of the optional terminal- and\n * control points. The terminal points are only required if an edge is\n * unconnected, and are stored in the {@link sourcePoint} and {@link targetPoint}\n * variables, respectively.\n *\n * ### Example\n *\n * If an edge is unconnected, that is, it has no source or target terminal,\n * then a geometry with terminal points for a new edge can be defined as\n * follows.\n *\n * ```javascript\n * geometry.setTerminalPoint(new mxPoint(x1, y1), true);\n * geometry.points: [new mxPoint(x2, y2)];\n * geometry.setTerminalPoint(new mxPoint(x3, y3), false);\n * ```\n *\n * Control points are used regardless of the connected state of an edge and may\n * be ignored or interpreted differently depending on the edge's {@link edgeStyle}.\n *\n * To disable automatic reset of control points after a cell has been moved or\n * resized, the the {@link graph.resizeEdgesOnMove} and\n * {@link graph.resetEdgesOnResize} may be used.\n *\n * ### Edge Labels\n *\n * Using the x- and y-coordinates of a cell's geometry, it is possible to\n * position the label on edges on a specific location on the actual edge shape\n * as it appears on the screen. The x-coordinate of an edge's geometry is used\n * to describe the distance from the center of the edge from -1 to 1 with 0\n * being the center of the edge and the default value. The y-coordinate of an\n * edge's geometry is used to describe the absolute, orthogonal distance in\n * pixels from that point. In addition, the {@link Geometry.offset} is used as an\n * absolute offset vector from the resulting point.\n *\n * This coordinate system is applied if {@link relative} is true, otherwise the\n * offset defines the absolute vector from the edge's center point to the\n * label and the values for {@link x} and {@link y} are ignored.\n *\n * The width and height parameter for edge geometries can be used to set the\n * label width and height (eg. for word wrapping).\n *\n * ### Ports\n *\n * The term \"port\" refers to a relatively positioned, connectable child cell,\n * which is used to specify the connection between the parent and another cell\n * in the graph. Ports are typically modeled as vertices with relative\n * geometries.\n *\n * ### Offsets\n *\n * The {@link offset} field is interpreted in 3 different ways, depending on the cell\n * and the geometry. For edges, the offset defines the absolute offset for the\n * edge label. For relative geometries, the offset defines the absolute offset\n * for the origin (top, left corner) of the vertex, otherwise the offset\n * defines the absolute offset for the label inside the vertex or group.\n */\nclass Geometry extends Rectangle {\n  constructor() {\n    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    super(x, y, width, height);\n    /**\n     * Global switch to translate the points in translate. Default is true.\n     */\n    this.TRANSLATE_CONTROL_POINTS = true;\n    /**\n     * Stores alternate values for x, y, width and height in a rectangle.\n     * See {@link swap} to exchange the values. Default is null.\n     *\n     * @see {@link swap}\n     */\n    this.alternateBounds = null;\n    /**\n     * Defines the source {@link Point} of the edge. This is used if the\n     * corresponding edge does not have a source vertex. Otherwise it is\n     * ignored. Default is  null.\n     */\n    this.sourcePoint = null;\n    /**\n     * Defines the target {@link Point} of the edge. This is used if the\n     * corresponding edge does not have a target vertex. Otherwise it is\n     * ignored. Default is null.\n     */\n    this.targetPoint = null;\n    /**\n     * Array of {@link Point} which specifies the control points along the edge.\n     * These points are the intermediate points on the edge, for the endpoints\n     * use {@link targetPoint} and {@link sourcePoint} or set the terminals of the edge to\n     * a non-null value. Default is null.\n     */\n    this.points = null;\n    /**\n     * For edges, this holds the offset (in pixels) from the position defined\n     * by {@link x} and {@link y} on the edge. For relative geometries (for vertices), this\n     * defines the absolute offset from the point defined by the relative\n     * coordinates. For absolute geometries (for vertices), this defines the\n     * offset for the label. Default is null.\n     */\n    this.offset = null;\n    /**\n     * Specifies if the coordinates in the geometry are to be interpreted as\n     * relative coordinates. For edges, this is used to define the location of\n     * the edge label relative to the edge as rendered on the display. For\n     * vertices, this specifies the relative location inside the bounds of the\n     * parent cell.\n     *\n     * If this is false, then the coordinates are relative to the origin of the\n     * parent cell or, for edges, the edge label position is relative to the\n     * center of the edge as rendered on screen.\n     *\n     * Default is false.\n     */\n    this.relative = false;\n  }\n  setRelative(isRelative) {\n    this.relative = isRelative;\n  }\n  /**\n   * Swaps the x, y, width and height with the values stored in\n   * {@link alternateBounds} and puts the previous values into {@link alternateBounds} as\n   * a rectangle. This operation is carried-out in-place, that is, using the\n   * existing geometry instance. If this operation is called during a graph\n   * model transactional change, then the geometry should be cloned before\n   * calling this method and setting the geometry of the cell using\n   * {@link mxGraphModel.setGeometry}.\n   */\n  swap() {\n    if (this.alternateBounds) {\n      const old = new Rectangle(this.x, this.y, this.width, this.height);\n      this.x = this.alternateBounds.x;\n      this.y = this.alternateBounds.y;\n      this.width = this.alternateBounds.width;\n      this.height = this.alternateBounds.height;\n      this.alternateBounds = old;\n    }\n  }\n  /**\n   * Returns the {@link Point} representing the source or target point of this\n   * edge. This is only used if the edge has no source or target vertex.\n   *\n   * @param {Boolean} isSource that specifies if the source or target point should be returned.\n   */\n  getTerminalPoint(isSource) {\n    return isSource ? this.sourcePoint : this.targetPoint;\n  }\n  /**\n   * Sets the {@link sourcePoint} or {@link targetPoint} to the given {@link Point} and\n   * returns the new point.\n   *\n   * @param {Point} point to be used as the new source or target point.\n   * @param {Boolean} isSource that specifies if the source or target point should be set.\n   */\n  setTerminalPoint(point, isSource) {\n    if (isSource) {\n      this.sourcePoint = point;\n    } else {\n      this.targetPoint = point;\n    }\n    return point;\n  }\n  /**\n   * Rotates the geometry by the given angle around the given center. That is,\n   * {@link x} and {@link y} of the geometry, the {@link sourcePoint}, {@link targetPoint} and all\n   * {@link points} are translated by the given amount. {@link x} and {@link y} are only\n   * translated if {@link relative} is false.\n   *\n   * @param {Number} angle that specifies the rotation angle in degrees.\n   * @param {Point} cx   that specifies the center of the rotation.\n   */\n  rotate(angle, cx) {\n    const rad = toRadians(angle);\n    const cos = Math.cos(rad);\n    const sin = Math.sin(rad);\n    // Rotates the geometry\n    if (!this.relative) {\n      const ct = new Point(this.getCenterX(), this.getCenterY());\n      const pt = getRotatedPoint(ct, cos, sin, cx);\n      this.x = Math.round(pt.x - this.width / 2);\n      this.y = Math.round(pt.y - this.height / 2);\n    }\n    // Rotates the source point\n    if (this.sourcePoint) {\n      const pt = getRotatedPoint(this.sourcePoint, cos, sin, cx);\n      this.sourcePoint.x = Math.round(pt.x);\n      this.sourcePoint.y = Math.round(pt.y);\n    }\n    // Translates the target point\n    if (this.targetPoint) {\n      const pt = getRotatedPoint(this.targetPoint, cos, sin, cx);\n      this.targetPoint.x = Math.round(pt.x);\n      this.targetPoint.y = Math.round(pt.y);\n    }\n    // Translate the control points\n    if (this.points) {\n      for (let i = 0; i < this.points.length; i += 1) {\n        if (this.points[i]) {\n          const pt = getRotatedPoint(this.points[i], cos, sin, cx);\n          this.points[i].x = Math.round(pt.x);\n          this.points[i].y = Math.round(pt.y);\n        }\n      }\n    }\n  }\n  /**\n   * Translates the geometry by the specified amount. That is, {@link x} and {@link y} of the\n   * geometry, the {@link sourcePoint}, {@link targetPoint} and all {@link points} are translated\n   * by the given amount. {@link x} and {@link y} are only translated if {@link relative} is false.\n   * If {@link TRANSLATE_CONTROL_POINTS} is false, then {@link points} are not modified by\n   * this function.\n   *\n   * @param {Number} dx that specifies the x-coordinate of the translation.\n   * @param {Number} dy that specifies the y-coordinate of the translation.\n   */\n  translate(dx, dy) {\n    // Translates the geometry\n    if (!this.relative) {\n      this.x += dx;\n      this.y += dy;\n    }\n    // Translates the source point\n    if (this.sourcePoint) {\n      this.sourcePoint.x = this.sourcePoint.x + dx;\n      this.sourcePoint.y = this.sourcePoint.y + dy;\n    }\n    // Translates the target point\n    if (this.targetPoint) {\n      this.targetPoint.x = this.targetPoint.x + dx;\n      this.targetPoint.y = this.targetPoint.y + dy;\n    }\n    // Translate the control points\n    if (this.TRANSLATE_CONTROL_POINTS && this.points) {\n      for (let i = 0; i < this.points.length; i += 1) {\n        if (this.points[i]) {\n          this.points[i].x = this.points[i].x + dx;\n          this.points[i].y = this.points[i].y + dy;\n        }\n      }\n    }\n  }\n  /**\n   * Scales the geometry by the given amount. That is, {@link x} and {@link y} of the\n   * geometry, the {@link sourcePoint}, {@link targetPoint} and all {@link points} are scaled\n   * by the given amount. {@link x}, {@link y}, {@link width} and {@link height} are only scaled if\n   * {@link relative} is false. If {@link fixedAspect} is true, then the smaller value\n   * is used to scale the width and the height.\n   *\n   * @param {Number} sx that specifies the horizontal scale factor.\n   * @param {Number} sy that specifies the vertical scale factor.\n   * @param {Optional} fixedAspect boolean to keep the aspect ratio fixed.\n   */\n  scale(sx, sy, fixedAspect) {\n    // Translates the source point\n    if (this.sourcePoint) {\n      this.sourcePoint.x = this.sourcePoint.x * sx;\n      this.sourcePoint.y = this.sourcePoint.y * sy;\n    }\n    // Translates the target point\n    if (this.targetPoint) {\n      this.targetPoint.x = this.targetPoint.x * sx;\n      this.targetPoint.y = this.targetPoint.y * sy;\n    }\n    // Translate the control points\n    if (this.points) {\n      for (let i = 0; i < this.points.length; i += 1) {\n        if (this.points[i]) {\n          this.points[i].x = this.points[i].x * sx;\n          this.points[i].y = this.points[i].y * sy;\n        }\n      }\n    }\n    // Translates the geometry\n    if (!this.relative) {\n      this.x *= sx;\n      this.y *= sy;\n      if (fixedAspect) {\n        sy = sx = Math.min(sx, sy);\n      }\n      this.width *= sx;\n      this.height *= sy;\n    }\n  }\n  /**\n   * Returns true if the given object equals this geometry.\n   */\n  equals(geom) {\n    var _this$sourcePoint, _this$targetPoint, _this$alternateBounds, _this$offset;\n    if (!geom) return false;\n    return super.equals(geom) && this.relative === geom.relative && (this.sourcePoint === null && geom.sourcePoint === null || !!((_this$sourcePoint = this.sourcePoint) !== null && _this$sourcePoint !== void 0 && _this$sourcePoint.equals(geom.sourcePoint))) && (this.targetPoint === null && geom.targetPoint === null || !!((_this$targetPoint = this.targetPoint) !== null && _this$targetPoint !== void 0 && _this$targetPoint.equals(geom.targetPoint))) && equalPoints(this.points, geom.points) && (this.alternateBounds === null && geom.alternateBounds === null || !!((_this$alternateBounds = this.alternateBounds) !== null && _this$alternateBounds !== void 0 && _this$alternateBounds.equals(geom.alternateBounds))) && (this.offset === null && geom.offset === null || !!((_this$offset = this.offset) !== null && _this$offset !== void 0 && _this$offset.equals(geom.offset)));\n  }\n  clone() {\n    return clone(this);\n  }\n}\nexport default Geometry;","map":{"version":3,"names":["Point","Rectangle","getRotatedPoint","toRadians","equalPoints","clone","Geometry","constructor","x","arguments","length","undefined","y","width","height","TRANSLATE_CONTROL_POINTS","alternateBounds","sourcePoint","targetPoint","points","offset","relative","setRelative","isRelative","swap","old","getTerminalPoint","isSource","setTerminalPoint","point","rotate","angle","cx","rad","cos","Math","sin","ct","getCenterX","getCenterY","pt","round","i","translate","dx","dy","scale","sx","sy","fixedAspect","min","equals","geom","_this$sourcePoint","_this$targetPoint","_this$alternateBounds","_this$offset"],"sources":["D:/ospanel/domains/react/react-intro/node_modules/@maxgraph/core/dist/view/geometry/Geometry.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from './Point';\nimport Rectangle from './Rectangle';\nimport { getRotatedPoint, toRadians } from '../../util/mathUtils';\nimport { equalPoints } from '../../util/arrayUtils';\nimport { clone } from '../../util/cloneUtils';\n/**\n * @class Geometry\n *\n * @extends {Rectangle}\n *\n * For vertices, the geometry consists of the x- and y-location, and the width\n * and height. For edges, the geometry consists of the optional terminal- and\n * control points. The terminal points are only required if an edge is\n * unconnected, and are stored in the {@link sourcePoint} and {@link targetPoint}\n * variables, respectively.\n *\n * ### Example\n *\n * If an edge is unconnected, that is, it has no source or target terminal,\n * then a geometry with terminal points for a new edge can be defined as\n * follows.\n *\n * ```javascript\n * geometry.setTerminalPoint(new mxPoint(x1, y1), true);\n * geometry.points: [new mxPoint(x2, y2)];\n * geometry.setTerminalPoint(new mxPoint(x3, y3), false);\n * ```\n *\n * Control points are used regardless of the connected state of an edge and may\n * be ignored or interpreted differently depending on the edge's {@link edgeStyle}.\n *\n * To disable automatic reset of control points after a cell has been moved or\n * resized, the the {@link graph.resizeEdgesOnMove} and\n * {@link graph.resetEdgesOnResize} may be used.\n *\n * ### Edge Labels\n *\n * Using the x- and y-coordinates of a cell's geometry, it is possible to\n * position the label on edges on a specific location on the actual edge shape\n * as it appears on the screen. The x-coordinate of an edge's geometry is used\n * to describe the distance from the center of the edge from -1 to 1 with 0\n * being the center of the edge and the default value. The y-coordinate of an\n * edge's geometry is used to describe the absolute, orthogonal distance in\n * pixels from that point. In addition, the {@link Geometry.offset} is used as an\n * absolute offset vector from the resulting point.\n *\n * This coordinate system is applied if {@link relative} is true, otherwise the\n * offset defines the absolute vector from the edge's center point to the\n * label and the values for {@link x} and {@link y} are ignored.\n *\n * The width and height parameter for edge geometries can be used to set the\n * label width and height (eg. for word wrapping).\n *\n * ### Ports\n *\n * The term \"port\" refers to a relatively positioned, connectable child cell,\n * which is used to specify the connection between the parent and another cell\n * in the graph. Ports are typically modeled as vertices with relative\n * geometries.\n *\n * ### Offsets\n *\n * The {@link offset} field is interpreted in 3 different ways, depending on the cell\n * and the geometry. For edges, the offset defines the absolute offset for the\n * edge label. For relative geometries, the offset defines the absolute offset\n * for the origin (top, left corner) of the vertex, otherwise the offset\n * defines the absolute offset for the label inside the vertex or group.\n */\nclass Geometry extends Rectangle {\n    constructor(x = 0, y = 0, width = 0, height = 0) {\n        super(x, y, width, height);\n        /**\n         * Global switch to translate the points in translate. Default is true.\n         */\n        this.TRANSLATE_CONTROL_POINTS = true;\n        /**\n         * Stores alternate values for x, y, width and height in a rectangle.\n         * See {@link swap} to exchange the values. Default is null.\n         *\n         * @see {@link swap}\n         */\n        this.alternateBounds = null;\n        /**\n         * Defines the source {@link Point} of the edge. This is used if the\n         * corresponding edge does not have a source vertex. Otherwise it is\n         * ignored. Default is  null.\n         */\n        this.sourcePoint = null;\n        /**\n         * Defines the target {@link Point} of the edge. This is used if the\n         * corresponding edge does not have a target vertex. Otherwise it is\n         * ignored. Default is null.\n         */\n        this.targetPoint = null;\n        /**\n         * Array of {@link Point} which specifies the control points along the edge.\n         * These points are the intermediate points on the edge, for the endpoints\n         * use {@link targetPoint} and {@link sourcePoint} or set the terminals of the edge to\n         * a non-null value. Default is null.\n         */\n        this.points = null;\n        /**\n         * For edges, this holds the offset (in pixels) from the position defined\n         * by {@link x} and {@link y} on the edge. For relative geometries (for vertices), this\n         * defines the absolute offset from the point defined by the relative\n         * coordinates. For absolute geometries (for vertices), this defines the\n         * offset for the label. Default is null.\n         */\n        this.offset = null;\n        /**\n         * Specifies if the coordinates in the geometry are to be interpreted as\n         * relative coordinates. For edges, this is used to define the location of\n         * the edge label relative to the edge as rendered on the display. For\n         * vertices, this specifies the relative location inside the bounds of the\n         * parent cell.\n         *\n         * If this is false, then the coordinates are relative to the origin of the\n         * parent cell or, for edges, the edge label position is relative to the\n         * center of the edge as rendered on screen.\n         *\n         * Default is false.\n         */\n        this.relative = false;\n    }\n    setRelative(isRelative) {\n        this.relative = isRelative;\n    }\n    /**\n     * Swaps the x, y, width and height with the values stored in\n     * {@link alternateBounds} and puts the previous values into {@link alternateBounds} as\n     * a rectangle. This operation is carried-out in-place, that is, using the\n     * existing geometry instance. If this operation is called during a graph\n     * model transactional change, then the geometry should be cloned before\n     * calling this method and setting the geometry of the cell using\n     * {@link mxGraphModel.setGeometry}.\n     */\n    swap() {\n        if (this.alternateBounds) {\n            const old = new Rectangle(this.x, this.y, this.width, this.height);\n            this.x = this.alternateBounds.x;\n            this.y = this.alternateBounds.y;\n            this.width = this.alternateBounds.width;\n            this.height = this.alternateBounds.height;\n            this.alternateBounds = old;\n        }\n    }\n    /**\n     * Returns the {@link Point} representing the source or target point of this\n     * edge. This is only used if the edge has no source or target vertex.\n     *\n     * @param {Boolean} isSource that specifies if the source or target point should be returned.\n     */\n    getTerminalPoint(isSource) {\n        return isSource ? this.sourcePoint : this.targetPoint;\n    }\n    /**\n     * Sets the {@link sourcePoint} or {@link targetPoint} to the given {@link Point} and\n     * returns the new point.\n     *\n     * @param {Point} point to be used as the new source or target point.\n     * @param {Boolean} isSource that specifies if the source or target point should be set.\n     */\n    setTerminalPoint(point, isSource) {\n        if (isSource) {\n            this.sourcePoint = point;\n        }\n        else {\n            this.targetPoint = point;\n        }\n        return point;\n    }\n    /**\n     * Rotates the geometry by the given angle around the given center. That is,\n     * {@link x} and {@link y} of the geometry, the {@link sourcePoint}, {@link targetPoint} and all\n     * {@link points} are translated by the given amount. {@link x} and {@link y} are only\n     * translated if {@link relative} is false.\n     *\n     * @param {Number} angle that specifies the rotation angle in degrees.\n     * @param {Point} cx   that specifies the center of the rotation.\n     */\n    rotate(angle, cx) {\n        const rad = toRadians(angle);\n        const cos = Math.cos(rad);\n        const sin = Math.sin(rad);\n        // Rotates the geometry\n        if (!this.relative) {\n            const ct = new Point(this.getCenterX(), this.getCenterY());\n            const pt = getRotatedPoint(ct, cos, sin, cx);\n            this.x = Math.round(pt.x - this.width / 2);\n            this.y = Math.round(pt.y - this.height / 2);\n        }\n        // Rotates the source point\n        if (this.sourcePoint) {\n            const pt = getRotatedPoint(this.sourcePoint, cos, sin, cx);\n            this.sourcePoint.x = Math.round(pt.x);\n            this.sourcePoint.y = Math.round(pt.y);\n        }\n        // Translates the target point\n        if (this.targetPoint) {\n            const pt = getRotatedPoint(this.targetPoint, cos, sin, cx);\n            this.targetPoint.x = Math.round(pt.x);\n            this.targetPoint.y = Math.round(pt.y);\n        }\n        // Translate the control points\n        if (this.points) {\n            for (let i = 0; i < this.points.length; i += 1) {\n                if (this.points[i]) {\n                    const pt = getRotatedPoint(this.points[i], cos, sin, cx);\n                    this.points[i].x = Math.round(pt.x);\n                    this.points[i].y = Math.round(pt.y);\n                }\n            }\n        }\n    }\n    /**\n     * Translates the geometry by the specified amount. That is, {@link x} and {@link y} of the\n     * geometry, the {@link sourcePoint}, {@link targetPoint} and all {@link points} are translated\n     * by the given amount. {@link x} and {@link y} are only translated if {@link relative} is false.\n     * If {@link TRANSLATE_CONTROL_POINTS} is false, then {@link points} are not modified by\n     * this function.\n     *\n     * @param {Number} dx that specifies the x-coordinate of the translation.\n     * @param {Number} dy that specifies the y-coordinate of the translation.\n     */\n    translate(dx, dy) {\n        // Translates the geometry\n        if (!this.relative) {\n            this.x += dx;\n            this.y += dy;\n        }\n        // Translates the source point\n        if (this.sourcePoint) {\n            this.sourcePoint.x = this.sourcePoint.x + dx;\n            this.sourcePoint.y = this.sourcePoint.y + dy;\n        }\n        // Translates the target point\n        if (this.targetPoint) {\n            this.targetPoint.x = this.targetPoint.x + dx;\n            this.targetPoint.y = this.targetPoint.y + dy;\n        }\n        // Translate the control points\n        if (this.TRANSLATE_CONTROL_POINTS && this.points) {\n            for (let i = 0; i < this.points.length; i += 1) {\n                if (this.points[i]) {\n                    this.points[i].x = this.points[i].x + dx;\n                    this.points[i].y = this.points[i].y + dy;\n                }\n            }\n        }\n    }\n    /**\n     * Scales the geometry by the given amount. That is, {@link x} and {@link y} of the\n     * geometry, the {@link sourcePoint}, {@link targetPoint} and all {@link points} are scaled\n     * by the given amount. {@link x}, {@link y}, {@link width} and {@link height} are only scaled if\n     * {@link relative} is false. If {@link fixedAspect} is true, then the smaller value\n     * is used to scale the width and the height.\n     *\n     * @param {Number} sx that specifies the horizontal scale factor.\n     * @param {Number} sy that specifies the vertical scale factor.\n     * @param {Optional} fixedAspect boolean to keep the aspect ratio fixed.\n     */\n    scale(sx, sy, fixedAspect) {\n        // Translates the source point\n        if (this.sourcePoint) {\n            this.sourcePoint.x = this.sourcePoint.x * sx;\n            this.sourcePoint.y = this.sourcePoint.y * sy;\n        }\n        // Translates the target point\n        if (this.targetPoint) {\n            this.targetPoint.x = this.targetPoint.x * sx;\n            this.targetPoint.y = this.targetPoint.y * sy;\n        }\n        // Translate the control points\n        if (this.points) {\n            for (let i = 0; i < this.points.length; i += 1) {\n                if (this.points[i]) {\n                    this.points[i].x = this.points[i].x * sx;\n                    this.points[i].y = this.points[i].y * sy;\n                }\n            }\n        }\n        // Translates the geometry\n        if (!this.relative) {\n            this.x *= sx;\n            this.y *= sy;\n            if (fixedAspect) {\n                sy = sx = Math.min(sx, sy);\n            }\n            this.width *= sx;\n            this.height *= sy;\n        }\n    }\n    /**\n     * Returns true if the given object equals this geometry.\n     */\n    equals(geom) {\n        if (!geom)\n            return false;\n        return (super.equals(geom) &&\n            this.relative === geom.relative &&\n            ((this.sourcePoint === null && geom.sourcePoint === null) ||\n                !!this.sourcePoint?.equals(geom.sourcePoint)) &&\n            ((this.targetPoint === null && geom.targetPoint === null) ||\n                !!this.targetPoint?.equals(geom.targetPoint)) &&\n            equalPoints(this.points, geom.points) &&\n            ((this.alternateBounds === null && geom.alternateBounds === null) ||\n                !!this.alternateBounds?.equals(geom.alternateBounds)) &&\n            ((this.offset === null && geom.offset === null) ||\n                !!this.offset?.equals(geom.offset)));\n    }\n    clone() {\n        return clone(this);\n    }\n}\nexport default Geometry;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,KAAK,MAAM,SAAS;AAC3B,OAAOC,SAAS,MAAM,aAAa;AACnC,SAASC,eAAe,EAAEC,SAAS,QAAQ,sBAAsB;AACjE,SAASC,WAAW,QAAQ,uBAAuB;AACnD,SAASC,KAAK,QAAQ,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,QAAQ,SAASL,SAAS,CAAC;EAC7BM,WAAWA,CAAA,EAAsC;IAAA,IAArCC,CAAC,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;IAAA,IAAEG,CAAC,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;IAAA,IAAEI,KAAK,GAAAJ,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;IAAA,IAAEK,MAAM,GAAAL,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;IAC3C,KAAK,CAACD,CAAC,EAAEI,CAAC,EAAEC,KAAK,EAAEC,MAAM,CAAC;IAC1B;AACR;AACA;IACQ,IAAI,CAACC,wBAAwB,GAAG,IAAI;IACpC;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,eAAe,GAAG,IAAI;IAC3B;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACC,WAAW,GAAG,IAAI;IACvB;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACC,WAAW,GAAG,IAAI;IACvB;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,MAAM,GAAG,IAAI;IAClB;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,MAAM,GAAG,IAAI;IAClB;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,QAAQ,GAAG,KAAK;EACzB;EACAC,WAAWA,CAACC,UAAU,EAAE;IACpB,IAAI,CAACF,QAAQ,GAAGE,UAAU;EAC9B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,IAAIA,CAAA,EAAG;IACH,IAAI,IAAI,CAACR,eAAe,EAAE;MACtB,MAAMS,GAAG,GAAG,IAAIxB,SAAS,CAAC,IAAI,CAACO,CAAC,EAAE,IAAI,CAACI,CAAC,EAAE,IAAI,CAACC,KAAK,EAAE,IAAI,CAACC,MAAM,CAAC;MAClE,IAAI,CAACN,CAAC,GAAG,IAAI,CAACQ,eAAe,CAACR,CAAC;MAC/B,IAAI,CAACI,CAAC,GAAG,IAAI,CAACI,eAAe,CAACJ,CAAC;MAC/B,IAAI,CAACC,KAAK,GAAG,IAAI,CAACG,eAAe,CAACH,KAAK;MACvC,IAAI,CAACC,MAAM,GAAG,IAAI,CAACE,eAAe,CAACF,MAAM;MACzC,IAAI,CAACE,eAAe,GAAGS,GAAG;IAC9B;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;EACIC,gBAAgBA,CAACC,QAAQ,EAAE;IACvB,OAAOA,QAAQ,GAAG,IAAI,CAACV,WAAW,GAAG,IAAI,CAACC,WAAW;EACzD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIU,gBAAgBA,CAACC,KAAK,EAAEF,QAAQ,EAAE;IAC9B,IAAIA,QAAQ,EAAE;MACV,IAAI,CAACV,WAAW,GAAGY,KAAK;IAC5B,CAAC,MACI;MACD,IAAI,CAACX,WAAW,GAAGW,KAAK;IAC5B;IACA,OAAOA,KAAK;EAChB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,MAAMA,CAACC,KAAK,EAAEC,EAAE,EAAE;IACd,MAAMC,GAAG,GAAG9B,SAAS,CAAC4B,KAAK,CAAC;IAC5B,MAAMG,GAAG,GAAGC,IAAI,CAACD,GAAG,CAACD,GAAG,CAAC;IACzB,MAAMG,GAAG,GAAGD,IAAI,CAACC,GAAG,CAACH,GAAG,CAAC;IACzB;IACA,IAAI,CAAC,IAAI,CAACZ,QAAQ,EAAE;MAChB,MAAMgB,EAAE,GAAG,IAAIrC,KAAK,CAAC,IAAI,CAACsC,UAAU,CAAC,CAAC,EAAE,IAAI,CAACC,UAAU,CAAC,CAAC,CAAC;MAC1D,MAAMC,EAAE,GAAGtC,eAAe,CAACmC,EAAE,EAAEH,GAAG,EAAEE,GAAG,EAAEJ,EAAE,CAAC;MAC5C,IAAI,CAACxB,CAAC,GAAG2B,IAAI,CAACM,KAAK,CAACD,EAAE,CAAChC,CAAC,GAAG,IAAI,CAACK,KAAK,GAAG,CAAC,CAAC;MAC1C,IAAI,CAACD,CAAC,GAAGuB,IAAI,CAACM,KAAK,CAACD,EAAE,CAAC5B,CAAC,GAAG,IAAI,CAACE,MAAM,GAAG,CAAC,CAAC;IAC/C;IACA;IACA,IAAI,IAAI,CAACG,WAAW,EAAE;MAClB,MAAMuB,EAAE,GAAGtC,eAAe,CAAC,IAAI,CAACe,WAAW,EAAEiB,GAAG,EAAEE,GAAG,EAAEJ,EAAE,CAAC;MAC1D,IAAI,CAACf,WAAW,CAACT,CAAC,GAAG2B,IAAI,CAACM,KAAK,CAACD,EAAE,CAAChC,CAAC,CAAC;MACrC,IAAI,CAACS,WAAW,CAACL,CAAC,GAAGuB,IAAI,CAACM,KAAK,CAACD,EAAE,CAAC5B,CAAC,CAAC;IACzC;IACA;IACA,IAAI,IAAI,CAACM,WAAW,EAAE;MAClB,MAAMsB,EAAE,GAAGtC,eAAe,CAAC,IAAI,CAACgB,WAAW,EAAEgB,GAAG,EAAEE,GAAG,EAAEJ,EAAE,CAAC;MAC1D,IAAI,CAACd,WAAW,CAACV,CAAC,GAAG2B,IAAI,CAACM,KAAK,CAACD,EAAE,CAAChC,CAAC,CAAC;MACrC,IAAI,CAACU,WAAW,CAACN,CAAC,GAAGuB,IAAI,CAACM,KAAK,CAACD,EAAE,CAAC5B,CAAC,CAAC;IACzC;IACA;IACA,IAAI,IAAI,CAACO,MAAM,EAAE;MACb,KAAK,IAAIuB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACvB,MAAM,CAACT,MAAM,EAAEgC,CAAC,IAAI,CAAC,EAAE;QAC5C,IAAI,IAAI,CAACvB,MAAM,CAACuB,CAAC,CAAC,EAAE;UAChB,MAAMF,EAAE,GAAGtC,eAAe,CAAC,IAAI,CAACiB,MAAM,CAACuB,CAAC,CAAC,EAAER,GAAG,EAAEE,GAAG,EAAEJ,EAAE,CAAC;UACxD,IAAI,CAACb,MAAM,CAACuB,CAAC,CAAC,CAAClC,CAAC,GAAG2B,IAAI,CAACM,KAAK,CAACD,EAAE,CAAChC,CAAC,CAAC;UACnC,IAAI,CAACW,MAAM,CAACuB,CAAC,CAAC,CAAC9B,CAAC,GAAGuB,IAAI,CAACM,KAAK,CAACD,EAAE,CAAC5B,CAAC,CAAC;QACvC;MACJ;IACJ;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI+B,SAASA,CAACC,EAAE,EAAEC,EAAE,EAAE;IACd;IACA,IAAI,CAAC,IAAI,CAACxB,QAAQ,EAAE;MAChB,IAAI,CAACb,CAAC,IAAIoC,EAAE;MACZ,IAAI,CAAChC,CAAC,IAAIiC,EAAE;IAChB;IACA;IACA,IAAI,IAAI,CAAC5B,WAAW,EAAE;MAClB,IAAI,CAACA,WAAW,CAACT,CAAC,GAAG,IAAI,CAACS,WAAW,CAACT,CAAC,GAAGoC,EAAE;MAC5C,IAAI,CAAC3B,WAAW,CAACL,CAAC,GAAG,IAAI,CAACK,WAAW,CAACL,CAAC,GAAGiC,EAAE;IAChD;IACA;IACA,IAAI,IAAI,CAAC3B,WAAW,EAAE;MAClB,IAAI,CAACA,WAAW,CAACV,CAAC,GAAG,IAAI,CAACU,WAAW,CAACV,CAAC,GAAGoC,EAAE;MAC5C,IAAI,CAAC1B,WAAW,CAACN,CAAC,GAAG,IAAI,CAACM,WAAW,CAACN,CAAC,GAAGiC,EAAE;IAChD;IACA;IACA,IAAI,IAAI,CAAC9B,wBAAwB,IAAI,IAAI,CAACI,MAAM,EAAE;MAC9C,KAAK,IAAIuB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACvB,MAAM,CAACT,MAAM,EAAEgC,CAAC,IAAI,CAAC,EAAE;QAC5C,IAAI,IAAI,CAACvB,MAAM,CAACuB,CAAC,CAAC,EAAE;UAChB,IAAI,CAACvB,MAAM,CAACuB,CAAC,CAAC,CAAClC,CAAC,GAAG,IAAI,CAACW,MAAM,CAACuB,CAAC,CAAC,CAAClC,CAAC,GAAGoC,EAAE;UACxC,IAAI,CAACzB,MAAM,CAACuB,CAAC,CAAC,CAAC9B,CAAC,GAAG,IAAI,CAACO,MAAM,CAACuB,CAAC,CAAC,CAAC9B,CAAC,GAAGiC,EAAE;QAC5C;MACJ;IACJ;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,KAAKA,CAACC,EAAE,EAAEC,EAAE,EAAEC,WAAW,EAAE;IACvB;IACA,IAAI,IAAI,CAAChC,WAAW,EAAE;MAClB,IAAI,CAACA,WAAW,CAACT,CAAC,GAAG,IAAI,CAACS,WAAW,CAACT,CAAC,GAAGuC,EAAE;MAC5C,IAAI,CAAC9B,WAAW,CAACL,CAAC,GAAG,IAAI,CAACK,WAAW,CAACL,CAAC,GAAGoC,EAAE;IAChD;IACA;IACA,IAAI,IAAI,CAAC9B,WAAW,EAAE;MAClB,IAAI,CAACA,WAAW,CAACV,CAAC,GAAG,IAAI,CAACU,WAAW,CAACV,CAAC,GAAGuC,EAAE;MAC5C,IAAI,CAAC7B,WAAW,CAACN,CAAC,GAAG,IAAI,CAACM,WAAW,CAACN,CAAC,GAAGoC,EAAE;IAChD;IACA;IACA,IAAI,IAAI,CAAC7B,MAAM,EAAE;MACb,KAAK,IAAIuB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACvB,MAAM,CAACT,MAAM,EAAEgC,CAAC,IAAI,CAAC,EAAE;QAC5C,IAAI,IAAI,CAACvB,MAAM,CAACuB,CAAC,CAAC,EAAE;UAChB,IAAI,CAACvB,MAAM,CAACuB,CAAC,CAAC,CAAClC,CAAC,GAAG,IAAI,CAACW,MAAM,CAACuB,CAAC,CAAC,CAAClC,CAAC,GAAGuC,EAAE;UACxC,IAAI,CAAC5B,MAAM,CAACuB,CAAC,CAAC,CAAC9B,CAAC,GAAG,IAAI,CAACO,MAAM,CAACuB,CAAC,CAAC,CAAC9B,CAAC,GAAGoC,EAAE;QAC5C;MACJ;IACJ;IACA;IACA,IAAI,CAAC,IAAI,CAAC3B,QAAQ,EAAE;MAChB,IAAI,CAACb,CAAC,IAAIuC,EAAE;MACZ,IAAI,CAACnC,CAAC,IAAIoC,EAAE;MACZ,IAAIC,WAAW,EAAE;QACbD,EAAE,GAAGD,EAAE,GAAGZ,IAAI,CAACe,GAAG,CAACH,EAAE,EAAEC,EAAE,CAAC;MAC9B;MACA,IAAI,CAACnC,KAAK,IAAIkC,EAAE;MAChB,IAAI,CAACjC,MAAM,IAAIkC,EAAE;IACrB;EACJ;EACA;AACJ;AACA;EACIG,MAAMA,CAACC,IAAI,EAAE;IAAA,IAAAC,iBAAA,EAAAC,iBAAA,EAAAC,qBAAA,EAAAC,YAAA;IACT,IAAI,CAACJ,IAAI,EACL,OAAO,KAAK;IAChB,OAAQ,KAAK,CAACD,MAAM,CAACC,IAAI,CAAC,IACtB,IAAI,CAAC/B,QAAQ,KAAK+B,IAAI,CAAC/B,QAAQ,KAC7B,IAAI,CAACJ,WAAW,KAAK,IAAI,IAAImC,IAAI,CAACnC,WAAW,KAAK,IAAI,IACpD,CAAC,GAAAoC,iBAAA,GAAC,IAAI,CAACpC,WAAW,cAAAoC,iBAAA,eAAhBA,iBAAA,CAAkBF,MAAM,CAACC,IAAI,CAACnC,WAAW,CAAC,EAAC,KAC/C,IAAI,CAACC,WAAW,KAAK,IAAI,IAAIkC,IAAI,CAAClC,WAAW,KAAK,IAAI,IACpD,CAAC,GAAAoC,iBAAA,GAAC,IAAI,CAACpC,WAAW,cAAAoC,iBAAA,eAAhBA,iBAAA,CAAkBH,MAAM,CAACC,IAAI,CAAClC,WAAW,CAAC,EAAC,IACjDd,WAAW,CAAC,IAAI,CAACe,MAAM,EAAEiC,IAAI,CAACjC,MAAM,CAAC,KACnC,IAAI,CAACH,eAAe,KAAK,IAAI,IAAIoC,IAAI,CAACpC,eAAe,KAAK,IAAI,IAC5D,CAAC,GAAAuC,qBAAA,GAAC,IAAI,CAACvC,eAAe,cAAAuC,qBAAA,eAApBA,qBAAA,CAAsBJ,MAAM,CAACC,IAAI,CAACpC,eAAe,CAAC,EAAC,KACvD,IAAI,CAACI,MAAM,KAAK,IAAI,IAAIgC,IAAI,CAAChC,MAAM,KAAK,IAAI,IAC1C,CAAC,GAAAoC,YAAA,GAAC,IAAI,CAACpC,MAAM,cAAAoC,YAAA,eAAXA,YAAA,CAAaL,MAAM,CAACC,IAAI,CAAChC,MAAM,CAAC,EAAC;EAC/C;EACAf,KAAKA,CAAA,EAAG;IACJ,OAAOA,KAAK,CAAC,IAAI,CAAC;EACtB;AACJ;AACA,eAAeC,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}