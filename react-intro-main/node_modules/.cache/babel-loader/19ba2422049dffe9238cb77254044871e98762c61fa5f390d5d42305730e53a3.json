{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nimport { IndentAction } from '../languages/languageConfiguration.js';\nimport { getIndentationAtPosition } from '../languages/languageConfigurationRegistry.js';\nimport { createScopedLineTokens } from '../languages/supports.js';\nimport { getIndentActionForType, getIndentForEnter, getInheritIndentForLine } from '../languages/autoIndent.js';\nimport { getEnterAction } from '../languages/enterAction.js';\nexport class AutoIndentOperation {\n  static getEdits(config, model, selections, ch, isDoingComposition) {\n    if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n      const indentationForSelections = [];\n      for (const selection of selections) {\n        const indentation = this._findActualIndentationForSelection(config, model, selection, ch);\n        if (indentation === null) {\n          // Auto indentation failed\n          return;\n        }\n        indentationForSelections.push({\n          selection,\n          indentation\n        });\n      }\n      const autoClosingPairClose = AutoClosingOpenCharTypeOperation.getAutoClosingPairClose(config, model, selections, ch, false);\n      return this._getIndentationAndAutoClosingPairEdits(config, model, indentationForSelections, ch, autoClosingPairClose);\n    }\n    return;\n  }\n  static _isAutoIndentType(config, model, selections) {\n    if (config.autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n      return false;\n    }\n    for (let i = 0, len = selections.length; i < len; i++) {\n      if (!model.tokenization.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  static _findActualIndentationForSelection(config, model, selection, ch) {\n    const actualIndentation = getIndentActionForType(config, model, selection, ch, {\n      shiftIndent: indentation => {\n        return shiftIndent(config, indentation);\n      },\n      unshiftIndent: indentation => {\n        return unshiftIndent(config, indentation);\n      }\n    }, config.languageConfigurationService);\n    if (actualIndentation === null) {\n      return null;\n    }\n    const currentIndentation = getIndentationAtPosition(model, selection.startLineNumber, selection.startColumn);\n    if (actualIndentation === config.normalizeIndentation(currentIndentation)) {\n      return null;\n    }\n    return actualIndentation;\n  }\n  static _getIndentationAndAutoClosingPairEdits(config, model, indentationForSelections, ch, autoClosingPairClose) {\n    const commands = indentationForSelections.map(_ref => {\n      let {\n        selection,\n        indentation\n      } = _ref;\n      if (autoClosingPairClose !== null) {\n        // Apply both auto closing pair edits and auto indentation edits\n        const indentationEdit = this._getEditFromIndentationAndSelection(config, model, indentation, selection, ch, false);\n        return new TypeWithIndentationAndAutoClosingCommand(indentationEdit, selection, ch, autoClosingPairClose);\n      } else {\n        // Apply only auto indentation edits\n        const indentationEdit = this._getEditFromIndentationAndSelection(config, model, indentation, selection, ch, true);\n        return typeCommand(indentationEdit.range, indentationEdit.text, false);\n      }\n    });\n    const editOptions = {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: false\n    };\n    return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, editOptions);\n  }\n  static _getEditFromIndentationAndSelection(config, model, indentation, selection, ch) {\n    let includeChInEdit = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    const startLineNumber = selection.startLineNumber;\n    const firstNonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(startLineNumber);\n    let text = config.normalizeIndentation(indentation);\n    if (firstNonWhitespaceColumn !== 0) {\n      const startLine = model.getLineContent(startLineNumber);\n      text += startLine.substring(firstNonWhitespaceColumn - 1, selection.startColumn - 1);\n    }\n    text += includeChInEdit ? ch : '';\n    const range = new Range(startLineNumber, 1, selection.endLineNumber, selection.endColumn);\n    return {\n      range,\n      text\n    };\n  }\n}\nexport class AutoClosingOvertypeOperation {\n  static getEdits(prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n    if (isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n      return this._runAutoClosingOvertype(prevEditOperationType, selections, ch);\n    }\n    return;\n  }\n  static _runAutoClosingOvertype(prevEditOperationType, selections, ch) {\n    const commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      const position = selection.getPosition();\n      const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n      commands[i] = new ReplaceCommand(typeSelection, ch);\n    }\n    return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n      shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n      shouldPushStackElementAfter: false\n    });\n  }\n}\nexport class AutoClosingOvertypeWithInterceptorsOperation {\n  static getEdits(config, model, selections, autoClosedCharacters, ch) {\n    if (isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n      // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n      const commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n      return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n        shouldPushStackElementBefore: true,\n        shouldPushStackElementAfter: false\n      });\n    }\n    return;\n  }\n}\nexport class AutoClosingOpenCharTypeOperation {\n  static getEdits(config, model, selections, ch, chIsAlreadyTyped, isDoingComposition) {\n    if (!isDoingComposition) {\n      const autoClosingPairClose = this.getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped);\n      if (autoClosingPairClose !== null) {\n        return this._runAutoClosingOpenCharType(selections, ch, chIsAlreadyTyped, autoClosingPairClose);\n      }\n    }\n    return;\n  }\n  static _runAutoClosingOpenCharType(selections, ch, chIsAlreadyTyped, autoClosingPairClose) {\n    const commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      commands[i] = new TypeWithAutoClosingCommand(selection, ch, !chIsAlreadyTyped, autoClosingPairClose);\n    }\n    return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: false\n    });\n  }\n  static getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped) {\n    for (const selection of selections) {\n      if (!selection.isEmpty()) {\n        return null;\n      }\n    }\n    // This method is called both when typing (regularly) and when composition ends\n    // This means that we need to work with a text buffer where sometimes `ch` is not\n    // there (it is being typed right now) or with a text buffer where `ch` has already been typed\n    //\n    // In order to avoid adding checks for `chIsAlreadyTyped` in all places, we will work\n    // with two conceptual positions, the position before `ch` and the position after `ch`\n    //\n    const positions = selections.map(s => {\n      const position = s.getPosition();\n      if (chIsAlreadyTyped) {\n        return {\n          lineNumber: position.lineNumber,\n          beforeColumn: position.column - ch.length,\n          afterColumn: position.column\n        };\n      } else {\n        return {\n          lineNumber: position.lineNumber,\n          beforeColumn: position.column,\n          afterColumn: position.column\n        };\n      }\n    });\n    // Find the longest auto-closing open pair in case of multiple ending in `ch`\n    // e.g. when having [f\",\"] and [\",\"], it picks [f\",\"] if the character before is f\n    const pair = this._findAutoClosingPairOpen(config, model, positions.map(p => new Position(p.lineNumber, p.beforeColumn)), ch);\n    if (!pair) {\n      return null;\n    }\n    let autoCloseConfig;\n    let shouldAutoCloseBefore;\n    const chIsQuote = isQuote(ch);\n    if (chIsQuote) {\n      autoCloseConfig = config.autoClosingQuotes;\n      shouldAutoCloseBefore = config.shouldAutoCloseBefore.quote;\n    } else {\n      const pairIsForComments = config.blockCommentStartToken ? pair.open.includes(config.blockCommentStartToken) : false;\n      if (pairIsForComments) {\n        autoCloseConfig = config.autoClosingComments;\n        shouldAutoCloseBefore = config.shouldAutoCloseBefore.comment;\n      } else {\n        autoCloseConfig = config.autoClosingBrackets;\n        shouldAutoCloseBefore = config.shouldAutoCloseBefore.bracket;\n      }\n    }\n    if (autoCloseConfig === 'never') {\n      return null;\n    }\n    // Sometimes, it is possible to have two auto-closing pairs that have a containment relationship\n    // e.g. when having [(,)] and [(*,*)]\n    // - when typing (, the resulting state is (|)\n    // - when typing *, the desired resulting state is (*|*), not (*|*))\n    const containedPair = this._findContainedAutoClosingPair(config, pair);\n    const containedPairClose = containedPair ? containedPair.close : '';\n    let isContainedPairPresent = true;\n    for (const position of positions) {\n      const {\n        lineNumber,\n        beforeColumn,\n        afterColumn\n      } = position;\n      const lineText = model.getLineContent(lineNumber);\n      const lineBefore = lineText.substring(0, beforeColumn - 1);\n      const lineAfter = lineText.substring(afterColumn - 1);\n      if (!lineAfter.startsWith(containedPairClose)) {\n        isContainedPairPresent = false;\n      }\n      // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n      if (lineAfter.length > 0) {\n        const characterAfter = lineAfter.charAt(0);\n        const isBeforeCloseBrace = this._isBeforeClosingBrace(config, lineAfter);\n        if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n          return null;\n        }\n      }\n      // Do not auto-close ' or \" after a word character\n      if (pair.open.length === 1 && (ch === '\\'' || ch === '\"') && autoCloseConfig !== 'always') {\n        const wordSeparators = getMapForWordSeparators(config.wordSeparators, []);\n        if (lineBefore.length > 0) {\n          const characterBefore = lineBefore.charCodeAt(lineBefore.length - 1);\n          if (wordSeparators.get(characterBefore) === 0 /* WordCharacterClass.Regular */) {\n            return null;\n          }\n        }\n      }\n      if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n        // Do not force tokenization\n        return null;\n      }\n      model.tokenization.forceTokenization(lineNumber);\n      const lineTokens = model.tokenization.getLineTokens(lineNumber);\n      const scopedLineTokens = createScopedLineTokens(lineTokens, beforeColumn - 1);\n      if (!pair.shouldAutoClose(scopedLineTokens, beforeColumn - scopedLineTokens.firstCharOffset)) {\n        return null;\n      }\n      // Typing for example a quote could either start a new string, in which case auto-closing is desirable\n      // or it could end a previously started string, in which case auto-closing is not desirable\n      //\n      // In certain cases, it is really not possible to look at the previous token to determine\n      // what would happen. That's why we do something really unusual, we pretend to type a different\n      // character and ask the tokenizer what the outcome of doing that is: after typing a neutral\n      // character, are we in a string (i.e. the quote would most likely end a string) or not?\n      //\n      const neutralCharacter = pair.findNeutralCharacter();\n      if (neutralCharacter) {\n        const tokenType = model.tokenization.getTokenTypeIfInsertingCharacter(lineNumber, beforeColumn, neutralCharacter);\n        if (!pair.isOK(tokenType)) {\n          return null;\n        }\n      }\n    }\n    if (isContainedPairPresent) {\n      return pair.close.substring(0, pair.close.length - containedPairClose.length);\n    } else {\n      return pair.close;\n    }\n  }\n  /**\n   * Find another auto-closing pair that is contained by the one passed in.\n   *\n   * e.g. when having [(,)] and [(*,*)] as auto-closing pairs\n   * this method will find [(,)] as a containment pair for [(*,*)]\n   */\n  static _findContainedAutoClosingPair(config, pair) {\n    if (pair.open.length <= 1) {\n      return null;\n    }\n    const lastChar = pair.close.charAt(pair.close.length - 1);\n    // get candidates with the same last character as close\n    const candidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n    let result = null;\n    for (const candidate of candidates) {\n      if (candidate.open !== pair.open && pair.open.includes(candidate.open) && pair.close.endsWith(candidate.close)) {\n        if (!result || candidate.open.length > result.open.length) {\n          result = candidate;\n        }\n      }\n    }\n    return result;\n  }\n  /**\n   * Determine if typing `ch` at all `positions` in the `model` results in an\n   * auto closing open sequence being typed.\n   *\n   * Auto closing open sequences can consist of multiple characters, which\n   * can lead to ambiguities. In such a case, the longest auto-closing open\n   * sequence is returned.\n   */\n  static _findAutoClosingPairOpen(config, model, positions, ch) {\n    const candidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n    if (!candidates) {\n      return null;\n    }\n    // Determine which auto-closing pair it is\n    let result = null;\n    for (const candidate of candidates) {\n      if (result === null || candidate.open.length > result.open.length) {\n        let candidateIsMatch = true;\n        for (const position of positions) {\n          const relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - candidate.open.length + 1, position.lineNumber, position.column));\n          if (relevantText + ch !== candidate.open) {\n            candidateIsMatch = false;\n            break;\n          }\n        }\n        if (candidateIsMatch) {\n          result = candidate;\n        }\n      }\n    }\n    return result;\n  }\n  static _isBeforeClosingBrace(config, lineAfter) {\n    // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n    const nextChar = lineAfter.charAt(0);\n    const potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n    const potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n    const isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n    const isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n    return !isBeforeStartingBrace && isBeforeClosingBrace;\n  }\n}\nexport class SurroundSelectionOperation {\n  static getEdits(config, model, selections, ch, isDoingComposition) {\n    if (!isDoingComposition && this._isSurroundSelectionType(config, model, selections, ch)) {\n      return this._runSurroundSelectionType(config, selections, ch);\n    }\n    return;\n  }\n  static _runSurroundSelectionType(config, selections, ch) {\n    const commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      const closeCharacter = config.surroundingPairs[ch];\n      commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n    }\n    return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: true\n    });\n  }\n  static _isSurroundSelectionType(config, model, selections, ch) {\n    if (!shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n      return false;\n    }\n    const isTypingAQuoteCharacter = isQuote(ch);\n    for (const selection of selections) {\n      if (selection.isEmpty()) {\n        return false;\n      }\n      let selectionContainsOnlyWhitespace = true;\n      for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n        const lineText = model.getLineContent(lineNumber);\n        const startIndex = lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0;\n        const endIndex = lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length;\n        const selectedText = lineText.substring(startIndex, endIndex);\n        if (/[^ \\t]/.test(selectedText)) {\n          // this selected text contains something other than whitespace\n          selectionContainsOnlyWhitespace = false;\n          break;\n        }\n      }\n      if (selectionContainsOnlyWhitespace) {\n        return false;\n      }\n      if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n        const selectionText = model.getValueInRange(selection);\n        if (isQuote(selectionText)) {\n          // Typing a quote character on top of another quote character\n          // => disable surround selection type\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n}\nexport class InterceptorElectricCharOperation {\n  static getEdits(prevEditOperationType, config, model, selections, ch, isDoingComposition) {\n    // Electric characters make sense only when dealing with a single cursor,\n    // as multiple cursors typing brackets for example would interfer with bracket matching\n    if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n      const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n      if (r) {\n        return r;\n      }\n    }\n    return;\n  }\n  static _isTypeInterceptorElectricChar(config, model, selections) {\n    if (selections.length === 1 && model.tokenization.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n      return true;\n    }\n    return false;\n  }\n  static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n    if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n      return null;\n    }\n    const position = selection.getPosition();\n    model.tokenization.forceTokenization(position.lineNumber);\n    const lineTokens = model.tokenization.getLineTokens(position.lineNumber);\n    let electricAction;\n    try {\n      electricAction = config.onElectricCharacter(ch, lineTokens, position.column);\n    } catch (e) {\n      onUnexpectedError(e);\n      return null;\n    }\n    if (!electricAction) {\n      return null;\n    }\n    if (electricAction.matchOpenBracket) {\n      const endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n      const match = model.bracketPairs.findMatchingBracketUp(electricAction.matchOpenBracket, {\n        lineNumber: position.lineNumber,\n        column: endColumn\n      }, 500 /* give at most 500ms to compute */);\n      if (match) {\n        if (match.startLineNumber === position.lineNumber) {\n          // matched something on the same line => no change in indentation\n          return null;\n        }\n        const matchLine = model.getLineContent(match.startLineNumber);\n        const matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n        const newIndentation = config.normalizeIndentation(matchLineIndentation);\n        const lineText = model.getLineContent(position.lineNumber);\n        const lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n        const prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n        const typeText = newIndentation + prefix + ch;\n        const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n        const command = new ReplaceCommand(typeSelection, typeText);\n        return new EditOperationResult(getTypingOperation(typeText, prevEditOperationType), [command], {\n          shouldPushStackElementBefore: false,\n          shouldPushStackElementAfter: true\n        });\n      }\n    }\n    return null;\n  }\n}\nexport class SimpleCharacterTypeOperation {\n  static getEdits(prevEditOperationType, selections, ch) {\n    // A simple character type\n    const commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ReplaceCommand(selections[i], ch);\n    }\n    const opType = getTypingOperation(ch, prevEditOperationType);\n    return new EditOperationResult(opType, commands, {\n      shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n      shouldPushStackElementAfter: false\n    });\n  }\n}\nexport class EnterOperation {\n  static getEdits(config, model, selections, ch, isDoingComposition) {\n    if (!isDoingComposition && ch === '\\n') {\n      const commands = [];\n      for (let i = 0, len = selections.length; i < len; i++) {\n        commands[i] = this._enter(config, model, false, selections[i]);\n      }\n      return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n        shouldPushStackElementBefore: true,\n        shouldPushStackElementAfter: false\n      });\n    }\n    return;\n  }\n  static _enter(config, model, keepPosition, range) {\n    if (config.autoIndent === 0 /* EditorAutoIndentStrategy.None */) {\n      return typeCommand(range, '\\n', keepPosition);\n    }\n    if (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1 /* EditorAutoIndentStrategy.Keep */) {\n      const lineText = model.getLineContent(range.startLineNumber);\n      const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n      return typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n    const r = getEnterAction(config.autoIndent, model, range, config.languageConfigurationService);\n    if (r) {\n      if (r.indentAction === IndentAction.None) {\n        // Nothing special\n        return typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n      } else if (r.indentAction === IndentAction.Indent) {\n        // Indent once\n        return typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n      } else if (r.indentAction === IndentAction.IndentOutdent) {\n        // Ultra special\n        const normalIndent = config.normalizeIndentation(r.indentation);\n        const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n        const typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n        if (keepPosition) {\n          return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n        } else {\n          return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n        }\n      } else if (r.indentAction === IndentAction.Outdent) {\n        const actualIndentation = unshiftIndent(config, r.indentation);\n        return typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n      }\n    }\n    const lineText = model.getLineContent(range.startLineNumber);\n    const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n    if (config.autoIndent >= 4 /* EditorAutoIndentStrategy.Full */) {\n      const ir = getIndentForEnter(config.autoIndent, model, range, {\n        unshiftIndent: indent => {\n          return unshiftIndent(config, indent);\n        },\n        shiftIndent: indent => {\n          return shiftIndent(config, indent);\n        },\n        normalizeIndentation: indent => {\n          return config.normalizeIndentation(indent);\n        }\n      }, config.languageConfigurationService);\n      if (ir) {\n        let oldEndViewColumn = config.visibleColumnFromColumn(model, range.getEndPosition());\n        const oldEndColumn = range.endColumn;\n        const newLineContent = model.getLineContent(range.endLineNumber);\n        const firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n        if (firstNonWhitespace >= 0) {\n          range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n        } else {\n          range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n        }\n        if (keepPosition) {\n          return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n        } else {\n          let offset = 0;\n          if (oldEndColumn <= firstNonWhitespace + 1) {\n            if (!config.insertSpaces) {\n              oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n            }\n            offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n          }\n          return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n        }\n      }\n    }\n    return typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n  }\n  static lineInsertBefore(config, model, selections) {\n    if (model === null || selections === null) {\n      return [];\n    }\n    const commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      let lineNumber = selections[i].positionLineNumber;\n      if (lineNumber === 1) {\n        commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n      } else {\n        lineNumber--;\n        const column = model.getLineMaxColumn(lineNumber);\n        commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n      }\n    }\n    return commands;\n  }\n  static lineInsertAfter(config, model, selections) {\n    if (model === null || selections === null) {\n      return [];\n    }\n    const commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const lineNumber = selections[i].positionLineNumber;\n      const column = model.getLineMaxColumn(lineNumber);\n      commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n    }\n    return commands;\n  }\n  static lineBreakInsert(config, model, selections) {\n    const commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = this._enter(config, model, true, selections[i]);\n    }\n    return commands;\n  }\n}\nexport class PasteOperation {\n  static getEdits(config, model, selections, text, pasteOnNewLine, multicursorText) {\n    const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n    if (distributedPaste) {\n      selections = selections.sort(Range.compareRangesUsingStarts);\n      return this._distributedPaste(config, model, selections, distributedPaste);\n    } else {\n      return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n    }\n  }\n  static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\n    if (pasteOnNewLine) {\n      return null;\n    }\n    if (selections.length === 1) {\n      return null;\n    }\n    if (multicursorText && multicursorText.length === selections.length) {\n      return multicursorText;\n    }\n    if (config.multiCursorPaste === 'spread') {\n      // Try to spread the pasted text in case the line count matches the cursor count\n      // Remove trailing \\n if present\n      if (text.charCodeAt(text.length - 1) === 10 /* CharCode.LineFeed */) {\n        text = text.substring(0, text.length - 1);\n      }\n      // Remove trailing \\r if present\n      if (text.charCodeAt(text.length - 1) === 13 /* CharCode.CarriageReturn */) {\n        text = text.substring(0, text.length - 1);\n      }\n      const lines = strings.splitLines(text);\n      if (lines.length === selections.length) {\n        return lines;\n      }\n    }\n    return null;\n  }\n  static _distributedPaste(config, model, selections, text) {\n    const commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ReplaceCommand(selections[i], text[i]);\n    }\n    return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: true\n    });\n  }\n  static _simplePaste(config, model, selections, text, pasteOnNewLine) {\n    const commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      const position = selection.getPosition();\n      if (pasteOnNewLine && !selection.isEmpty()) {\n        pasteOnNewLine = false;\n      }\n      if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n        pasteOnNewLine = false;\n      }\n      if (pasteOnNewLine) {\n        // Paste entire line at the beginning of line\n        const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n        commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n      } else {\n        commands[i] = new ReplaceCommand(selection, text);\n      }\n    }\n    return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: true\n    });\n  }\n}\nexport class CompositionOperation {\n  static getEdits(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n    const commands = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n    return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n      shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n      shouldPushStackElementAfter: false\n    });\n  }\n  static _compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n    if (!selection.isEmpty()) {\n      // looks like https://github.com/microsoft/vscode/issues/2773\n      // where a cursor operation occurred before a canceled composition\n      // => ignore composition\n      return null;\n    }\n    const pos = selection.getPosition();\n    const startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n    const endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n    const range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n    const oldText = model.getValueInRange(range);\n    if (oldText === text && positionDelta === 0) {\n      // => ignore composition that doesn't do anything\n      return null;\n    }\n    return new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n  }\n}\nexport class TypeWithoutInterceptorsOperation {\n  static getEdits(prevEditOperationType, selections, str) {\n    const commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ReplaceCommand(selections[i], str);\n    }\n    const opType = getTypingOperation(str, prevEditOperationType);\n    return new EditOperationResult(opType, commands, {\n      shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n      shouldPushStackElementAfter: false\n    });\n  }\n}\nexport class TabOperation {\n  static getCommands(config, model, selections) {\n    const commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      if (selection.isEmpty()) {\n        const lineText = model.getLineContent(selection.startLineNumber);\n        if (/^\\s*$/.test(lineText) && model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n          let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n          goodIndent = goodIndent || '\\t';\n          const possibleTypeText = config.normalizeIndentation(goodIndent);\n          if (!lineText.startsWith(possibleTypeText)) {\n            commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n            continue;\n          }\n        }\n        commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n      } else {\n        if (selection.startLineNumber === selection.endLineNumber) {\n          const lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n          if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n            // This is a single line selection that is not the entire line\n            commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n            continue;\n          }\n        }\n        commands[i] = new ShiftCommand(selection, {\n          isUnshift: false,\n          tabSize: config.tabSize,\n          indentSize: config.indentSize,\n          insertSpaces: config.insertSpaces,\n          useTabStops: config.useTabStops,\n          autoIndent: config.autoIndent\n        }, config.languageConfigurationService);\n      }\n    }\n    return commands;\n  }\n  static _goodIndentForLine(config, model, lineNumber) {\n    let action = null;\n    let indentation = '';\n    const expectedIndentAction = getInheritIndentForLine(config.autoIndent, model, lineNumber, false, config.languageConfigurationService);\n    if (expectedIndentAction) {\n      action = expectedIndentAction.action;\n      indentation = expectedIndentAction.indentation;\n    } else if (lineNumber > 1) {\n      let lastLineNumber;\n      for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n        const lineText = model.getLineContent(lastLineNumber);\n        const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n        if (nonWhitespaceIdx >= 0) {\n          break;\n        }\n      }\n      if (lastLineNumber < 1) {\n        // No previous line with content found\n        return null;\n      }\n      const maxColumn = model.getLineMaxColumn(lastLineNumber);\n      const expectedEnterAction = getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn), config.languageConfigurationService);\n      if (expectedEnterAction) {\n        indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n      }\n    }\n    if (action) {\n      if (action === IndentAction.Indent) {\n        indentation = shiftIndent(config, indentation);\n      }\n      if (action === IndentAction.Outdent) {\n        indentation = unshiftIndent(config, indentation);\n      }\n      indentation = config.normalizeIndentation(indentation);\n    }\n    if (!indentation) {\n      return null;\n    }\n    return indentation;\n  }\n  static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n    let typeText = '';\n    const position = selection.getStartPosition();\n    if (config.insertSpaces) {\n      const visibleColumnFromColumn = config.visibleColumnFromColumn(model, position);\n      const indentSize = config.indentSize;\n      const spacesCnt = indentSize - visibleColumnFromColumn % indentSize;\n      for (let i = 0; i < spacesCnt; i++) {\n        typeText += ' ';\n      }\n    } else {\n      typeText = '\\t';\n    }\n    return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n  }\n}\nexport class BaseTypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n  constructor(selection, text, lineNumberDeltaOffset, columnDeltaOffset, openCharacter, closeCharacter) {\n    super(selection, text, lineNumberDeltaOffset, columnDeltaOffset);\n    this._openCharacter = openCharacter;\n    this._closeCharacter = closeCharacter;\n    this.closeCharacterRange = null;\n    this.enclosingRange = null;\n  }\n  _computeCursorStateWithRange(model, range, helper) {\n    this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n    this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n    return super.computeCursorState(model, helper);\n  }\n}\nclass TypeWithAutoClosingCommand extends BaseTypeWithAutoClosingCommand {\n  constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n    const text = (insertOpenCharacter ? openCharacter : '') + closeCharacter;\n    const lineNumberDeltaOffset = 0;\n    const columnDeltaOffset = -closeCharacter.length;\n    super(selection, text, lineNumberDeltaOffset, columnDeltaOffset, openCharacter, closeCharacter);\n  }\n  computeCursorState(model, helper) {\n    const inverseEditOperations = helper.getInverseEditOperations();\n    const range = inverseEditOperations[0].range;\n    return this._computeCursorStateWithRange(model, range, helper);\n  }\n}\nclass TypeWithIndentationAndAutoClosingCommand extends BaseTypeWithAutoClosingCommand {\n  constructor(autoIndentationEdit, selection, openCharacter, closeCharacter) {\n    const text = openCharacter + closeCharacter;\n    const lineNumberDeltaOffset = 0;\n    const columnDeltaOffset = openCharacter.length;\n    super(selection, text, lineNumberDeltaOffset, columnDeltaOffset, openCharacter, closeCharacter);\n    this._autoIndentationEdit = autoIndentationEdit;\n    this._autoClosingEdit = {\n      range: selection,\n      text\n    };\n  }\n  getEditOperations(model, builder) {\n    builder.addTrackedEditOperation(this._autoIndentationEdit.range, this._autoIndentationEdit.text);\n    builder.addTrackedEditOperation(this._autoClosingEdit.range, this._autoClosingEdit.text);\n  }\n  computeCursorState(model, helper) {\n    const inverseEditOperations = helper.getInverseEditOperations();\n    if (inverseEditOperations.length !== 2) {\n      throw new Error('There should be two inverse edit operations!');\n    }\n    const range1 = inverseEditOperations[0].range;\n    const range2 = inverseEditOperations[1].range;\n    const range = range1.plusRange(range2);\n    return this._computeCursorStateWithRange(model, range, helper);\n  }\n}\nfunction getTypingOperation(typedText, previousTypingOperation) {\n  if (typedText === ' ') {\n    return previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */ || previousTypingOperation === 6 /* EditOperationType.TypingConsecutiveSpace */ ? 6 /* EditOperationType.TypingConsecutiveSpace */ : 5 /* EditOperationType.TypingFirstSpace */;\n  }\n  return 4 /* EditOperationType.TypingOther */;\n}\nfunction shouldPushStackElementBetween(previousTypingOperation, typingOperation) {\n  if (isTypingOperation(previousTypingOperation) && !isTypingOperation(typingOperation)) {\n    // Always set an undo stop before non-type operations\n    return true;\n  }\n  if (previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */) {\n    // `abc |d`: No undo stop\n    // `abc  |d`: Undo stop\n    return false;\n  }\n  // Insert undo stop between different operation types\n  return normalizeOperationType(previousTypingOperation) !== normalizeOperationType(typingOperation);\n}\nfunction normalizeOperationType(type) {\n  return type === 6 /* EditOperationType.TypingConsecutiveSpace */ || type === 5 /* EditOperationType.TypingFirstSpace */ ? 'space' : type;\n}\nfunction isTypingOperation(type) {\n  return type === 4 /* EditOperationType.TypingOther */ || type === 5 /* EditOperationType.TypingFirstSpace */ || type === 6 /* EditOperationType.TypingConsecutiveSpace */;\n}\nfunction isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\n  if (config.autoClosingOvertype === 'never') {\n    return false;\n  }\n  if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n    return false;\n  }\n  for (let i = 0, len = selections.length; i < len; i++) {\n    const selection = selections[i];\n    if (!selection.isEmpty()) {\n      return false;\n    }\n    const position = selection.getPosition();\n    const lineText = model.getLineContent(position.lineNumber);\n    const afterCharacter = lineText.charAt(position.column - 1);\n    if (afterCharacter !== ch) {\n      return false;\n    }\n    // Do not over-type quotes after a backslash\n    const chIsQuote = isQuote(ch);\n    const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0 /* CharCode.Null */;\n    if (beforeCharacter === 92 /* CharCode.Backslash */ && chIsQuote) {\n      return false;\n    }\n    // Must over-type a closing character typed by the editor\n    if (config.autoClosingOvertype === 'auto') {\n      let found = false;\n      for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n        const autoClosedCharacter = autoClosedCharacters[j];\n        if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nfunction typeCommand(range, text, keepPosition) {\n  if (keepPosition) {\n    return new ReplaceCommandWithoutChangingPosition(range, text, true);\n  } else {\n    return new ReplaceCommand(range, text, true);\n  }\n}\nexport function shiftIndent(config, indentation, count) {\n  count = count || 1;\n  return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n}\nexport function unshiftIndent(config, indentation, count) {\n  count = count || 1;\n  return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n}\nexport function shouldSurroundChar(config, ch) {\n  if (isQuote(ch)) {\n    return config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined';\n  } else {\n    // Character is a bracket\n    return config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined';\n  }\n}","map":{"version":3,"names":["onUnexpectedError","strings","ReplaceCommand","ReplaceCommandWithOffsetCursorState","ReplaceCommandWithoutChangingPosition","ReplaceCommandThatPreservesSelection","ShiftCommand","SurroundSelectionCommand","EditOperationResult","isQuote","getMapForWordSeparators","Range","Position","IndentAction","getIndentationAtPosition","createScopedLineTokens","getIndentActionForType","getIndentForEnter","getInheritIndentForLine","getEnterAction","AutoIndentOperation","getEdits","config","model","selections","ch","isDoingComposition","_isAutoIndentType","indentationForSelections","selection","indentation","_findActualIndentationForSelection","push","autoClosingPairClose","AutoClosingOpenCharTypeOperation","getAutoClosingPairClose","_getIndentationAndAutoClosingPairEdits","autoIndent","i","len","length","tokenization","isCheapToTokenize","getEndPosition","lineNumber","actualIndentation","shiftIndent","unshiftIndent","languageConfigurationService","currentIndentation","startLineNumber","startColumn","normalizeIndentation","commands","map","_ref","indentationEdit","_getEditFromIndentationAndSelection","TypeWithIndentationAndAutoClosingCommand","typeCommand","range","text","editOptions","shouldPushStackElementBefore","shouldPushStackElementAfter","includeChInEdit","arguments","undefined","firstNonWhitespaceColumn","getLineFirstNonWhitespaceColumn","startLine","getLineContent","substring","endLineNumber","endColumn","AutoClosingOvertypeOperation","prevEditOperationType","autoClosedCharacters","isAutoClosingOvertype","_runAutoClosingOvertype","position","getPosition","typeSelection","column","shouldPushStackElementBetween","AutoClosingOvertypeWithInterceptorsOperation","s","positionLineNumber","positionColumn","chIsAlreadyTyped","_runAutoClosingOpenCharType","TypeWithAutoClosingCommand","isEmpty","positions","beforeColumn","afterColumn","pair","_findAutoClosingPairOpen","p","autoCloseConfig","shouldAutoCloseBefore","chIsQuote","autoClosingQuotes","quote","pairIsForComments","blockCommentStartToken","open","includes","autoClosingComments","comment","autoClosingBrackets","bracket","containedPair","_findContainedAutoClosingPair","containedPairClose","close","isContainedPairPresent","lineText","lineBefore","lineAfter","startsWith","characterAfter","charAt","isBeforeCloseBrace","_isBeforeClosingBrace","wordSeparators","characterBefore","charCodeAt","get","forceTokenization","lineTokens","getLineTokens","scopedLineTokens","shouldAutoClose","firstCharOffset","neutralCharacter","findNeutralCharacter","tokenType","getTokenTypeIfInsertingCharacter","isOK","lastChar","candidates","autoClosingPairs","autoClosingPairsCloseByEnd","result","candidate","endsWith","autoClosingPairsOpenByEnd","candidateIsMatch","relevantText","getValueInRange","nextChar","potentialStartingBraces","autoClosingPairsOpenByStart","potentialClosingBraces","autoClosingPairsCloseByStart","isBeforeStartingBrace","some","x","isBeforeClosingBrace","SurroundSelectionOperation","_isSurroundSelectionType","_runSurroundSelectionType","closeCharacter","surroundingPairs","shouldSurroundChar","hasOwnProperty","isTypingAQuoteCharacter","selectionContainsOnlyWhitespace","startIndex","endIndex","selectedText","test","selectionText","InterceptorElectricCharOperation","_isTypeInterceptorElectricChar","r","_typeInterceptorElectricChar","electricChars","electricAction","onElectricCharacter","e","matchOpenBracket","lastIndexOf","match","bracketPairs","findMatchingBracketUp","matchLine","matchLineIndentation","getLeadingWhitespace","newIndentation","lineFirstNonBlankColumn","prefix","typeText","command","getTypingOperation","SimpleCharacterTypeOperation","opType","EnterOperation","_enter","keepPosition","getStartPosition","indentAction","None","appendText","Indent","IndentOutdent","normalIndent","increasedIndent","Outdent","ir","indent","oldEndViewColumn","visibleColumnFromColumn","oldEndColumn","newLineContent","firstNonWhitespace","firstNonWhitespaceIndex","setEndPosition","Math","max","getLineMaxColumn","afterEnter","offset","insertSpaces","ceil","indentSize","min","lineInsertBefore","lineInsertAfter","lineBreakInsert","PasteOperation","pasteOnNewLine","multicursorText","distributedPaste","_distributePasteToCursors","sort","compareRangesUsingStarts","_distributedPaste","_simplePaste","multiCursorPaste","lines","splitLines","indexOf","CompositionOperation","replacePrevCharCnt","replaceNextCharCnt","positionDelta","_compositionType","pos","oldText","TypeWithoutInterceptorsOperation","str","TabOperation","getCommands","goodIndent","_goodIndentForLine","possibleTypeText","_replaceJumpToNextIndent","lineMaxColumn","isUnshift","tabSize","useTabStops","action","expectedIndentAction","lastLineNumber","nonWhitespaceIdx","lastNonWhitespaceIndex","maxColumn","expectedEnterAction","insertsAutoWhitespace","spacesCnt","BaseTypeWithAutoClosingCommand","constructor","lineNumberDeltaOffset","columnDeltaOffset","openCharacter","_openCharacter","_closeCharacter","closeCharacterRange","enclosingRange","_computeCursorStateWithRange","helper","computeCursorState","insertOpenCharacter","inverseEditOperations","getInverseEditOperations","autoIndentationEdit","_autoIndentationEdit","_autoClosingEdit","getEditOperations","builder","addTrackedEditOperation","Error","range1","range2","plusRange","typedText","previousTypingOperation","typingOperation","isTypingOperation","normalizeOperationType","type","autoClosingOvertype","autoClosingPairsCloseSingleChar","has","afterCharacter","beforeCharacter","found","j","lenJ","autoClosedCharacter","count","autoSurround"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorTypeEditOperations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nimport { IndentAction } from '../languages/languageConfiguration.js';\nimport { getIndentationAtPosition } from '../languages/languageConfigurationRegistry.js';\nimport { createScopedLineTokens } from '../languages/supports.js';\nimport { getIndentActionForType, getIndentForEnter, getInheritIndentForLine } from '../languages/autoIndent.js';\nimport { getEnterAction } from '../languages/enterAction.js';\nexport class AutoIndentOperation {\n    static getEdits(config, model, selections, ch, isDoingComposition) {\n        if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n            const indentationForSelections = [];\n            for (const selection of selections) {\n                const indentation = this._findActualIndentationForSelection(config, model, selection, ch);\n                if (indentation === null) {\n                    // Auto indentation failed\n                    return;\n                }\n                indentationForSelections.push({ selection, indentation });\n            }\n            const autoClosingPairClose = AutoClosingOpenCharTypeOperation.getAutoClosingPairClose(config, model, selections, ch, false);\n            return this._getIndentationAndAutoClosingPairEdits(config, model, indentationForSelections, ch, autoClosingPairClose);\n        }\n        return;\n    }\n    static _isAutoIndentType(config, model, selections) {\n        if (config.autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            if (!model.tokenization.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _findActualIndentationForSelection(config, model, selection, ch) {\n        const actualIndentation = getIndentActionForType(config, model, selection, ch, {\n            shiftIndent: (indentation) => {\n                return shiftIndent(config, indentation);\n            },\n            unshiftIndent: (indentation) => {\n                return unshiftIndent(config, indentation);\n            },\n        }, config.languageConfigurationService);\n        if (actualIndentation === null) {\n            return null;\n        }\n        const currentIndentation = getIndentationAtPosition(model, selection.startLineNumber, selection.startColumn);\n        if (actualIndentation === config.normalizeIndentation(currentIndentation)) {\n            return null;\n        }\n        return actualIndentation;\n    }\n    static _getIndentationAndAutoClosingPairEdits(config, model, indentationForSelections, ch, autoClosingPairClose) {\n        const commands = indentationForSelections.map(({ selection, indentation }) => {\n            if (autoClosingPairClose !== null) {\n                // Apply both auto closing pair edits and auto indentation edits\n                const indentationEdit = this._getEditFromIndentationAndSelection(config, model, indentation, selection, ch, false);\n                return new TypeWithIndentationAndAutoClosingCommand(indentationEdit, selection, ch, autoClosingPairClose);\n            }\n            else {\n                // Apply only auto indentation edits\n                const indentationEdit = this._getEditFromIndentationAndSelection(config, model, indentation, selection, ch, true);\n                return typeCommand(indentationEdit.range, indentationEdit.text, false);\n            }\n        });\n        const editOptions = { shouldPushStackElementBefore: true, shouldPushStackElementAfter: false };\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, editOptions);\n    }\n    static _getEditFromIndentationAndSelection(config, model, indentation, selection, ch, includeChInEdit = true) {\n        const startLineNumber = selection.startLineNumber;\n        const firstNonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(startLineNumber);\n        let text = config.normalizeIndentation(indentation);\n        if (firstNonWhitespaceColumn !== 0) {\n            const startLine = model.getLineContent(startLineNumber);\n            text += startLine.substring(firstNonWhitespaceColumn - 1, selection.startColumn - 1);\n        }\n        text += includeChInEdit ? ch : '';\n        const range = new Range(startLineNumber, 1, selection.endLineNumber, selection.endColumn);\n        return { range, text };\n    }\n}\nexport class AutoClosingOvertypeOperation {\n    static getEdits(prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n        if (isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            return this._runAutoClosingOvertype(prevEditOperationType, selections, ch);\n        }\n        return;\n    }\n    static _runAutoClosingOvertype(prevEditOperationType, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(typeSelection, ch);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n}\nexport class AutoClosingOvertypeWithInterceptorsOperation {\n    static getEdits(config, model, selections, autoClosedCharacters, ch) {\n        if (isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n            const commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        return;\n    }\n}\nexport class AutoClosingOpenCharTypeOperation {\n    static getEdits(config, model, selections, ch, chIsAlreadyTyped, isDoingComposition) {\n        if (!isDoingComposition) {\n            const autoClosingPairClose = this.getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped);\n            if (autoClosingPairClose !== null) {\n                return this._runAutoClosingOpenCharType(selections, ch, chIsAlreadyTyped, autoClosingPairClose);\n            }\n        }\n        return;\n    }\n    static _runAutoClosingOpenCharType(selections, ch, chIsAlreadyTyped, autoClosingPairClose) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            commands[i] = new TypeWithAutoClosingCommand(selection, ch, !chIsAlreadyTyped, autoClosingPairClose);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: false\n        });\n    }\n    static getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped) {\n        for (const selection of selections) {\n            if (!selection.isEmpty()) {\n                return null;\n            }\n        }\n        // This method is called both when typing (regularly) and when composition ends\n        // This means that we need to work with a text buffer where sometimes `ch` is not\n        // there (it is being typed right now) or with a text buffer where `ch` has already been typed\n        //\n        // In order to avoid adding checks for `chIsAlreadyTyped` in all places, we will work\n        // with two conceptual positions, the position before `ch` and the position after `ch`\n        //\n        const positions = selections.map((s) => {\n            const position = s.getPosition();\n            if (chIsAlreadyTyped) {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column - ch.length, afterColumn: position.column };\n            }\n            else {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column, afterColumn: position.column };\n            }\n        });\n        // Find the longest auto-closing open pair in case of multiple ending in `ch`\n        // e.g. when having [f\",\"] and [\",\"], it picks [f\",\"] if the character before is f\n        const pair = this._findAutoClosingPairOpen(config, model, positions.map(p => new Position(p.lineNumber, p.beforeColumn)), ch);\n        if (!pair) {\n            return null;\n        }\n        let autoCloseConfig;\n        let shouldAutoCloseBefore;\n        const chIsQuote = isQuote(ch);\n        if (chIsQuote) {\n            autoCloseConfig = config.autoClosingQuotes;\n            shouldAutoCloseBefore = config.shouldAutoCloseBefore.quote;\n        }\n        else {\n            const pairIsForComments = config.blockCommentStartToken ? pair.open.includes(config.blockCommentStartToken) : false;\n            if (pairIsForComments) {\n                autoCloseConfig = config.autoClosingComments;\n                shouldAutoCloseBefore = config.shouldAutoCloseBefore.comment;\n            }\n            else {\n                autoCloseConfig = config.autoClosingBrackets;\n                shouldAutoCloseBefore = config.shouldAutoCloseBefore.bracket;\n            }\n        }\n        if (autoCloseConfig === 'never') {\n            return null;\n        }\n        // Sometimes, it is possible to have two auto-closing pairs that have a containment relationship\n        // e.g. when having [(,)] and [(*,*)]\n        // - when typing (, the resulting state is (|)\n        // - when typing *, the desired resulting state is (*|*), not (*|*))\n        const containedPair = this._findContainedAutoClosingPair(config, pair);\n        const containedPairClose = containedPair ? containedPair.close : '';\n        let isContainedPairPresent = true;\n        for (const position of positions) {\n            const { lineNumber, beforeColumn, afterColumn } = position;\n            const lineText = model.getLineContent(lineNumber);\n            const lineBefore = lineText.substring(0, beforeColumn - 1);\n            const lineAfter = lineText.substring(afterColumn - 1);\n            if (!lineAfter.startsWith(containedPairClose)) {\n                isContainedPairPresent = false;\n            }\n            // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n            if (lineAfter.length > 0) {\n                const characterAfter = lineAfter.charAt(0);\n                const isBeforeCloseBrace = this._isBeforeClosingBrace(config, lineAfter);\n                if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n                    return null;\n                }\n            }\n            // Do not auto-close ' or \" after a word character\n            if (pair.open.length === 1 && (ch === '\\'' || ch === '\"') && autoCloseConfig !== 'always') {\n                const wordSeparators = getMapForWordSeparators(config.wordSeparators, []);\n                if (lineBefore.length > 0) {\n                    const characterBefore = lineBefore.charCodeAt(lineBefore.length - 1);\n                    if (wordSeparators.get(characterBefore) === 0 /* WordCharacterClass.Regular */) {\n                        return null;\n                    }\n                }\n            }\n            if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n                // Do not force tokenization\n                return null;\n            }\n            model.tokenization.forceTokenization(lineNumber);\n            const lineTokens = model.tokenization.getLineTokens(lineNumber);\n            const scopedLineTokens = createScopedLineTokens(lineTokens, beforeColumn - 1);\n            if (!pair.shouldAutoClose(scopedLineTokens, beforeColumn - scopedLineTokens.firstCharOffset)) {\n                return null;\n            }\n            // Typing for example a quote could either start a new string, in which case auto-closing is desirable\n            // or it could end a previously started string, in which case auto-closing is not desirable\n            //\n            // In certain cases, it is really not possible to look at the previous token to determine\n            // what would happen. That's why we do something really unusual, we pretend to type a different\n            // character and ask the tokenizer what the outcome of doing that is: after typing a neutral\n            // character, are we in a string (i.e. the quote would most likely end a string) or not?\n            //\n            const neutralCharacter = pair.findNeutralCharacter();\n            if (neutralCharacter) {\n                const tokenType = model.tokenization.getTokenTypeIfInsertingCharacter(lineNumber, beforeColumn, neutralCharacter);\n                if (!pair.isOK(tokenType)) {\n                    return null;\n                }\n            }\n        }\n        if (isContainedPairPresent) {\n            return pair.close.substring(0, pair.close.length - containedPairClose.length);\n        }\n        else {\n            return pair.close;\n        }\n    }\n    /**\n     * Find another auto-closing pair that is contained by the one passed in.\n     *\n     * e.g. when having [(,)] and [(*,*)] as auto-closing pairs\n     * this method will find [(,)] as a containment pair for [(*,*)]\n     */\n    static _findContainedAutoClosingPair(config, pair) {\n        if (pair.open.length <= 1) {\n            return null;\n        }\n        const lastChar = pair.close.charAt(pair.close.length - 1);\n        // get candidates with the same last character as close\n        const candidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n        let result = null;\n        for (const candidate of candidates) {\n            if (candidate.open !== pair.open && pair.open.includes(candidate.open) && pair.close.endsWith(candidate.close)) {\n                if (!result || candidate.open.length > result.open.length) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Determine if typing `ch` at all `positions` in the `model` results in an\n     * auto closing open sequence being typed.\n     *\n     * Auto closing open sequences can consist of multiple characters, which\n     * can lead to ambiguities. In such a case, the longest auto-closing open\n     * sequence is returned.\n     */\n    static _findAutoClosingPairOpen(config, model, positions, ch) {\n        const candidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n        if (!candidates) {\n            return null;\n        }\n        // Determine which auto-closing pair it is\n        let result = null;\n        for (const candidate of candidates) {\n            if (result === null || candidate.open.length > result.open.length) {\n                let candidateIsMatch = true;\n                for (const position of positions) {\n                    const relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - candidate.open.length + 1, position.lineNumber, position.column));\n                    if (relevantText + ch !== candidate.open) {\n                        candidateIsMatch = false;\n                        break;\n                    }\n                }\n                if (candidateIsMatch) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    static _isBeforeClosingBrace(config, lineAfter) {\n        // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n        const nextChar = lineAfter.charAt(0);\n        const potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n        const potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n        const isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n        const isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n        return !isBeforeStartingBrace && isBeforeClosingBrace;\n    }\n}\nexport class SurroundSelectionOperation {\n    static getEdits(config, model, selections, ch, isDoingComposition) {\n        if (!isDoingComposition && this._isSurroundSelectionType(config, model, selections, ch)) {\n            return this._runSurroundSelectionType(config, selections, ch);\n        }\n        return;\n    }\n    static _runSurroundSelectionType(config, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const closeCharacter = config.surroundingPairs[ch];\n            commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _isSurroundSelectionType(config, model, selections, ch) {\n        if (!shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n            return false;\n        }\n        const isTypingAQuoteCharacter = isQuote(ch);\n        for (const selection of selections) {\n            if (selection.isEmpty()) {\n                return false;\n            }\n            let selectionContainsOnlyWhitespace = true;\n            for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n                const lineText = model.getLineContent(lineNumber);\n                const startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\n                const endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\n                const selectedText = lineText.substring(startIndex, endIndex);\n                if (/[^ \\t]/.test(selectedText)) {\n                    // this selected text contains something other than whitespace\n                    selectionContainsOnlyWhitespace = false;\n                    break;\n                }\n            }\n            if (selectionContainsOnlyWhitespace) {\n                return false;\n            }\n            if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n                const selectionText = model.getValueInRange(selection);\n                if (isQuote(selectionText)) {\n                    // Typing a quote character on top of another quote character\n                    // => disable surround selection type\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\nexport class InterceptorElectricCharOperation {\n    static getEdits(prevEditOperationType, config, model, selections, ch, isDoingComposition) {\n        // Electric characters make sense only when dealing with a single cursor,\n        // as multiple cursors typing brackets for example would interfer with bracket matching\n        if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n            const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n            if (r) {\n                return r;\n            }\n        }\n        return;\n    }\n    static _isTypeInterceptorElectricChar(config, model, selections) {\n        if (selections.length === 1 && model.tokenization.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n            return true;\n        }\n        return false;\n    }\n    static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n        if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n            return null;\n        }\n        const position = selection.getPosition();\n        model.tokenization.forceTokenization(position.lineNumber);\n        const lineTokens = model.tokenization.getLineTokens(position.lineNumber);\n        let electricAction;\n        try {\n            electricAction = config.onElectricCharacter(ch, lineTokens, position.column);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n        if (!electricAction) {\n            return null;\n        }\n        if (electricAction.matchOpenBracket) {\n            const endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n            const match = model.bracketPairs.findMatchingBracketUp(electricAction.matchOpenBracket, {\n                lineNumber: position.lineNumber,\n                column: endColumn\n            }, 500 /* give at most 500ms to compute */);\n            if (match) {\n                if (match.startLineNumber === position.lineNumber) {\n                    // matched something on the same line => no change in indentation\n                    return null;\n                }\n                const matchLine = model.getLineContent(match.startLineNumber);\n                const matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n                const newIndentation = config.normalizeIndentation(matchLineIndentation);\n                const lineText = model.getLineContent(position.lineNumber);\n                const lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n                const prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n                const typeText = newIndentation + prefix + ch;\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n                const command = new ReplaceCommand(typeSelection, typeText);\n                return new EditOperationResult(getTypingOperation(typeText, prevEditOperationType), [command], {\n                    shouldPushStackElementBefore: false,\n                    shouldPushStackElementAfter: true\n                });\n            }\n        }\n        return null;\n    }\n}\nexport class SimpleCharacterTypeOperation {\n    static getEdits(prevEditOperationType, selections, ch) {\n        // A simple character type\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], ch);\n        }\n        const opType = getTypingOperation(ch, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n}\nexport class EnterOperation {\n    static getEdits(config, model, selections, ch, isDoingComposition) {\n        if (!isDoingComposition && ch === '\\n') {\n            const commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = this._enter(config, model, false, selections[i]);\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false,\n            });\n        }\n        return;\n    }\n    static _enter(config, model, keepPosition, range) {\n        if (config.autoIndent === 0 /* EditorAutoIndentStrategy.None */) {\n            return typeCommand(range, '\\n', keepPosition);\n        }\n        if (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1 /* EditorAutoIndentStrategy.Keep */) {\n            const lineText = model.getLineContent(range.startLineNumber);\n            const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n            return typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n        }\n        const r = getEnterAction(config.autoIndent, model, range, config.languageConfigurationService);\n        if (r) {\n            if (r.indentAction === IndentAction.None) {\n                // Nothing special\n                return typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.Indent) {\n                // Indent once\n                return typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.IndentOutdent) {\n                // Ultra special\n                const normalIndent = config.normalizeIndentation(r.indentation);\n                const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n                const typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n                }\n                else {\n                    return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n                }\n            }\n            else if (r.indentAction === IndentAction.Outdent) {\n                const actualIndentation = unshiftIndent(config, r.indentation);\n                return typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n            }\n        }\n        const lineText = model.getLineContent(range.startLineNumber);\n        const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n        if (config.autoIndent >= 4 /* EditorAutoIndentStrategy.Full */) {\n            const ir = getIndentForEnter(config.autoIndent, model, range, {\n                unshiftIndent: (indent) => {\n                    return unshiftIndent(config, indent);\n                },\n                shiftIndent: (indent) => {\n                    return shiftIndent(config, indent);\n                },\n                normalizeIndentation: (indent) => {\n                    return config.normalizeIndentation(indent);\n                }\n            }, config.languageConfigurationService);\n            if (ir) {\n                let oldEndViewColumn = config.visibleColumnFromColumn(model, range.getEndPosition());\n                const oldEndColumn = range.endColumn;\n                const newLineContent = model.getLineContent(range.endLineNumber);\n                const firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n                if (firstNonWhitespace >= 0) {\n                    range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n                }\n                else {\n                    range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n                }\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n                }\n                else {\n                    let offset = 0;\n                    if (oldEndColumn <= firstNonWhitespace + 1) {\n                        if (!config.insertSpaces) {\n                            oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n                        }\n                        offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n                    }\n                    return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n                }\n            }\n        }\n        return typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n    static lineInsertBefore(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            let lineNumber = selections[i].positionLineNumber;\n            if (lineNumber === 1) {\n                commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n            }\n            else {\n                lineNumber--;\n                const column = model.getLineMaxColumn(lineNumber);\n                commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n            }\n        }\n        return commands;\n    }\n    static lineInsertAfter(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const lineNumber = selections[i].positionLineNumber;\n            const column = model.getLineMaxColumn(lineNumber);\n            commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n        }\n        return commands;\n    }\n    static lineBreakInsert(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = this._enter(config, model, true, selections[i]);\n        }\n        return commands;\n    }\n}\nexport class PasteOperation {\n    static getEdits(config, model, selections, text, pasteOnNewLine, multicursorText) {\n        const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n        if (distributedPaste) {\n            selections = selections.sort(Range.compareRangesUsingStarts);\n            return this._distributedPaste(config, model, selections, distributedPaste);\n        }\n        else {\n            return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n        }\n    }\n    static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\n        if (pasteOnNewLine) {\n            return null;\n        }\n        if (selections.length === 1) {\n            return null;\n        }\n        if (multicursorText && multicursorText.length === selections.length) {\n            return multicursorText;\n        }\n        if (config.multiCursorPaste === 'spread') {\n            // Try to spread the pasted text in case the line count matches the cursor count\n            // Remove trailing \\n if present\n            if (text.charCodeAt(text.length - 1) === 10 /* CharCode.LineFeed */) {\n                text = text.substring(0, text.length - 1);\n            }\n            // Remove trailing \\r if present\n            if (text.charCodeAt(text.length - 1) === 13 /* CharCode.CarriageReturn */) {\n                text = text.substring(0, text.length - 1);\n            }\n            const lines = strings.splitLines(text);\n            if (lines.length === selections.length) {\n                return lines;\n            }\n        }\n        return null;\n    }\n    static _distributedPaste(config, model, selections, text) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], text[i]);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _simplePaste(config, model, selections, text, pasteOnNewLine) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (pasteOnNewLine && !selection.isEmpty()) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine) {\n                // Paste entire line at the beginning of line\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n                commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, text);\n            }\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n}\nexport class CompositionOperation {\n    static getEdits(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        const commands = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        if (!selection.isEmpty()) {\n            // looks like https://github.com/microsoft/vscode/issues/2773\n            // where a cursor operation occurred before a canceled composition\n            // => ignore composition\n            return null;\n        }\n        const pos = selection.getPosition();\n        const startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n        const endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n        const range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n        const oldText = model.getValueInRange(range);\n        if (oldText === text && positionDelta === 0) {\n            // => ignore composition that doesn't do anything\n            return null;\n        }\n        return new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n    }\n}\nexport class TypeWithoutInterceptorsOperation {\n    static getEdits(prevEditOperationType, selections, str) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], str);\n        }\n        const opType = getTypingOperation(str, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n}\nexport class TabOperation {\n    static getCommands(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                const lineText = model.getLineContent(selection.startLineNumber);\n                if (/^\\s*$/.test(lineText) && model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n                    let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n                    goodIndent = goodIndent || '\\t';\n                    const possibleTypeText = config.normalizeIndentation(goodIndent);\n                    if (!lineText.startsWith(possibleTypeText)) {\n                        commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n                        continue;\n                    }\n                }\n                commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n            }\n            else {\n                if (selection.startLineNumber === selection.endLineNumber) {\n                    const lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n                        // This is a single line selection that is not the entire line\n                        commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n                        continue;\n                    }\n                }\n                commands[i] = new ShiftCommand(selection, {\n                    isUnshift: false,\n                    tabSize: config.tabSize,\n                    indentSize: config.indentSize,\n                    insertSpaces: config.insertSpaces,\n                    useTabStops: config.useTabStops,\n                    autoIndent: config.autoIndent\n                }, config.languageConfigurationService);\n            }\n        }\n        return commands;\n    }\n    static _goodIndentForLine(config, model, lineNumber) {\n        let action = null;\n        let indentation = '';\n        const expectedIndentAction = getInheritIndentForLine(config.autoIndent, model, lineNumber, false, config.languageConfigurationService);\n        if (expectedIndentAction) {\n            action = expectedIndentAction.action;\n            indentation = expectedIndentAction.indentation;\n        }\n        else if (lineNumber > 1) {\n            let lastLineNumber;\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                const lineText = model.getLineContent(lastLineNumber);\n                const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n            }\n            if (lastLineNumber < 1) {\n                // No previous line with content found\n                return null;\n            }\n            const maxColumn = model.getLineMaxColumn(lastLineNumber);\n            const expectedEnterAction = getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn), config.languageConfigurationService);\n            if (expectedEnterAction) {\n                indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n            }\n        }\n        if (action) {\n            if (action === IndentAction.Indent) {\n                indentation = shiftIndent(config, indentation);\n            }\n            if (action === IndentAction.Outdent) {\n                indentation = unshiftIndent(config, indentation);\n            }\n            indentation = config.normalizeIndentation(indentation);\n        }\n        if (!indentation) {\n            return null;\n        }\n        return indentation;\n    }\n    static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n        let typeText = '';\n        const position = selection.getStartPosition();\n        if (config.insertSpaces) {\n            const visibleColumnFromColumn = config.visibleColumnFromColumn(model, position);\n            const indentSize = config.indentSize;\n            const spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\n            for (let i = 0; i < spacesCnt; i++) {\n                typeText += ' ';\n            }\n        }\n        else {\n            typeText = '\\t';\n        }\n        return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n    }\n}\nexport class BaseTypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n    constructor(selection, text, lineNumberDeltaOffset, columnDeltaOffset, openCharacter, closeCharacter) {\n        super(selection, text, lineNumberDeltaOffset, columnDeltaOffset);\n        this._openCharacter = openCharacter;\n        this._closeCharacter = closeCharacter;\n        this.closeCharacterRange = null;\n        this.enclosingRange = null;\n    }\n    _computeCursorStateWithRange(model, range, helper) {\n        this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        return super.computeCursorState(model, helper);\n    }\n}\nclass TypeWithAutoClosingCommand extends BaseTypeWithAutoClosingCommand {\n    constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n        const text = (insertOpenCharacter ? openCharacter : '') + closeCharacter;\n        const lineNumberDeltaOffset = 0;\n        const columnDeltaOffset = -closeCharacter.length;\n        super(selection, text, lineNumberDeltaOffset, columnDeltaOffset, openCharacter, closeCharacter);\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        const range = inverseEditOperations[0].range;\n        return this._computeCursorStateWithRange(model, range, helper);\n    }\n}\nclass TypeWithIndentationAndAutoClosingCommand extends BaseTypeWithAutoClosingCommand {\n    constructor(autoIndentationEdit, selection, openCharacter, closeCharacter) {\n        const text = openCharacter + closeCharacter;\n        const lineNumberDeltaOffset = 0;\n        const columnDeltaOffset = openCharacter.length;\n        super(selection, text, lineNumberDeltaOffset, columnDeltaOffset, openCharacter, closeCharacter);\n        this._autoIndentationEdit = autoIndentationEdit;\n        this._autoClosingEdit = { range: selection, text };\n    }\n    getEditOperations(model, builder) {\n        builder.addTrackedEditOperation(this._autoIndentationEdit.range, this._autoIndentationEdit.text);\n        builder.addTrackedEditOperation(this._autoClosingEdit.range, this._autoClosingEdit.text);\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        if (inverseEditOperations.length !== 2) {\n            throw new Error('There should be two inverse edit operations!');\n        }\n        const range1 = inverseEditOperations[0].range;\n        const range2 = inverseEditOperations[1].range;\n        const range = range1.plusRange(range2);\n        return this._computeCursorStateWithRange(model, range, helper);\n    }\n}\nfunction getTypingOperation(typedText, previousTypingOperation) {\n    if (typedText === ' ') {\n        return previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */\n            || previousTypingOperation === 6 /* EditOperationType.TypingConsecutiveSpace */\n            ? 6 /* EditOperationType.TypingConsecutiveSpace */\n            : 5 /* EditOperationType.TypingFirstSpace */;\n    }\n    return 4 /* EditOperationType.TypingOther */;\n}\nfunction shouldPushStackElementBetween(previousTypingOperation, typingOperation) {\n    if (isTypingOperation(previousTypingOperation) && !isTypingOperation(typingOperation)) {\n        // Always set an undo stop before non-type operations\n        return true;\n    }\n    if (previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */) {\n        // `abc |d`: No undo stop\n        // `abc  |d`: Undo stop\n        return false;\n    }\n    // Insert undo stop between different operation types\n    return normalizeOperationType(previousTypingOperation) !== normalizeOperationType(typingOperation);\n}\nfunction normalizeOperationType(type) {\n    return (type === 6 /* EditOperationType.TypingConsecutiveSpace */ || type === 5 /* EditOperationType.TypingFirstSpace */)\n        ? 'space'\n        : type;\n}\nfunction isTypingOperation(type) {\n    return type === 4 /* EditOperationType.TypingOther */\n        || type === 5 /* EditOperationType.TypingFirstSpace */\n        || type === 6 /* EditOperationType.TypingConsecutiveSpace */;\n}\nfunction isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\n    if (config.autoClosingOvertype === 'never') {\n        return false;\n    }\n    if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n        return false;\n    }\n    for (let i = 0, len = selections.length; i < len; i++) {\n        const selection = selections[i];\n        if (!selection.isEmpty()) {\n            return false;\n        }\n        const position = selection.getPosition();\n        const lineText = model.getLineContent(position.lineNumber);\n        const afterCharacter = lineText.charAt(position.column - 1);\n        if (afterCharacter !== ch) {\n            return false;\n        }\n        // Do not over-type quotes after a backslash\n        const chIsQuote = isQuote(ch);\n        const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0 /* CharCode.Null */;\n        if (beforeCharacter === 92 /* CharCode.Backslash */ && chIsQuote) {\n            return false;\n        }\n        // Must over-type a closing character typed by the editor\n        if (config.autoClosingOvertype === 'auto') {\n            let found = false;\n            for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                const autoClosedCharacter = autoClosedCharacters[j];\n                if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction typeCommand(range, text, keepPosition) {\n    if (keepPosition) {\n        return new ReplaceCommandWithoutChangingPosition(range, text, true);\n    }\n    else {\n        return new ReplaceCommand(range, text, true);\n    }\n}\nexport function shiftIndent(config, indentation, count) {\n    count = count || 1;\n    return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n}\nexport function unshiftIndent(config, indentation, count) {\n    count = count || 1;\n    return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n}\nexport function shouldSurroundChar(config, ch) {\n    if (isQuote(ch)) {\n        return (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\n    }\n    else {\n        // Character is a bracket\n        return (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,iBAAiB,QAAQ,gCAAgC;AAClE,OAAO,KAAKC,OAAO,MAAM,iCAAiC;AAC1D,SAASC,cAAc,EAAEC,mCAAmC,EAAEC,qCAAqC,EAAEC,oCAAoC,QAAQ,+BAA+B;AAChL,SAASC,YAAY,QAAQ,6BAA6B;AAC1D,SAASC,wBAAwB,QAAQ,yCAAyC;AAClF,SAASC,mBAAmB,EAAEC,OAAO,QAAQ,oBAAoB;AACjE,SAASC,uBAAuB,QAAQ,oCAAoC;AAC5E,SAASC,KAAK,QAAQ,kBAAkB;AACxC,SAASC,QAAQ,QAAQ,qBAAqB;AAC9C,SAASC,YAAY,QAAQ,uCAAuC;AACpE,SAASC,wBAAwB,QAAQ,+CAA+C;AACxF,SAASC,sBAAsB,QAAQ,0BAA0B;AACjE,SAASC,sBAAsB,EAAEC,iBAAiB,EAAEC,uBAAuB,QAAQ,4BAA4B;AAC/G,SAASC,cAAc,QAAQ,6BAA6B;AAC5D,OAAO,MAAMC,mBAAmB,CAAC;EAC7B,OAAOC,QAAQA,CAACC,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEC,EAAE,EAAEC,kBAAkB,EAAE;IAC/D,IAAI,CAACA,kBAAkB,IAAI,IAAI,CAACC,iBAAiB,CAACL,MAAM,EAAEC,KAAK,EAAEC,UAAU,CAAC,EAAE;MAC1E,MAAMI,wBAAwB,GAAG,EAAE;MACnC,KAAK,MAAMC,SAAS,IAAIL,UAAU,EAAE;QAChC,MAAMM,WAAW,GAAG,IAAI,CAACC,kCAAkC,CAACT,MAAM,EAAEC,KAAK,EAAEM,SAAS,EAAEJ,EAAE,CAAC;QACzF,IAAIK,WAAW,KAAK,IAAI,EAAE;UACtB;UACA;QACJ;QACAF,wBAAwB,CAACI,IAAI,CAAC;UAAEH,SAAS;UAAEC;QAAY,CAAC,CAAC;MAC7D;MACA,MAAMG,oBAAoB,GAAGC,gCAAgC,CAACC,uBAAuB,CAACb,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEC,EAAE,EAAE,KAAK,CAAC;MAC3H,OAAO,IAAI,CAACW,sCAAsC,CAACd,MAAM,EAAEC,KAAK,EAAEK,wBAAwB,EAAEH,EAAE,EAAEQ,oBAAoB,CAAC;IACzH;IACA;EACJ;EACA,OAAON,iBAAiBA,CAACL,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAE;IAChD,IAAIF,MAAM,CAACe,UAAU,GAAG,CAAC,CAAC,qCAAqC;MAC3D,OAAO,KAAK;IAChB;IACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGf,UAAU,CAACgB,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnD,IAAI,CAACf,KAAK,CAACkB,YAAY,CAACC,iBAAiB,CAAClB,UAAU,CAACc,CAAC,CAAC,CAACK,cAAc,CAAC,CAAC,CAACC,UAAU,CAAC,EAAE;QAClF,OAAO,KAAK;MAChB;IACJ;IACA,OAAO,IAAI;EACf;EACA,OAAOb,kCAAkCA,CAACT,MAAM,EAAEC,KAAK,EAAEM,SAAS,EAAEJ,EAAE,EAAE;IACpE,MAAMoB,iBAAiB,GAAG7B,sBAAsB,CAACM,MAAM,EAAEC,KAAK,EAAEM,SAAS,EAAEJ,EAAE,EAAE;MAC3EqB,WAAW,EAAGhB,WAAW,IAAK;QAC1B,OAAOgB,WAAW,CAACxB,MAAM,EAAEQ,WAAW,CAAC;MAC3C,CAAC;MACDiB,aAAa,EAAGjB,WAAW,IAAK;QAC5B,OAAOiB,aAAa,CAACzB,MAAM,EAAEQ,WAAW,CAAC;MAC7C;IACJ,CAAC,EAAER,MAAM,CAAC0B,4BAA4B,CAAC;IACvC,IAAIH,iBAAiB,KAAK,IAAI,EAAE;MAC5B,OAAO,IAAI;IACf;IACA,MAAMI,kBAAkB,GAAGnC,wBAAwB,CAACS,KAAK,EAAEM,SAAS,CAACqB,eAAe,EAAErB,SAAS,CAACsB,WAAW,CAAC;IAC5G,IAAIN,iBAAiB,KAAKvB,MAAM,CAAC8B,oBAAoB,CAACH,kBAAkB,CAAC,EAAE;MACvE,OAAO,IAAI;IACf;IACA,OAAOJ,iBAAiB;EAC5B;EACA,OAAOT,sCAAsCA,CAACd,MAAM,EAAEC,KAAK,EAAEK,wBAAwB,EAAEH,EAAE,EAAEQ,oBAAoB,EAAE;IAC7G,MAAMoB,QAAQ,GAAGzB,wBAAwB,CAAC0B,GAAG,CAACC,IAAA,IAAgC;MAAA,IAA/B;QAAE1B,SAAS;QAAEC;MAAY,CAAC,GAAAyB,IAAA;MACrE,IAAItB,oBAAoB,KAAK,IAAI,EAAE;QAC/B;QACA,MAAMuB,eAAe,GAAG,IAAI,CAACC,mCAAmC,CAACnC,MAAM,EAAEC,KAAK,EAAEO,WAAW,EAAED,SAAS,EAAEJ,EAAE,EAAE,KAAK,CAAC;QAClH,OAAO,IAAIiC,wCAAwC,CAACF,eAAe,EAAE3B,SAAS,EAAEJ,EAAE,EAAEQ,oBAAoB,CAAC;MAC7G,CAAC,MACI;QACD;QACA,MAAMuB,eAAe,GAAG,IAAI,CAACC,mCAAmC,CAACnC,MAAM,EAAEC,KAAK,EAAEO,WAAW,EAAED,SAAS,EAAEJ,EAAE,EAAE,IAAI,CAAC;QACjH,OAAOkC,WAAW,CAACH,eAAe,CAACI,KAAK,EAAEJ,eAAe,CAACK,IAAI,EAAE,KAAK,CAAC;MAC1E;IACJ,CAAC,CAAC;IACF,MAAMC,WAAW,GAAG;MAAEC,4BAA4B,EAAE,IAAI;MAAEC,2BAA2B,EAAE;IAAM,CAAC;IAC9F,OAAO,IAAIxD,mBAAmB,CAAC,CAAC,CAAC,qCAAqC6C,QAAQ,EAAES,WAAW,CAAC;EAChG;EACA,OAAOL,mCAAmCA,CAACnC,MAAM,EAAEC,KAAK,EAAEO,WAAW,EAAED,SAAS,EAAEJ,EAAE,EAA0B;IAAA,IAAxBwC,eAAe,GAAAC,SAAA,CAAA1B,MAAA,QAAA0B,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,IAAI;IACxG,MAAMhB,eAAe,GAAGrB,SAAS,CAACqB,eAAe;IACjD,MAAMkB,wBAAwB,GAAG7C,KAAK,CAAC8C,+BAA+B,CAACnB,eAAe,CAAC;IACvF,IAAIW,IAAI,GAAGvC,MAAM,CAAC8B,oBAAoB,CAACtB,WAAW,CAAC;IACnD,IAAIsC,wBAAwB,KAAK,CAAC,EAAE;MAChC,MAAME,SAAS,GAAG/C,KAAK,CAACgD,cAAc,CAACrB,eAAe,CAAC;MACvDW,IAAI,IAAIS,SAAS,CAACE,SAAS,CAACJ,wBAAwB,GAAG,CAAC,EAAEvC,SAAS,CAACsB,WAAW,GAAG,CAAC,CAAC;IACxF;IACAU,IAAI,IAAII,eAAe,GAAGxC,EAAE,GAAG,EAAE;IACjC,MAAMmC,KAAK,GAAG,IAAIjD,KAAK,CAACuC,eAAe,EAAE,CAAC,EAAErB,SAAS,CAAC4C,aAAa,EAAE5C,SAAS,CAAC6C,SAAS,CAAC;IACzF,OAAO;MAAEd,KAAK;MAAEC;IAAK,CAAC;EAC1B;AACJ;AACA,OAAO,MAAMc,4BAA4B,CAAC;EACtC,OAAOtD,QAAQA,CAACuD,qBAAqB,EAAEtD,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEqD,oBAAoB,EAAEpD,EAAE,EAAE;IACxF,IAAIqD,qBAAqB,CAACxD,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEqD,oBAAoB,EAAEpD,EAAE,CAAC,EAAE;MAC5E,OAAO,IAAI,CAACsD,uBAAuB,CAACH,qBAAqB,EAAEpD,UAAU,EAAEC,EAAE,CAAC;IAC9E;IACA;EACJ;EACA,OAAOsD,uBAAuBA,CAACH,qBAAqB,EAAEpD,UAAU,EAAEC,EAAE,EAAE;IAClE,MAAM4B,QAAQ,GAAG,EAAE;IACnB,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGf,UAAU,CAACgB,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnD,MAAMT,SAAS,GAAGL,UAAU,CAACc,CAAC,CAAC;MAC/B,MAAM0C,QAAQ,GAAGnD,SAAS,CAACoD,WAAW,CAAC,CAAC;MACxC,MAAMC,aAAa,GAAG,IAAIvE,KAAK,CAACqE,QAAQ,CAACpC,UAAU,EAAEoC,QAAQ,CAACG,MAAM,EAAEH,QAAQ,CAACpC,UAAU,EAAEoC,QAAQ,CAACG,MAAM,GAAG,CAAC,CAAC;MAC/G9B,QAAQ,CAACf,CAAC,CAAC,GAAG,IAAIpC,cAAc,CAACgF,aAAa,EAAEzD,EAAE,CAAC;IACvD;IACA,OAAO,IAAIjB,mBAAmB,CAAC,CAAC,CAAC,qCAAqC6C,QAAQ,EAAE;MAC5EU,4BAA4B,EAAEqB,6BAA6B,CAACR,qBAAqB,EAAE,CAAC,CAAC,mCAAmC,CAAC;MACzHZ,2BAA2B,EAAE;IACjC,CAAC,CAAC;EACN;AACJ;AACA,OAAO,MAAMqB,4CAA4C,CAAC;EACtD,OAAOhE,QAAQA,CAACC,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEqD,oBAAoB,EAAEpD,EAAE,EAAE;IACjE,IAAIqD,qBAAqB,CAACxD,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEqD,oBAAoB,EAAEpD,EAAE,CAAC,EAAE;MAC5E;MACA,MAAM4B,QAAQ,GAAG7B,UAAU,CAAC8B,GAAG,CAACgC,CAAC,IAAI,IAAIpF,cAAc,CAAC,IAAIS,KAAK,CAAC2E,CAAC,CAACC,kBAAkB,EAAED,CAAC,CAACE,cAAc,EAAEF,CAAC,CAACC,kBAAkB,EAAED,CAAC,CAACE,cAAc,GAAG,CAAC,CAAC,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC;MAClK,OAAO,IAAIhF,mBAAmB,CAAC,CAAC,CAAC,qCAAqC6C,QAAQ,EAAE;QAC5EU,4BAA4B,EAAE,IAAI;QAClCC,2BAA2B,EAAE;MACjC,CAAC,CAAC;IACN;IACA;EACJ;AACJ;AACA,OAAO,MAAM9B,gCAAgC,CAAC;EAC1C,OAAOb,QAAQA,CAACC,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEC,EAAE,EAAEgE,gBAAgB,EAAE/D,kBAAkB,EAAE;IACjF,IAAI,CAACA,kBAAkB,EAAE;MACrB,MAAMO,oBAAoB,GAAG,IAAI,CAACE,uBAAuB,CAACb,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEC,EAAE,EAAEgE,gBAAgB,CAAC;MAC1G,IAAIxD,oBAAoB,KAAK,IAAI,EAAE;QAC/B,OAAO,IAAI,CAACyD,2BAA2B,CAAClE,UAAU,EAAEC,EAAE,EAAEgE,gBAAgB,EAAExD,oBAAoB,CAAC;MACnG;IACJ;IACA;EACJ;EACA,OAAOyD,2BAA2BA,CAAClE,UAAU,EAAEC,EAAE,EAAEgE,gBAAgB,EAAExD,oBAAoB,EAAE;IACvF,MAAMoB,QAAQ,GAAG,EAAE;IACnB,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGf,UAAU,CAACgB,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnD,MAAMT,SAAS,GAAGL,UAAU,CAACc,CAAC,CAAC;MAC/Be,QAAQ,CAACf,CAAC,CAAC,GAAG,IAAIqD,0BAA0B,CAAC9D,SAAS,EAAEJ,EAAE,EAAE,CAACgE,gBAAgB,EAAExD,oBAAoB,CAAC;IACxG;IACA,OAAO,IAAIzB,mBAAmB,CAAC,CAAC,CAAC,qCAAqC6C,QAAQ,EAAE;MAC5EU,4BAA4B,EAAE,IAAI;MAClCC,2BAA2B,EAAE;IACjC,CAAC,CAAC;EACN;EACA,OAAO7B,uBAAuBA,CAACb,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEC,EAAE,EAAEgE,gBAAgB,EAAE;IAC5E,KAAK,MAAM5D,SAAS,IAAIL,UAAU,EAAE;MAChC,IAAI,CAACK,SAAS,CAAC+D,OAAO,CAAC,CAAC,EAAE;QACtB,OAAO,IAAI;MACf;IACJ;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,MAAMC,SAAS,GAAGrE,UAAU,CAAC8B,GAAG,CAAEgC,CAAC,IAAK;MACpC,MAAMN,QAAQ,GAAGM,CAAC,CAACL,WAAW,CAAC,CAAC;MAChC,IAAIQ,gBAAgB,EAAE;QAClB,OAAO;UAAE7C,UAAU,EAAEoC,QAAQ,CAACpC,UAAU;UAAEkD,YAAY,EAAEd,QAAQ,CAACG,MAAM,GAAG1D,EAAE,CAACe,MAAM;UAAEuD,WAAW,EAAEf,QAAQ,CAACG;QAAO,CAAC;MACvH,CAAC,MACI;QACD,OAAO;UAAEvC,UAAU,EAAEoC,QAAQ,CAACpC,UAAU;UAAEkD,YAAY,EAAEd,QAAQ,CAACG,MAAM;UAAEY,WAAW,EAAEf,QAAQ,CAACG;QAAO,CAAC;MAC3G;IACJ,CAAC,CAAC;IACF;IACA;IACA,MAAMa,IAAI,GAAG,IAAI,CAACC,wBAAwB,CAAC3E,MAAM,EAAEC,KAAK,EAAEsE,SAAS,CAACvC,GAAG,CAAC4C,CAAC,IAAI,IAAItF,QAAQ,CAACsF,CAAC,CAACtD,UAAU,EAAEsD,CAAC,CAACJ,YAAY,CAAC,CAAC,EAAErE,EAAE,CAAC;IAC7H,IAAI,CAACuE,IAAI,EAAE;MACP,OAAO,IAAI;IACf;IACA,IAAIG,eAAe;IACnB,IAAIC,qBAAqB;IACzB,MAAMC,SAAS,GAAG5F,OAAO,CAACgB,EAAE,CAAC;IAC7B,IAAI4E,SAAS,EAAE;MACXF,eAAe,GAAG7E,MAAM,CAACgF,iBAAiB;MAC1CF,qBAAqB,GAAG9E,MAAM,CAAC8E,qBAAqB,CAACG,KAAK;IAC9D,CAAC,MACI;MACD,MAAMC,iBAAiB,GAAGlF,MAAM,CAACmF,sBAAsB,GAAGT,IAAI,CAACU,IAAI,CAACC,QAAQ,CAACrF,MAAM,CAACmF,sBAAsB,CAAC,GAAG,KAAK;MACnH,IAAID,iBAAiB,EAAE;QACnBL,eAAe,GAAG7E,MAAM,CAACsF,mBAAmB;QAC5CR,qBAAqB,GAAG9E,MAAM,CAAC8E,qBAAqB,CAACS,OAAO;MAChE,CAAC,MACI;QACDV,eAAe,GAAG7E,MAAM,CAACwF,mBAAmB;QAC5CV,qBAAqB,GAAG9E,MAAM,CAAC8E,qBAAqB,CAACW,OAAO;MAChE;IACJ;IACA,IAAIZ,eAAe,KAAK,OAAO,EAAE;MAC7B,OAAO,IAAI;IACf;IACA;IACA;IACA;IACA;IACA,MAAMa,aAAa,GAAG,IAAI,CAACC,6BAA6B,CAAC3F,MAAM,EAAE0E,IAAI,CAAC;IACtE,MAAMkB,kBAAkB,GAAGF,aAAa,GAAGA,aAAa,CAACG,KAAK,GAAG,EAAE;IACnE,IAAIC,sBAAsB,GAAG,IAAI;IACjC,KAAK,MAAMpC,QAAQ,IAAIa,SAAS,EAAE;MAC9B,MAAM;QAAEjD,UAAU;QAAEkD,YAAY;QAAEC;MAAY,CAAC,GAAGf,QAAQ;MAC1D,MAAMqC,QAAQ,GAAG9F,KAAK,CAACgD,cAAc,CAAC3B,UAAU,CAAC;MACjD,MAAM0E,UAAU,GAAGD,QAAQ,CAAC7C,SAAS,CAAC,CAAC,EAAEsB,YAAY,GAAG,CAAC,CAAC;MAC1D,MAAMyB,SAAS,GAAGF,QAAQ,CAAC7C,SAAS,CAACuB,WAAW,GAAG,CAAC,CAAC;MACrD,IAAI,CAACwB,SAAS,CAACC,UAAU,CAACN,kBAAkB,CAAC,EAAE;QAC3CE,sBAAsB,GAAG,KAAK;MAClC;MACA;MACA,IAAIG,SAAS,CAAC/E,MAAM,GAAG,CAAC,EAAE;QACtB,MAAMiF,cAAc,GAAGF,SAAS,CAACG,MAAM,CAAC,CAAC,CAAC;QAC1C,MAAMC,kBAAkB,GAAG,IAAI,CAACC,qBAAqB,CAACtG,MAAM,EAAEiG,SAAS,CAAC;QACxE,IAAI,CAACI,kBAAkB,IAAI,CAACvB,qBAAqB,CAACqB,cAAc,CAAC,EAAE;UAC/D,OAAO,IAAI;QACf;MACJ;MACA;MACA,IAAIzB,IAAI,CAACU,IAAI,CAAClE,MAAM,KAAK,CAAC,KAAKf,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,GAAG,CAAC,IAAI0E,eAAe,KAAK,QAAQ,EAAE;QACvF,MAAM0B,cAAc,GAAGnH,uBAAuB,CAACY,MAAM,CAACuG,cAAc,EAAE,EAAE,CAAC;QACzE,IAAIP,UAAU,CAAC9E,MAAM,GAAG,CAAC,EAAE;UACvB,MAAMsF,eAAe,GAAGR,UAAU,CAACS,UAAU,CAACT,UAAU,CAAC9E,MAAM,GAAG,CAAC,CAAC;UACpE,IAAIqF,cAAc,CAACG,GAAG,CAACF,eAAe,CAAC,KAAK,CAAC,CAAC,kCAAkC;YAC5E,OAAO,IAAI;UACf;QACJ;MACJ;MACA,IAAI,CAACvG,KAAK,CAACkB,YAAY,CAACC,iBAAiB,CAACE,UAAU,CAAC,EAAE;QACnD;QACA,OAAO,IAAI;MACf;MACArB,KAAK,CAACkB,YAAY,CAACwF,iBAAiB,CAACrF,UAAU,CAAC;MAChD,MAAMsF,UAAU,GAAG3G,KAAK,CAACkB,YAAY,CAAC0F,aAAa,CAACvF,UAAU,CAAC;MAC/D,MAAMwF,gBAAgB,GAAGrH,sBAAsB,CAACmH,UAAU,EAAEpC,YAAY,GAAG,CAAC,CAAC;MAC7E,IAAI,CAACE,IAAI,CAACqC,eAAe,CAACD,gBAAgB,EAAEtC,YAAY,GAAGsC,gBAAgB,CAACE,eAAe,CAAC,EAAE;QAC1F,OAAO,IAAI;MACf;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,MAAMC,gBAAgB,GAAGvC,IAAI,CAACwC,oBAAoB,CAAC,CAAC;MACpD,IAAID,gBAAgB,EAAE;QAClB,MAAME,SAAS,GAAGlH,KAAK,CAACkB,YAAY,CAACiG,gCAAgC,CAAC9F,UAAU,EAAEkD,YAAY,EAAEyC,gBAAgB,CAAC;QACjH,IAAI,CAACvC,IAAI,CAAC2C,IAAI,CAACF,SAAS,CAAC,EAAE;UACvB,OAAO,IAAI;QACf;MACJ;IACJ;IACA,IAAIrB,sBAAsB,EAAE;MACxB,OAAOpB,IAAI,CAACmB,KAAK,CAAC3C,SAAS,CAAC,CAAC,EAAEwB,IAAI,CAACmB,KAAK,CAAC3E,MAAM,GAAG0E,kBAAkB,CAAC1E,MAAM,CAAC;IACjF,CAAC,MACI;MACD,OAAOwD,IAAI,CAACmB,KAAK;IACrB;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,OAAOF,6BAA6BA,CAAC3F,MAAM,EAAE0E,IAAI,EAAE;IAC/C,IAAIA,IAAI,CAACU,IAAI,CAAClE,MAAM,IAAI,CAAC,EAAE;MACvB,OAAO,IAAI;IACf;IACA,MAAMoG,QAAQ,GAAG5C,IAAI,CAACmB,KAAK,CAACO,MAAM,CAAC1B,IAAI,CAACmB,KAAK,CAAC3E,MAAM,GAAG,CAAC,CAAC;IACzD;IACA,MAAMqG,UAAU,GAAGvH,MAAM,CAACwH,gBAAgB,CAACC,0BAA0B,CAACf,GAAG,CAACY,QAAQ,CAAC,IAAI,EAAE;IACzF,IAAII,MAAM,GAAG,IAAI;IACjB,KAAK,MAAMC,SAAS,IAAIJ,UAAU,EAAE;MAChC,IAAII,SAAS,CAACvC,IAAI,KAAKV,IAAI,CAACU,IAAI,IAAIV,IAAI,CAACU,IAAI,CAACC,QAAQ,CAACsC,SAAS,CAACvC,IAAI,CAAC,IAAIV,IAAI,CAACmB,KAAK,CAAC+B,QAAQ,CAACD,SAAS,CAAC9B,KAAK,CAAC,EAAE;QAC5G,IAAI,CAAC6B,MAAM,IAAIC,SAAS,CAACvC,IAAI,CAAClE,MAAM,GAAGwG,MAAM,CAACtC,IAAI,CAAClE,MAAM,EAAE;UACvDwG,MAAM,GAAGC,SAAS;QACtB;MACJ;IACJ;IACA,OAAOD,MAAM;EACjB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAO/C,wBAAwBA,CAAC3E,MAAM,EAAEC,KAAK,EAAEsE,SAAS,EAAEpE,EAAE,EAAE;IAC1D,MAAMoH,UAAU,GAAGvH,MAAM,CAACwH,gBAAgB,CAACK,yBAAyB,CAACnB,GAAG,CAACvG,EAAE,CAAC;IAC5E,IAAI,CAACoH,UAAU,EAAE;MACb,OAAO,IAAI;IACf;IACA;IACA,IAAIG,MAAM,GAAG,IAAI;IACjB,KAAK,MAAMC,SAAS,IAAIJ,UAAU,EAAE;MAChC,IAAIG,MAAM,KAAK,IAAI,IAAIC,SAAS,CAACvC,IAAI,CAAClE,MAAM,GAAGwG,MAAM,CAACtC,IAAI,CAAClE,MAAM,EAAE;QAC/D,IAAI4G,gBAAgB,GAAG,IAAI;QAC3B,KAAK,MAAMpE,QAAQ,IAAIa,SAAS,EAAE;UAC9B,MAAMwD,YAAY,GAAG9H,KAAK,CAAC+H,eAAe,CAAC,IAAI3I,KAAK,CAACqE,QAAQ,CAACpC,UAAU,EAAEoC,QAAQ,CAACG,MAAM,GAAG8D,SAAS,CAACvC,IAAI,CAAClE,MAAM,GAAG,CAAC,EAAEwC,QAAQ,CAACpC,UAAU,EAAEoC,QAAQ,CAACG,MAAM,CAAC,CAAC;UAC7J,IAAIkE,YAAY,GAAG5H,EAAE,KAAKwH,SAAS,CAACvC,IAAI,EAAE;YACtC0C,gBAAgB,GAAG,KAAK;YACxB;UACJ;QACJ;QACA,IAAIA,gBAAgB,EAAE;UAClBJ,MAAM,GAAGC,SAAS;QACtB;MACJ;IACJ;IACA,OAAOD,MAAM;EACjB;EACA,OAAOpB,qBAAqBA,CAACtG,MAAM,EAAEiG,SAAS,EAAE;IAC5C;IACA,MAAMgC,QAAQ,GAAGhC,SAAS,CAACG,MAAM,CAAC,CAAC,CAAC;IACpC,MAAM8B,uBAAuB,GAAGlI,MAAM,CAACwH,gBAAgB,CAACW,2BAA2B,CAACzB,GAAG,CAACuB,QAAQ,CAAC,IAAI,EAAE;IACvG,MAAMG,sBAAsB,GAAGpI,MAAM,CAACwH,gBAAgB,CAACa,4BAA4B,CAAC3B,GAAG,CAACuB,QAAQ,CAAC,IAAI,EAAE;IACvG,MAAMK,qBAAqB,GAAGJ,uBAAuB,CAACK,IAAI,CAACC,CAAC,IAAIvC,SAAS,CAACC,UAAU,CAACsC,CAAC,CAACpD,IAAI,CAAC,CAAC;IAC7F,MAAMqD,oBAAoB,GAAGL,sBAAsB,CAACG,IAAI,CAACC,CAAC,IAAIvC,SAAS,CAACC,UAAU,CAACsC,CAAC,CAAC3C,KAAK,CAAC,CAAC;IAC5F,OAAO,CAACyC,qBAAqB,IAAIG,oBAAoB;EACzD;AACJ;AACA,OAAO,MAAMC,0BAA0B,CAAC;EACpC,OAAO3I,QAAQA,CAACC,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEC,EAAE,EAAEC,kBAAkB,EAAE;IAC/D,IAAI,CAACA,kBAAkB,IAAI,IAAI,CAACuI,wBAAwB,CAAC3I,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEC,EAAE,CAAC,EAAE;MACrF,OAAO,IAAI,CAACyI,yBAAyB,CAAC5I,MAAM,EAAEE,UAAU,EAAEC,EAAE,CAAC;IACjE;IACA;EACJ;EACA,OAAOyI,yBAAyBA,CAAC5I,MAAM,EAAEE,UAAU,EAAEC,EAAE,EAAE;IACrD,MAAM4B,QAAQ,GAAG,EAAE;IACnB,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGf,UAAU,CAACgB,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnD,MAAMT,SAAS,GAAGL,UAAU,CAACc,CAAC,CAAC;MAC/B,MAAM6H,cAAc,GAAG7I,MAAM,CAAC8I,gBAAgB,CAAC3I,EAAE,CAAC;MAClD4B,QAAQ,CAACf,CAAC,CAAC,GAAG,IAAI/B,wBAAwB,CAACsB,SAAS,EAAEJ,EAAE,EAAE0I,cAAc,CAAC;IAC7E;IACA,OAAO,IAAI3J,mBAAmB,CAAC,CAAC,CAAC,+BAA+B6C,QAAQ,EAAE;MACtEU,4BAA4B,EAAE,IAAI;MAClCC,2BAA2B,EAAE;IACjC,CAAC,CAAC;EACN;EACA,OAAOiG,wBAAwBA,CAAC3I,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEC,EAAE,EAAE;IAC3D,IAAI,CAAC4I,kBAAkB,CAAC/I,MAAM,EAAEG,EAAE,CAAC,IAAI,CAACH,MAAM,CAAC8I,gBAAgB,CAACE,cAAc,CAAC7I,EAAE,CAAC,EAAE;MAChF,OAAO,KAAK;IAChB;IACA,MAAM8I,uBAAuB,GAAG9J,OAAO,CAACgB,EAAE,CAAC;IAC3C,KAAK,MAAMI,SAAS,IAAIL,UAAU,EAAE;MAChC,IAAIK,SAAS,CAAC+D,OAAO,CAAC,CAAC,EAAE;QACrB,OAAO,KAAK;MAChB;MACA,IAAI4E,+BAA+B,GAAG,IAAI;MAC1C,KAAK,IAAI5H,UAAU,GAAGf,SAAS,CAACqB,eAAe,EAAEN,UAAU,IAAIf,SAAS,CAAC4C,aAAa,EAAE7B,UAAU,EAAE,EAAE;QAClG,MAAMyE,QAAQ,GAAG9F,KAAK,CAACgD,cAAc,CAAC3B,UAAU,CAAC;QACjD,MAAM6H,UAAU,GAAI7H,UAAU,KAAKf,SAAS,CAACqB,eAAe,GAAGrB,SAAS,CAACsB,WAAW,GAAG,CAAC,GAAG,CAAE;QAC7F,MAAMuH,QAAQ,GAAI9H,UAAU,KAAKf,SAAS,CAAC4C,aAAa,GAAG5C,SAAS,CAAC6C,SAAS,GAAG,CAAC,GAAG2C,QAAQ,CAAC7E,MAAO;QACrG,MAAMmI,YAAY,GAAGtD,QAAQ,CAAC7C,SAAS,CAACiG,UAAU,EAAEC,QAAQ,CAAC;QAC7D,IAAI,QAAQ,CAACE,IAAI,CAACD,YAAY,CAAC,EAAE;UAC7B;UACAH,+BAA+B,GAAG,KAAK;UACvC;QACJ;MACJ;MACA,IAAIA,+BAA+B,EAAE;QACjC,OAAO,KAAK;MAChB;MACA,IAAID,uBAAuB,IAAI1I,SAAS,CAACqB,eAAe,KAAKrB,SAAS,CAAC4C,aAAa,IAAI5C,SAAS,CAACsB,WAAW,GAAG,CAAC,KAAKtB,SAAS,CAAC6C,SAAS,EAAE;QACvI,MAAMmG,aAAa,GAAGtJ,KAAK,CAAC+H,eAAe,CAACzH,SAAS,CAAC;QACtD,IAAIpB,OAAO,CAACoK,aAAa,CAAC,EAAE;UACxB;UACA;UACA,OAAO,KAAK;QAChB;MACJ;IACJ;IACA,OAAO,IAAI;EACf;AACJ;AACA,OAAO,MAAMC,gCAAgC,CAAC;EAC1C,OAAOzJ,QAAQA,CAACuD,qBAAqB,EAAEtD,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEC,EAAE,EAAEC,kBAAkB,EAAE;IACtF;IACA;IACA,IAAI,CAACA,kBAAkB,IAAI,IAAI,CAACqJ,8BAA8B,CAACzJ,MAAM,EAAEC,KAAK,EAAEC,UAAU,CAAC,EAAE;MACvF,MAAMwJ,CAAC,GAAG,IAAI,CAACC,4BAA4B,CAACrG,qBAAqB,EAAEtD,MAAM,EAAEC,KAAK,EAAEC,UAAU,CAAC,CAAC,CAAC,EAAEC,EAAE,CAAC;MACpG,IAAIuJ,CAAC,EAAE;QACH,OAAOA,CAAC;MACZ;IACJ;IACA;EACJ;EACA,OAAOD,8BAA8BA,CAACzJ,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAE;IAC7D,IAAIA,UAAU,CAACgB,MAAM,KAAK,CAAC,IAAIjB,KAAK,CAACkB,YAAY,CAACC,iBAAiB,CAAClB,UAAU,CAAC,CAAC,CAAC,CAACmB,cAAc,CAAC,CAAC,CAACC,UAAU,CAAC,EAAE;MAC5G,OAAO,IAAI;IACf;IACA,OAAO,KAAK;EAChB;EACA,OAAOqI,4BAA4BA,CAACrG,qBAAqB,EAAEtD,MAAM,EAAEC,KAAK,EAAEM,SAAS,EAAEJ,EAAE,EAAE;IACrF,IAAI,CAACH,MAAM,CAAC4J,aAAa,CAACZ,cAAc,CAAC7I,EAAE,CAAC,IAAI,CAACI,SAAS,CAAC+D,OAAO,CAAC,CAAC,EAAE;MAClE,OAAO,IAAI;IACf;IACA,MAAMZ,QAAQ,GAAGnD,SAAS,CAACoD,WAAW,CAAC,CAAC;IACxC1D,KAAK,CAACkB,YAAY,CAACwF,iBAAiB,CAACjD,QAAQ,CAACpC,UAAU,CAAC;IACzD,MAAMsF,UAAU,GAAG3G,KAAK,CAACkB,YAAY,CAAC0F,aAAa,CAACnD,QAAQ,CAACpC,UAAU,CAAC;IACxE,IAAIuI,cAAc;IAClB,IAAI;MACAA,cAAc,GAAG7J,MAAM,CAAC8J,mBAAmB,CAAC3J,EAAE,EAAEyG,UAAU,EAAElD,QAAQ,CAACG,MAAM,CAAC;IAChF,CAAC,CACD,OAAOkG,CAAC,EAAE;MACNrL,iBAAiB,CAACqL,CAAC,CAAC;MACpB,OAAO,IAAI;IACf;IACA,IAAI,CAACF,cAAc,EAAE;MACjB,OAAO,IAAI;IACf;IACA,IAAIA,cAAc,CAACG,gBAAgB,EAAE;MACjC,MAAM5G,SAAS,GAAG,CAACwD,UAAU,CAAC3D,cAAc,CAAC,CAAC,GAAG9C,EAAE,EAAE8J,WAAW,CAACJ,cAAc,CAACG,gBAAgB,CAAC,GAAG,CAAC;MACrG,MAAME,KAAK,GAAGjK,KAAK,CAACkK,YAAY,CAACC,qBAAqB,CAACP,cAAc,CAACG,gBAAgB,EAAE;QACpF1I,UAAU,EAAEoC,QAAQ,CAACpC,UAAU;QAC/BuC,MAAM,EAAET;MACZ,CAAC,EAAE,GAAG,CAAC,mCAAmC,CAAC;MAC3C,IAAI8G,KAAK,EAAE;QACP,IAAIA,KAAK,CAACtI,eAAe,KAAK8B,QAAQ,CAACpC,UAAU,EAAE;UAC/C;UACA,OAAO,IAAI;QACf;QACA,MAAM+I,SAAS,GAAGpK,KAAK,CAACgD,cAAc,CAACiH,KAAK,CAACtI,eAAe,CAAC;QAC7D,MAAM0I,oBAAoB,GAAG3L,OAAO,CAAC4L,oBAAoB,CAACF,SAAS,CAAC;QACpE,MAAMG,cAAc,GAAGxK,MAAM,CAAC8B,oBAAoB,CAACwI,oBAAoB,CAAC;QACxE,MAAMvE,QAAQ,GAAG9F,KAAK,CAACgD,cAAc,CAACS,QAAQ,CAACpC,UAAU,CAAC;QAC1D,MAAMmJ,uBAAuB,GAAGxK,KAAK,CAAC8C,+BAA+B,CAACW,QAAQ,CAACpC,UAAU,CAAC,IAAIoC,QAAQ,CAACG,MAAM;QAC7G,MAAM6G,MAAM,GAAG3E,QAAQ,CAAC7C,SAAS,CAACuH,uBAAuB,GAAG,CAAC,EAAE/G,QAAQ,CAACG,MAAM,GAAG,CAAC,CAAC;QACnF,MAAM8G,QAAQ,GAAGH,cAAc,GAAGE,MAAM,GAAGvK,EAAE;QAC7C,MAAMyD,aAAa,GAAG,IAAIvE,KAAK,CAACqE,QAAQ,CAACpC,UAAU,EAAE,CAAC,EAAEoC,QAAQ,CAACpC,UAAU,EAAEoC,QAAQ,CAACG,MAAM,CAAC;QAC7F,MAAM+G,OAAO,GAAG,IAAIhM,cAAc,CAACgF,aAAa,EAAE+G,QAAQ,CAAC;QAC3D,OAAO,IAAIzL,mBAAmB,CAAC2L,kBAAkB,CAACF,QAAQ,EAAErH,qBAAqB,CAAC,EAAE,CAACsH,OAAO,CAAC,EAAE;UAC3FnI,4BAA4B,EAAE,KAAK;UACnCC,2BAA2B,EAAE;QACjC,CAAC,CAAC;MACN;IACJ;IACA,OAAO,IAAI;EACf;AACJ;AACA,OAAO,MAAMoI,4BAA4B,CAAC;EACtC,OAAO/K,QAAQA,CAACuD,qBAAqB,EAAEpD,UAAU,EAAEC,EAAE,EAAE;IACnD;IACA,MAAM4B,QAAQ,GAAG,EAAE;IACnB,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGf,UAAU,CAACgB,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnDe,QAAQ,CAACf,CAAC,CAAC,GAAG,IAAIpC,cAAc,CAACsB,UAAU,CAACc,CAAC,CAAC,EAAEb,EAAE,CAAC;IACvD;IACA,MAAM4K,MAAM,GAAGF,kBAAkB,CAAC1K,EAAE,EAAEmD,qBAAqB,CAAC;IAC5D,OAAO,IAAIpE,mBAAmB,CAAC6L,MAAM,EAAEhJ,QAAQ,EAAE;MAC7CU,4BAA4B,EAAEqB,6BAA6B,CAACR,qBAAqB,EAAEyH,MAAM,CAAC;MAC1FrI,2BAA2B,EAAE;IACjC,CAAC,CAAC;EACN;AACJ;AACA,OAAO,MAAMsI,cAAc,CAAC;EACxB,OAAOjL,QAAQA,CAACC,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEC,EAAE,EAAEC,kBAAkB,EAAE;IAC/D,IAAI,CAACA,kBAAkB,IAAID,EAAE,KAAK,IAAI,EAAE;MACpC,MAAM4B,QAAQ,GAAG,EAAE;MACnB,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGf,UAAU,CAACgB,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;QACnDe,QAAQ,CAACf,CAAC,CAAC,GAAG,IAAI,CAACiK,MAAM,CAACjL,MAAM,EAAEC,KAAK,EAAE,KAAK,EAAEC,UAAU,CAACc,CAAC,CAAC,CAAC;MAClE;MACA,OAAO,IAAI9B,mBAAmB,CAAC,CAAC,CAAC,qCAAqC6C,QAAQ,EAAE;QAC5EU,4BAA4B,EAAE,IAAI;QAClCC,2BAA2B,EAAE;MACjC,CAAC,CAAC;IACN;IACA;EACJ;EACA,OAAOuI,MAAMA,CAACjL,MAAM,EAAEC,KAAK,EAAEiL,YAAY,EAAE5I,KAAK,EAAE;IAC9C,IAAItC,MAAM,CAACe,UAAU,KAAK,CAAC,CAAC,qCAAqC;MAC7D,OAAOsB,WAAW,CAACC,KAAK,EAAE,IAAI,EAAE4I,YAAY,CAAC;IACjD;IACA,IAAI,CAACjL,KAAK,CAACkB,YAAY,CAACC,iBAAiB,CAACkB,KAAK,CAAC6I,gBAAgB,CAAC,CAAC,CAAC7J,UAAU,CAAC,IAAItB,MAAM,CAACe,UAAU,KAAK,CAAC,CAAC,qCAAqC;MAC3I,MAAMgF,QAAQ,GAAG9F,KAAK,CAACgD,cAAc,CAACX,KAAK,CAACV,eAAe,CAAC;MAC5D,MAAMpB,WAAW,GAAG7B,OAAO,CAAC4L,oBAAoB,CAACxE,QAAQ,CAAC,CAAC7C,SAAS,CAAC,CAAC,EAAEZ,KAAK,CAACT,WAAW,GAAG,CAAC,CAAC;MAC9F,OAAOQ,WAAW,CAACC,KAAK,EAAE,IAAI,GAAGtC,MAAM,CAAC8B,oBAAoB,CAACtB,WAAW,CAAC,EAAE0K,YAAY,CAAC;IAC5F;IACA,MAAMxB,CAAC,GAAG7J,cAAc,CAACG,MAAM,CAACe,UAAU,EAAEd,KAAK,EAAEqC,KAAK,EAAEtC,MAAM,CAAC0B,4BAA4B,CAAC;IAC9F,IAAIgI,CAAC,EAAE;MACH,IAAIA,CAAC,CAAC0B,YAAY,KAAK7L,YAAY,CAAC8L,IAAI,EAAE;QACtC;QACA,OAAOhJ,WAAW,CAACC,KAAK,EAAE,IAAI,GAAGtC,MAAM,CAAC8B,oBAAoB,CAAC4H,CAAC,CAAClJ,WAAW,GAAGkJ,CAAC,CAAC4B,UAAU,CAAC,EAAEJ,YAAY,CAAC;MAC7G,CAAC,MACI,IAAIxB,CAAC,CAAC0B,YAAY,KAAK7L,YAAY,CAACgM,MAAM,EAAE;QAC7C;QACA,OAAOlJ,WAAW,CAACC,KAAK,EAAE,IAAI,GAAGtC,MAAM,CAAC8B,oBAAoB,CAAC4H,CAAC,CAAClJ,WAAW,GAAGkJ,CAAC,CAAC4B,UAAU,CAAC,EAAEJ,YAAY,CAAC;MAC7G,CAAC,MACI,IAAIxB,CAAC,CAAC0B,YAAY,KAAK7L,YAAY,CAACiM,aAAa,EAAE;QACpD;QACA,MAAMC,YAAY,GAAGzL,MAAM,CAAC8B,oBAAoB,CAAC4H,CAAC,CAAClJ,WAAW,CAAC;QAC/D,MAAMkL,eAAe,GAAG1L,MAAM,CAAC8B,oBAAoB,CAAC4H,CAAC,CAAClJ,WAAW,GAAGkJ,CAAC,CAAC4B,UAAU,CAAC;QACjF,MAAMX,QAAQ,GAAG,IAAI,GAAGe,eAAe,GAAG,IAAI,GAAGD,YAAY;QAC7D,IAAIP,YAAY,EAAE;UACd,OAAO,IAAIpM,qCAAqC,CAACwD,KAAK,EAAEqI,QAAQ,EAAE,IAAI,CAAC;QAC3E,CAAC,MACI;UACD,OAAO,IAAI9L,mCAAmC,CAACyD,KAAK,EAAEqI,QAAQ,EAAE,CAAC,CAAC,EAAEe,eAAe,CAACxK,MAAM,GAAGuK,YAAY,CAACvK,MAAM,EAAE,IAAI,CAAC;QAC3H;MACJ,CAAC,MACI,IAAIwI,CAAC,CAAC0B,YAAY,KAAK7L,YAAY,CAACoM,OAAO,EAAE;QAC9C,MAAMpK,iBAAiB,GAAGE,aAAa,CAACzB,MAAM,EAAE0J,CAAC,CAAClJ,WAAW,CAAC;QAC9D,OAAO6B,WAAW,CAACC,KAAK,EAAE,IAAI,GAAGtC,MAAM,CAAC8B,oBAAoB,CAACP,iBAAiB,GAAGmI,CAAC,CAAC4B,UAAU,CAAC,EAAEJ,YAAY,CAAC;MACjH;IACJ;IACA,MAAMnF,QAAQ,GAAG9F,KAAK,CAACgD,cAAc,CAACX,KAAK,CAACV,eAAe,CAAC;IAC5D,MAAMpB,WAAW,GAAG7B,OAAO,CAAC4L,oBAAoB,CAACxE,QAAQ,CAAC,CAAC7C,SAAS,CAAC,CAAC,EAAEZ,KAAK,CAACT,WAAW,GAAG,CAAC,CAAC;IAC9F,IAAI7B,MAAM,CAACe,UAAU,IAAI,CAAC,CAAC,qCAAqC;MAC5D,MAAM6K,EAAE,GAAGjM,iBAAiB,CAACK,MAAM,CAACe,UAAU,EAAEd,KAAK,EAAEqC,KAAK,EAAE;QAC1Db,aAAa,EAAGoK,MAAM,IAAK;UACvB,OAAOpK,aAAa,CAACzB,MAAM,EAAE6L,MAAM,CAAC;QACxC,CAAC;QACDrK,WAAW,EAAGqK,MAAM,IAAK;UACrB,OAAOrK,WAAW,CAACxB,MAAM,EAAE6L,MAAM,CAAC;QACtC,CAAC;QACD/J,oBAAoB,EAAG+J,MAAM,IAAK;UAC9B,OAAO7L,MAAM,CAAC8B,oBAAoB,CAAC+J,MAAM,CAAC;QAC9C;MACJ,CAAC,EAAE7L,MAAM,CAAC0B,4BAA4B,CAAC;MACvC,IAAIkK,EAAE,EAAE;QACJ,IAAIE,gBAAgB,GAAG9L,MAAM,CAAC+L,uBAAuB,CAAC9L,KAAK,EAAEqC,KAAK,CAACjB,cAAc,CAAC,CAAC,CAAC;QACpF,MAAM2K,YAAY,GAAG1J,KAAK,CAACc,SAAS;QACpC,MAAM6I,cAAc,GAAGhM,KAAK,CAACgD,cAAc,CAACX,KAAK,CAACa,aAAa,CAAC;QAChE,MAAM+I,kBAAkB,GAAGvN,OAAO,CAACwN,uBAAuB,CAACF,cAAc,CAAC;QAC1E,IAAIC,kBAAkB,IAAI,CAAC,EAAE;UACzB5J,KAAK,GAAGA,KAAK,CAAC8J,cAAc,CAAC9J,KAAK,CAACa,aAAa,EAAEkJ,IAAI,CAACC,GAAG,CAAChK,KAAK,CAACc,SAAS,EAAE8I,kBAAkB,GAAG,CAAC,CAAC,CAAC;QACxG,CAAC,MACI;UACD5J,KAAK,GAAGA,KAAK,CAAC8J,cAAc,CAAC9J,KAAK,CAACa,aAAa,EAAElD,KAAK,CAACsM,gBAAgB,CAACjK,KAAK,CAACa,aAAa,CAAC,CAAC;QAClG;QACA,IAAI+H,YAAY,EAAE;UACd,OAAO,IAAIpM,qCAAqC,CAACwD,KAAK,EAAE,IAAI,GAAGtC,MAAM,CAAC8B,oBAAoB,CAAC8J,EAAE,CAACY,UAAU,CAAC,EAAE,IAAI,CAAC;QACpH,CAAC,MACI;UACD,IAAIC,MAAM,GAAG,CAAC;UACd,IAAIT,YAAY,IAAIE,kBAAkB,GAAG,CAAC,EAAE;YACxC,IAAI,CAAClM,MAAM,CAAC0M,YAAY,EAAE;cACtBZ,gBAAgB,GAAGO,IAAI,CAACM,IAAI,CAACb,gBAAgB,GAAG9L,MAAM,CAAC4M,UAAU,CAAC;YACtE;YACAH,MAAM,GAAGJ,IAAI,CAACQ,GAAG,CAACf,gBAAgB,GAAG,CAAC,GAAG9L,MAAM,CAAC8B,oBAAoB,CAAC8J,EAAE,CAACY,UAAU,CAAC,CAACtL,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;UACtG;UACA,OAAO,IAAIrC,mCAAmC,CAACyD,KAAK,EAAE,IAAI,GAAGtC,MAAM,CAAC8B,oBAAoB,CAAC8J,EAAE,CAACY,UAAU,CAAC,EAAE,CAAC,EAAEC,MAAM,EAAE,IAAI,CAAC;QAC7H;MACJ;IACJ;IACA,OAAOpK,WAAW,CAACC,KAAK,EAAE,IAAI,GAAGtC,MAAM,CAAC8B,oBAAoB,CAACtB,WAAW,CAAC,EAAE0K,YAAY,CAAC;EAC5F;EACA,OAAO4B,gBAAgBA,CAAC9M,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAE;IAC/C,IAAID,KAAK,KAAK,IAAI,IAAIC,UAAU,KAAK,IAAI,EAAE;MACvC,OAAO,EAAE;IACb;IACA,MAAM6B,QAAQ,GAAG,EAAE;IACnB,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGf,UAAU,CAACgB,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnD,IAAIM,UAAU,GAAGpB,UAAU,CAACc,CAAC,CAAC,CAACiD,kBAAkB;MACjD,IAAI3C,UAAU,KAAK,CAAC,EAAE;QAClBS,QAAQ,CAACf,CAAC,CAAC,GAAG,IAAIlC,qCAAqC,CAAC,IAAIO,KAAK,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC;MACxF,CAAC,MACI;QACDiC,UAAU,EAAE;QACZ,MAAMuC,MAAM,GAAG5D,KAAK,CAACsM,gBAAgB,CAACjL,UAAU,CAAC;QACjDS,QAAQ,CAACf,CAAC,CAAC,GAAG,IAAI,CAACiK,MAAM,CAACjL,MAAM,EAAEC,KAAK,EAAE,KAAK,EAAE,IAAIZ,KAAK,CAACiC,UAAU,EAAEuC,MAAM,EAAEvC,UAAU,EAAEuC,MAAM,CAAC,CAAC;MACtG;IACJ;IACA,OAAO9B,QAAQ;EACnB;EACA,OAAOgL,eAAeA,CAAC/M,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAE;IAC9C,IAAID,KAAK,KAAK,IAAI,IAAIC,UAAU,KAAK,IAAI,EAAE;MACvC,OAAO,EAAE;IACb;IACA,MAAM6B,QAAQ,GAAG,EAAE;IACnB,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGf,UAAU,CAACgB,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnD,MAAMM,UAAU,GAAGpB,UAAU,CAACc,CAAC,CAAC,CAACiD,kBAAkB;MACnD,MAAMJ,MAAM,GAAG5D,KAAK,CAACsM,gBAAgB,CAACjL,UAAU,CAAC;MACjDS,QAAQ,CAACf,CAAC,CAAC,GAAG,IAAI,CAACiK,MAAM,CAACjL,MAAM,EAAEC,KAAK,EAAE,KAAK,EAAE,IAAIZ,KAAK,CAACiC,UAAU,EAAEuC,MAAM,EAAEvC,UAAU,EAAEuC,MAAM,CAAC,CAAC;IACtG;IACA,OAAO9B,QAAQ;EACnB;EACA,OAAOiL,eAAeA,CAAChN,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAE;IAC9C,MAAM6B,QAAQ,GAAG,EAAE;IACnB,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGf,UAAU,CAACgB,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnDe,QAAQ,CAACf,CAAC,CAAC,GAAG,IAAI,CAACiK,MAAM,CAACjL,MAAM,EAAEC,KAAK,EAAE,IAAI,EAAEC,UAAU,CAACc,CAAC,CAAC,CAAC;IACjE;IACA,OAAOe,QAAQ;EACnB;AACJ;AACA,OAAO,MAAMkL,cAAc,CAAC;EACxB,OAAOlN,QAAQA,CAACC,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEqC,IAAI,EAAE2K,cAAc,EAAEC,eAAe,EAAE;IAC9E,MAAMC,gBAAgB,GAAG,IAAI,CAACC,yBAAyB,CAACrN,MAAM,EAAEE,UAAU,EAAEqC,IAAI,EAAE2K,cAAc,EAAEC,eAAe,CAAC;IAClH,IAAIC,gBAAgB,EAAE;MAClBlN,UAAU,GAAGA,UAAU,CAACoN,IAAI,CAACjO,KAAK,CAACkO,wBAAwB,CAAC;MAC5D,OAAO,IAAI,CAACC,iBAAiB,CAACxN,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEkN,gBAAgB,CAAC;IAC9E,CAAC,MACI;MACD,OAAO,IAAI,CAACK,YAAY,CAACzN,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEqC,IAAI,EAAE2K,cAAc,CAAC;IAC7E;EACJ;EACA,OAAOG,yBAAyBA,CAACrN,MAAM,EAAEE,UAAU,EAAEqC,IAAI,EAAE2K,cAAc,EAAEC,eAAe,EAAE;IACxF,IAAID,cAAc,EAAE;MAChB,OAAO,IAAI;IACf;IACA,IAAIhN,UAAU,CAACgB,MAAM,KAAK,CAAC,EAAE;MACzB,OAAO,IAAI;IACf;IACA,IAAIiM,eAAe,IAAIA,eAAe,CAACjM,MAAM,KAAKhB,UAAU,CAACgB,MAAM,EAAE;MACjE,OAAOiM,eAAe;IAC1B;IACA,IAAInN,MAAM,CAAC0N,gBAAgB,KAAK,QAAQ,EAAE;MACtC;MACA;MACA,IAAInL,IAAI,CAACkE,UAAU,CAAClE,IAAI,CAACrB,MAAM,GAAG,CAAC,CAAC,KAAK,EAAE,CAAC,yBAAyB;QACjEqB,IAAI,GAAGA,IAAI,CAACW,SAAS,CAAC,CAAC,EAAEX,IAAI,CAACrB,MAAM,GAAG,CAAC,CAAC;MAC7C;MACA;MACA,IAAIqB,IAAI,CAACkE,UAAU,CAAClE,IAAI,CAACrB,MAAM,GAAG,CAAC,CAAC,KAAK,EAAE,CAAC,+BAA+B;QACvEqB,IAAI,GAAGA,IAAI,CAACW,SAAS,CAAC,CAAC,EAAEX,IAAI,CAACrB,MAAM,GAAG,CAAC,CAAC;MAC7C;MACA,MAAMyM,KAAK,GAAGhP,OAAO,CAACiP,UAAU,CAACrL,IAAI,CAAC;MACtC,IAAIoL,KAAK,CAACzM,MAAM,KAAKhB,UAAU,CAACgB,MAAM,EAAE;QACpC,OAAOyM,KAAK;MAChB;IACJ;IACA,OAAO,IAAI;EACf;EACA,OAAOH,iBAAiBA,CAACxN,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEqC,IAAI,EAAE;IACtD,MAAMR,QAAQ,GAAG,EAAE;IACnB,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGf,UAAU,CAACgB,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnDe,QAAQ,CAACf,CAAC,CAAC,GAAG,IAAIpC,cAAc,CAACsB,UAAU,CAACc,CAAC,CAAC,EAAEuB,IAAI,CAACvB,CAAC,CAAC,CAAC;IAC5D;IACA,OAAO,IAAI9B,mBAAmB,CAAC,CAAC,CAAC,+BAA+B6C,QAAQ,EAAE;MACtEU,4BAA4B,EAAE,IAAI;MAClCC,2BAA2B,EAAE;IACjC,CAAC,CAAC;EACN;EACA,OAAO+K,YAAYA,CAACzN,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEqC,IAAI,EAAE2K,cAAc,EAAE;IACjE,MAAMnL,QAAQ,GAAG,EAAE;IACnB,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGf,UAAU,CAACgB,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnD,MAAMT,SAAS,GAAGL,UAAU,CAACc,CAAC,CAAC;MAC/B,MAAM0C,QAAQ,GAAGnD,SAAS,CAACoD,WAAW,CAAC,CAAC;MACxC,IAAIuJ,cAAc,IAAI,CAAC3M,SAAS,CAAC+D,OAAO,CAAC,CAAC,EAAE;QACxC4I,cAAc,GAAG,KAAK;MAC1B;MACA,IAAIA,cAAc,IAAI3K,IAAI,CAACsL,OAAO,CAAC,IAAI,CAAC,KAAKtL,IAAI,CAACrB,MAAM,GAAG,CAAC,EAAE;QAC1DgM,cAAc,GAAG,KAAK;MAC1B;MACA,IAAIA,cAAc,EAAE;QAChB;QACA,MAAMtJ,aAAa,GAAG,IAAIvE,KAAK,CAACqE,QAAQ,CAACpC,UAAU,EAAE,CAAC,EAAEoC,QAAQ,CAACpC,UAAU,EAAE,CAAC,CAAC;QAC/ES,QAAQ,CAACf,CAAC,CAAC,GAAG,IAAIjC,oCAAoC,CAAC6E,aAAa,EAAErB,IAAI,EAAEhC,SAAS,EAAE,IAAI,CAAC;MAChG,CAAC,MACI;QACDwB,QAAQ,CAACf,CAAC,CAAC,GAAG,IAAIpC,cAAc,CAAC2B,SAAS,EAAEgC,IAAI,CAAC;MACrD;IACJ;IACA,OAAO,IAAIrD,mBAAmB,CAAC,CAAC,CAAC,+BAA+B6C,QAAQ,EAAE;MACtEU,4BAA4B,EAAE,IAAI;MAClCC,2BAA2B,EAAE;IACjC,CAAC,CAAC;EACN;AACJ;AACA,OAAO,MAAMoL,oBAAoB,CAAC;EAC9B,OAAO/N,QAAQA,CAACuD,qBAAqB,EAAEtD,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEqC,IAAI,EAAEwL,kBAAkB,EAAEC,kBAAkB,EAAEC,aAAa,EAAE;IAC3H,MAAMlM,QAAQ,GAAG7B,UAAU,CAAC8B,GAAG,CAACzB,SAAS,IAAI,IAAI,CAAC2N,gBAAgB,CAACjO,KAAK,EAAEM,SAAS,EAAEgC,IAAI,EAAEwL,kBAAkB,EAAEC,kBAAkB,EAAEC,aAAa,CAAC,CAAC;IAClJ,OAAO,IAAI/O,mBAAmB,CAAC,CAAC,CAAC,qCAAqC6C,QAAQ,EAAE;MAC5EU,4BAA4B,EAAEqB,6BAA6B,CAACR,qBAAqB,EAAE,CAAC,CAAC,mCAAmC,CAAC;MACzHZ,2BAA2B,EAAE;IACjC,CAAC,CAAC;EACN;EACA,OAAOwL,gBAAgBA,CAACjO,KAAK,EAAEM,SAAS,EAAEgC,IAAI,EAAEwL,kBAAkB,EAAEC,kBAAkB,EAAEC,aAAa,EAAE;IACnG,IAAI,CAAC1N,SAAS,CAAC+D,OAAO,CAAC,CAAC,EAAE;MACtB;MACA;MACA;MACA,OAAO,IAAI;IACf;IACA,MAAM6J,GAAG,GAAG5N,SAAS,CAACoD,WAAW,CAAC,CAAC;IACnC,MAAM9B,WAAW,GAAGwK,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE6B,GAAG,CAACtK,MAAM,GAAGkK,kBAAkB,CAAC;IAChE,MAAM3K,SAAS,GAAGiJ,IAAI,CAACQ,GAAG,CAAC5M,KAAK,CAACsM,gBAAgB,CAAC4B,GAAG,CAAC7M,UAAU,CAAC,EAAE6M,GAAG,CAACtK,MAAM,GAAGmK,kBAAkB,CAAC;IACnG,MAAM1L,KAAK,GAAG,IAAIjD,KAAK,CAAC8O,GAAG,CAAC7M,UAAU,EAAEO,WAAW,EAAEsM,GAAG,CAAC7M,UAAU,EAAE8B,SAAS,CAAC;IAC/E,MAAMgL,OAAO,GAAGnO,KAAK,CAAC+H,eAAe,CAAC1F,KAAK,CAAC;IAC5C,IAAI8L,OAAO,KAAK7L,IAAI,IAAI0L,aAAa,KAAK,CAAC,EAAE;MACzC;MACA,OAAO,IAAI;IACf;IACA,OAAO,IAAIpP,mCAAmC,CAACyD,KAAK,EAAEC,IAAI,EAAE,CAAC,EAAE0L,aAAa,CAAC;EACjF;AACJ;AACA,OAAO,MAAMI,gCAAgC,CAAC;EAC1C,OAAOtO,QAAQA,CAACuD,qBAAqB,EAAEpD,UAAU,EAAEoO,GAAG,EAAE;IACpD,MAAMvM,QAAQ,GAAG,EAAE;IACnB,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGf,UAAU,CAACgB,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnDe,QAAQ,CAACf,CAAC,CAAC,GAAG,IAAIpC,cAAc,CAACsB,UAAU,CAACc,CAAC,CAAC,EAAEsN,GAAG,CAAC;IACxD;IACA,MAAMvD,MAAM,GAAGF,kBAAkB,CAACyD,GAAG,EAAEhL,qBAAqB,CAAC;IAC7D,OAAO,IAAIpE,mBAAmB,CAAC6L,MAAM,EAAEhJ,QAAQ,EAAE;MAC7CU,4BAA4B,EAAEqB,6BAA6B,CAACR,qBAAqB,EAAEyH,MAAM,CAAC;MAC1FrI,2BAA2B,EAAE;IACjC,CAAC,CAAC;EACN;AACJ;AACA,OAAO,MAAM6L,YAAY,CAAC;EACtB,OAAOC,WAAWA,CAACxO,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAE;IAC1C,MAAM6B,QAAQ,GAAG,EAAE;IACnB,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGf,UAAU,CAACgB,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnD,MAAMT,SAAS,GAAGL,UAAU,CAACc,CAAC,CAAC;MAC/B,IAAIT,SAAS,CAAC+D,OAAO,CAAC,CAAC,EAAE;QACrB,MAAMyB,QAAQ,GAAG9F,KAAK,CAACgD,cAAc,CAAC1C,SAAS,CAACqB,eAAe,CAAC;QAChE,IAAI,OAAO,CAAC0H,IAAI,CAACvD,QAAQ,CAAC,IAAI9F,KAAK,CAACkB,YAAY,CAACC,iBAAiB,CAACb,SAAS,CAACqB,eAAe,CAAC,EAAE;UAC3F,IAAI6M,UAAU,GAAG,IAAI,CAACC,kBAAkB,CAAC1O,MAAM,EAAEC,KAAK,EAAEM,SAAS,CAACqB,eAAe,CAAC;UAClF6M,UAAU,GAAGA,UAAU,IAAI,IAAI;UAC/B,MAAME,gBAAgB,GAAG3O,MAAM,CAAC8B,oBAAoB,CAAC2M,UAAU,CAAC;UAChE,IAAI,CAAC1I,QAAQ,CAACG,UAAU,CAACyI,gBAAgB,CAAC,EAAE;YACxC5M,QAAQ,CAACf,CAAC,CAAC,GAAG,IAAIpC,cAAc,CAAC,IAAIS,KAAK,CAACkB,SAAS,CAACqB,eAAe,EAAE,CAAC,EAAErB,SAAS,CAACqB,eAAe,EAAEmE,QAAQ,CAAC7E,MAAM,GAAG,CAAC,CAAC,EAAEyN,gBAAgB,EAAE,IAAI,CAAC;YACjJ;UACJ;QACJ;QACA5M,QAAQ,CAACf,CAAC,CAAC,GAAG,IAAI,CAAC4N,wBAAwB,CAAC5O,MAAM,EAAEC,KAAK,EAAEM,SAAS,EAAE,IAAI,CAAC;MAC/E,CAAC,MACI;QACD,IAAIA,SAAS,CAACqB,eAAe,KAAKrB,SAAS,CAAC4C,aAAa,EAAE;UACvD,MAAM0L,aAAa,GAAG5O,KAAK,CAACsM,gBAAgB,CAAChM,SAAS,CAACqB,eAAe,CAAC;UACvE,IAAIrB,SAAS,CAACsB,WAAW,KAAK,CAAC,IAAItB,SAAS,CAAC6C,SAAS,KAAKyL,aAAa,EAAE;YACtE;YACA9M,QAAQ,CAACf,CAAC,CAAC,GAAG,IAAI,CAAC4N,wBAAwB,CAAC5O,MAAM,EAAEC,KAAK,EAAEM,SAAS,EAAE,KAAK,CAAC;YAC5E;UACJ;QACJ;QACAwB,QAAQ,CAACf,CAAC,CAAC,GAAG,IAAIhC,YAAY,CAACuB,SAAS,EAAE;UACtCuO,SAAS,EAAE,KAAK;UAChBC,OAAO,EAAE/O,MAAM,CAAC+O,OAAO;UACvBnC,UAAU,EAAE5M,MAAM,CAAC4M,UAAU;UAC7BF,YAAY,EAAE1M,MAAM,CAAC0M,YAAY;UACjCsC,WAAW,EAAEhP,MAAM,CAACgP,WAAW;UAC/BjO,UAAU,EAAEf,MAAM,CAACe;QACvB,CAAC,EAAEf,MAAM,CAAC0B,4BAA4B,CAAC;MAC3C;IACJ;IACA,OAAOK,QAAQ;EACnB;EACA,OAAO2M,kBAAkBA,CAAC1O,MAAM,EAAEC,KAAK,EAAEqB,UAAU,EAAE;IACjD,IAAI2N,MAAM,GAAG,IAAI;IACjB,IAAIzO,WAAW,GAAG,EAAE;IACpB,MAAM0O,oBAAoB,GAAGtP,uBAAuB,CAACI,MAAM,CAACe,UAAU,EAAEd,KAAK,EAAEqB,UAAU,EAAE,KAAK,EAAEtB,MAAM,CAAC0B,4BAA4B,CAAC;IACtI,IAAIwN,oBAAoB,EAAE;MACtBD,MAAM,GAAGC,oBAAoB,CAACD,MAAM;MACpCzO,WAAW,GAAG0O,oBAAoB,CAAC1O,WAAW;IAClD,CAAC,MACI,IAAIc,UAAU,GAAG,CAAC,EAAE;MACrB,IAAI6N,cAAc;MAClB,KAAKA,cAAc,GAAG7N,UAAU,GAAG,CAAC,EAAE6N,cAAc,IAAI,CAAC,EAAEA,cAAc,EAAE,EAAE;QACzE,MAAMpJ,QAAQ,GAAG9F,KAAK,CAACgD,cAAc,CAACkM,cAAc,CAAC;QACrD,MAAMC,gBAAgB,GAAGzQ,OAAO,CAAC0Q,sBAAsB,CAACtJ,QAAQ,CAAC;QACjE,IAAIqJ,gBAAgB,IAAI,CAAC,EAAE;UACvB;QACJ;MACJ;MACA,IAAID,cAAc,GAAG,CAAC,EAAE;QACpB;QACA,OAAO,IAAI;MACf;MACA,MAAMG,SAAS,GAAGrP,KAAK,CAACsM,gBAAgB,CAAC4C,cAAc,CAAC;MACxD,MAAMI,mBAAmB,GAAG1P,cAAc,CAACG,MAAM,CAACe,UAAU,EAAEd,KAAK,EAAE,IAAIZ,KAAK,CAAC8P,cAAc,EAAEG,SAAS,EAAEH,cAAc,EAAEG,SAAS,CAAC,EAAEtP,MAAM,CAAC0B,4BAA4B,CAAC;MAC1K,IAAI6N,mBAAmB,EAAE;QACrB/O,WAAW,GAAG+O,mBAAmB,CAAC/O,WAAW,GAAG+O,mBAAmB,CAACjE,UAAU;MAClF;IACJ;IACA,IAAI2D,MAAM,EAAE;MACR,IAAIA,MAAM,KAAK1P,YAAY,CAACgM,MAAM,EAAE;QAChC/K,WAAW,GAAGgB,WAAW,CAACxB,MAAM,EAAEQ,WAAW,CAAC;MAClD;MACA,IAAIyO,MAAM,KAAK1P,YAAY,CAACoM,OAAO,EAAE;QACjCnL,WAAW,GAAGiB,aAAa,CAACzB,MAAM,EAAEQ,WAAW,CAAC;MACpD;MACAA,WAAW,GAAGR,MAAM,CAAC8B,oBAAoB,CAACtB,WAAW,CAAC;IAC1D;IACA,IAAI,CAACA,WAAW,EAAE;MACd,OAAO,IAAI;IACf;IACA,OAAOA,WAAW;EACtB;EACA,OAAOoO,wBAAwBA,CAAC5O,MAAM,EAAEC,KAAK,EAAEM,SAAS,EAAEiP,qBAAqB,EAAE;IAC7E,IAAI7E,QAAQ,GAAG,EAAE;IACjB,MAAMjH,QAAQ,GAAGnD,SAAS,CAAC4K,gBAAgB,CAAC,CAAC;IAC7C,IAAInL,MAAM,CAAC0M,YAAY,EAAE;MACrB,MAAMX,uBAAuB,GAAG/L,MAAM,CAAC+L,uBAAuB,CAAC9L,KAAK,EAAEyD,QAAQ,CAAC;MAC/E,MAAMkJ,UAAU,GAAG5M,MAAM,CAAC4M,UAAU;MACpC,MAAM6C,SAAS,GAAG7C,UAAU,GAAIb,uBAAuB,GAAGa,UAAW;MACrE,KAAK,IAAI5L,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyO,SAAS,EAAEzO,CAAC,EAAE,EAAE;QAChC2J,QAAQ,IAAI,GAAG;MACnB;IACJ,CAAC,MACI;MACDA,QAAQ,GAAG,IAAI;IACnB;IACA,OAAO,IAAI/L,cAAc,CAAC2B,SAAS,EAAEoK,QAAQ,EAAE6E,qBAAqB,CAAC;EACzE;AACJ;AACA,OAAO,MAAME,8BAA8B,SAAS7Q,mCAAmC,CAAC;EACpF8Q,WAAWA,CAACpP,SAAS,EAAEgC,IAAI,EAAEqN,qBAAqB,EAAEC,iBAAiB,EAAEC,aAAa,EAAEjH,cAAc,EAAE;IAClG,KAAK,CAACtI,SAAS,EAAEgC,IAAI,EAAEqN,qBAAqB,EAAEC,iBAAiB,CAAC;IAChE,IAAI,CAACE,cAAc,GAAGD,aAAa;IACnC,IAAI,CAACE,eAAe,GAAGnH,cAAc;IACrC,IAAI,CAACoH,mBAAmB,GAAG,IAAI;IAC/B,IAAI,CAACC,cAAc,GAAG,IAAI;EAC9B;EACAC,4BAA4BA,CAAClQ,KAAK,EAAEqC,KAAK,EAAE8N,MAAM,EAAE;IAC/C,IAAI,CAACH,mBAAmB,GAAG,IAAI5Q,KAAK,CAACiD,KAAK,CAACV,eAAe,EAAEU,KAAK,CAACc,SAAS,GAAG,IAAI,CAAC4M,eAAe,CAAC9O,MAAM,EAAEoB,KAAK,CAACa,aAAa,EAAEb,KAAK,CAACc,SAAS,CAAC;IAChJ,IAAI,CAAC8M,cAAc,GAAG,IAAI7Q,KAAK,CAACiD,KAAK,CAACV,eAAe,EAAEU,KAAK,CAACc,SAAS,GAAG,IAAI,CAAC2M,cAAc,CAAC7O,MAAM,GAAG,IAAI,CAAC8O,eAAe,CAAC9O,MAAM,EAAEoB,KAAK,CAACa,aAAa,EAAEb,KAAK,CAACc,SAAS,CAAC;IACxK,OAAO,KAAK,CAACiN,kBAAkB,CAACpQ,KAAK,EAAEmQ,MAAM,CAAC;EAClD;AACJ;AACA,MAAM/L,0BAA0B,SAASqL,8BAA8B,CAAC;EACpEC,WAAWA,CAACpP,SAAS,EAAEuP,aAAa,EAAEQ,mBAAmB,EAAEzH,cAAc,EAAE;IACvE,MAAMtG,IAAI,GAAG,CAAC+N,mBAAmB,GAAGR,aAAa,GAAG,EAAE,IAAIjH,cAAc;IACxE,MAAM+G,qBAAqB,GAAG,CAAC;IAC/B,MAAMC,iBAAiB,GAAG,CAAChH,cAAc,CAAC3H,MAAM;IAChD,KAAK,CAACX,SAAS,EAAEgC,IAAI,EAAEqN,qBAAqB,EAAEC,iBAAiB,EAAEC,aAAa,EAAEjH,cAAc,CAAC;EACnG;EACAwH,kBAAkBA,CAACpQ,KAAK,EAAEmQ,MAAM,EAAE;IAC9B,MAAMG,qBAAqB,GAAGH,MAAM,CAACI,wBAAwB,CAAC,CAAC;IAC/D,MAAMlO,KAAK,GAAGiO,qBAAqB,CAAC,CAAC,CAAC,CAACjO,KAAK;IAC5C,OAAO,IAAI,CAAC6N,4BAA4B,CAAClQ,KAAK,EAAEqC,KAAK,EAAE8N,MAAM,CAAC;EAClE;AACJ;AACA,MAAMhO,wCAAwC,SAASsN,8BAA8B,CAAC;EAClFC,WAAWA,CAACc,mBAAmB,EAAElQ,SAAS,EAAEuP,aAAa,EAAEjH,cAAc,EAAE;IACvE,MAAMtG,IAAI,GAAGuN,aAAa,GAAGjH,cAAc;IAC3C,MAAM+G,qBAAqB,GAAG,CAAC;IAC/B,MAAMC,iBAAiB,GAAGC,aAAa,CAAC5O,MAAM;IAC9C,KAAK,CAACX,SAAS,EAAEgC,IAAI,EAAEqN,qBAAqB,EAAEC,iBAAiB,EAAEC,aAAa,EAAEjH,cAAc,CAAC;IAC/F,IAAI,CAAC6H,oBAAoB,GAAGD,mBAAmB;IAC/C,IAAI,CAACE,gBAAgB,GAAG;MAAErO,KAAK,EAAE/B,SAAS;MAAEgC;IAAK,CAAC;EACtD;EACAqO,iBAAiBA,CAAC3Q,KAAK,EAAE4Q,OAAO,EAAE;IAC9BA,OAAO,CAACC,uBAAuB,CAAC,IAAI,CAACJ,oBAAoB,CAACpO,KAAK,EAAE,IAAI,CAACoO,oBAAoB,CAACnO,IAAI,CAAC;IAChGsO,OAAO,CAACC,uBAAuB,CAAC,IAAI,CAACH,gBAAgB,CAACrO,KAAK,EAAE,IAAI,CAACqO,gBAAgB,CAACpO,IAAI,CAAC;EAC5F;EACA8N,kBAAkBA,CAACpQ,KAAK,EAAEmQ,MAAM,EAAE;IAC9B,MAAMG,qBAAqB,GAAGH,MAAM,CAACI,wBAAwB,CAAC,CAAC;IAC/D,IAAID,qBAAqB,CAACrP,MAAM,KAAK,CAAC,EAAE;MACpC,MAAM,IAAI6P,KAAK,CAAC,8CAA8C,CAAC;IACnE;IACA,MAAMC,MAAM,GAAGT,qBAAqB,CAAC,CAAC,CAAC,CAACjO,KAAK;IAC7C,MAAM2O,MAAM,GAAGV,qBAAqB,CAAC,CAAC,CAAC,CAACjO,KAAK;IAC7C,MAAMA,KAAK,GAAG0O,MAAM,CAACE,SAAS,CAACD,MAAM,CAAC;IACtC,OAAO,IAAI,CAACd,4BAA4B,CAAClQ,KAAK,EAAEqC,KAAK,EAAE8N,MAAM,CAAC;EAClE;AACJ;AACA,SAASvF,kBAAkBA,CAACsG,SAAS,EAAEC,uBAAuB,EAAE;EAC5D,IAAID,SAAS,KAAK,GAAG,EAAE;IACnB,OAAOC,uBAAuB,KAAK,CAAC,CAAC,4CAC9BA,uBAAuB,KAAK,CAAC,CAAC,iDAC/B,CAAC,CAAC,iDACF,CAAC,CAAC;EACZ;EACA,OAAO,CAAC,CAAC;AACb;AACA,SAAStN,6BAA6BA,CAACsN,uBAAuB,EAAEC,eAAe,EAAE;EAC7E,IAAIC,iBAAiB,CAACF,uBAAuB,CAAC,IAAI,CAACE,iBAAiB,CAACD,eAAe,CAAC,EAAE;IACnF;IACA,OAAO,IAAI;EACf;EACA,IAAID,uBAAuB,KAAK,CAAC,CAAC,0CAA0C;IACxE;IACA;IACA,OAAO,KAAK;EAChB;EACA;EACA,OAAOG,sBAAsB,CAACH,uBAAuB,CAAC,KAAKG,sBAAsB,CAACF,eAAe,CAAC;AACtG;AACA,SAASE,sBAAsBA,CAACC,IAAI,EAAE;EAClC,OAAQA,IAAI,KAAK,CAAC,CAAC,kDAAkDA,IAAI,KAAK,CAAC,CAAC,2CAC1E,OAAO,GACPA,IAAI;AACd;AACA,SAASF,iBAAiBA,CAACE,IAAI,EAAE;EAC7B,OAAOA,IAAI,KAAK,CAAC,CAAC,uCACXA,IAAI,KAAK,CAAC,CAAC,4CACXA,IAAI,KAAK,CAAC,CAAC;AACtB;AACA,SAAShO,qBAAqBA,CAACxD,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEqD,oBAAoB,EAAEpD,EAAE,EAAE;EAChF,IAAIH,MAAM,CAACyR,mBAAmB,KAAK,OAAO,EAAE;IACxC,OAAO,KAAK;EAChB;EACA,IAAI,CAACzR,MAAM,CAACwH,gBAAgB,CAACkK,+BAA+B,CAACC,GAAG,CAACxR,EAAE,CAAC,EAAE;IAClE,OAAO,KAAK;EAChB;EACA,KAAK,IAAIa,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGf,UAAU,CAACgB,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;IACnD,MAAMT,SAAS,GAAGL,UAAU,CAACc,CAAC,CAAC;IAC/B,IAAI,CAACT,SAAS,CAAC+D,OAAO,CAAC,CAAC,EAAE;MACtB,OAAO,KAAK;IAChB;IACA,MAAMZ,QAAQ,GAAGnD,SAAS,CAACoD,WAAW,CAAC,CAAC;IACxC,MAAMoC,QAAQ,GAAG9F,KAAK,CAACgD,cAAc,CAACS,QAAQ,CAACpC,UAAU,CAAC;IAC1D,MAAMsQ,cAAc,GAAG7L,QAAQ,CAACK,MAAM,CAAC1C,QAAQ,CAACG,MAAM,GAAG,CAAC,CAAC;IAC3D,IAAI+N,cAAc,KAAKzR,EAAE,EAAE;MACvB,OAAO,KAAK;IAChB;IACA;IACA,MAAM4E,SAAS,GAAG5F,OAAO,CAACgB,EAAE,CAAC;IAC7B,MAAM0R,eAAe,GAAGnO,QAAQ,CAACG,MAAM,GAAG,CAAC,GAAGkC,QAAQ,CAACU,UAAU,CAAC/C,QAAQ,CAACG,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;IAC3F,IAAIgO,eAAe,KAAK,EAAE,CAAC,4BAA4B9M,SAAS,EAAE;MAC9D,OAAO,KAAK;IAChB;IACA;IACA,IAAI/E,MAAM,CAACyR,mBAAmB,KAAK,MAAM,EAAE;MACvC,IAAIK,KAAK,GAAG,KAAK;MACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAGzO,oBAAoB,CAACrC,MAAM,EAAE6Q,CAAC,GAAGC,IAAI,EAAED,CAAC,EAAE,EAAE;QAC/D,MAAME,mBAAmB,GAAG1O,oBAAoB,CAACwO,CAAC,CAAC;QACnD,IAAIrO,QAAQ,CAACpC,UAAU,KAAK2Q,mBAAmB,CAACrQ,eAAe,IAAI8B,QAAQ,CAACG,MAAM,KAAKoO,mBAAmB,CAACpQ,WAAW,EAAE;UACpHiQ,KAAK,GAAG,IAAI;UACZ;QACJ;MACJ;MACA,IAAI,CAACA,KAAK,EAAE;QACR,OAAO,KAAK;MAChB;IACJ;EACJ;EACA,OAAO,IAAI;AACf;AACA,SAASzP,WAAWA,CAACC,KAAK,EAAEC,IAAI,EAAE2I,YAAY,EAAE;EAC5C,IAAIA,YAAY,EAAE;IACd,OAAO,IAAIpM,qCAAqC,CAACwD,KAAK,EAAEC,IAAI,EAAE,IAAI,CAAC;EACvE,CAAC,MACI;IACD,OAAO,IAAI3D,cAAc,CAAC0D,KAAK,EAAEC,IAAI,EAAE,IAAI,CAAC;EAChD;AACJ;AACA,OAAO,SAASf,WAAWA,CAACxB,MAAM,EAAEQ,WAAW,EAAE0R,KAAK,EAAE;EACpDA,KAAK,GAAGA,KAAK,IAAI,CAAC;EAClB,OAAOlT,YAAY,CAACwC,WAAW,CAAChB,WAAW,EAAEA,WAAW,CAACU,MAAM,GAAGgR,KAAK,EAAElS,MAAM,CAAC+O,OAAO,EAAE/O,MAAM,CAAC4M,UAAU,EAAE5M,MAAM,CAAC0M,YAAY,CAAC;AACpI;AACA,OAAO,SAASjL,aAAaA,CAACzB,MAAM,EAAEQ,WAAW,EAAE0R,KAAK,EAAE;EACtDA,KAAK,GAAGA,KAAK,IAAI,CAAC;EAClB,OAAOlT,YAAY,CAACyC,aAAa,CAACjB,WAAW,EAAEA,WAAW,CAACU,MAAM,GAAGgR,KAAK,EAAElS,MAAM,CAAC+O,OAAO,EAAE/O,MAAM,CAAC4M,UAAU,EAAE5M,MAAM,CAAC0M,YAAY,CAAC;AACtI;AACA,OAAO,SAAS3D,kBAAkBA,CAAC/I,MAAM,EAAEG,EAAE,EAAE;EAC3C,IAAIhB,OAAO,CAACgB,EAAE,CAAC,EAAE;IACb,OAAQH,MAAM,CAACmS,YAAY,KAAK,QAAQ,IAAInS,MAAM,CAACmS,YAAY,KAAK,iBAAiB;EACzF,CAAC,MACI;IACD;IACA,OAAQnS,MAAM,CAACmS,YAAY,KAAK,UAAU,IAAInS,MAAM,CAACmS,YAAY,KAAK,iBAAiB;EAC3F;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}