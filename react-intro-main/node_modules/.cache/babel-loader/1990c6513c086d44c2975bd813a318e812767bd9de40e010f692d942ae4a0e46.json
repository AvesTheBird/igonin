{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createCancelablePromise, TimeoutTimer } from '../../../../base/common/async.js';\nimport { isCancellationError } from '../../../../base/common/errors.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { isEqual } from '../../../../base/common/resources.js';\nimport { ShowLightbulbIconMode } from '../../../common/config/editorOptions.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { Progress } from '../../../../platform/progress/common/progress.js';\nimport { CodeActionKind, CodeActionTriggerSource } from '../common/types.js';\nimport { getCodeActions } from './codeAction.js';\nimport { HierarchicalKind } from '../../../../base/common/hierarchicalKind.js';\nimport { StopWatch } from '../../../../base/common/stopwatch.js';\nexport const SUPPORTED_CODE_ACTIONS = new RawContextKey('supportedCodeAction', '');\nexport const APPLY_FIX_ALL_COMMAND_ID = '_typescript.applyFixAllCodeAction';\nclass CodeActionOracle extends Disposable {\n  constructor(_editor, _markerService, _signalChange) {\n    let _delay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 250;\n    super();\n    this._editor = _editor;\n    this._markerService = _markerService;\n    this._signalChange = _signalChange;\n    this._delay = _delay;\n    this._autoTriggerTimer = this._register(new TimeoutTimer());\n    this._register(this._markerService.onMarkerChanged(e => this._onMarkerChanges(e)));\n    this._register(this._editor.onDidChangeCursorPosition(() => this._tryAutoTrigger()));\n  }\n  trigger(trigger) {\n    const selection = this._getRangeOfSelectionUnlessWhitespaceEnclosed(trigger);\n    this._signalChange(selection ? {\n      trigger,\n      selection\n    } : undefined);\n  }\n  _onMarkerChanges(resources) {\n    const model = this._editor.getModel();\n    if (model && resources.some(resource => isEqual(resource, model.uri))) {\n      this._tryAutoTrigger();\n    }\n  }\n  _tryAutoTrigger() {\n    this._autoTriggerTimer.cancelAndSet(() => {\n      this.trigger({\n        type: 2 /* CodeActionTriggerType.Auto */,\n        triggerAction: CodeActionTriggerSource.Default\n      });\n    }, this._delay);\n  }\n  _getRangeOfSelectionUnlessWhitespaceEnclosed(trigger) {\n    if (!this._editor.hasModel()) {\n      return undefined;\n    }\n    const selection = this._editor.getSelection();\n    if (trigger.type === 1 /* CodeActionTriggerType.Invoke */) {\n      return selection;\n    }\n    const enabled = this._editor.getOption(65 /* EditorOption.lightbulb */).enabled;\n    if (enabled === ShowLightbulbIconMode.Off) {\n      return undefined;\n    } else if (enabled === ShowLightbulbIconMode.On) {\n      return selection;\n    } else if (enabled === ShowLightbulbIconMode.OnCode) {\n      const isSelectionEmpty = selection.isEmpty();\n      if (!isSelectionEmpty) {\n        return selection;\n      }\n      const model = this._editor.getModel();\n      const {\n        lineNumber,\n        column\n      } = selection.getPosition();\n      const line = model.getLineContent(lineNumber);\n      if (line.length === 0) {\n        // empty line\n        return undefined;\n      } else if (column === 1) {\n        // look only right\n        if (/\\s/.test(line[0])) {\n          return undefined;\n        }\n      } else if (column === model.getLineMaxColumn(lineNumber)) {\n        // look only left\n        if (/\\s/.test(line[line.length - 1])) {\n          return undefined;\n        }\n      } else {\n        // look left and right\n        if (/\\s/.test(line[column - 2]) && /\\s/.test(line[column - 1])) {\n          return undefined;\n        }\n      }\n    }\n    return selection;\n  }\n}\nexport var CodeActionsState;\n(function (CodeActionsState) {\n  CodeActionsState.Empty = {\n    type: 0 /* Type.Empty */\n  };\n  class Triggered {\n    constructor(trigger, position, _cancellablePromise) {\n      this.trigger = trigger;\n      this.position = position;\n      this._cancellablePromise = _cancellablePromise;\n      this.type = 1 /* Type.Triggered */;\n      this.actions = _cancellablePromise.catch(e => {\n        if (isCancellationError(e)) {\n          return emptyCodeActionSet;\n        }\n        throw e;\n      });\n    }\n    cancel() {\n      this._cancellablePromise.cancel();\n    }\n  }\n  CodeActionsState.Triggered = Triggered;\n})(CodeActionsState || (CodeActionsState = {}));\nconst emptyCodeActionSet = Object.freeze({\n  allActions: [],\n  validActions: [],\n  dispose: () => {},\n  documentation: [],\n  hasAutoFix: false,\n  hasAIFix: false,\n  allAIFixes: false\n});\nexport class CodeActionModel extends Disposable {\n  constructor(_editor, _registry, _markerService, contextKeyService, _progressService, _configurationService, _telemetryService) {\n    super();\n    this._editor = _editor;\n    this._registry = _registry;\n    this._markerService = _markerService;\n    this._progressService = _progressService;\n    this._configurationService = _configurationService;\n    this._telemetryService = _telemetryService;\n    this._codeActionOracle = this._register(new MutableDisposable());\n    this._state = CodeActionsState.Empty;\n    this._onDidChangeState = this._register(new Emitter());\n    this.onDidChangeState = this._onDidChangeState.event;\n    this._disposed = false;\n    this._supportedCodeActions = SUPPORTED_CODE_ACTIONS.bindTo(contextKeyService);\n    this._register(this._editor.onDidChangeModel(() => this._update()));\n    this._register(this._editor.onDidChangeModelLanguage(() => this._update()));\n    this._register(this._registry.onDidChange(() => this._update()));\n    this._register(this._editor.onDidChangeConfiguration(e => {\n      if (e.hasChanged(65 /* EditorOption.lightbulb */)) {\n        this._update();\n      }\n    }));\n    this._update();\n  }\n  dispose() {\n    if (this._disposed) {\n      return;\n    }\n    this._disposed = true;\n    super.dispose();\n    this.setState(CodeActionsState.Empty, true);\n  }\n  _settingEnabledNearbyQuickfixes() {\n    var _this$_editor;\n    const model = (_this$_editor = this._editor) === null || _this$_editor === void 0 ? void 0 : _this$_editor.getModel();\n    return this._configurationService ? this._configurationService.getValue('editor.codeActionWidget.includeNearbyQuickFixes', {\n      resource: model === null || model === void 0 ? void 0 : model.uri\n    }) : false;\n  }\n  _update() {\n    if (this._disposed) {\n      return;\n    }\n    this._codeActionOracle.value = undefined;\n    this.setState(CodeActionsState.Empty);\n    const model = this._editor.getModel();\n    if (model && this._registry.has(model) && !this._editor.getOption(92 /* EditorOption.readOnly */)) {\n      const supportedActions = this._registry.all(model).flatMap(provider => {\n        var _provider$providedCod;\n        return (_provider$providedCod = provider.providedCodeActionKinds) !== null && _provider$providedCod !== void 0 ? _provider$providedCod : [];\n      });\n      this._supportedCodeActions.set(supportedActions.join(' '));\n      this._codeActionOracle.value = new CodeActionOracle(this._editor, this._markerService, trigger => {\n        if (!trigger) {\n          this.setState(CodeActionsState.Empty);\n          return;\n        }\n        const startPosition = trigger.selection.getStartPosition();\n        const actions = createCancelablePromise(async token => {\n          var _trigger$trigger$filt;\n          if (this._settingEnabledNearbyQuickfixes() && trigger.trigger.type === 1 /* CodeActionTriggerType.Invoke */ && (trigger.trigger.triggerAction === CodeActionTriggerSource.QuickFix || (_trigger$trigger$filt = trigger.trigger.filter) !== null && _trigger$trigger$filt !== void 0 && (_trigger$trigger$filt = _trigger$trigger$filt.include) !== null && _trigger$trigger$filt !== void 0 && _trigger$trigger$filt.contains(CodeActionKind.QuickFix))) {\n            var _codeActionSet$validA;\n            const codeActionSet = await getCodeActions(this._registry, model, trigger.selection, trigger.trigger, Progress.None, token);\n            const allCodeActions = [...codeActionSet.allActions];\n            if (token.isCancellationRequested) {\n              return emptyCodeActionSet;\n            }\n            // Search for quickfixes in the curret code action set.\n            const foundQuickfix = (_codeActionSet$validA = codeActionSet.validActions) === null || _codeActionSet$validA === void 0 ? void 0 : _codeActionSet$validA.some(action => action.action.kind ? CodeActionKind.QuickFix.contains(new HierarchicalKind(action.action.kind)) : false);\n            const allMarkers = this._markerService.read({\n              resource: model.uri\n            });\n            if (foundQuickfix) {\n              for (const action of codeActionSet.validActions) {\n                var _action$action$comman;\n                if ((_action$action$comman = action.action.command) !== null && _action$action$comman !== void 0 && (_action$action$comman = _action$action$comman.arguments) !== null && _action$action$comman !== void 0 && _action$action$comman.some(arg => typeof arg === 'string' && arg.includes(APPLY_FIX_ALL_COMMAND_ID))) {\n                  action.action.diagnostics = [...allMarkers.filter(marker => marker.relatedInformation)];\n                }\n              }\n              return {\n                validActions: codeActionSet.validActions,\n                allActions: allCodeActions,\n                documentation: codeActionSet.documentation,\n                hasAutoFix: codeActionSet.hasAutoFix,\n                hasAIFix: codeActionSet.hasAIFix,\n                allAIFixes: codeActionSet.allAIFixes,\n                dispose: () => {\n                  codeActionSet.dispose();\n                }\n              };\n            } else if (!foundQuickfix) {\n              // If markers exists, and there are no quickfixes found or length is zero, check for quickfixes on that line.\n              if (allMarkers.length > 0) {\n                const currPosition = trigger.selection.getPosition();\n                let trackedPosition = currPosition;\n                let distance = Number.MAX_VALUE;\n                const currentActions = [...codeActionSet.validActions];\n                for (const marker of allMarkers) {\n                  const col = marker.endColumn;\n                  const row = marker.endLineNumber;\n                  const startRow = marker.startLineNumber;\n                  // Found quickfix on the same line and check relative distance to other markers\n                  if (row === currPosition.lineNumber || startRow === currPosition.lineNumber) {\n                    var _trigger$trigger$filt2, _trigger$trigger$filt3, _trigger$trigger$cont;\n                    trackedPosition = new Position(row, col);\n                    const newCodeActionTrigger = {\n                      type: trigger.trigger.type,\n                      triggerAction: trigger.trigger.triggerAction,\n                      filter: {\n                        include: (_trigger$trigger$filt2 = trigger.trigger.filter) !== null && _trigger$trigger$filt2 !== void 0 && _trigger$trigger$filt2.include ? (_trigger$trigger$filt3 = trigger.trigger.filter) === null || _trigger$trigger$filt3 === void 0 ? void 0 : _trigger$trigger$filt3.include : CodeActionKind.QuickFix\n                      },\n                      autoApply: trigger.trigger.autoApply,\n                      context: {\n                        notAvailableMessage: ((_trigger$trigger$cont = trigger.trigger.context) === null || _trigger$trigger$cont === void 0 ? void 0 : _trigger$trigger$cont.notAvailableMessage) || '',\n                        position: trackedPosition\n                      }\n                    };\n                    const selectionAsPosition = new Selection(trackedPosition.lineNumber, trackedPosition.column, trackedPosition.lineNumber, trackedPosition.column);\n                    const actionsAtMarker = await getCodeActions(this._registry, model, selectionAsPosition, newCodeActionTrigger, Progress.None, token);\n                    if (actionsAtMarker.validActions.length !== 0) {\n                      for (const action of actionsAtMarker.validActions) {\n                        var _action$action$comman2;\n                        if ((_action$action$comman2 = action.action.command) !== null && _action$action$comman2 !== void 0 && (_action$action$comman2 = _action$action$comman2.arguments) !== null && _action$action$comman2 !== void 0 && _action$action$comman2.some(arg => typeof arg === 'string' && arg.includes(APPLY_FIX_ALL_COMMAND_ID))) {\n                          action.action.diagnostics = [...allMarkers.filter(marker => marker.relatedInformation)];\n                        }\n                      }\n                      if (codeActionSet.allActions.length === 0) {\n                        allCodeActions.push(...actionsAtMarker.allActions);\n                      }\n                      // Already filtered through to only get quickfixes, so no need to filter again.\n                      if (Math.abs(currPosition.column - col) < distance) {\n                        currentActions.unshift(...actionsAtMarker.validActions);\n                      } else {\n                        currentActions.push(...actionsAtMarker.validActions);\n                      }\n                    }\n                    distance = Math.abs(currPosition.column - col);\n                  }\n                }\n                const filteredActions = currentActions.filter((action, index, self) => self.findIndex(a => a.action.title === action.action.title) === index);\n                filteredActions.sort((a, b) => {\n                  if (a.action.isPreferred && !b.action.isPreferred) {\n                    return -1;\n                  } else if (!a.action.isPreferred && b.action.isPreferred) {\n                    return 1;\n                  } else if (a.action.isAI && !b.action.isAI) {\n                    return 1;\n                  } else if (!a.action.isAI && b.action.isAI) {\n                    return -1;\n                  } else {\n                    return 0;\n                  }\n                });\n                // Only retriggers if actually found quickfix on the same line as cursor\n                return {\n                  validActions: filteredActions,\n                  allActions: allCodeActions,\n                  documentation: codeActionSet.documentation,\n                  hasAutoFix: codeActionSet.hasAutoFix,\n                  hasAIFix: codeActionSet.hasAIFix,\n                  allAIFixes: codeActionSet.allAIFixes,\n                  dispose: () => {\n                    codeActionSet.dispose();\n                  }\n                };\n              }\n            }\n          }\n          // Case for manual triggers - specifically Source Actions and Refactors\n          if (trigger.trigger.type === 1 /* CodeActionTriggerType.Invoke */) {\n            const sw = new StopWatch();\n            const codeActions = await getCodeActions(this._registry, model, trigger.selection, trigger.trigger, Progress.None, token);\n            // Telemetry for duration of each code action on save.\n            if (this._telemetryService) {\n              this._telemetryService.publicLog2('codeAction.invokedDurations', {\n                codeActions: codeActions.validActions.length,\n                duration: sw.elapsed()\n              });\n            }\n            return codeActions;\n          }\n          return getCodeActions(this._registry, model, trigger.selection, trigger.trigger, Progress.None, token);\n        });\n        if (trigger.trigger.type === 1 /* CodeActionTriggerType.Invoke */) {\n          var _this$_progressServic;\n          (_this$_progressServic = this._progressService) === null || _this$_progressServic === void 0 || _this$_progressServic.showWhile(actions, 250);\n        }\n        const newState = new CodeActionsState.Triggered(trigger.trigger, startPosition, actions);\n        let isManualToAutoTransition = false;\n        if (this._state.type === 1 /* CodeActionsState.Type.Triggered */) {\n          // Check if the current state is manual and the new state is automatic\n          isManualToAutoTransition = this._state.trigger.type === 1 /* CodeActionTriggerType.Invoke */ && newState.type === 1 /* CodeActionsState.Type.Triggered */ && newState.trigger.type === 2 /* CodeActionTriggerType.Auto */ && this._state.position !== newState.position;\n        }\n        // Do not trigger state if current state is manual and incoming state is automatic\n        if (!isManualToAutoTransition) {\n          this.setState(newState);\n        } else {\n          // Reset the new state after getting code actions back.\n          setTimeout(() => {\n            this.setState(newState);\n          }, 500);\n        }\n      }, undefined);\n      this._codeActionOracle.value.trigger({\n        type: 2 /* CodeActionTriggerType.Auto */,\n        triggerAction: CodeActionTriggerSource.Default\n      });\n    } else {\n      this._supportedCodeActions.reset();\n    }\n  }\n  trigger(trigger) {\n    var _this$_codeActionOrac;\n    (_this$_codeActionOrac = this._codeActionOracle.value) === null || _this$_codeActionOrac === void 0 || _this$_codeActionOrac.trigger(trigger);\n  }\n  setState(newState, skipNotify) {\n    if (newState === this._state) {\n      return;\n    }\n    // Cancel old request\n    if (this._state.type === 1 /* CodeActionsState.Type.Triggered */) {\n      this._state.cancel();\n    }\n    this._state = newState;\n    if (!skipNotify && !this._disposed) {\n      this._onDidChangeState.fire(newState);\n    }\n  }\n}","map":{"version":3,"names":["createCancelablePromise","TimeoutTimer","isCancellationError","Emitter","Disposable","MutableDisposable","isEqual","ShowLightbulbIconMode","Position","Selection","RawContextKey","Progress","CodeActionKind","CodeActionTriggerSource","getCodeActions","HierarchicalKind","StopWatch","SUPPORTED_CODE_ACTIONS","APPLY_FIX_ALL_COMMAND_ID","CodeActionOracle","constructor","_editor","_markerService","_signalChange","_delay","arguments","length","undefined","_autoTriggerTimer","_register","onMarkerChanged","e","_onMarkerChanges","onDidChangeCursorPosition","_tryAutoTrigger","trigger","selection","_getRangeOfSelectionUnlessWhitespaceEnclosed","resources","model","getModel","some","resource","uri","cancelAndSet","type","triggerAction","Default","hasModel","getSelection","enabled","getOption","Off","On","OnCode","isSelectionEmpty","isEmpty","lineNumber","column","getPosition","line","getLineContent","test","getLineMaxColumn","CodeActionsState","Empty","Triggered","position","_cancellablePromise","actions","catch","emptyCodeActionSet","cancel","Object","freeze","allActions","validActions","dispose","documentation","hasAutoFix","hasAIFix","allAIFixes","CodeActionModel","_registry","contextKeyService","_progressService","_configurationService","_telemetryService","_codeActionOracle","_state","_onDidChangeState","onDidChangeState","event","_disposed","_supportedCodeActions","bindTo","onDidChangeModel","_update","onDidChangeModelLanguage","onDidChange","onDidChangeConfiguration","hasChanged","setState","_settingEnabledNearbyQuickfixes","_this$_editor","getValue","value","has","supportedActions","all","flatMap","provider","_provider$providedCod","providedCodeActionKinds","set","join","startPosition","getStartPosition","token","_trigger$trigger$filt","QuickFix","filter","include","contains","_codeActionSet$validA","codeActionSet","None","allCodeActions","isCancellationRequested","foundQuickfix","action","kind","allMarkers","read","_action$action$comman","command","arg","includes","diagnostics","marker","relatedInformation","currPosition","trackedPosition","distance","Number","MAX_VALUE","currentActions","col","endColumn","row","endLineNumber","startRow","startLineNumber","_trigger$trigger$filt2","_trigger$trigger$filt3","_trigger$trigger$cont","newCodeActionTrigger","autoApply","context","notAvailableMessage","selectionAsPosition","actionsAtMarker","_action$action$comman2","push","Math","abs","unshift","filteredActions","index","self","findIndex","a","title","sort","b","isPreferred","isAI","sw","codeActions","publicLog2","duration","elapsed","_this$_progressServic","showWhile","newState","isManualToAutoTransition","setTimeout","reset","_this$_codeActionOrac","skipNotify","fire"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createCancelablePromise, TimeoutTimer } from '../../../../base/common/async.js';\nimport { isCancellationError } from '../../../../base/common/errors.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { isEqual } from '../../../../base/common/resources.js';\nimport { ShowLightbulbIconMode } from '../../../common/config/editorOptions.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { Progress } from '../../../../platform/progress/common/progress.js';\nimport { CodeActionKind, CodeActionTriggerSource } from '../common/types.js';\nimport { getCodeActions } from './codeAction.js';\nimport { HierarchicalKind } from '../../../../base/common/hierarchicalKind.js';\nimport { StopWatch } from '../../../../base/common/stopwatch.js';\nexport const SUPPORTED_CODE_ACTIONS = new RawContextKey('supportedCodeAction', '');\nexport const APPLY_FIX_ALL_COMMAND_ID = '_typescript.applyFixAllCodeAction';\nclass CodeActionOracle extends Disposable {\n    constructor(_editor, _markerService, _signalChange, _delay = 250) {\n        super();\n        this._editor = _editor;\n        this._markerService = _markerService;\n        this._signalChange = _signalChange;\n        this._delay = _delay;\n        this._autoTriggerTimer = this._register(new TimeoutTimer());\n        this._register(this._markerService.onMarkerChanged(e => this._onMarkerChanges(e)));\n        this._register(this._editor.onDidChangeCursorPosition(() => this._tryAutoTrigger()));\n    }\n    trigger(trigger) {\n        const selection = this._getRangeOfSelectionUnlessWhitespaceEnclosed(trigger);\n        this._signalChange(selection ? { trigger, selection } : undefined);\n    }\n    _onMarkerChanges(resources) {\n        const model = this._editor.getModel();\n        if (model && resources.some(resource => isEqual(resource, model.uri))) {\n            this._tryAutoTrigger();\n        }\n    }\n    _tryAutoTrigger() {\n        this._autoTriggerTimer.cancelAndSet(() => {\n            this.trigger({ type: 2 /* CodeActionTriggerType.Auto */, triggerAction: CodeActionTriggerSource.Default });\n        }, this._delay);\n    }\n    _getRangeOfSelectionUnlessWhitespaceEnclosed(trigger) {\n        if (!this._editor.hasModel()) {\n            return undefined;\n        }\n        const selection = this._editor.getSelection();\n        if (trigger.type === 1 /* CodeActionTriggerType.Invoke */) {\n            return selection;\n        }\n        const enabled = this._editor.getOption(65 /* EditorOption.lightbulb */).enabled;\n        if (enabled === ShowLightbulbIconMode.Off) {\n            return undefined;\n        }\n        else if (enabled === ShowLightbulbIconMode.On) {\n            return selection;\n        }\n        else if (enabled === ShowLightbulbIconMode.OnCode) {\n            const isSelectionEmpty = selection.isEmpty();\n            if (!isSelectionEmpty) {\n                return selection;\n            }\n            const model = this._editor.getModel();\n            const { lineNumber, column } = selection.getPosition();\n            const line = model.getLineContent(lineNumber);\n            if (line.length === 0) {\n                // empty line\n                return undefined;\n            }\n            else if (column === 1) {\n                // look only right\n                if (/\\s/.test(line[0])) {\n                    return undefined;\n                }\n            }\n            else if (column === model.getLineMaxColumn(lineNumber)) {\n                // look only left\n                if (/\\s/.test(line[line.length - 1])) {\n                    return undefined;\n                }\n            }\n            else {\n                // look left and right\n                if (/\\s/.test(line[column - 2]) && /\\s/.test(line[column - 1])) {\n                    return undefined;\n                }\n            }\n        }\n        return selection;\n    }\n}\nexport var CodeActionsState;\n(function (CodeActionsState) {\n    CodeActionsState.Empty = { type: 0 /* Type.Empty */ };\n    class Triggered {\n        constructor(trigger, position, _cancellablePromise) {\n            this.trigger = trigger;\n            this.position = position;\n            this._cancellablePromise = _cancellablePromise;\n            this.type = 1 /* Type.Triggered */;\n            this.actions = _cancellablePromise.catch((e) => {\n                if (isCancellationError(e)) {\n                    return emptyCodeActionSet;\n                }\n                throw e;\n            });\n        }\n        cancel() {\n            this._cancellablePromise.cancel();\n        }\n    }\n    CodeActionsState.Triggered = Triggered;\n})(CodeActionsState || (CodeActionsState = {}));\nconst emptyCodeActionSet = Object.freeze({\n    allActions: [],\n    validActions: [],\n    dispose: () => { },\n    documentation: [],\n    hasAutoFix: false,\n    hasAIFix: false,\n    allAIFixes: false,\n});\nexport class CodeActionModel extends Disposable {\n    constructor(_editor, _registry, _markerService, contextKeyService, _progressService, _configurationService, _telemetryService) {\n        super();\n        this._editor = _editor;\n        this._registry = _registry;\n        this._markerService = _markerService;\n        this._progressService = _progressService;\n        this._configurationService = _configurationService;\n        this._telemetryService = _telemetryService;\n        this._codeActionOracle = this._register(new MutableDisposable());\n        this._state = CodeActionsState.Empty;\n        this._onDidChangeState = this._register(new Emitter());\n        this.onDidChangeState = this._onDidChangeState.event;\n        this._disposed = false;\n        this._supportedCodeActions = SUPPORTED_CODE_ACTIONS.bindTo(contextKeyService);\n        this._register(this._editor.onDidChangeModel(() => this._update()));\n        this._register(this._editor.onDidChangeModelLanguage(() => this._update()));\n        this._register(this._registry.onDidChange(() => this._update()));\n        this._register(this._editor.onDidChangeConfiguration((e) => {\n            if (e.hasChanged(65 /* EditorOption.lightbulb */)) {\n                this._update();\n            }\n        }));\n        this._update();\n    }\n    dispose() {\n        if (this._disposed) {\n            return;\n        }\n        this._disposed = true;\n        super.dispose();\n        this.setState(CodeActionsState.Empty, true);\n    }\n    _settingEnabledNearbyQuickfixes() {\n        const model = this._editor?.getModel();\n        return this._configurationService ? this._configurationService.getValue('editor.codeActionWidget.includeNearbyQuickFixes', { resource: model?.uri }) : false;\n    }\n    _update() {\n        if (this._disposed) {\n            return;\n        }\n        this._codeActionOracle.value = undefined;\n        this.setState(CodeActionsState.Empty);\n        const model = this._editor.getModel();\n        if (model\n            && this._registry.has(model)\n            && !this._editor.getOption(92 /* EditorOption.readOnly */)) {\n            const supportedActions = this._registry.all(model).flatMap(provider => provider.providedCodeActionKinds ?? []);\n            this._supportedCodeActions.set(supportedActions.join(' '));\n            this._codeActionOracle.value = new CodeActionOracle(this._editor, this._markerService, trigger => {\n                if (!trigger) {\n                    this.setState(CodeActionsState.Empty);\n                    return;\n                }\n                const startPosition = trigger.selection.getStartPosition();\n                const actions = createCancelablePromise(async (token) => {\n                    if (this._settingEnabledNearbyQuickfixes() && trigger.trigger.type === 1 /* CodeActionTriggerType.Invoke */ && (trigger.trigger.triggerAction === CodeActionTriggerSource.QuickFix || trigger.trigger.filter?.include?.contains(CodeActionKind.QuickFix))) {\n                        const codeActionSet = await getCodeActions(this._registry, model, trigger.selection, trigger.trigger, Progress.None, token);\n                        const allCodeActions = [...codeActionSet.allActions];\n                        if (token.isCancellationRequested) {\n                            return emptyCodeActionSet;\n                        }\n                        // Search for quickfixes in the curret code action set.\n                        const foundQuickfix = codeActionSet.validActions?.some(action => action.action.kind ? CodeActionKind.QuickFix.contains(new HierarchicalKind(action.action.kind)) : false);\n                        const allMarkers = this._markerService.read({ resource: model.uri });\n                        if (foundQuickfix) {\n                            for (const action of codeActionSet.validActions) {\n                                if (action.action.command?.arguments?.some(arg => typeof arg === 'string' && arg.includes(APPLY_FIX_ALL_COMMAND_ID))) {\n                                    action.action.diagnostics = [...allMarkers.filter(marker => marker.relatedInformation)];\n                                }\n                            }\n                            return { validActions: codeActionSet.validActions, allActions: allCodeActions, documentation: codeActionSet.documentation, hasAutoFix: codeActionSet.hasAutoFix, hasAIFix: codeActionSet.hasAIFix, allAIFixes: codeActionSet.allAIFixes, dispose: () => { codeActionSet.dispose(); } };\n                        }\n                        else if (!foundQuickfix) {\n                            // If markers exists, and there are no quickfixes found or length is zero, check for quickfixes on that line.\n                            if (allMarkers.length > 0) {\n                                const currPosition = trigger.selection.getPosition();\n                                let trackedPosition = currPosition;\n                                let distance = Number.MAX_VALUE;\n                                const currentActions = [...codeActionSet.validActions];\n                                for (const marker of allMarkers) {\n                                    const col = marker.endColumn;\n                                    const row = marker.endLineNumber;\n                                    const startRow = marker.startLineNumber;\n                                    // Found quickfix on the same line and check relative distance to other markers\n                                    if ((row === currPosition.lineNumber || startRow === currPosition.lineNumber)) {\n                                        trackedPosition = new Position(row, col);\n                                        const newCodeActionTrigger = {\n                                            type: trigger.trigger.type,\n                                            triggerAction: trigger.trigger.triggerAction,\n                                            filter: { include: trigger.trigger.filter?.include ? trigger.trigger.filter?.include : CodeActionKind.QuickFix },\n                                            autoApply: trigger.trigger.autoApply,\n                                            context: { notAvailableMessage: trigger.trigger.context?.notAvailableMessage || '', position: trackedPosition }\n                                        };\n                                        const selectionAsPosition = new Selection(trackedPosition.lineNumber, trackedPosition.column, trackedPosition.lineNumber, trackedPosition.column);\n                                        const actionsAtMarker = await getCodeActions(this._registry, model, selectionAsPosition, newCodeActionTrigger, Progress.None, token);\n                                        if (actionsAtMarker.validActions.length !== 0) {\n                                            for (const action of actionsAtMarker.validActions) {\n                                                if (action.action.command?.arguments?.some(arg => typeof arg === 'string' && arg.includes(APPLY_FIX_ALL_COMMAND_ID))) {\n                                                    action.action.diagnostics = [...allMarkers.filter(marker => marker.relatedInformation)];\n                                                }\n                                            }\n                                            if (codeActionSet.allActions.length === 0) {\n                                                allCodeActions.push(...actionsAtMarker.allActions);\n                                            }\n                                            // Already filtered through to only get quickfixes, so no need to filter again.\n                                            if (Math.abs(currPosition.column - col) < distance) {\n                                                currentActions.unshift(...actionsAtMarker.validActions);\n                                            }\n                                            else {\n                                                currentActions.push(...actionsAtMarker.validActions);\n                                            }\n                                        }\n                                        distance = Math.abs(currPosition.column - col);\n                                    }\n                                }\n                                const filteredActions = currentActions.filter((action, index, self) => self.findIndex((a) => a.action.title === action.action.title) === index);\n                                filteredActions.sort((a, b) => {\n                                    if (a.action.isPreferred && !b.action.isPreferred) {\n                                        return -1;\n                                    }\n                                    else if (!a.action.isPreferred && b.action.isPreferred) {\n                                        return 1;\n                                    }\n                                    else if (a.action.isAI && !b.action.isAI) {\n                                        return 1;\n                                    }\n                                    else if (!a.action.isAI && b.action.isAI) {\n                                        return -1;\n                                    }\n                                    else {\n                                        return 0;\n                                    }\n                                });\n                                // Only retriggers if actually found quickfix on the same line as cursor\n                                return { validActions: filteredActions, allActions: allCodeActions, documentation: codeActionSet.documentation, hasAutoFix: codeActionSet.hasAutoFix, hasAIFix: codeActionSet.hasAIFix, allAIFixes: codeActionSet.allAIFixes, dispose: () => { codeActionSet.dispose(); } };\n                            }\n                        }\n                    }\n                    // Case for manual triggers - specifically Source Actions and Refactors\n                    if (trigger.trigger.type === 1 /* CodeActionTriggerType.Invoke */) {\n                        const sw = new StopWatch();\n                        const codeActions = await getCodeActions(this._registry, model, trigger.selection, trigger.trigger, Progress.None, token);\n                        // Telemetry for duration of each code action on save.\n                        if (this._telemetryService) {\n                            this._telemetryService.publicLog2('codeAction.invokedDurations', {\n                                codeActions: codeActions.validActions.length,\n                                duration: sw.elapsed()\n                            });\n                        }\n                        return codeActions;\n                    }\n                    return getCodeActions(this._registry, model, trigger.selection, trigger.trigger, Progress.None, token);\n                });\n                if (trigger.trigger.type === 1 /* CodeActionTriggerType.Invoke */) {\n                    this._progressService?.showWhile(actions, 250);\n                }\n                const newState = new CodeActionsState.Triggered(trigger.trigger, startPosition, actions);\n                let isManualToAutoTransition = false;\n                if (this._state.type === 1 /* CodeActionsState.Type.Triggered */) {\n                    // Check if the current state is manual and the new state is automatic\n                    isManualToAutoTransition = this._state.trigger.type === 1 /* CodeActionTriggerType.Invoke */ &&\n                        newState.type === 1 /* CodeActionsState.Type.Triggered */ &&\n                        newState.trigger.type === 2 /* CodeActionTriggerType.Auto */ &&\n                        this._state.position !== newState.position;\n                }\n                // Do not trigger state if current state is manual and incoming state is automatic\n                if (!isManualToAutoTransition) {\n                    this.setState(newState);\n                }\n                else {\n                    // Reset the new state after getting code actions back.\n                    setTimeout(() => {\n                        this.setState(newState);\n                    }, 500);\n                }\n            }, undefined);\n            this._codeActionOracle.value.trigger({ type: 2 /* CodeActionTriggerType.Auto */, triggerAction: CodeActionTriggerSource.Default });\n        }\n        else {\n            this._supportedCodeActions.reset();\n        }\n    }\n    trigger(trigger) {\n        this._codeActionOracle.value?.trigger(trigger);\n    }\n    setState(newState, skipNotify) {\n        if (newState === this._state) {\n            return;\n        }\n        // Cancel old request\n        if (this._state.type === 1 /* CodeActionsState.Type.Triggered */) {\n            this._state.cancel();\n        }\n        this._state = newState;\n        if (!skipNotify && !this._disposed) {\n            this._onDidChangeState.fire(newState);\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}