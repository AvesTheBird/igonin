{"ast":null,"code":"/*\nCopyright 2023-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectCodec from '../ObjectCodec';\nimport GraphView from '../../view/GraphView';\nimport StyleRegistry from '../../view/style/StyleRegistry';\n/**\n * Custom encoder for {@link GraphView}s.\n *\n * This class is created and registered dynamically at load time and used implicitly via {@link Codec} and the {@link CodecRegistry}.\n *\n * This codec only writes views into an XML format that can be used to create an image for the graph, that is,\n * it contains absolute coordinates with computed perimeters, edge styles and cell styles.\n */\nexport class GraphViewCodec extends ObjectCodec {\n  constructor() {\n    const __dummy = undefined;\n    super(new GraphView(__dummy));\n  }\n  /**\n   * Encodes the given {@link GraphView} using {@link encodeCell} starting at the model's root. This returns the\n   * top-level graph node of the recursive encoding.\n   */\n  encode(enc, view) {\n    return this.encodeCell(enc, view, view.graph.getDataModel().getRoot());\n  }\n  /**\n   * Recursively encodes the specified cell.\n   *\n   * Uses layer as the default node name. If the cell's parent is null, then graph is used for the node name.\n   * If {@link Cell.isEdge} returns `true` for the cell, then edge is used for the node name, else if {@link Cell.isVertex} returns `true` for the cell,\n   * then vertex is used for the node name.\n   *\n   * {@link Graph.getLabel} is used to create the label attribute for the cell.\n   * For graph nodes and vertices the bounds are encoded into x, y, width and height.\n   * For edges the points are encoded into a points attribute as a space-separated list of comma-separated coordinate pairs (e.g. x0,y0 x1,y1 ... xn,yn).\n   * All values from the cell style are added as attribute values to the node.\n   */\n  encodeCell(enc, view, cell) {\n    let node;\n    const model = view.graph.getDataModel();\n    const state = view.getState(cell);\n    const parent = cell.getParent();\n    if (parent == null || state != null) {\n      const childCount = cell.getChildCount();\n      const geo = cell.getGeometry();\n      let name = null;\n      if (parent === model.getRoot()) {\n        name = 'layer';\n      } else if (parent == null) {\n        name = 'graph';\n      } else if (cell.isEdge()) {\n        name = 'edge';\n      } else if (childCount > 0 && geo != null) {\n        name = 'group';\n      } else if (cell.isVertex()) {\n        name = 'vertex';\n      }\n      if (name != null) {\n        node = enc.document.createElement(name);\n        const lab = view.graph.getLabel(cell);\n        if (lab != null) {\n          node.setAttribute('label', view.graph.getLabel(cell));\n          if (view.graph.isHtmlLabel(cell)) {\n            node.setAttribute('html', true);\n          }\n        }\n        if (parent == null) {\n          const bounds = view.getGraphBounds();\n          if (bounds != null) {\n            node.setAttribute('x', Math.round(bounds.x));\n            node.setAttribute('y', Math.round(bounds.y));\n            node.setAttribute('width', Math.round(bounds.width));\n            node.setAttribute('height', Math.round(bounds.height));\n          }\n          node.setAttribute('scale', view.scale);\n        } else if (state != null && geo != null) {\n          // Writes each key, value in the style pair to an attribute\n          for (const i in state.style) {\n            // @ts-ignore\n            let value = state.style[i];\n            // Tries to turn objects and functions into strings\n            if (typeof value === 'function' && typeof value === 'object') {\n              value = StyleRegistry.getName(value);\n            }\n            if (value != null && typeof value !== 'function' && typeof value !== 'object') {\n              node.setAttribute(i, value);\n            }\n          }\n          const abs = state.absolutePoints;\n          // Writes the list of points into one attribute\n          if (abs != null && abs.length > 0) {\n            let pts = `${Math.round(abs[0].x)},${Math.round(abs[0].y)}`;\n            for (let i = 1; i < abs.length; i += 1) {\n              pts += ` ${Math.round(abs[i].x)},${Math.round(abs[i].y)}`;\n            }\n            node.setAttribute('points', pts);\n          }\n          // Writes the bounds into 4 attributes\n          else {\n            node.setAttribute('x', Math.round(state.x));\n            node.setAttribute('y', Math.round(state.y));\n            node.setAttribute('width', Math.round(state.width));\n            node.setAttribute('height', Math.round(state.height));\n          }\n          const offset = state.absoluteOffset;\n          // Writes the offset into 2 attributes\n          if (offset != null) {\n            if (offset.x !== 0) {\n              node.setAttribute('dx', Math.round(offset.x));\n            }\n            if (offset.y !== 0) {\n              node.setAttribute('dy', Math.round(offset.y));\n            }\n          }\n        }\n        for (let i = 0; i < childCount; i += 1) {\n          const childNode = this.encodeCell(enc, view, cell.getChildAt(i));\n          if (childNode != null) {\n            node.appendChild(childNode);\n          }\n        }\n      }\n    }\n    return node;\n  }\n}","map":{"version":3,"names":["ObjectCodec","GraphView","StyleRegistry","GraphViewCodec","constructor","__dummy","undefined","encode","enc","view","encodeCell","graph","getDataModel","getRoot","cell","node","model","state","getState","parent","getParent","childCount","getChildCount","geo","getGeometry","name","isEdge","isVertex","document","createElement","lab","getLabel","setAttribute","isHtmlLabel","bounds","getGraphBounds","Math","round","x","y","width","height","scale","i","style","value","getName","abs","absolutePoints","length","pts","offset","absoluteOffset","childNode","getChildAt","appendChild"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/@maxgraph/core/dist/serialization/codecs/GraphViewCodec.js"],"sourcesContent":["/*\nCopyright 2023-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectCodec from '../ObjectCodec';\nimport GraphView from '../../view/GraphView';\nimport StyleRegistry from '../../view/style/StyleRegistry';\n/**\n * Custom encoder for {@link GraphView}s.\n *\n * This class is created and registered dynamically at load time and used implicitly via {@link Codec} and the {@link CodecRegistry}.\n *\n * This codec only writes views into an XML format that can be used to create an image for the graph, that is,\n * it contains absolute coordinates with computed perimeters, edge styles and cell styles.\n */\nexport class GraphViewCodec extends ObjectCodec {\n    constructor() {\n        const __dummy = undefined;\n        super(new GraphView(__dummy));\n    }\n    /**\n     * Encodes the given {@link GraphView} using {@link encodeCell} starting at the model's root. This returns the\n     * top-level graph node of the recursive encoding.\n     */\n    encode(enc, view) {\n        return this.encodeCell(enc, view, view.graph.getDataModel().getRoot());\n    }\n    /**\n     * Recursively encodes the specified cell.\n     *\n     * Uses layer as the default node name. If the cell's parent is null, then graph is used for the node name.\n     * If {@link Cell.isEdge} returns `true` for the cell, then edge is used for the node name, else if {@link Cell.isVertex} returns `true` for the cell,\n     * then vertex is used for the node name.\n     *\n     * {@link Graph.getLabel} is used to create the label attribute for the cell.\n     * For graph nodes and vertices the bounds are encoded into x, y, width and height.\n     * For edges the points are encoded into a points attribute as a space-separated list of comma-separated coordinate pairs (e.g. x0,y0 x1,y1 ... xn,yn).\n     * All values from the cell style are added as attribute values to the node.\n     */\n    encodeCell(enc, view, cell) {\n        let node;\n        const model = view.graph.getDataModel();\n        const state = view.getState(cell);\n        const parent = cell.getParent();\n        if (parent == null || state != null) {\n            const childCount = cell.getChildCount();\n            const geo = cell.getGeometry();\n            let name = null;\n            if (parent === model.getRoot()) {\n                name = 'layer';\n            }\n            else if (parent == null) {\n                name = 'graph';\n            }\n            else if (cell.isEdge()) {\n                name = 'edge';\n            }\n            else if (childCount > 0 && geo != null) {\n                name = 'group';\n            }\n            else if (cell.isVertex()) {\n                name = 'vertex';\n            }\n            if (name != null) {\n                node = enc.document.createElement(name);\n                const lab = view.graph.getLabel(cell);\n                if (lab != null) {\n                    node.setAttribute('label', view.graph.getLabel(cell));\n                    if (view.graph.isHtmlLabel(cell)) {\n                        node.setAttribute('html', true);\n                    }\n                }\n                if (parent == null) {\n                    const bounds = view.getGraphBounds();\n                    if (bounds != null) {\n                        node.setAttribute('x', Math.round(bounds.x));\n                        node.setAttribute('y', Math.round(bounds.y));\n                        node.setAttribute('width', Math.round(bounds.width));\n                        node.setAttribute('height', Math.round(bounds.height));\n                    }\n                    node.setAttribute('scale', view.scale);\n                }\n                else if (state != null && geo != null) {\n                    // Writes each key, value in the style pair to an attribute\n                    for (const i in state.style) {\n                        // @ts-ignore\n                        let value = state.style[i];\n                        // Tries to turn objects and functions into strings\n                        if (typeof value === 'function' && typeof value === 'object') {\n                            value = StyleRegistry.getName(value);\n                        }\n                        if (value != null &&\n                            typeof value !== 'function' &&\n                            typeof value !== 'object') {\n                            node.setAttribute(i, value);\n                        }\n                    }\n                    const abs = state.absolutePoints;\n                    // Writes the list of points into one attribute\n                    if (abs != null && abs.length > 0) {\n                        let pts = `${Math.round(abs[0].x)},${Math.round(abs[0].y)}`;\n                        for (let i = 1; i < abs.length; i += 1) {\n                            pts += ` ${Math.round(abs[i].x)},${Math.round(abs[i].y)}`;\n                        }\n                        node.setAttribute('points', pts);\n                    }\n                    // Writes the bounds into 4 attributes\n                    else {\n                        node.setAttribute('x', Math.round(state.x));\n                        node.setAttribute('y', Math.round(state.y));\n                        node.setAttribute('width', Math.round(state.width));\n                        node.setAttribute('height', Math.round(state.height));\n                    }\n                    const offset = state.absoluteOffset;\n                    // Writes the offset into 2 attributes\n                    if (offset != null) {\n                        if (offset.x !== 0) {\n                            node.setAttribute('dx', Math.round(offset.x));\n                        }\n                        if (offset.y !== 0) {\n                            node.setAttribute('dy', Math.round(offset.y));\n                        }\n                    }\n                }\n                for (let i = 0; i < childCount; i += 1) {\n                    const childNode = this.encodeCell(enc, view, cell.getChildAt(i));\n                    if (childNode != null) {\n                        node.appendChild(childNode);\n                    }\n                }\n            }\n        }\n        return node;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}