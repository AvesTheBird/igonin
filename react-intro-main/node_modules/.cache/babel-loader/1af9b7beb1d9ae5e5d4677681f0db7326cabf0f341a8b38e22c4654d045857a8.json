{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from '../geometry/Rectangle';\nimport { mixInto } from '../../util/Utils';\nimport { convertPoint } from '../../util/styleUtils';\nimport { mod } from '../../util/mathUtils';\nimport { DEFAULT_STARTSIZE, DIRECTION, SHAPE } from '../../util/Constants';\nimport { getClientX, getClientY } from '../../util/EventUtils';\nimport { Graph } from '../Graph';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst SwimlaneMixin = {\n  /**\n   * Specifies if swimlanes should be selectable via the content if the\n   * mouse is released.\n   * @default true\n   */\n  swimlaneSelectionEnabled: true,\n  /**\n   * Specifies if nesting of swimlanes is allowed.\n   * @default true\n   */\n  swimlaneNesting: true,\n  /**\n   * The attribute used to find the color for the indicator if the indicator\n   * color is set to 'swimlane'.\n   * @default {@link 'fillColor'}\n   */\n  swimlaneIndicatorColorAttribute: 'fillColor',\n  /**\n   * Returns the nearest ancestor of the given cell which is a swimlane, or\n   * the given cell, if it is itself a swimlane.\n   *\n   * @param cell {@link mxCell} for which the ancestor swimlane should be returned.\n   */\n  getSwimlane(cell = null) {\n    while (cell && !this.isSwimlane(cell)) {\n      cell = cell.getParent();\n    }\n    return cell;\n  },\n  /**\n   * Returns the bottom-most swimlane that intersects the given point (x, y)\n   * in the cell hierarchy that starts at the given parent.\n   *\n   * @param x X-coordinate of the location to be checked.\n   * @param y Y-coordinate of the location to be checked.\n   * @param parent {@link mxCell} that should be used as the root of the recursion.\n   * Default is {@link defaultParent}.\n   */\n  getSwimlaneAt(x, y, parent) {\n    if (!parent) {\n      parent = this.getCurrentRoot();\n      if (!parent) {\n        parent = this.getDataModel().getRoot();\n      }\n    }\n    if (parent) {\n      const childCount = parent.getChildCount();\n      for (let i = 0; i < childCount; i += 1) {\n        const child = parent.getChildAt(i);\n        if (child) {\n          const result = this.getSwimlaneAt(x, y, child);\n          if (result != null) {\n            return result;\n          }\n          if (child.isVisible() && this.isSwimlane(child)) {\n            const state = this.getView().getState(child);\n            if (state && this.intersects(state, x, y)) {\n              return child;\n            }\n          }\n        }\n      }\n    }\n    return null;\n  },\n  /**\n   * Returns true if the given coordinate pair is inside the content\n   * are of the given swimlane.\n   *\n   * @param swimlane {@link mxCell} that specifies the swimlane.\n   * @param x X-coordinate of the mouse event.\n   * @param y Y-coordinate of the mouse event.\n   */\n  hitsSwimlaneContent(swimlane, x, y) {\n    const state = this.getView().getState(swimlane);\n    const size = this.getStartSize(swimlane);\n    if (state) {\n      const scale = this.getView().getScale();\n      x -= state.x;\n      y -= state.y;\n      if (size.width > 0 && x > 0 && x > size.width * scale) {\n        return true;\n      }\n      if (size.height > 0 && y > 0 && y > size.height * scale) {\n        return true;\n      }\n    }\n    return false;\n  },\n  /*****************************************************************************\n   * Group: Graph appearance\n   *****************************************************************************/\n  /**\n   * Returns the start size of the given swimlane, that is, the width or\n   * height of the part that contains the title, depending on the\n   * horizontal style. The return value is an {@link Rectangle} with either\n   * width or height set as appropriate.\n   *\n   * @param swimlane {@link mxCell} whose start size should be returned.\n   * @param ignoreState Optional boolean that specifies if cell state should be ignored.\n   */\n  getStartSize(swimlane, ignoreState = false) {\n    const result = new Rectangle();\n    const style = this.getCurrentCellStyle(swimlane, ignoreState);\n    const size = style.startSize ?? DEFAULT_STARTSIZE;\n    if (style.horizontal ?? true) {\n      result.height = size;\n    } else {\n      result.width = size;\n    }\n    return result;\n  },\n  /**\n   * Returns the direction for the given swimlane style.\n   */\n  getSwimlaneDirection(style) {\n    const dir = style.direction ?? DIRECTION.EAST;\n    const flipH = style.flipH;\n    const flipV = style.flipV;\n    const h = style.horizontal ?? true;\n    let n = h ? 0 : 3;\n    if (dir === DIRECTION.NORTH) {\n      n--;\n    } else if (dir === DIRECTION.WEST) {\n      n += 2;\n    } else if (dir === DIRECTION.SOUTH) {\n      n += 1;\n    }\n    const _mod = mod(n, 2);\n    if (flipH && _mod === 1) {\n      n += 2;\n    }\n    if (flipV && _mod === 0) {\n      n += 2;\n    }\n    return [DIRECTION.NORTH, DIRECTION.EAST, DIRECTION.SOUTH, DIRECTION.WEST][mod(n, 4)];\n  },\n  /**\n   * Returns the actual start size of the given swimlane taking into account\n   * direction and horizontal and vertial flip styles. The start size is\n   * returned as an {@link Rectangle} where top, left, bottom, right start sizes\n   * are returned as x, y, height and width, respectively.\n   *\n   * @param swimlane {@link mxCell} whose start size should be returned.\n   * @param ignoreState Optional boolean that specifies if cell state should be ignored.\n   */\n  getActualStartSize(swimlane, ignoreState = false) {\n    const result = new Rectangle();\n    if (this.isSwimlane(swimlane, ignoreState)) {\n      const style = this.getCurrentCellStyle(swimlane, ignoreState);\n      const size = style.startSize ?? DEFAULT_STARTSIZE;\n      const dir = this.getSwimlaneDirection(style);\n      if (dir === DIRECTION.NORTH) {\n        result.y = size;\n      } else if (dir === DIRECTION.WEST) {\n        result.x = size;\n      } else if (dir === DIRECTION.SOUTH) {\n        result.height = size;\n      } else {\n        result.width = size;\n      }\n    }\n    return result;\n  },\n  /**\n   * Returns true if the given cell is a swimlane in the graph. A swimlane is\n   * a container cell with some specific behaviour. This implementation\n   * checks if the shape associated with the given cell is a {@link mxSwimlane}.\n   *\n   * @param cell {@link mxCell} to be checked.\n   * @param ignoreState Optional boolean that specifies if the cell state should be ignored.\n   */\n  isSwimlane(cell, ignoreState = false) {\n    if (cell && cell.getParent() !== this.getDataModel().getRoot() && !cell.isEdge()) {\n      return this.getCurrentCellStyle(cell, ignoreState).shape === SHAPE.SWIMLANE;\n    }\n    return false;\n  },\n  /*****************************************************************************\n   * Group: Graph behaviour\n   *****************************************************************************/\n  /**\n   * Returns true if the given cell is a valid drop target for the specified\n   * cells. If {@link splitEnabled} is true then this returns {@link isSplitTarget} for\n   * the given arguments else it returns true if the cell is not collapsed\n   * and its child count is greater than 0.\n   *\n   * @param cell {@link mxCell} that represents the possible drop target.\n   * @param cells {@link mxCell} that should be dropped into the target.\n   * @param evt Mouseevent that triggered the invocation.\n   */\n  isValidDropTarget(cell, cells, evt) {\n    return cell && (this.isSplitEnabled() && this.isSplitTarget(cell, cells, evt) || !cell.isEdge() && (this.isSwimlane(cell) || cell.getChildCount() > 0 && !cell.isCollapsed()));\n  },\n  /**\n   * Returns the given cell if it is a drop target for the given cells or the\n   * nearest ancestor that may be used as a drop target for the given cells.\n   * If the given array contains a swimlane and {@link swimlaneNesting} is false\n   * then this always returns null. If no cell is given, then the bottommost\n   * swimlane at the location of the given event is returned.\n   *\n   * This function should only be used if {@link isDropEnabled} returns true.\n   *\n   * @param cells Array of {@link Cell} which are to be dropped onto the target.\n   * @param evt Mouseevent for the drag and drop.\n   * @param cell {@link mxCell} that is under the mousepointer.\n   * @param clone Optional boolean to indicate of cells will be cloned.\n   */\n  getDropTarget(cells, evt, cell = null, clone = false) {\n    if (!this.isSwimlaneNesting()) {\n      for (let i = 0; i < cells.length; i += 1) {\n        if (this.isSwimlane(cells[i])) {\n          return null;\n        }\n      }\n    }\n    const pt = convertPoint(this.getContainer(), getClientX(evt), getClientY(evt));\n    pt.x -= this.getPanDx();\n    pt.y -= this.getPanDy();\n    const swimlane = this.getSwimlaneAt(pt.x, pt.y);\n    if (!cell) {\n      cell = swimlane;\n    } else if (swimlane) {\n      // Checks if the cell is an ancestor of the swimlane\n      // under the mouse and uses the swimlane in that case\n      let tmp = swimlane.getParent();\n      while (tmp && this.isSwimlane(tmp) && tmp !== cell) {\n        tmp = tmp.getParent();\n      }\n      if (tmp === cell) {\n        cell = swimlane;\n      }\n    }\n    while (cell && !this.isValidDropTarget(cell, cells, evt) && !this.getDataModel().isLayer(cell)) {\n      cell = cell.getParent();\n    }\n    // Checks if parent is dropped into child if not cloning\n    if (!clone) {\n      let parent = cell;\n      while (parent && cells.indexOf(parent) < 0) {\n        parent = parent.getParent();\n      }\n    }\n    return !this.getDataModel().isLayer(cell) && !parent ? cell : null;\n  },\n  /**\n   * Returns {@link swimlaneNesting} as a boolean.\n   */\n  isSwimlaneNesting() {\n    return this.swimlaneNesting;\n  },\n  /**\n   * Specifies if swimlanes can be nested by drag and drop. This is only\n   * taken into account if dropEnabled is true.\n   *\n   * @param value Boolean indicating if swimlanes can be nested.\n   */\n  setSwimlaneNesting(value) {\n    this.swimlaneNesting = value;\n  },\n  /**\n   * Returns {@link swimlaneSelectionEnabled} as a boolean.\n   */\n  isSwimlaneSelectionEnabled() {\n    return this.swimlaneSelectionEnabled;\n  },\n  /**\n   * Specifies if swimlanes should be selected if the mouse is released\n   * over their content area.\n   *\n   * @param value Boolean indicating if swimlanes content areas\n   * should be selected when the mouse is released over them.\n   */\n  setSwimlaneSelectionEnabled(value) {\n    this.swimlaneSelectionEnabled = value;\n  }\n};\nmixInto(Graph)(SwimlaneMixin);","map":{"version":3,"names":["Rectangle","mixInto","convertPoint","mod","DEFAULT_STARTSIZE","DIRECTION","SHAPE","getClientX","getClientY","Graph","SwimlaneMixin","swimlaneSelectionEnabled","swimlaneNesting","swimlaneIndicatorColorAttribute","getSwimlane","cell","isSwimlane","getParent","getSwimlaneAt","x","y","parent","getCurrentRoot","getDataModel","getRoot","childCount","getChildCount","i","child","getChildAt","result","isVisible","state","getView","getState","intersects","hitsSwimlaneContent","swimlane","size","getStartSize","scale","getScale","width","height","ignoreState","style","getCurrentCellStyle","startSize","horizontal","getSwimlaneDirection","dir","direction","EAST","flipH","flipV","h","n","NORTH","WEST","SOUTH","_mod","getActualStartSize","isEdge","shape","SWIMLANE","isValidDropTarget","cells","evt","isSplitEnabled","isSplitTarget","isCollapsed","getDropTarget","clone","isSwimlaneNesting","length","pt","getContainer","getPanDx","getPanDy","tmp","isLayer","indexOf","setSwimlaneNesting","value","isSwimlaneSelectionEnabled","setSwimlaneSelectionEnabled"],"sources":["D:/OSPanel/domains/react/react-intro-main/node_modules/@maxgraph/core/dist/view/mixins/SwimlaneMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from '../geometry/Rectangle';\nimport { mixInto } from '../../util/Utils';\nimport { convertPoint } from '../../util/styleUtils';\nimport { mod } from '../../util/mathUtils';\nimport { DEFAULT_STARTSIZE, DIRECTION, SHAPE } from '../../util/Constants';\nimport { getClientX, getClientY } from '../../util/EventUtils';\nimport { Graph } from '../Graph';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst SwimlaneMixin = {\n    /**\n     * Specifies if swimlanes should be selectable via the content if the\n     * mouse is released.\n     * @default true\n     */\n    swimlaneSelectionEnabled: true,\n    /**\n     * Specifies if nesting of swimlanes is allowed.\n     * @default true\n     */\n    swimlaneNesting: true,\n    /**\n     * The attribute used to find the color for the indicator if the indicator\n     * color is set to 'swimlane'.\n     * @default {@link 'fillColor'}\n     */\n    swimlaneIndicatorColorAttribute: 'fillColor',\n    /**\n     * Returns the nearest ancestor of the given cell which is a swimlane, or\n     * the given cell, if it is itself a swimlane.\n     *\n     * @param cell {@link mxCell} for which the ancestor swimlane should be returned.\n     */\n    getSwimlane(cell = null) {\n        while (cell && !this.isSwimlane(cell)) {\n            cell = cell.getParent();\n        }\n        return cell;\n    },\n    /**\n     * Returns the bottom-most swimlane that intersects the given point (x, y)\n     * in the cell hierarchy that starts at the given parent.\n     *\n     * @param x X-coordinate of the location to be checked.\n     * @param y Y-coordinate of the location to be checked.\n     * @param parent {@link mxCell} that should be used as the root of the recursion.\n     * Default is {@link defaultParent}.\n     */\n    getSwimlaneAt(x, y, parent) {\n        if (!parent) {\n            parent = this.getCurrentRoot();\n            if (!parent) {\n                parent = this.getDataModel().getRoot();\n            }\n        }\n        if (parent) {\n            const childCount = parent.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                const child = parent.getChildAt(i);\n                if (child) {\n                    const result = this.getSwimlaneAt(x, y, child);\n                    if (result != null) {\n                        return result;\n                    }\n                    if (child.isVisible() && this.isSwimlane(child)) {\n                        const state = this.getView().getState(child);\n                        if (state && this.intersects(state, x, y)) {\n                            return child;\n                        }\n                    }\n                }\n            }\n        }\n        return null;\n    },\n    /**\n     * Returns true if the given coordinate pair is inside the content\n     * are of the given swimlane.\n     *\n     * @param swimlane {@link mxCell} that specifies the swimlane.\n     * @param x X-coordinate of the mouse event.\n     * @param y Y-coordinate of the mouse event.\n     */\n    hitsSwimlaneContent(swimlane, x, y) {\n        const state = this.getView().getState(swimlane);\n        const size = this.getStartSize(swimlane);\n        if (state) {\n            const scale = this.getView().getScale();\n            x -= state.x;\n            y -= state.y;\n            if (size.width > 0 && x > 0 && x > size.width * scale) {\n                return true;\n            }\n            if (size.height > 0 && y > 0 && y > size.height * scale) {\n                return true;\n            }\n        }\n        return false;\n    },\n    /*****************************************************************************\n     * Group: Graph appearance\n     *****************************************************************************/\n    /**\n     * Returns the start size of the given swimlane, that is, the width or\n     * height of the part that contains the title, depending on the\n     * horizontal style. The return value is an {@link Rectangle} with either\n     * width or height set as appropriate.\n     *\n     * @param swimlane {@link mxCell} whose start size should be returned.\n     * @param ignoreState Optional boolean that specifies if cell state should be ignored.\n     */\n    getStartSize(swimlane, ignoreState = false) {\n        const result = new Rectangle();\n        const style = this.getCurrentCellStyle(swimlane, ignoreState);\n        const size = style.startSize ?? DEFAULT_STARTSIZE;\n        if (style.horizontal ?? true) {\n            result.height = size;\n        }\n        else {\n            result.width = size;\n        }\n        return result;\n    },\n    /**\n     * Returns the direction for the given swimlane style.\n     */\n    getSwimlaneDirection(style) {\n        const dir = style.direction ?? DIRECTION.EAST;\n        const flipH = style.flipH;\n        const flipV = style.flipV;\n        const h = style.horizontal ?? true;\n        let n = h ? 0 : 3;\n        if (dir === DIRECTION.NORTH) {\n            n--;\n        }\n        else if (dir === DIRECTION.WEST) {\n            n += 2;\n        }\n        else if (dir === DIRECTION.SOUTH) {\n            n += 1;\n        }\n        const _mod = mod(n, 2);\n        if (flipH && _mod === 1) {\n            n += 2;\n        }\n        if (flipV && _mod === 0) {\n            n += 2;\n        }\n        return [DIRECTION.NORTH, DIRECTION.EAST, DIRECTION.SOUTH, DIRECTION.WEST][mod(n, 4)];\n    },\n    /**\n     * Returns the actual start size of the given swimlane taking into account\n     * direction and horizontal and vertial flip styles. The start size is\n     * returned as an {@link Rectangle} where top, left, bottom, right start sizes\n     * are returned as x, y, height and width, respectively.\n     *\n     * @param swimlane {@link mxCell} whose start size should be returned.\n     * @param ignoreState Optional boolean that specifies if cell state should be ignored.\n     */\n    getActualStartSize(swimlane, ignoreState = false) {\n        const result = new Rectangle();\n        if (this.isSwimlane(swimlane, ignoreState)) {\n            const style = this.getCurrentCellStyle(swimlane, ignoreState);\n            const size = style.startSize ?? DEFAULT_STARTSIZE;\n            const dir = this.getSwimlaneDirection(style);\n            if (dir === DIRECTION.NORTH) {\n                result.y = size;\n            }\n            else if (dir === DIRECTION.WEST) {\n                result.x = size;\n            }\n            else if (dir === DIRECTION.SOUTH) {\n                result.height = size;\n            }\n            else {\n                result.width = size;\n            }\n        }\n        return result;\n    },\n    /**\n     * Returns true if the given cell is a swimlane in the graph. A swimlane is\n     * a container cell with some specific behaviour. This implementation\n     * checks if the shape associated with the given cell is a {@link mxSwimlane}.\n     *\n     * @param cell {@link mxCell} to be checked.\n     * @param ignoreState Optional boolean that specifies if the cell state should be ignored.\n     */\n    isSwimlane(cell, ignoreState = false) {\n        if (cell && cell.getParent() !== this.getDataModel().getRoot() && !cell.isEdge()) {\n            return this.getCurrentCellStyle(cell, ignoreState).shape === SHAPE.SWIMLANE;\n        }\n        return false;\n    },\n    /*****************************************************************************\n     * Group: Graph behaviour\n     *****************************************************************************/\n    /**\n     * Returns true if the given cell is a valid drop target for the specified\n     * cells. If {@link splitEnabled} is true then this returns {@link isSplitTarget} for\n     * the given arguments else it returns true if the cell is not collapsed\n     * and its child count is greater than 0.\n     *\n     * @param cell {@link mxCell} that represents the possible drop target.\n     * @param cells {@link mxCell} that should be dropped into the target.\n     * @param evt Mouseevent that triggered the invocation.\n     */\n    isValidDropTarget(cell, cells, evt) {\n        return (cell &&\n            ((this.isSplitEnabled() && this.isSplitTarget(cell, cells, evt)) ||\n                (!cell.isEdge() &&\n                    (this.isSwimlane(cell) || (cell.getChildCount() > 0 && !cell.isCollapsed())))));\n    },\n    /**\n     * Returns the given cell if it is a drop target for the given cells or the\n     * nearest ancestor that may be used as a drop target for the given cells.\n     * If the given array contains a swimlane and {@link swimlaneNesting} is false\n     * then this always returns null. If no cell is given, then the bottommost\n     * swimlane at the location of the given event is returned.\n     *\n     * This function should only be used if {@link isDropEnabled} returns true.\n     *\n     * @param cells Array of {@link Cell} which are to be dropped onto the target.\n     * @param evt Mouseevent for the drag and drop.\n     * @param cell {@link mxCell} that is under the mousepointer.\n     * @param clone Optional boolean to indicate of cells will be cloned.\n     */\n    getDropTarget(cells, evt, cell = null, clone = false) {\n        if (!this.isSwimlaneNesting()) {\n            for (let i = 0; i < cells.length; i += 1) {\n                if (this.isSwimlane(cells[i])) {\n                    return null;\n                }\n            }\n        }\n        const pt = convertPoint(this.getContainer(), getClientX(evt), getClientY(evt));\n        pt.x -= this.getPanDx();\n        pt.y -= this.getPanDy();\n        const swimlane = this.getSwimlaneAt(pt.x, pt.y);\n        if (!cell) {\n            cell = swimlane;\n        }\n        else if (swimlane) {\n            // Checks if the cell is an ancestor of the swimlane\n            // under the mouse and uses the swimlane in that case\n            let tmp = swimlane.getParent();\n            while (tmp && this.isSwimlane(tmp) && tmp !== cell) {\n                tmp = tmp.getParent();\n            }\n            if (tmp === cell) {\n                cell = swimlane;\n            }\n        }\n        while (cell &&\n            !this.isValidDropTarget(cell, cells, evt) &&\n            !this.getDataModel().isLayer(cell)) {\n            cell = cell.getParent();\n        }\n        // Checks if parent is dropped into child if not cloning\n        if (!clone) {\n            let parent = cell;\n            while (parent && cells.indexOf(parent) < 0) {\n                parent = parent.getParent();\n            }\n        }\n        return !this.getDataModel().isLayer(cell) && !parent ? cell : null;\n    },\n    /**\n     * Returns {@link swimlaneNesting} as a boolean.\n     */\n    isSwimlaneNesting() {\n        return this.swimlaneNesting;\n    },\n    /**\n     * Specifies if swimlanes can be nested by drag and drop. This is only\n     * taken into account if dropEnabled is true.\n     *\n     * @param value Boolean indicating if swimlanes can be nested.\n     */\n    setSwimlaneNesting(value) {\n        this.swimlaneNesting = value;\n    },\n    /**\n     * Returns {@link swimlaneSelectionEnabled} as a boolean.\n     */\n    isSwimlaneSelectionEnabled() {\n        return this.swimlaneSelectionEnabled;\n    },\n    /**\n     * Specifies if swimlanes should be selected if the mouse is released\n     * over their content area.\n     *\n     * @param value Boolean indicating if swimlanes content areas\n     * should be selected when the mouse is released over them.\n     */\n    setSwimlaneSelectionEnabled(value) {\n        this.swimlaneSelectionEnabled = value;\n    },\n};\nmixInto(Graph)(SwimlaneMixin);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}