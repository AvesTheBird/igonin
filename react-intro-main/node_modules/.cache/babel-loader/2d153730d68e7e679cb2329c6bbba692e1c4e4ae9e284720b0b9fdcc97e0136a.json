{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport CellOverlay from '../cell/CellOverlay';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport { Graph } from '../Graph';\nimport { mixInto } from '../../util/Utils';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst OverlaysMixin = {\n  /*****************************************************************************\n   * Group: Overlays\n   *****************************************************************************/\n  /**\n   * Adds an {@link CellOverlay} for the specified cell. This method fires an\n   * {@link addoverlay} event and returns the new {@link CellOverlay}.\n   *\n   * @param cell {@link mxCell} to add the overlay for.\n   * @param overlay {@link CellOverlay} to be added for the cell.\n   */\n  addCellOverlay(cell, overlay) {\n    cell.overlays.push(overlay);\n    // Immediately update the cell display if the state exists\n    const state = this.getView().getState(cell);\n    if (state) {\n      this.getCellRenderer().redraw(state);\n    }\n    this.fireEvent(new EventObject(InternalEvent.ADD_OVERLAY, {\n      cell,\n      overlay\n    }));\n    return overlay;\n  },\n  /**\n   * Returns the array of {@link mxCellOverlays} for the given cell or null, if\n   * no overlays are defined.\n   *\n   * @param cell {@link mxCell} whose overlays should be returned.\n   */\n  getCellOverlays(cell) {\n    return cell.overlays;\n  },\n  /**\n   * Removes and returns the given {@link CellOverlay} from the given cell. This\n   * method fires a {@link removeoverlay} event. If no overlay is given, then all\n   * overlays are removed using {@link removeOverlays}.\n   *\n   * @param cell {@link mxCell} whose overlay should be removed.\n   * @param overlay Optional {@link CellOverlay} to be removed.\n   */\n  // removeCellOverlay(cell: mxCell, overlay: CellOverlay): CellOverlay;\n  removeCellOverlay(cell, overlay = null) {\n    if (!overlay) {\n      this.removeCellOverlays(cell);\n    } else {\n      const index = cell.overlays.indexOf(overlay);\n      if (index >= 0) {\n        cell.overlays.splice(index, 1);\n        // Immediately updates the cell display if the state exists\n        const state = this.getView().getState(cell);\n        if (state) {\n          this.getCellRenderer().redraw(state);\n        }\n        this.fireEvent(new EventObject(InternalEvent.REMOVE_OVERLAY, {\n          cell,\n          overlay\n        }));\n      } else {\n        overlay = null;\n      }\n    }\n    return overlay;\n  },\n  /**\n   * Removes all {@link mxCellOverlays} from the given cell. This method\n   * fires a {@link removeoverlay} event for each {@link CellOverlay} and returns\n   * the array of {@link mxCellOverlays} that was removed from the cell.\n   *\n   * @param cell {@link mxCell} whose overlays should be removed\n   */\n  removeCellOverlays(cell) {\n    const {\n      overlays\n    } = cell;\n    cell.overlays = [];\n    // Immediately updates the cell display if the state exists\n    const state = this.getView().getState(cell);\n    if (state) {\n      this.getCellRenderer().redraw(state);\n    }\n    for (let i = 0; i < overlays.length; i += 1) {\n      this.fireEvent(new EventObject(InternalEvent.REMOVE_OVERLAY, 'cell', cell, 'overlay', overlays[i]));\n    }\n    return overlays;\n  },\n  /**\n   * Removes all {@link mxCellOverlays} in the graph for the given cell and all its\n   * descendants. If no cell is specified then all overlays are removed from\n   * the graph. This implementation uses {@link removeCellOverlays} to remove the\n   * overlays from the individual cells.\n   *\n   * @param cell Optional {@link Cell} that represents the root of the subtree to\n   * remove the overlays from. Default is the root in the model.\n   */\n  clearCellOverlays(cell = null) {\n    cell = cell ?? this.getDataModel().getRoot();\n    if (!cell) return;\n    this.removeCellOverlays(cell);\n    // Recursively removes all overlays from the children\n    const childCount = cell.getChildCount();\n    for (let i = 0; i < childCount; i += 1) {\n      const child = cell.getChildAt(i);\n      this.clearCellOverlays(child); // recurse\n    }\n  },\n  /**\n   * Creates an overlay for the given cell using the warning and image or\n   * {@link warningImage} and returns the new {@link CellOverlay}. The warning is\n   * displayed as a tooltip in a red font and may contain HTML markup. If\n   * the warning is null or a zero length string, then all overlays are\n   * removed from the cell.\n   *\n   * @example\n   * ```javascript\n   * graph.setCellWarning(cell, '{@link b}Warning:</b>: Hello, World!');\n   * ```\n   *\n   * @param cell {@link mxCell} whose warning should be set.\n   * @param warning String that represents the warning to be displayed.\n   * @param img Optional {@link Image} to be used for the overlay. Default is\n   * {@link warningImage}.\n   * @param isSelect Optional boolean indicating if a click on the overlay\n   * should select the corresponding cell. Default is `false`.\n   */\n  setCellWarning(cell, warning = null, img, isSelect = false) {\n    img = img ?? this.getWarningImage();\n    if (warning && warning.length > 0) {\n      // Creates the overlay with the image and warning\n      const overlay = new CellOverlay(img, `<font color=red>${warning}</font>`);\n      // Adds a handler for single mouseclicks to select the cell\n      if (isSelect) {\n        overlay.addListener(InternalEvent.CLICK, (sender, evt) => {\n          if (this.isEnabled()) {\n            this.setSelectionCell(cell);\n          }\n        });\n      }\n      // Sets and returns the overlay in the graph\n      return this.addCellOverlay(cell, overlay);\n    }\n    this.removeCellOverlays(cell);\n    return null;\n  }\n};\nmixInto(Graph)(OverlaysMixin);","map":{"version":3,"names":["CellOverlay","EventObject","InternalEvent","Graph","mixInto","OverlaysMixin","addCellOverlay","cell","overlay","overlays","push","state","getView","getState","getCellRenderer","redraw","fireEvent","ADD_OVERLAY","getCellOverlays","removeCellOverlay","removeCellOverlays","index","indexOf","splice","REMOVE_OVERLAY","i","length","clearCellOverlays","getDataModel","getRoot","childCount","getChildCount","child","getChildAt","setCellWarning","warning","img","isSelect","getWarningImage","addListener","CLICK","sender","evt","isEnabled","setSelectionCell"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/@maxgraph/core/dist/view/mixins/OverlaysMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport CellOverlay from '../cell/CellOverlay';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport { Graph } from '../Graph';\nimport { mixInto } from '../../util/Utils';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst OverlaysMixin = {\n    /*****************************************************************************\n     * Group: Overlays\n     *****************************************************************************/\n    /**\n     * Adds an {@link CellOverlay} for the specified cell. This method fires an\n     * {@link addoverlay} event and returns the new {@link CellOverlay}.\n     *\n     * @param cell {@link mxCell} to add the overlay for.\n     * @param overlay {@link CellOverlay} to be added for the cell.\n     */\n    addCellOverlay(cell, overlay) {\n        cell.overlays.push(overlay);\n        // Immediately update the cell display if the state exists\n        const state = this.getView().getState(cell);\n        if (state) {\n            this.getCellRenderer().redraw(state);\n        }\n        this.fireEvent(new EventObject(InternalEvent.ADD_OVERLAY, { cell, overlay }));\n        return overlay;\n    },\n    /**\n     * Returns the array of {@link mxCellOverlays} for the given cell or null, if\n     * no overlays are defined.\n     *\n     * @param cell {@link mxCell} whose overlays should be returned.\n     */\n    getCellOverlays(cell) {\n        return cell.overlays;\n    },\n    /**\n     * Removes and returns the given {@link CellOverlay} from the given cell. This\n     * method fires a {@link removeoverlay} event. If no overlay is given, then all\n     * overlays are removed using {@link removeOverlays}.\n     *\n     * @param cell {@link mxCell} whose overlay should be removed.\n     * @param overlay Optional {@link CellOverlay} to be removed.\n     */\n    // removeCellOverlay(cell: mxCell, overlay: CellOverlay): CellOverlay;\n    removeCellOverlay(cell, overlay = null) {\n        if (!overlay) {\n            this.removeCellOverlays(cell);\n        }\n        else {\n            const index = cell.overlays.indexOf(overlay);\n            if (index >= 0) {\n                cell.overlays.splice(index, 1);\n                // Immediately updates the cell display if the state exists\n                const state = this.getView().getState(cell);\n                if (state) {\n                    this.getCellRenderer().redraw(state);\n                }\n                this.fireEvent(new EventObject(InternalEvent.REMOVE_OVERLAY, { cell, overlay }));\n            }\n            else {\n                overlay = null;\n            }\n        }\n        return overlay;\n    },\n    /**\n     * Removes all {@link mxCellOverlays} from the given cell. This method\n     * fires a {@link removeoverlay} event for each {@link CellOverlay} and returns\n     * the array of {@link mxCellOverlays} that was removed from the cell.\n     *\n     * @param cell {@link mxCell} whose overlays should be removed\n     */\n    removeCellOverlays(cell) {\n        const { overlays } = cell;\n        cell.overlays = [];\n        // Immediately updates the cell display if the state exists\n        const state = this.getView().getState(cell);\n        if (state) {\n            this.getCellRenderer().redraw(state);\n        }\n        for (let i = 0; i < overlays.length; i += 1) {\n            this.fireEvent(new EventObject(InternalEvent.REMOVE_OVERLAY, 'cell', cell, 'overlay', overlays[i]));\n        }\n        return overlays;\n    },\n    /**\n     * Removes all {@link mxCellOverlays} in the graph for the given cell and all its\n     * descendants. If no cell is specified then all overlays are removed from\n     * the graph. This implementation uses {@link removeCellOverlays} to remove the\n     * overlays from the individual cells.\n     *\n     * @param cell Optional {@link Cell} that represents the root of the subtree to\n     * remove the overlays from. Default is the root in the model.\n     */\n    clearCellOverlays(cell = null) {\n        cell = cell ?? this.getDataModel().getRoot();\n        if (!cell)\n            return;\n        this.removeCellOverlays(cell);\n        // Recursively removes all overlays from the children\n        const childCount = cell.getChildCount();\n        for (let i = 0; i < childCount; i += 1) {\n            const child = cell.getChildAt(i);\n            this.clearCellOverlays(child); // recurse\n        }\n    },\n    /**\n     * Creates an overlay for the given cell using the warning and image or\n     * {@link warningImage} and returns the new {@link CellOverlay}. The warning is\n     * displayed as a tooltip in a red font and may contain HTML markup. If\n     * the warning is null or a zero length string, then all overlays are\n     * removed from the cell.\n     *\n     * @example\n     * ```javascript\n     * graph.setCellWarning(cell, '{@link b}Warning:</b>: Hello, World!');\n     * ```\n     *\n     * @param cell {@link mxCell} whose warning should be set.\n     * @param warning String that represents the warning to be displayed.\n     * @param img Optional {@link Image} to be used for the overlay. Default is\n     * {@link warningImage}.\n     * @param isSelect Optional boolean indicating if a click on the overlay\n     * should select the corresponding cell. Default is `false`.\n     */\n    setCellWarning(cell, warning = null, img, isSelect = false) {\n        img = img ?? this.getWarningImage();\n        if (warning && warning.length > 0) {\n            // Creates the overlay with the image and warning\n            const overlay = new CellOverlay(img, `<font color=red>${warning}</font>`);\n            // Adds a handler for single mouseclicks to select the cell\n            if (isSelect) {\n                overlay.addListener(InternalEvent.CLICK, (sender, evt) => {\n                    if (this.isEnabled()) {\n                        this.setSelectionCell(cell);\n                    }\n                });\n            }\n            // Sets and returns the overlay in the graph\n            return this.addCellOverlay(cell, overlay);\n        }\n        this.removeCellOverlays(cell);\n        return null;\n    },\n};\nmixInto(Graph)(OverlaysMixin);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}