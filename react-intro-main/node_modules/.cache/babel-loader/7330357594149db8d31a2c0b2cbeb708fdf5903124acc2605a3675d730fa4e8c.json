{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport EventSource from '../event/EventSource';\nimport Dictionary from '../../util/Dictionary';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport { sortCells } from '../../util/styleUtils';\n/**\n * An event handler that manages cell handlers and invokes their mouse event\n * processing functions.\n *\n * Group: Events\n *\n * Event: mxEvent.ADD\n *\n * Fires if a cell has been added to the selection. The <code>state</code>\n * property contains the <CellState> that has been added.\n *\n * Event: mxEvent.REMOVE\n *\n * Fires if a cell has been remove from the selection. The <code>state</code>\n * property contains the <CellState> that has been removed.\n *\n * @param graph Reference to the enclosing {@link Graph}.\n */\nclass SelectionCellsHandler extends EventSource {\n  constructor(graph) {\n    super();\n    /**\n     * Specifies if events are handled. Default is true.\n     */\n    this.enabled = true;\n    /**\n     * Defines the maximum number of handlers to paint individually. Default is 100.\n     */\n    this.maxHandlers = 100;\n    this.graph = graph;\n    this.handlers = new Dictionary();\n    this.graph.addMouseListener(this);\n    this.refreshHandler = (sender, evt) => {\n      if (this.isEnabled()) {\n        this.refresh();\n      }\n    };\n    this.graph.getSelectionModel().addListener(InternalEvent.CHANGE, this.refreshHandler);\n    this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.refreshHandler);\n    this.graph.getView().addListener(InternalEvent.SCALE, this.refreshHandler);\n    this.graph.getView().addListener(InternalEvent.TRANSLATE, this.refreshHandler);\n    this.graph.getView().addListener(InternalEvent.SCALE_AND_TRANSLATE, this.refreshHandler);\n    this.graph.getView().addListener(InternalEvent.DOWN, this.refreshHandler);\n    this.graph.getView().addListener(InternalEvent.UP, this.refreshHandler);\n  }\n  /**\n   * Returns <enabled>.\n   */\n  isEnabled() {\n    return this.enabled;\n  }\n  /**\n   * Sets <enabled>.\n   */\n  setEnabled(value) {\n    this.enabled = value;\n  }\n  /**\n   * Returns the handler for the given cell.\n   */\n  getHandler(cell) {\n    return this.handlers.get(cell);\n  }\n  /**\n   * Returns true if the given cell has a handler.\n   */\n  isHandled(cell) {\n    return !!this.getHandler(cell);\n  }\n  /**\n   * Resets all handlers.\n   */\n  reset() {\n    this.handlers.visit((key, handler) => {\n      handler.reset.apply(handler);\n    });\n  }\n  /**\n   * Reloads or updates all handlers.\n   */\n  getHandledSelectionCells() {\n    return this.graph.getSelectionCells();\n  }\n  /**\n   * Reloads or updates all handlers.\n   */\n  refresh() {\n    // Removes all existing handlers\n    const oldHandlers = this.handlers;\n    this.handlers = new Dictionary();\n    // Creates handles for all selection cells\n    const tmp = sortCells(this.getHandledSelectionCells(), false);\n    // Destroys or updates old handlers\n    for (let i = 0; i < tmp.length; i += 1) {\n      const state = this.graph.view.getState(tmp[i]);\n      if (state) {\n        let handler = oldHandlers.remove(tmp[i]);\n        if (handler) {\n          if (handler.state !== state) {\n            handler.onDestroy();\n            handler = null;\n          } else if (!this.isHandlerActive(handler)) {\n            // @ts-ignore refresh may exist\n            if (handler.refresh) handler.refresh();\n            handler.redraw();\n          }\n        }\n        if (handler) {\n          this.handlers.put(tmp[i], handler);\n        }\n      }\n    }\n    // Destroys unused handlers\n    oldHandlers.visit((key, handler) => {\n      this.fireEvent(new EventObject(InternalEvent.REMOVE, {\n        state: handler.state\n      }));\n      handler.onDestroy();\n    });\n    // Creates new handlers and updates parent highlight on existing handlers\n    for (let i = 0; i < tmp.length; i += 1) {\n      const state = this.graph.view.getState(tmp[i]);\n      if (state) {\n        let handler = this.handlers.get(tmp[i]);\n        if (!handler) {\n          handler = this.graph.createHandler(state);\n          this.fireEvent(new EventObject(InternalEvent.ADD, {\n            state\n          }));\n          this.handlers.put(tmp[i], handler);\n        } else {\n          handler.updateParentHighlight();\n        }\n      }\n    }\n  }\n  /**\n   * Returns true if the given handler is active and should not be redrawn.\n   */\n  isHandlerActive(handler) {\n    return handler.index !== null;\n  }\n  /**\n   * Updates the handler for the given shape if one exists.\n   */\n  updateHandler(state) {\n    let handler = this.handlers.remove(state.cell);\n    if (handler) {\n      // Transfers the current state to the new handler\n      const {\n        index\n      } = handler;\n      const x = handler.startX;\n      const y = handler.startY;\n      handler.onDestroy();\n      handler = this.graph.createHandler(state);\n      if (handler) {\n        this.handlers.put(state.cell, handler);\n        if (index !== null) {\n          handler.start(x, y, index);\n        }\n      }\n    }\n  }\n  /**\n   * Redirects the given event to the handlers.\n   */\n  mouseDown(sender, me) {\n    if (this.graph.isEnabled() && this.isEnabled()) {\n      this.handlers.visit((key, handler) => {\n        handler.mouseDown(sender, me);\n      });\n    }\n  }\n  /**\n   * Redirects the given event to the handlers.\n   */\n  mouseMove(sender, me) {\n    if (this.graph.isEnabled() && this.isEnabled()) {\n      this.handlers.visit((key, handler) => {\n        handler.mouseMove(sender, me);\n      });\n    }\n  }\n  /**\n   * Redirects the given event to the handlers.\n   */\n  mouseUp(sender, me) {\n    if (this.graph.isEnabled() && this.isEnabled()) {\n      this.handlers.visit((key, handler) => {\n        handler.mouseUp(sender, me);\n      });\n    }\n  }\n  /**\n   * Destroys the handler and all its resources and DOM nodes.\n   */\n  onDestroy() {\n    this.graph.removeMouseListener(this);\n    this.graph.removeListener(this.refreshHandler);\n    this.graph.getDataModel().removeListener(this.refreshHandler);\n    this.graph.getView().removeListener(this.refreshHandler);\n  }\n}\nSelectionCellsHandler.pluginId = 'SelectionCellsHandler';\nexport default SelectionCellsHandler;","map":{"version":3,"names":["EventSource","Dictionary","EventObject","InternalEvent","sortCells","SelectionCellsHandler","constructor","graph","enabled","maxHandlers","handlers","addMouseListener","refreshHandler","sender","evt","isEnabled","refresh","getSelectionModel","addListener","CHANGE","getDataModel","getView","SCALE","TRANSLATE","SCALE_AND_TRANSLATE","DOWN","UP","setEnabled","value","getHandler","cell","get","isHandled","reset","visit","key","handler","apply","getHandledSelectionCells","getSelectionCells","oldHandlers","tmp","i","length","state","view","getState","remove","onDestroy","isHandlerActive","redraw","put","fireEvent","REMOVE","createHandler","ADD","updateParentHighlight","index","updateHandler","x","startX","y","startY","start","mouseDown","me","mouseMove","mouseUp","removeMouseListener","removeListener","pluginId"],"sources":["D:/ospanel/domains/old/react/react-intro/node_modules/@maxgraph/core/dist/view/handler/SelectionCellsHandler.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport EventSource from '../event/EventSource';\nimport Dictionary from '../../util/Dictionary';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport { sortCells } from '../../util/styleUtils';\n/**\n * An event handler that manages cell handlers and invokes their mouse event\n * processing functions.\n *\n * Group: Events\n *\n * Event: mxEvent.ADD\n *\n * Fires if a cell has been added to the selection. The <code>state</code>\n * property contains the <CellState> that has been added.\n *\n * Event: mxEvent.REMOVE\n *\n * Fires if a cell has been remove from the selection. The <code>state</code>\n * property contains the <CellState> that has been removed.\n *\n * @param graph Reference to the enclosing {@link Graph}.\n */\nclass SelectionCellsHandler extends EventSource {\n    constructor(graph) {\n        super();\n        /**\n         * Specifies if events are handled. Default is true.\n         */\n        this.enabled = true;\n        /**\n         * Defines the maximum number of handlers to paint individually. Default is 100.\n         */\n        this.maxHandlers = 100;\n        this.graph = graph;\n        this.handlers = new Dictionary();\n        this.graph.addMouseListener(this);\n        this.refreshHandler = (sender, evt) => {\n            if (this.isEnabled()) {\n                this.refresh();\n            }\n        };\n        this.graph.getSelectionModel().addListener(InternalEvent.CHANGE, this.refreshHandler);\n        this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.refreshHandler);\n        this.graph.getView().addListener(InternalEvent.SCALE, this.refreshHandler);\n        this.graph.getView().addListener(InternalEvent.TRANSLATE, this.refreshHandler);\n        this.graph\n            .getView()\n            .addListener(InternalEvent.SCALE_AND_TRANSLATE, this.refreshHandler);\n        this.graph.getView().addListener(InternalEvent.DOWN, this.refreshHandler);\n        this.graph.getView().addListener(InternalEvent.UP, this.refreshHandler);\n    }\n    /**\n     * Returns <enabled>.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Sets <enabled>.\n     */\n    setEnabled(value) {\n        this.enabled = value;\n    }\n    /**\n     * Returns the handler for the given cell.\n     */\n    getHandler(cell) {\n        return this.handlers.get(cell);\n    }\n    /**\n     * Returns true if the given cell has a handler.\n     */\n    isHandled(cell) {\n        return !!this.getHandler(cell);\n    }\n    /**\n     * Resets all handlers.\n     */\n    reset() {\n        this.handlers.visit((key, handler) => {\n            handler.reset.apply(handler);\n        });\n    }\n    /**\n     * Reloads or updates all handlers.\n     */\n    getHandledSelectionCells() {\n        return this.graph.getSelectionCells();\n    }\n    /**\n     * Reloads or updates all handlers.\n     */\n    refresh() {\n        // Removes all existing handlers\n        const oldHandlers = this.handlers;\n        this.handlers = new Dictionary();\n        // Creates handles for all selection cells\n        const tmp = sortCells(this.getHandledSelectionCells(), false);\n        // Destroys or updates old handlers\n        for (let i = 0; i < tmp.length; i += 1) {\n            const state = this.graph.view.getState(tmp[i]);\n            if (state) {\n                let handler = oldHandlers.remove(tmp[i]);\n                if (handler) {\n                    if (handler.state !== state) {\n                        handler.onDestroy();\n                        handler = null;\n                    }\n                    else if (!this.isHandlerActive(handler)) {\n                        // @ts-ignore refresh may exist\n                        if (handler.refresh)\n                            handler.refresh();\n                        handler.redraw();\n                    }\n                }\n                if (handler) {\n                    this.handlers.put(tmp[i], handler);\n                }\n            }\n        }\n        // Destroys unused handlers\n        oldHandlers.visit((key, handler) => {\n            this.fireEvent(new EventObject(InternalEvent.REMOVE, { state: handler.state }));\n            handler.onDestroy();\n        });\n        // Creates new handlers and updates parent highlight on existing handlers\n        for (let i = 0; i < tmp.length; i += 1) {\n            const state = this.graph.view.getState(tmp[i]);\n            if (state) {\n                let handler = this.handlers.get(tmp[i]);\n                if (!handler) {\n                    handler = this.graph.createHandler(state);\n                    this.fireEvent(new EventObject(InternalEvent.ADD, { state }));\n                    this.handlers.put(tmp[i], handler);\n                }\n                else {\n                    handler.updateParentHighlight();\n                }\n            }\n        }\n    }\n    /**\n     * Returns true if the given handler is active and should not be redrawn.\n     */\n    isHandlerActive(handler) {\n        return handler.index !== null;\n    }\n    /**\n     * Updates the handler for the given shape if one exists.\n     */\n    updateHandler(state) {\n        let handler = this.handlers.remove(state.cell);\n        if (handler) {\n            // Transfers the current state to the new handler\n            const { index } = handler;\n            const x = handler.startX;\n            const y = handler.startY;\n            handler.onDestroy();\n            handler = this.graph.createHandler(state);\n            if (handler) {\n                this.handlers.put(state.cell, handler);\n                if (index !== null) {\n                    handler.start(x, y, index);\n                }\n            }\n        }\n    }\n    /**\n     * Redirects the given event to the handlers.\n     */\n    mouseDown(sender, me) {\n        if (this.graph.isEnabled() && this.isEnabled()) {\n            this.handlers.visit((key, handler) => {\n                handler.mouseDown(sender, me);\n            });\n        }\n    }\n    /**\n     * Redirects the given event to the handlers.\n     */\n    mouseMove(sender, me) {\n        if (this.graph.isEnabled() && this.isEnabled()) {\n            this.handlers.visit((key, handler) => {\n                handler.mouseMove(sender, me);\n            });\n        }\n    }\n    /**\n     * Redirects the given event to the handlers.\n     */\n    mouseUp(sender, me) {\n        if (this.graph.isEnabled() && this.isEnabled()) {\n            this.handlers.visit((key, handler) => {\n                handler.mouseUp(sender, me);\n            });\n        }\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes.\n     */\n    onDestroy() {\n        this.graph.removeMouseListener(this);\n        this.graph.removeListener(this.refreshHandler);\n        this.graph.getDataModel().removeListener(this.refreshHandler);\n        this.graph.getView().removeListener(this.refreshHandler);\n    }\n}\nSelectionCellsHandler.pluginId = 'SelectionCellsHandler';\nexport default SelectionCellsHandler;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}