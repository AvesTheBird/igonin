{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../geometry/Point';\nimport Dictionary from '../../util/Dictionary';\n/**\n * @class CellStatePreview\n *\n * Implements a live preview for moving cells.\n */\nclass CellStatePreview {\n  constructor(graph) {\n    /**\n     * Contains the number of entries in the map.\n     */\n    this.count = 0;\n    this.deltas = new Dictionary();\n    this.graph = graph;\n  }\n  /**\n   * Returns true if this contains no entries.\n   */\n  isEmpty() {\n    return this.count === 0;\n  }\n  /**\n   *\n   * @param {CellState} state\n   * @param {number} dx\n   * @param {number} dy\n   * @param {boolean} add\n   * @param {boolean} includeEdges\n   * @return {*}  {mxPoint}\n   * @memberof mxCellStatePreview\n   */\n  moveState(state, dx, dy) {\n    let add = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    let includeEdges = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    let delta = this.deltas.get(state.cell);\n    if (delta == null) {\n      // Note: Deltas stores the point and the state since the key is a string.\n      delta = {\n        point: new Point(dx, dy),\n        state\n      };\n      this.deltas.put(state.cell, delta);\n      this.count++;\n    } else if (add) {\n      delta.point.x += dx;\n      delta.point.y += dy;\n    } else {\n      delta.point.x = dx;\n      delta.point.y = dy;\n    }\n    if (includeEdges) {\n      this.addEdges(state);\n    }\n    return delta.point;\n  }\n  /**\n   *\n   * @param {Function} visitor\n   * @memberof mxCellStatePreview\n   */\n  show() {\n    let visitor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    this.deltas.visit((key, delta) => {\n      this.translateState(delta.state, delta.point.x, delta.point.y);\n    });\n    this.deltas.visit((key, delta) => {\n      this.revalidateState(delta.state, delta.point.x, delta.point.y, visitor);\n    });\n  }\n  /**\n   *\n   * @param {CellState} state\n   * @param {number} dx\n   * @param {number} dy\n   * @memberof mxCellStatePreview\n   */\n  translateState(state, dx, dy) {\n    if (state != null) {\n      if (state.cell.isVertex()) {\n        state.view.updateCellState(state);\n        const geo = state.cell.getGeometry();\n        // Moves selection cells and non-relative vertices in\n        // the first phase so that edge terminal points will\n        // be updated in the second phase\n        if ((dx !== 0 || dy !== 0) && geo != null && (!geo.relative || this.deltas.get(state.cell) != null)) {\n          state.x += dx;\n          state.y += dy;\n        }\n      }\n      for (const child of state.cell.getChildren()) {\n        this.translateState(state.view.getState(child), dx, dy);\n      }\n    }\n  }\n  /**\n   *\n   * @param {CellState} state\n   * @param {number} dx\n   * @param {number} dy\n   * @param {Function} visitor\n   * @memberof mxCellStatePreview\n   */\n  revalidateState(state, dx, dy) {\n    let visitor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    // Updates the edge terminal points and restores the\n    // (relative) positions of any (relative) children\n    if (state.cell.isEdge()) {\n      state.view.updateCellState(state);\n    }\n    const geo = state.cell.getGeometry();\n    const pState = state.view.getState(state.cell.getParent());\n    // Moves selection vertices which are relative\n    if ((dx !== 0 || dy !== 0) && geo != null && geo.relative && state.cell.isVertex() && (pState == null || pState.cell.isVertex() || this.deltas.get(state.cell) != null)) {\n      state.x += dx;\n      state.y += dy;\n    }\n    this.graph.cellRenderer.redraw(state);\n    // Invokes the visitor on the given state\n    if (visitor != null) {\n      visitor(state);\n    }\n    for (const child of state.cell.getChildren()) {\n      this.revalidateState(this.graph.view.getState(child), dx, dy, visitor);\n    }\n  }\n  /**\n   *\n   * @param {CellState} state\n   * @memberof mxCellStatePreview\n   */\n  addEdges(state) {\n    const edgeCount = state.cell.getEdgeCount();\n    for (let i = 0; i < edgeCount; i += 1) {\n      const s = state.view.getState(state.cell.getEdgeAt(i));\n      if (s != null) {\n        this.moveState(s, 0, 0);\n      }\n    }\n  }\n}\nexport default CellStatePreview;","map":{"version":3,"names":["Point","Dictionary","CellStatePreview","constructor","graph","count","deltas","isEmpty","moveState","state","dx","dy","add","arguments","length","undefined","includeEdges","delta","get","cell","point","put","x","y","addEdges","show","visitor","visit","key","translateState","revalidateState","isVertex","view","updateCellState","geo","getGeometry","relative","child","getChildren","getState","isEdge","pState","getParent","cellRenderer","redraw","edgeCount","getEdgeCount","i","s","getEdgeAt"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/@maxgraph/core/dist/view/cell/CellStatePreview.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../geometry/Point';\nimport Dictionary from '../../util/Dictionary';\n/**\n * @class CellStatePreview\n *\n * Implements a live preview for moving cells.\n */\nclass CellStatePreview {\n    constructor(graph) {\n        /**\n         * Contains the number of entries in the map.\n         */\n        this.count = 0;\n        this.deltas = new Dictionary();\n        this.graph = graph;\n    }\n    /**\n     * Returns true if this contains no entries.\n     */\n    isEmpty() {\n        return this.count === 0;\n    }\n    /**\n     *\n     * @param {CellState} state\n     * @param {number} dx\n     * @param {number} dy\n     * @param {boolean} add\n     * @param {boolean} includeEdges\n     * @return {*}  {mxPoint}\n     * @memberof mxCellStatePreview\n     */\n    moveState(state, dx, dy, add = true, includeEdges = true) {\n        let delta = this.deltas.get(state.cell);\n        if (delta == null) {\n            // Note: Deltas stores the point and the state since the key is a string.\n            delta = { point: new Point(dx, dy), state };\n            this.deltas.put(state.cell, delta);\n            this.count++;\n        }\n        else if (add) {\n            delta.point.x += dx;\n            delta.point.y += dy;\n        }\n        else {\n            delta.point.x = dx;\n            delta.point.y = dy;\n        }\n        if (includeEdges) {\n            this.addEdges(state);\n        }\n        return delta.point;\n    }\n    /**\n     *\n     * @param {Function} visitor\n     * @memberof mxCellStatePreview\n     */\n    show(visitor = null) {\n        this.deltas.visit((key, delta) => {\n            this.translateState(delta.state, delta.point.x, delta.point.y);\n        });\n        this.deltas.visit((key, delta) => {\n            this.revalidateState(delta.state, delta.point.x, delta.point.y, visitor);\n        });\n    }\n    /**\n     *\n     * @param {CellState} state\n     * @param {number} dx\n     * @param {number} dy\n     * @memberof mxCellStatePreview\n     */\n    translateState(state, dx, dy) {\n        if (state != null) {\n            if (state.cell.isVertex()) {\n                state.view.updateCellState(state);\n                const geo = state.cell.getGeometry();\n                // Moves selection cells and non-relative vertices in\n                // the first phase so that edge terminal points will\n                // be updated in the second phase\n                if ((dx !== 0 || dy !== 0) &&\n                    geo != null &&\n                    (!geo.relative || this.deltas.get(state.cell) != null)) {\n                    state.x += dx;\n                    state.y += dy;\n                }\n            }\n            for (const child of state.cell.getChildren()) {\n                this.translateState(state.view.getState(child), dx, dy);\n            }\n        }\n    }\n    /**\n     *\n     * @param {CellState} state\n     * @param {number} dx\n     * @param {number} dy\n     * @param {Function} visitor\n     * @memberof mxCellStatePreview\n     */\n    revalidateState(state, dx, dy, visitor = null) {\n        // Updates the edge terminal points and restores the\n        // (relative) positions of any (relative) children\n        if (state.cell.isEdge()) {\n            state.view.updateCellState(state);\n        }\n        const geo = state.cell.getGeometry();\n        const pState = state.view.getState(state.cell.getParent());\n        // Moves selection vertices which are relative\n        if ((dx !== 0 || dy !== 0) &&\n            geo != null &&\n            geo.relative &&\n            state.cell.isVertex() &&\n            (pState == null || pState.cell.isVertex() || this.deltas.get(state.cell) != null)) {\n            state.x += dx;\n            state.y += dy;\n        }\n        this.graph.cellRenderer.redraw(state);\n        // Invokes the visitor on the given state\n        if (visitor != null) {\n            visitor(state);\n        }\n        for (const child of state.cell.getChildren()) {\n            this.revalidateState(this.graph.view.getState(child), dx, dy, visitor);\n        }\n    }\n    /**\n     *\n     * @param {CellState} state\n     * @memberof mxCellStatePreview\n     */\n    addEdges(state) {\n        const edgeCount = state.cell.getEdgeCount();\n        for (let i = 0; i < edgeCount; i += 1) {\n            const s = state.view.getState(state.cell.getEdgeAt(i));\n            if (s != null) {\n                this.moveState(s, 0, 0);\n            }\n        }\n    }\n}\nexport default CellStatePreview;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}