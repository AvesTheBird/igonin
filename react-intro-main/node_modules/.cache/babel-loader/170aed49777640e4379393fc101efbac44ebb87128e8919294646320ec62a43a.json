{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nimport { compareBy, Permutation } from '../../../../../base/common/arrays.js';\nimport { mapFindFirst } from '../../../../../base/common/arraysFind.js';\nimport { itemsEquals } from '../../../../../base/common/equals.js';\nimport { BugIndicatingError, onUnexpectedError, onUnexpectedExternalError } from '../../../../../base/common/errors.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { autorun, derived, derivedHandleChanges, derivedOpts, observableSignal, observableValue, recomputeInitiallyAndOnChange, subtransaction, transaction } from '../../../../../base/common/observable.js';\nimport { commonPrefixLength, splitLinesIncludeSeparators } from '../../../../../base/common/strings.js';\nimport { isDefined } from '../../../../../base/common/types.js';\nimport { EditOperation } from '../../../../common/core/editOperation.js';\nimport { Position } from '../../../../common/core/position.js';\nimport { Range } from '../../../../common/core/range.js';\nimport { Selection } from '../../../../common/core/selection.js';\nimport { SingleTextEdit, TextEdit } from '../../../../common/core/textEdit.js';\nimport { TextLength } from '../../../../common/core/textLength.js';\nimport { InlineCompletionTriggerKind } from '../../../../common/languages.js';\nimport { ILanguageConfigurationService } from '../../../../common/languages/languageConfigurationRegistry.js';\nimport { GhostText, ghostTextOrReplacementEquals, ghostTextsOrReplacementsEqual } from './ghostText.js';\nimport { InlineCompletionsSource } from './inlineCompletionsSource.js';\nimport { computeGhostText, singleTextEditAugments, singleTextRemoveCommonPrefix } from './singleTextEdit.js';\nimport { addPositions, subtractPositions } from '../utils.js';\nimport { SnippetController2 } from '../../../snippet/browser/snippetController2.js';\nimport { ICommandService } from '../../../../../platform/commands/common/commands.js';\nimport { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\nlet InlineCompletionsModel = class InlineCompletionsModel extends Disposable {\n  get isAcceptingPartially() {\n    return this._isAcceptingPartially;\n  }\n  constructor(textModel, selectedSuggestItem, _textModelVersionId, _positions, _debounceValue, _suggestPreviewEnabled, _suggestPreviewMode, _inlineSuggestMode, _enabled, _instantiationService, _commandService, _languageConfigurationService) {\n    super();\n    this.textModel = textModel;\n    this.selectedSuggestItem = selectedSuggestItem;\n    this._textModelVersionId = _textModelVersionId;\n    this._positions = _positions;\n    this._debounceValue = _debounceValue;\n    this._suggestPreviewEnabled = _suggestPreviewEnabled;\n    this._suggestPreviewMode = _suggestPreviewMode;\n    this._inlineSuggestMode = _inlineSuggestMode;\n    this._enabled = _enabled;\n    this._instantiationService = _instantiationService;\n    this._commandService = _commandService;\n    this._languageConfigurationService = _languageConfigurationService;\n    this._source = this._register(this._instantiationService.createInstance(InlineCompletionsSource, this.textModel, this._textModelVersionId, this._debounceValue));\n    this._isActive = observableValue(this, false);\n    this._forceUpdateExplicitlySignal = observableSignal(this);\n    // We use a semantic id to keep the same inline completion selected even if the provider reorders the completions.\n    this._selectedInlineCompletionId = observableValue(this, undefined);\n    this._primaryPosition = derived(this, reader => {\n      var _this$_positions$read;\n      return (_this$_positions$read = this._positions.read(reader)[0]) !== null && _this$_positions$read !== void 0 ? _this$_positions$read : new Position(1, 1);\n    });\n    this._isAcceptingPartially = false;\n    this._preserveCurrentCompletionReasons = new Set([VersionIdChangeReason.Redo, VersionIdChangeReason.Undo, VersionIdChangeReason.AcceptWord]);\n    this._fetchInlineCompletionsPromise = derivedHandleChanges({\n      owner: this,\n      createEmptyChangeSummary: () => ({\n        preserveCurrentCompletion: false,\n        inlineCompletionTriggerKind: InlineCompletionTriggerKind.Automatic\n      }),\n      handleChange: (ctx, changeSummary) => {\n        /** @description fetch inline completions */\n        if (ctx.didChange(this._textModelVersionId) && this._preserveCurrentCompletionReasons.has(this._getReason(ctx.change))) {\n          changeSummary.preserveCurrentCompletion = true;\n        } else if (ctx.didChange(this._forceUpdateExplicitlySignal)) {\n          changeSummary.inlineCompletionTriggerKind = InlineCompletionTriggerKind.Explicit;\n        }\n        return true;\n      }\n    }, (reader, changeSummary) => {\n      this._forceUpdateExplicitlySignal.read(reader);\n      const shouldUpdate = this._enabled.read(reader) && this.selectedSuggestItem.read(reader) || this._isActive.read(reader);\n      if (!shouldUpdate) {\n        this._source.cancelUpdate();\n        return undefined;\n      }\n      this._textModelVersionId.read(reader); // Refetch on text change\n      const suggestWidgetInlineCompletions = this._source.suggestWidgetInlineCompletions.get();\n      const suggestItem = this.selectedSuggestItem.read(reader);\n      if (suggestWidgetInlineCompletions && !suggestItem) {\n        const inlineCompletions = this._source.inlineCompletions.get();\n        transaction(tx => {\n          /** @description Seed inline completions with (newer) suggest widget inline completions */\n          if (!inlineCompletions || suggestWidgetInlineCompletions.request.versionId > inlineCompletions.request.versionId) {\n            this._source.inlineCompletions.set(suggestWidgetInlineCompletions.clone(), tx);\n          }\n          this._source.clearSuggestWidgetInlineCompletions(tx);\n        });\n      }\n      const cursorPosition = this._primaryPosition.read(reader);\n      const context = {\n        triggerKind: changeSummary.inlineCompletionTriggerKind,\n        selectedSuggestionInfo: suggestItem === null || suggestItem === void 0 ? void 0 : suggestItem.toSelectedSuggestionInfo()\n      };\n      const itemToPreserveCandidate = this.selectedInlineCompletion.get();\n      const itemToPreserve = changeSummary.preserveCurrentCompletion || itemToPreserveCandidate !== null && itemToPreserveCandidate !== void 0 && itemToPreserveCandidate.forwardStable ? itemToPreserveCandidate : undefined;\n      return this._source.fetch(cursorPosition, context, itemToPreserve);\n    });\n    this._filteredInlineCompletionItems = derivedOpts({\n      owner: this,\n      equalsFn: itemsEquals()\n    }, reader => {\n      const c = this._source.inlineCompletions.read(reader);\n      if (!c) {\n        return [];\n      }\n      const cursorPosition = this._primaryPosition.read(reader);\n      const filteredCompletions = c.inlineCompletions.filter(c => c.isVisible(this.textModel, cursorPosition, reader));\n      return filteredCompletions;\n    });\n    this.selectedInlineCompletionIndex = derived(this, reader => {\n      const selectedInlineCompletionId = this._selectedInlineCompletionId.read(reader);\n      const filteredCompletions = this._filteredInlineCompletionItems.read(reader);\n      const idx = this._selectedInlineCompletionId === undefined ? -1 : filteredCompletions.findIndex(v => v.semanticId === selectedInlineCompletionId);\n      if (idx === -1) {\n        // Reset the selection so that the selection does not jump back when it appears again\n        this._selectedInlineCompletionId.set(undefined, undefined);\n        return 0;\n      }\n      return idx;\n    });\n    this.selectedInlineCompletion = derived(this, reader => {\n      const filteredCompletions = this._filteredInlineCompletionItems.read(reader);\n      const idx = this.selectedInlineCompletionIndex.read(reader);\n      return filteredCompletions[idx];\n    });\n    this.activeCommands = derivedOpts({\n      owner: this,\n      equalsFn: itemsEquals()\n    }, r => {\n      var _this$selectedInlineC, _this$selectedInlineC2;\n      return (_this$selectedInlineC = (_this$selectedInlineC2 = this.selectedInlineCompletion.read(r)) === null || _this$selectedInlineC2 === void 0 ? void 0 : _this$selectedInlineC2.inlineCompletion.source.inlineCompletions.commands) !== null && _this$selectedInlineC !== void 0 ? _this$selectedInlineC : [];\n    });\n    this.lastTriggerKind = this._source.inlineCompletions.map(this, v => v === null || v === void 0 ? void 0 : v.request.context.triggerKind);\n    this.inlineCompletionsCount = derived(this, reader => {\n      if (this.lastTriggerKind.read(reader) === InlineCompletionTriggerKind.Explicit) {\n        return this._filteredInlineCompletionItems.read(reader).length;\n      } else {\n        return undefined;\n      }\n    });\n    this.state = derivedOpts({\n      owner: this,\n      equalsFn: (a, b) => {\n        if (!a || !b) {\n          return a === b;\n        }\n        return ghostTextsOrReplacementsEqual(a.ghostTexts, b.ghostTexts) && a.inlineCompletion === b.inlineCompletion && a.suggestItem === b.suggestItem;\n      }\n    }, reader => {\n      const model = this.textModel;\n      const suggestItem = this.selectedSuggestItem.read(reader);\n      if (suggestItem) {\n        var _augmentation$edit, _ghostTexts$;\n        const suggestCompletionEdit = singleTextRemoveCommonPrefix(suggestItem.toSingleTextEdit(), model);\n        const augmentation = this._computeAugmentation(suggestCompletionEdit, reader);\n        const isSuggestionPreviewEnabled = this._suggestPreviewEnabled.read(reader);\n        if (!isSuggestionPreviewEnabled && !augmentation) {\n          return undefined;\n        }\n        const fullEdit = (_augmentation$edit = augmentation === null || augmentation === void 0 ? void 0 : augmentation.edit) !== null && _augmentation$edit !== void 0 ? _augmentation$edit : suggestCompletionEdit;\n        const fullEditPreviewLength = augmentation ? augmentation.edit.text.length - suggestCompletionEdit.text.length : 0;\n        const mode = this._suggestPreviewMode.read(reader);\n        const positions = this._positions.read(reader);\n        const edits = [fullEdit, ...getSecondaryEdits(this.textModel, positions, fullEdit)];\n        const ghostTexts = edits.map((edit, idx) => computeGhostText(edit, model, mode, positions[idx], fullEditPreviewLength)).filter(isDefined);\n        const primaryGhostText = (_ghostTexts$ = ghostTexts[0]) !== null && _ghostTexts$ !== void 0 ? _ghostTexts$ : new GhostText(fullEdit.range.endLineNumber, []);\n        return {\n          edits,\n          primaryGhostText,\n          ghostTexts,\n          inlineCompletion: augmentation === null || augmentation === void 0 ? void 0 : augmentation.completion,\n          suggestItem\n        };\n      } else {\n        if (!this._isActive.read(reader)) {\n          return undefined;\n        }\n        const inlineCompletion = this.selectedInlineCompletion.read(reader);\n        if (!inlineCompletion) {\n          return undefined;\n        }\n        const replacement = inlineCompletion.toSingleTextEdit(reader);\n        const mode = this._inlineSuggestMode.read(reader);\n        const positions = this._positions.read(reader);\n        const edits = [replacement, ...getSecondaryEdits(this.textModel, positions, replacement)];\n        const ghostTexts = edits.map((edit, idx) => computeGhostText(edit, model, mode, positions[idx], 0)).filter(isDefined);\n        if (!ghostTexts[0]) {\n          return undefined;\n        }\n        return {\n          edits,\n          primaryGhostText: ghostTexts[0],\n          ghostTexts,\n          inlineCompletion,\n          suggestItem: undefined\n        };\n      }\n    });\n    this.ghostTexts = derivedOpts({\n      owner: this,\n      equalsFn: ghostTextsOrReplacementsEqual\n    }, reader => {\n      const v = this.state.read(reader);\n      if (!v) {\n        return undefined;\n      }\n      return v.ghostTexts;\n    });\n    this.primaryGhostText = derivedOpts({\n      owner: this,\n      equalsFn: ghostTextOrReplacementEquals\n    }, reader => {\n      const v = this.state.read(reader);\n      if (!v) {\n        return undefined;\n      }\n      return v === null || v === void 0 ? void 0 : v.primaryGhostText;\n    });\n    this._register(recomputeInitiallyAndOnChange(this._fetchInlineCompletionsPromise));\n    let lastItem = undefined;\n    this._register(autorun(reader => {\n      var _lastItem;\n      /** @description call handleItemDidShow */\n      const item = this.state.read(reader);\n      const completion = item === null || item === void 0 ? void 0 : item.inlineCompletion;\n      if ((completion === null || completion === void 0 ? void 0 : completion.semanticId) !== ((_lastItem = lastItem) === null || _lastItem === void 0 ? void 0 : _lastItem.semanticId)) {\n        lastItem = completion;\n        if (completion) {\n          var _src$provider$handleI, _src$provider;\n          const i = completion.inlineCompletion;\n          const src = i.source;\n          (_src$provider$handleI = (_src$provider = src.provider).handleItemDidShow) === null || _src$provider$handleI === void 0 || _src$provider$handleI.call(_src$provider, src.inlineCompletions, i.sourceInlineCompletion, i.insertText);\n        }\n      }\n    }));\n  }\n  _getReason(e) {\n    if (e !== null && e !== void 0 && e.isUndoing) {\n      return VersionIdChangeReason.Undo;\n    }\n    if (e !== null && e !== void 0 && e.isRedoing) {\n      return VersionIdChangeReason.Redo;\n    }\n    if (this.isAcceptingPartially) {\n      return VersionIdChangeReason.AcceptWord;\n    }\n    return VersionIdChangeReason.Other;\n  }\n  async trigger(tx) {\n    this._isActive.set(true, tx);\n    await this._fetchInlineCompletionsPromise.get();\n  }\n  async triggerExplicitly(tx) {\n    subtransaction(tx, tx => {\n      this._isActive.set(true, tx);\n      this._forceUpdateExplicitlySignal.trigger(tx);\n    });\n    await this._fetchInlineCompletionsPromise.get();\n  }\n  stop(tx) {\n    subtransaction(tx, tx => {\n      this._isActive.set(false, tx);\n      this._source.clear(tx);\n    });\n  }\n  _computeAugmentation(suggestCompletion, reader) {\n    const model = this.textModel;\n    const suggestWidgetInlineCompletions = this._source.suggestWidgetInlineCompletions.read(reader);\n    const candidateInlineCompletions = suggestWidgetInlineCompletions ? suggestWidgetInlineCompletions.inlineCompletions : [this.selectedInlineCompletion.read(reader)].filter(isDefined);\n    const augmentedCompletion = mapFindFirst(candidateInlineCompletions, completion => {\n      let r = completion.toSingleTextEdit(reader);\n      r = singleTextRemoveCommonPrefix(r, model, Range.fromPositions(r.range.getStartPosition(), suggestCompletion.range.getEndPosition()));\n      return singleTextEditAugments(r, suggestCompletion) ? {\n        completion,\n        edit: r\n      } : undefined;\n    });\n    return augmentedCompletion;\n  }\n  async _deltaSelectedInlineCompletionIndex(delta) {\n    await this.triggerExplicitly();\n    const completions = this._filteredInlineCompletionItems.get() || [];\n    if (completions.length > 0) {\n      const newIdx = (this.selectedInlineCompletionIndex.get() + delta + completions.length) % completions.length;\n      this._selectedInlineCompletionId.set(completions[newIdx].semanticId, undefined);\n    } else {\n      this._selectedInlineCompletionId.set(undefined, undefined);\n    }\n  }\n  async next() {\n    await this._deltaSelectedInlineCompletionIndex(1);\n  }\n  async previous() {\n    await this._deltaSelectedInlineCompletionIndex(-1);\n  }\n  async accept(editor) {\n    if (editor.getModel() !== this.textModel) {\n      throw new BugIndicatingError();\n    }\n    const state = this.state.get();\n    if (!state || state.primaryGhostText.isEmpty() || !state.inlineCompletion) {\n      return;\n    }\n    const completion = state.inlineCompletion.toInlineCompletion(undefined);\n    if (completion.command) {\n      // Make sure the completion list will not be disposed.\n      completion.source.addRef();\n    }\n    editor.pushUndoStop();\n    if (completion.snippetInfo) {\n      var _SnippetController2$g;\n      editor.executeEdits('inlineSuggestion.accept', [EditOperation.replace(completion.range, ''), ...completion.additionalTextEdits]);\n      editor.setPosition(completion.snippetInfo.range.getStartPosition(), 'inlineCompletionAccept');\n      (_SnippetController2$g = SnippetController2.get(editor)) === null || _SnippetController2$g === void 0 || _SnippetController2$g.insert(completion.snippetInfo.snippet, {\n        undoStopBefore: false\n      });\n    } else {\n      const edits = state.edits;\n      const selections = getEndPositionsAfterApplying(edits).map(p => Selection.fromPositions(p));\n      editor.executeEdits('inlineSuggestion.accept', [...edits.map(edit => EditOperation.replace(edit.range, edit.text)), ...completion.additionalTextEdits]);\n      editor.setSelections(selections, 'inlineCompletionAccept');\n    }\n    // Reset before invoking the command, as the command might cause a follow up trigger (which we don't want to reset).\n    this.stop();\n    if (completion.command) {\n      await this._commandService.executeCommand(completion.command.id, ...(completion.command.arguments || [])).then(undefined, onUnexpectedExternalError);\n      completion.source.removeRef();\n    }\n  }\n  async acceptNextWord(editor) {\n    await this._acceptNext(editor, (pos, text) => {\n      const langId = this.textModel.getLanguageIdAtPosition(pos.lineNumber, pos.column);\n      const config = this._languageConfigurationService.getLanguageConfiguration(langId);\n      const wordRegExp = new RegExp(config.wordDefinition.source, config.wordDefinition.flags.replace('g', ''));\n      const m1 = text.match(wordRegExp);\n      let acceptUntilIndexExclusive = 0;\n      if (m1 && m1.index !== undefined) {\n        if (m1.index === 0) {\n          acceptUntilIndexExclusive = m1[0].length;\n        } else {\n          acceptUntilIndexExclusive = m1.index;\n        }\n      } else {\n        acceptUntilIndexExclusive = text.length;\n      }\n      const wsRegExp = /\\s+/g;\n      const m2 = wsRegExp.exec(text);\n      if (m2 && m2.index !== undefined) {\n        if (m2.index + m2[0].length < acceptUntilIndexExclusive) {\n          acceptUntilIndexExclusive = m2.index + m2[0].length;\n        }\n      }\n      return acceptUntilIndexExclusive;\n    }, 0 /* PartialAcceptTriggerKind.Word */);\n  }\n  async acceptNextLine(editor) {\n    await this._acceptNext(editor, (pos, text) => {\n      const m = text.match(/\\n/);\n      if (m && m.index !== undefined) {\n        return m.index + 1;\n      }\n      return text.length;\n    }, 1 /* PartialAcceptTriggerKind.Line */);\n  }\n  async _acceptNext(editor, getAcceptUntilIndex, kind) {\n    if (editor.getModel() !== this.textModel) {\n      throw new BugIndicatingError();\n    }\n    const state = this.state.get();\n    if (!state || state.primaryGhostText.isEmpty() || !state.inlineCompletion) {\n      return;\n    }\n    const ghostText = state.primaryGhostText;\n    const completion = state.inlineCompletion.toInlineCompletion(undefined);\n    if (completion.snippetInfo || completion.filterText !== completion.insertText) {\n      // not in WYSIWYG mode, partial commit might change completion, thus it is not supported\n      await this.accept(editor);\n      return;\n    }\n    const firstPart = ghostText.parts[0];\n    const ghostTextPos = new Position(ghostText.lineNumber, firstPart.column);\n    const ghostTextVal = firstPart.text;\n    const acceptUntilIndexExclusive = getAcceptUntilIndex(ghostTextPos, ghostTextVal);\n    if (acceptUntilIndexExclusive === ghostTextVal.length && ghostText.parts.length === 1) {\n      this.accept(editor);\n      return;\n    }\n    const partialGhostTextVal = ghostTextVal.substring(0, acceptUntilIndexExclusive);\n    const positions = this._positions.get();\n    const cursorPosition = positions[0];\n    // Executing the edit might free the completion, so we have to hold a reference on it.\n    completion.source.addRef();\n    try {\n      this._isAcceptingPartially = true;\n      try {\n        editor.pushUndoStop();\n        const replaceRange = Range.fromPositions(cursorPosition, ghostTextPos);\n        const newText = editor.getModel().getValueInRange(replaceRange) + partialGhostTextVal;\n        const primaryEdit = new SingleTextEdit(replaceRange, newText);\n        const edits = [primaryEdit, ...getSecondaryEdits(this.textModel, positions, primaryEdit)];\n        const selections = getEndPositionsAfterApplying(edits).map(p => Selection.fromPositions(p));\n        editor.executeEdits('inlineSuggestion.accept', edits.map(edit => EditOperation.replace(edit.range, edit.text)));\n        editor.setSelections(selections, 'inlineCompletionPartialAccept');\n        editor.revealPositionInCenterIfOutsideViewport(editor.getPosition(), 1 /* ScrollType.Immediate */);\n      } finally {\n        this._isAcceptingPartially = false;\n      }\n      if (completion.source.provider.handlePartialAccept) {\n        const acceptedRange = Range.fromPositions(completion.range.getStartPosition(), TextLength.ofText(partialGhostTextVal).addToPosition(ghostTextPos));\n        // This assumes that the inline completion and the model use the same EOL style.\n        const text = editor.getModel().getValueInRange(acceptedRange, 1 /* EndOfLinePreference.LF */);\n        completion.source.provider.handlePartialAccept(completion.source.inlineCompletions, completion.sourceInlineCompletion, text.length, {\n          kind\n        });\n      }\n    } finally {\n      completion.source.removeRef();\n    }\n  }\n  handleSuggestAccepted(item) {\n    var _inlineCompletion$sou, _inlineCompletion$sou2;\n    const itemEdit = singleTextRemoveCommonPrefix(item.toSingleTextEdit(), this.textModel);\n    const augmentedCompletion = this._computeAugmentation(itemEdit, undefined);\n    if (!augmentedCompletion) {\n      return;\n    }\n    const inlineCompletion = augmentedCompletion.completion.inlineCompletion;\n    (_inlineCompletion$sou = (_inlineCompletion$sou2 = inlineCompletion.source.provider).handlePartialAccept) === null || _inlineCompletion$sou === void 0 || _inlineCompletion$sou.call(_inlineCompletion$sou2, inlineCompletion.source.inlineCompletions, inlineCompletion.sourceInlineCompletion, itemEdit.text.length, {\n      kind: 2 /* PartialAcceptTriggerKind.Suggest */\n    });\n  }\n};\nInlineCompletionsModel = __decorate([__param(9, IInstantiationService), __param(10, ICommandService), __param(11, ILanguageConfigurationService)], InlineCompletionsModel);\nexport { InlineCompletionsModel };\nexport var VersionIdChangeReason;\n(function (VersionIdChangeReason) {\n  VersionIdChangeReason[VersionIdChangeReason[\"Undo\"] = 0] = \"Undo\";\n  VersionIdChangeReason[VersionIdChangeReason[\"Redo\"] = 1] = \"Redo\";\n  VersionIdChangeReason[VersionIdChangeReason[\"AcceptWord\"] = 2] = \"AcceptWord\";\n  VersionIdChangeReason[VersionIdChangeReason[\"Other\"] = 3] = \"Other\";\n})(VersionIdChangeReason || (VersionIdChangeReason = {}));\nexport function getSecondaryEdits(textModel, positions, primaryEdit) {\n  if (positions.length === 1) {\n    // No secondary cursor positions\n    return [];\n  }\n  const primaryPosition = positions[0];\n  const secondaryPositions = positions.slice(1);\n  const primaryEditStartPosition = primaryEdit.range.getStartPosition();\n  const primaryEditEndPosition = primaryEdit.range.getEndPosition();\n  const replacedTextAfterPrimaryCursor = textModel.getValueInRange(Range.fromPositions(primaryPosition, primaryEditEndPosition));\n  const positionWithinTextEdit = subtractPositions(primaryPosition, primaryEditStartPosition);\n  if (positionWithinTextEdit.lineNumber < 1) {\n    onUnexpectedError(new BugIndicatingError(\"positionWithinTextEdit line number should be bigger than 0.\\n\\t\\t\\tInvalid subtraction between \".concat(primaryPosition.toString(), \" and \").concat(primaryEditStartPosition.toString())));\n    return [];\n  }\n  const secondaryEditText = substringPos(primaryEdit.text, positionWithinTextEdit);\n  return secondaryPositions.map(pos => {\n    const posEnd = addPositions(subtractPositions(pos, primaryEditStartPosition), primaryEditEndPosition);\n    const textAfterSecondaryCursor = textModel.getValueInRange(Range.fromPositions(pos, posEnd));\n    const l = commonPrefixLength(replacedTextAfterPrimaryCursor, textAfterSecondaryCursor);\n    const range = Range.fromPositions(pos, pos.delta(0, l));\n    return new SingleTextEdit(range, secondaryEditText);\n  });\n}\nfunction substringPos(text, pos) {\n  let subtext = '';\n  const lines = splitLinesIncludeSeparators(text);\n  for (let i = pos.lineNumber - 1; i < lines.length; i++) {\n    subtext += lines[i].substring(i === pos.lineNumber - 1 ? pos.column - 1 : 0);\n  }\n  return subtext;\n}\nfunction getEndPositionsAfterApplying(edits) {\n  const sortPerm = Permutation.createSortPermutation(edits, compareBy(e => e.range, Range.compareRangesUsingStarts));\n  const edit = new TextEdit(sortPerm.apply(edits));\n  const sortedNewRanges = edit.getNewRanges();\n  const newRanges = sortPerm.inverse().apply(sortedNewRanges);\n  return newRanges.map(range => range.getEndPosition());\n}","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","compareBy","Permutation","mapFindFirst","itemsEquals","BugIndicatingError","onUnexpectedError","onUnexpectedExternalError","Disposable","autorun","derived","derivedHandleChanges","derivedOpts","observableSignal","observableValue","recomputeInitiallyAndOnChange","subtransaction","transaction","commonPrefixLength","splitLinesIncludeSeparators","isDefined","EditOperation","Position","Range","Selection","SingleTextEdit","TextEdit","TextLength","InlineCompletionTriggerKind","ILanguageConfigurationService","GhostText","ghostTextOrReplacementEquals","ghostTextsOrReplacementsEqual","InlineCompletionsSource","computeGhostText","singleTextEditAugments","singleTextRemoveCommonPrefix","addPositions","subtractPositions","SnippetController2","ICommandService","IInstantiationService","InlineCompletionsModel","isAcceptingPartially","_isAcceptingPartially","constructor","textModel","selectedSuggestItem","_textModelVersionId","_positions","_debounceValue","_suggestPreviewEnabled","_suggestPreviewMode","_inlineSuggestMode","_enabled","_instantiationService","_commandService","_languageConfigurationService","_source","_register","createInstance","_isActive","_forceUpdateExplicitlySignal","_selectedInlineCompletionId","undefined","_primaryPosition","reader","_this$_positions$read","read","_preserveCurrentCompletionReasons","Set","VersionIdChangeReason","Redo","Undo","AcceptWord","_fetchInlineCompletionsPromise","owner","createEmptyChangeSummary","preserveCurrentCompletion","inlineCompletionTriggerKind","Automatic","handleChange","ctx","changeSummary","didChange","has","_getReason","change","Explicit","shouldUpdate","cancelUpdate","suggestWidgetInlineCompletions","get","suggestItem","inlineCompletions","tx","request","versionId","set","clone","clearSuggestWidgetInlineCompletions","cursorPosition","context","triggerKind","selectedSuggestionInfo","toSelectedSuggestionInfo","itemToPreserveCandidate","selectedInlineCompletion","itemToPreserve","forwardStable","fetch","_filteredInlineCompletionItems","equalsFn","filteredCompletions","filter","isVisible","selectedInlineCompletionIndex","selectedInlineCompletionId","idx","findIndex","v","semanticId","activeCommands","_this$selectedInlineC","_this$selectedInlineC2","inlineCompletion","source","commands","lastTriggerKind","map","inlineCompletionsCount","state","a","b","ghostTexts","model","_augmentation$edit","_ghostTexts$","suggestCompletionEdit","toSingleTextEdit","augmentation","_computeAugmentation","isSuggestionPreviewEnabled","fullEdit","edit","fullEditPreviewLength","text","mode","positions","edits","getSecondaryEdits","primaryGhostText","range","endLineNumber","completion","replacement","lastItem","_lastItem","item","_src$provider$handleI","_src$provider","src","provider","handleItemDidShow","call","sourceInlineCompletion","insertText","e","isUndoing","isRedoing","Other","trigger","triggerExplicitly","stop","clear","suggestCompletion","candidateInlineCompletions","augmentedCompletion","fromPositions","getStartPosition","getEndPosition","_deltaSelectedInlineCompletionIndex","delta","completions","newIdx","next","previous","accept","editor","getModel","isEmpty","toInlineCompletion","command","addRef","pushUndoStop","snippetInfo","_SnippetController2$g","executeEdits","replace","additionalTextEdits","setPosition","insert","snippet","undoStopBefore","selections","getEndPositionsAfterApplying","p","setSelections","executeCommand","id","then","removeRef","acceptNextWord","_acceptNext","pos","langId","getLanguageIdAtPosition","lineNumber","column","config","getLanguageConfiguration","wordRegExp","RegExp","wordDefinition","flags","m1","match","acceptUntilIndexExclusive","index","wsRegExp","m2","exec","acceptNextLine","m","getAcceptUntilIndex","kind","ghostText","filterText","firstPart","parts","ghostTextPos","ghostTextVal","partialGhostTextVal","substring","replaceRange","newText","getValueInRange","primaryEdit","revealPositionInCenterIfOutsideViewport","getPosition","handlePartialAccept","acceptedRange","ofText","addToPosition","handleSuggestAccepted","_inlineCompletion$sou","_inlineCompletion$sou2","itemEdit","primaryPosition","secondaryPositions","slice","primaryEditStartPosition","primaryEditEndPosition","replacedTextAfterPrimaryCursor","positionWithinTextEdit","concat","toString","secondaryEditText","substringPos","posEnd","textAfterSecondaryCursor","l","subtext","lines","sortPerm","createSortPermutation","compareRangesUsingStarts","apply","sortedNewRanges","getNewRanges","newRanges","inverse"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/inlineCompletionsModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { compareBy, Permutation } from '../../../../../base/common/arrays.js';\nimport { mapFindFirst } from '../../../../../base/common/arraysFind.js';\nimport { itemsEquals } from '../../../../../base/common/equals.js';\nimport { BugIndicatingError, onUnexpectedError, onUnexpectedExternalError } from '../../../../../base/common/errors.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { autorun, derived, derivedHandleChanges, derivedOpts, observableSignal, observableValue, recomputeInitiallyAndOnChange, subtransaction, transaction } from '../../../../../base/common/observable.js';\nimport { commonPrefixLength, splitLinesIncludeSeparators } from '../../../../../base/common/strings.js';\nimport { isDefined } from '../../../../../base/common/types.js';\nimport { EditOperation } from '../../../../common/core/editOperation.js';\nimport { Position } from '../../../../common/core/position.js';\nimport { Range } from '../../../../common/core/range.js';\nimport { Selection } from '../../../../common/core/selection.js';\nimport { SingleTextEdit, TextEdit } from '../../../../common/core/textEdit.js';\nimport { TextLength } from '../../../../common/core/textLength.js';\nimport { InlineCompletionTriggerKind } from '../../../../common/languages.js';\nimport { ILanguageConfigurationService } from '../../../../common/languages/languageConfigurationRegistry.js';\nimport { GhostText, ghostTextOrReplacementEquals, ghostTextsOrReplacementsEqual } from './ghostText.js';\nimport { InlineCompletionsSource } from './inlineCompletionsSource.js';\nimport { computeGhostText, singleTextEditAugments, singleTextRemoveCommonPrefix } from './singleTextEdit.js';\nimport { addPositions, subtractPositions } from '../utils.js';\nimport { SnippetController2 } from '../../../snippet/browser/snippetController2.js';\nimport { ICommandService } from '../../../../../platform/commands/common/commands.js';\nimport { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\nlet InlineCompletionsModel = class InlineCompletionsModel extends Disposable {\n    get isAcceptingPartially() { return this._isAcceptingPartially; }\n    constructor(textModel, selectedSuggestItem, _textModelVersionId, _positions, _debounceValue, _suggestPreviewEnabled, _suggestPreviewMode, _inlineSuggestMode, _enabled, _instantiationService, _commandService, _languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.selectedSuggestItem = selectedSuggestItem;\n        this._textModelVersionId = _textModelVersionId;\n        this._positions = _positions;\n        this._debounceValue = _debounceValue;\n        this._suggestPreviewEnabled = _suggestPreviewEnabled;\n        this._suggestPreviewMode = _suggestPreviewMode;\n        this._inlineSuggestMode = _inlineSuggestMode;\n        this._enabled = _enabled;\n        this._instantiationService = _instantiationService;\n        this._commandService = _commandService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this._source = this._register(this._instantiationService.createInstance(InlineCompletionsSource, this.textModel, this._textModelVersionId, this._debounceValue));\n        this._isActive = observableValue(this, false);\n        this._forceUpdateExplicitlySignal = observableSignal(this);\n        // We use a semantic id to keep the same inline completion selected even if the provider reorders the completions.\n        this._selectedInlineCompletionId = observableValue(this, undefined);\n        this._primaryPosition = derived(this, reader => this._positions.read(reader)[0] ?? new Position(1, 1));\n        this._isAcceptingPartially = false;\n        this._preserveCurrentCompletionReasons = new Set([\n            VersionIdChangeReason.Redo,\n            VersionIdChangeReason.Undo,\n            VersionIdChangeReason.AcceptWord,\n        ]);\n        this._fetchInlineCompletionsPromise = derivedHandleChanges({\n            owner: this,\n            createEmptyChangeSummary: () => ({\n                preserveCurrentCompletion: false,\n                inlineCompletionTriggerKind: InlineCompletionTriggerKind.Automatic\n            }),\n            handleChange: (ctx, changeSummary) => {\n                /** @description fetch inline completions */\n                if (ctx.didChange(this._textModelVersionId) && this._preserveCurrentCompletionReasons.has(this._getReason(ctx.change))) {\n                    changeSummary.preserveCurrentCompletion = true;\n                }\n                else if (ctx.didChange(this._forceUpdateExplicitlySignal)) {\n                    changeSummary.inlineCompletionTriggerKind = InlineCompletionTriggerKind.Explicit;\n                }\n                return true;\n            },\n        }, (reader, changeSummary) => {\n            this._forceUpdateExplicitlySignal.read(reader);\n            const shouldUpdate = (this._enabled.read(reader) && this.selectedSuggestItem.read(reader)) || this._isActive.read(reader);\n            if (!shouldUpdate) {\n                this._source.cancelUpdate();\n                return undefined;\n            }\n            this._textModelVersionId.read(reader); // Refetch on text change\n            const suggestWidgetInlineCompletions = this._source.suggestWidgetInlineCompletions.get();\n            const suggestItem = this.selectedSuggestItem.read(reader);\n            if (suggestWidgetInlineCompletions && !suggestItem) {\n                const inlineCompletions = this._source.inlineCompletions.get();\n                transaction(tx => {\n                    /** @description Seed inline completions with (newer) suggest widget inline completions */\n                    if (!inlineCompletions || suggestWidgetInlineCompletions.request.versionId > inlineCompletions.request.versionId) {\n                        this._source.inlineCompletions.set(suggestWidgetInlineCompletions.clone(), tx);\n                    }\n                    this._source.clearSuggestWidgetInlineCompletions(tx);\n                });\n            }\n            const cursorPosition = this._primaryPosition.read(reader);\n            const context = {\n                triggerKind: changeSummary.inlineCompletionTriggerKind,\n                selectedSuggestionInfo: suggestItem?.toSelectedSuggestionInfo(),\n            };\n            const itemToPreserveCandidate = this.selectedInlineCompletion.get();\n            const itemToPreserve = changeSummary.preserveCurrentCompletion || itemToPreserveCandidate?.forwardStable\n                ? itemToPreserveCandidate : undefined;\n            return this._source.fetch(cursorPosition, context, itemToPreserve);\n        });\n        this._filteredInlineCompletionItems = derivedOpts({ owner: this, equalsFn: itemsEquals() }, reader => {\n            const c = this._source.inlineCompletions.read(reader);\n            if (!c) {\n                return [];\n            }\n            const cursorPosition = this._primaryPosition.read(reader);\n            const filteredCompletions = c.inlineCompletions.filter(c => c.isVisible(this.textModel, cursorPosition, reader));\n            return filteredCompletions;\n        });\n        this.selectedInlineCompletionIndex = derived(this, (reader) => {\n            const selectedInlineCompletionId = this._selectedInlineCompletionId.read(reader);\n            const filteredCompletions = this._filteredInlineCompletionItems.read(reader);\n            const idx = this._selectedInlineCompletionId === undefined ? -1\n                : filteredCompletions.findIndex(v => v.semanticId === selectedInlineCompletionId);\n            if (idx === -1) {\n                // Reset the selection so that the selection does not jump back when it appears again\n                this._selectedInlineCompletionId.set(undefined, undefined);\n                return 0;\n            }\n            return idx;\n        });\n        this.selectedInlineCompletion = derived(this, (reader) => {\n            const filteredCompletions = this._filteredInlineCompletionItems.read(reader);\n            const idx = this.selectedInlineCompletionIndex.read(reader);\n            return filteredCompletions[idx];\n        });\n        this.activeCommands = derivedOpts({ owner: this, equalsFn: itemsEquals() }, r => this.selectedInlineCompletion.read(r)?.inlineCompletion.source.inlineCompletions.commands ?? []);\n        this.lastTriggerKind = this._source.inlineCompletions.map(this, v => v?.request.context.triggerKind);\n        this.inlineCompletionsCount = derived(this, reader => {\n            if (this.lastTriggerKind.read(reader) === InlineCompletionTriggerKind.Explicit) {\n                return this._filteredInlineCompletionItems.read(reader).length;\n            }\n            else {\n                return undefined;\n            }\n        });\n        this.state = derivedOpts({\n            owner: this,\n            equalsFn: (a, b) => {\n                if (!a || !b) {\n                    return a === b;\n                }\n                return ghostTextsOrReplacementsEqual(a.ghostTexts, b.ghostTexts)\n                    && a.inlineCompletion === b.inlineCompletion\n                    && a.suggestItem === b.suggestItem;\n            }\n        }, (reader) => {\n            const model = this.textModel;\n            const suggestItem = this.selectedSuggestItem.read(reader);\n            if (suggestItem) {\n                const suggestCompletionEdit = singleTextRemoveCommonPrefix(suggestItem.toSingleTextEdit(), model);\n                const augmentation = this._computeAugmentation(suggestCompletionEdit, reader);\n                const isSuggestionPreviewEnabled = this._suggestPreviewEnabled.read(reader);\n                if (!isSuggestionPreviewEnabled && !augmentation) {\n                    return undefined;\n                }\n                const fullEdit = augmentation?.edit ?? suggestCompletionEdit;\n                const fullEditPreviewLength = augmentation ? augmentation.edit.text.length - suggestCompletionEdit.text.length : 0;\n                const mode = this._suggestPreviewMode.read(reader);\n                const positions = this._positions.read(reader);\n                const edits = [fullEdit, ...getSecondaryEdits(this.textModel, positions, fullEdit)];\n                const ghostTexts = edits\n                    .map((edit, idx) => computeGhostText(edit, model, mode, positions[idx], fullEditPreviewLength))\n                    .filter(isDefined);\n                const primaryGhostText = ghostTexts[0] ?? new GhostText(fullEdit.range.endLineNumber, []);\n                return { edits, primaryGhostText, ghostTexts, inlineCompletion: augmentation?.completion, suggestItem };\n            }\n            else {\n                if (!this._isActive.read(reader)) {\n                    return undefined;\n                }\n                const inlineCompletion = this.selectedInlineCompletion.read(reader);\n                if (!inlineCompletion) {\n                    return undefined;\n                }\n                const replacement = inlineCompletion.toSingleTextEdit(reader);\n                const mode = this._inlineSuggestMode.read(reader);\n                const positions = this._positions.read(reader);\n                const edits = [replacement, ...getSecondaryEdits(this.textModel, positions, replacement)];\n                const ghostTexts = edits\n                    .map((edit, idx) => computeGhostText(edit, model, mode, positions[idx], 0))\n                    .filter(isDefined);\n                if (!ghostTexts[0]) {\n                    return undefined;\n                }\n                return { edits, primaryGhostText: ghostTexts[0], ghostTexts, inlineCompletion, suggestItem: undefined };\n            }\n        });\n        this.ghostTexts = derivedOpts({ owner: this, equalsFn: ghostTextsOrReplacementsEqual }, reader => {\n            const v = this.state.read(reader);\n            if (!v) {\n                return undefined;\n            }\n            return v.ghostTexts;\n        });\n        this.primaryGhostText = derivedOpts({ owner: this, equalsFn: ghostTextOrReplacementEquals }, reader => {\n            const v = this.state.read(reader);\n            if (!v) {\n                return undefined;\n            }\n            return v?.primaryGhostText;\n        });\n        this._register(recomputeInitiallyAndOnChange(this._fetchInlineCompletionsPromise));\n        let lastItem = undefined;\n        this._register(autorun(reader => {\n            /** @description call handleItemDidShow */\n            const item = this.state.read(reader);\n            const completion = item?.inlineCompletion;\n            if (completion?.semanticId !== lastItem?.semanticId) {\n                lastItem = completion;\n                if (completion) {\n                    const i = completion.inlineCompletion;\n                    const src = i.source;\n                    src.provider.handleItemDidShow?.(src.inlineCompletions, i.sourceInlineCompletion, i.insertText);\n                }\n            }\n        }));\n    }\n    _getReason(e) {\n        if (e?.isUndoing) {\n            return VersionIdChangeReason.Undo;\n        }\n        if (e?.isRedoing) {\n            return VersionIdChangeReason.Redo;\n        }\n        if (this.isAcceptingPartially) {\n            return VersionIdChangeReason.AcceptWord;\n        }\n        return VersionIdChangeReason.Other;\n    }\n    async trigger(tx) {\n        this._isActive.set(true, tx);\n        await this._fetchInlineCompletionsPromise.get();\n    }\n    async triggerExplicitly(tx) {\n        subtransaction(tx, tx => {\n            this._isActive.set(true, tx);\n            this._forceUpdateExplicitlySignal.trigger(tx);\n        });\n        await this._fetchInlineCompletionsPromise.get();\n    }\n    stop(tx) {\n        subtransaction(tx, tx => {\n            this._isActive.set(false, tx);\n            this._source.clear(tx);\n        });\n    }\n    _computeAugmentation(suggestCompletion, reader) {\n        const model = this.textModel;\n        const suggestWidgetInlineCompletions = this._source.suggestWidgetInlineCompletions.read(reader);\n        const candidateInlineCompletions = suggestWidgetInlineCompletions\n            ? suggestWidgetInlineCompletions.inlineCompletions\n            : [this.selectedInlineCompletion.read(reader)].filter(isDefined);\n        const augmentedCompletion = mapFindFirst(candidateInlineCompletions, completion => {\n            let r = completion.toSingleTextEdit(reader);\n            r = singleTextRemoveCommonPrefix(r, model, Range.fromPositions(r.range.getStartPosition(), suggestCompletion.range.getEndPosition()));\n            return singleTextEditAugments(r, suggestCompletion) ? { completion, edit: r } : undefined;\n        });\n        return augmentedCompletion;\n    }\n    async _deltaSelectedInlineCompletionIndex(delta) {\n        await this.triggerExplicitly();\n        const completions = this._filteredInlineCompletionItems.get() || [];\n        if (completions.length > 0) {\n            const newIdx = (this.selectedInlineCompletionIndex.get() + delta + completions.length) % completions.length;\n            this._selectedInlineCompletionId.set(completions[newIdx].semanticId, undefined);\n        }\n        else {\n            this._selectedInlineCompletionId.set(undefined, undefined);\n        }\n    }\n    async next() {\n        await this._deltaSelectedInlineCompletionIndex(1);\n    }\n    async previous() {\n        await this._deltaSelectedInlineCompletionIndex(-1);\n    }\n    async accept(editor) {\n        if (editor.getModel() !== this.textModel) {\n            throw new BugIndicatingError();\n        }\n        const state = this.state.get();\n        if (!state || state.primaryGhostText.isEmpty() || !state.inlineCompletion) {\n            return;\n        }\n        const completion = state.inlineCompletion.toInlineCompletion(undefined);\n        if (completion.command) {\n            // Make sure the completion list will not be disposed.\n            completion.source.addRef();\n        }\n        editor.pushUndoStop();\n        if (completion.snippetInfo) {\n            editor.executeEdits('inlineSuggestion.accept', [\n                EditOperation.replace(completion.range, ''),\n                ...completion.additionalTextEdits\n            ]);\n            editor.setPosition(completion.snippetInfo.range.getStartPosition(), 'inlineCompletionAccept');\n            SnippetController2.get(editor)?.insert(completion.snippetInfo.snippet, { undoStopBefore: false });\n        }\n        else {\n            const edits = state.edits;\n            const selections = getEndPositionsAfterApplying(edits).map(p => Selection.fromPositions(p));\n            editor.executeEdits('inlineSuggestion.accept', [\n                ...edits.map(edit => EditOperation.replace(edit.range, edit.text)),\n                ...completion.additionalTextEdits\n            ]);\n            editor.setSelections(selections, 'inlineCompletionAccept');\n        }\n        // Reset before invoking the command, as the command might cause a follow up trigger (which we don't want to reset).\n        this.stop();\n        if (completion.command) {\n            await this._commandService\n                .executeCommand(completion.command.id, ...(completion.command.arguments || []))\n                .then(undefined, onUnexpectedExternalError);\n            completion.source.removeRef();\n        }\n    }\n    async acceptNextWord(editor) {\n        await this._acceptNext(editor, (pos, text) => {\n            const langId = this.textModel.getLanguageIdAtPosition(pos.lineNumber, pos.column);\n            const config = this._languageConfigurationService.getLanguageConfiguration(langId);\n            const wordRegExp = new RegExp(config.wordDefinition.source, config.wordDefinition.flags.replace('g', ''));\n            const m1 = text.match(wordRegExp);\n            let acceptUntilIndexExclusive = 0;\n            if (m1 && m1.index !== undefined) {\n                if (m1.index === 0) {\n                    acceptUntilIndexExclusive = m1[0].length;\n                }\n                else {\n                    acceptUntilIndexExclusive = m1.index;\n                }\n            }\n            else {\n                acceptUntilIndexExclusive = text.length;\n            }\n            const wsRegExp = /\\s+/g;\n            const m2 = wsRegExp.exec(text);\n            if (m2 && m2.index !== undefined) {\n                if (m2.index + m2[0].length < acceptUntilIndexExclusive) {\n                    acceptUntilIndexExclusive = m2.index + m2[0].length;\n                }\n            }\n            return acceptUntilIndexExclusive;\n        }, 0 /* PartialAcceptTriggerKind.Word */);\n    }\n    async acceptNextLine(editor) {\n        await this._acceptNext(editor, (pos, text) => {\n            const m = text.match(/\\n/);\n            if (m && m.index !== undefined) {\n                return m.index + 1;\n            }\n            return text.length;\n        }, 1 /* PartialAcceptTriggerKind.Line */);\n    }\n    async _acceptNext(editor, getAcceptUntilIndex, kind) {\n        if (editor.getModel() !== this.textModel) {\n            throw new BugIndicatingError();\n        }\n        const state = this.state.get();\n        if (!state || state.primaryGhostText.isEmpty() || !state.inlineCompletion) {\n            return;\n        }\n        const ghostText = state.primaryGhostText;\n        const completion = state.inlineCompletion.toInlineCompletion(undefined);\n        if (completion.snippetInfo || completion.filterText !== completion.insertText) {\n            // not in WYSIWYG mode, partial commit might change completion, thus it is not supported\n            await this.accept(editor);\n            return;\n        }\n        const firstPart = ghostText.parts[0];\n        const ghostTextPos = new Position(ghostText.lineNumber, firstPart.column);\n        const ghostTextVal = firstPart.text;\n        const acceptUntilIndexExclusive = getAcceptUntilIndex(ghostTextPos, ghostTextVal);\n        if (acceptUntilIndexExclusive === ghostTextVal.length && ghostText.parts.length === 1) {\n            this.accept(editor);\n            return;\n        }\n        const partialGhostTextVal = ghostTextVal.substring(0, acceptUntilIndexExclusive);\n        const positions = this._positions.get();\n        const cursorPosition = positions[0];\n        // Executing the edit might free the completion, so we have to hold a reference on it.\n        completion.source.addRef();\n        try {\n            this._isAcceptingPartially = true;\n            try {\n                editor.pushUndoStop();\n                const replaceRange = Range.fromPositions(cursorPosition, ghostTextPos);\n                const newText = editor.getModel().getValueInRange(replaceRange) + partialGhostTextVal;\n                const primaryEdit = new SingleTextEdit(replaceRange, newText);\n                const edits = [primaryEdit, ...getSecondaryEdits(this.textModel, positions, primaryEdit)];\n                const selections = getEndPositionsAfterApplying(edits).map(p => Selection.fromPositions(p));\n                editor.executeEdits('inlineSuggestion.accept', edits.map(edit => EditOperation.replace(edit.range, edit.text)));\n                editor.setSelections(selections, 'inlineCompletionPartialAccept');\n                editor.revealPositionInCenterIfOutsideViewport(editor.getPosition(), 1 /* ScrollType.Immediate */);\n            }\n            finally {\n                this._isAcceptingPartially = false;\n            }\n            if (completion.source.provider.handlePartialAccept) {\n                const acceptedRange = Range.fromPositions(completion.range.getStartPosition(), TextLength.ofText(partialGhostTextVal).addToPosition(ghostTextPos));\n                // This assumes that the inline completion and the model use the same EOL style.\n                const text = editor.getModel().getValueInRange(acceptedRange, 1 /* EndOfLinePreference.LF */);\n                completion.source.provider.handlePartialAccept(completion.source.inlineCompletions, completion.sourceInlineCompletion, text.length, { kind, });\n            }\n        }\n        finally {\n            completion.source.removeRef();\n        }\n    }\n    handleSuggestAccepted(item) {\n        const itemEdit = singleTextRemoveCommonPrefix(item.toSingleTextEdit(), this.textModel);\n        const augmentedCompletion = this._computeAugmentation(itemEdit, undefined);\n        if (!augmentedCompletion) {\n            return;\n        }\n        const inlineCompletion = augmentedCompletion.completion.inlineCompletion;\n        inlineCompletion.source.provider.handlePartialAccept?.(inlineCompletion.source.inlineCompletions, inlineCompletion.sourceInlineCompletion, itemEdit.text.length, {\n            kind: 2 /* PartialAcceptTriggerKind.Suggest */,\n        });\n    }\n};\nInlineCompletionsModel = __decorate([\n    __param(9, IInstantiationService),\n    __param(10, ICommandService),\n    __param(11, ILanguageConfigurationService)\n], InlineCompletionsModel);\nexport { InlineCompletionsModel };\nexport var VersionIdChangeReason;\n(function (VersionIdChangeReason) {\n    VersionIdChangeReason[VersionIdChangeReason[\"Undo\"] = 0] = \"Undo\";\n    VersionIdChangeReason[VersionIdChangeReason[\"Redo\"] = 1] = \"Redo\";\n    VersionIdChangeReason[VersionIdChangeReason[\"AcceptWord\"] = 2] = \"AcceptWord\";\n    VersionIdChangeReason[VersionIdChangeReason[\"Other\"] = 3] = \"Other\";\n})(VersionIdChangeReason || (VersionIdChangeReason = {}));\nexport function getSecondaryEdits(textModel, positions, primaryEdit) {\n    if (positions.length === 1) {\n        // No secondary cursor positions\n        return [];\n    }\n    const primaryPosition = positions[0];\n    const secondaryPositions = positions.slice(1);\n    const primaryEditStartPosition = primaryEdit.range.getStartPosition();\n    const primaryEditEndPosition = primaryEdit.range.getEndPosition();\n    const replacedTextAfterPrimaryCursor = textModel.getValueInRange(Range.fromPositions(primaryPosition, primaryEditEndPosition));\n    const positionWithinTextEdit = subtractPositions(primaryPosition, primaryEditStartPosition);\n    if (positionWithinTextEdit.lineNumber < 1) {\n        onUnexpectedError(new BugIndicatingError(`positionWithinTextEdit line number should be bigger than 0.\n\t\t\tInvalid subtraction between ${primaryPosition.toString()} and ${primaryEditStartPosition.toString()}`));\n        return [];\n    }\n    const secondaryEditText = substringPos(primaryEdit.text, positionWithinTextEdit);\n    return secondaryPositions.map(pos => {\n        const posEnd = addPositions(subtractPositions(pos, primaryEditStartPosition), primaryEditEndPosition);\n        const textAfterSecondaryCursor = textModel.getValueInRange(Range.fromPositions(pos, posEnd));\n        const l = commonPrefixLength(replacedTextAfterPrimaryCursor, textAfterSecondaryCursor);\n        const range = Range.fromPositions(pos, pos.delta(0, l));\n        return new SingleTextEdit(range, secondaryEditText);\n    });\n}\nfunction substringPos(text, pos) {\n    let subtext = '';\n    const lines = splitLinesIncludeSeparators(text);\n    for (let i = pos.lineNumber - 1; i < lines.length; i++) {\n        subtext += lines[i].substring(i === pos.lineNumber - 1 ? pos.column - 1 : 0);\n    }\n    return subtext;\n}\nfunction getEndPositionsAfterApplying(edits) {\n    const sortPerm = Permutation.createSortPermutation(edits, compareBy(e => e.range, Range.compareRangesUsingStarts));\n    const edit = new TextEdit(sortPerm.apply(edits));\n    const sortedNewRanges = edit.getNewRanges();\n    const newRanges = sortPerm.inverse().apply(sortedNewRanges);\n    return newRanges.map(range => range.getEndPosition());\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}