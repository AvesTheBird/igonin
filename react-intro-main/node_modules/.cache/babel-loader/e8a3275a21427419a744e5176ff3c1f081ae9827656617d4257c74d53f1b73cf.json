{"ast":null,"code":"var _TreeRenderer;\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { $, append, clearNode, createStyleSheet, getWindow, h, hasParentWithClass, asCssValueWithDefault, isKeyboardEvent, addDisposableListener } from '../../dom.js';\nimport { DomEmitter } from '../../event.js';\nimport { StandardKeyboardEvent } from '../../keyboardEvent.js';\nimport { ActionBar } from '../actionbar/actionbar.js';\nimport { FindInput } from '../findinput/findInput.js';\nimport { unthemedInboxStyles } from '../inputbox/inputBox.js';\nimport { ElementsDragAndDropData } from '../list/listView.js';\nimport { isActionItem, isButton, isInputElement, isMonacoCustomToggle, isMonacoEditor, isStickyScrollContainer, isStickyScrollElement, List, MouseController } from '../list/listWidget.js';\nimport { Toggle, unthemedToggleStyles } from '../toggle/toggle.js';\nimport { getVisibleState, isFilterResult } from './indexTreeModel.js';\nimport { TreeMouseEventTarget } from './tree.js';\nimport { Action } from '../../../common/actions.js';\nimport { distinct, equals, range } from '../../../common/arrays.js';\nimport { Delayer, disposableTimeout, timeout } from '../../../common/async.js';\nimport { Codicon } from '../../../common/codicons.js';\nimport { ThemeIcon } from '../../../common/themables.js';\nimport { SetMap } from '../../../common/map.js';\nimport { Emitter, Event, EventBufferer, Relay } from '../../../common/event.js';\nimport { fuzzyScore, FuzzyScore } from '../../../common/filters.js';\nimport { Disposable, DisposableStore, dispose, toDisposable } from '../../../common/lifecycle.js';\nimport { clamp } from '../../../common/numbers.js';\nimport { isNumber } from '../../../common/types.js';\nimport './media/tree.css';\nimport { localize } from '../../../../nls.js';\nimport { createInstantHoverDelegate, getDefaultHoverDelegate } from '../hover/hoverDelegateFactory.js';\nimport { autorun, constObservable } from '../../../common/observable.js';\nimport { alert } from '../aria/aria.js';\nclass TreeElementsDragAndDropData extends ElementsDragAndDropData {\n  constructor(data) {\n    super(data.elements.map(node => node.element));\n    this.data = data;\n  }\n}\nfunction asTreeDragAndDropData(data) {\n  if (data instanceof ElementsDragAndDropData) {\n    return new TreeElementsDragAndDropData(data);\n  }\n  return data;\n}\nclass TreeNodeListDragAndDrop {\n  constructor(modelProvider, dnd) {\n    this.modelProvider = modelProvider;\n    this.dnd = dnd;\n    this.autoExpandDisposable = Disposable.None;\n    this.disposables = new DisposableStore();\n  }\n  getDragURI(node) {\n    return this.dnd.getDragURI(node.element);\n  }\n  getDragLabel(nodes, originalEvent) {\n    if (this.dnd.getDragLabel) {\n      return this.dnd.getDragLabel(nodes.map(node => node.element), originalEvent);\n    }\n    return undefined;\n  }\n  onDragStart(data, originalEvent) {\n    var _this$dnd$onDragStart, _this$dnd;\n    (_this$dnd$onDragStart = (_this$dnd = this.dnd).onDragStart) === null || _this$dnd$onDragStart === void 0 || _this$dnd$onDragStart.call(_this$dnd, asTreeDragAndDropData(data), originalEvent);\n  }\n  onDragOver(data, targetNode, targetIndex, targetSector, originalEvent) {\n    let raw = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    const result = this.dnd.onDragOver(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, targetSector, originalEvent);\n    const didChangeAutoExpandNode = this.autoExpandNode !== targetNode;\n    if (didChangeAutoExpandNode) {\n      this.autoExpandDisposable.dispose();\n      this.autoExpandNode = targetNode;\n    }\n    if (typeof targetNode === 'undefined') {\n      return result;\n    }\n    if (didChangeAutoExpandNode && typeof result !== 'boolean' && result.autoExpand) {\n      this.autoExpandDisposable = disposableTimeout(() => {\n        const model = this.modelProvider();\n        const ref = model.getNodeLocation(targetNode);\n        if (model.isCollapsed(ref)) {\n          model.setCollapsed(ref, false);\n        }\n        this.autoExpandNode = undefined;\n      }, 500, this.disposables);\n    }\n    if (typeof result === 'boolean' || !result.accept || typeof result.bubble === 'undefined' || result.feedback) {\n      if (!raw) {\n        const accept = typeof result === 'boolean' ? result : result.accept;\n        const effect = typeof result === 'boolean' ? undefined : result.effect;\n        return {\n          accept,\n          effect,\n          feedback: [targetIndex]\n        };\n      }\n      return result;\n    }\n    if (result.bubble === 1 /* TreeDragOverBubble.Up */) {\n      const model = this.modelProvider();\n      const ref = model.getNodeLocation(targetNode);\n      const parentRef = model.getParentNodeLocation(ref);\n      const parentNode = model.getNode(parentRef);\n      const parentIndex = parentRef && model.getListIndex(parentRef);\n      return this.onDragOver(data, parentNode, parentIndex, targetSector, originalEvent, false);\n    }\n    const model = this.modelProvider();\n    const ref = model.getNodeLocation(targetNode);\n    const start = model.getListIndex(ref);\n    const length = model.getListRenderCount(ref);\n    return {\n      ...result,\n      feedback: range(start, start + length)\n    };\n  }\n  drop(data, targetNode, targetIndex, targetSector, originalEvent) {\n    this.autoExpandDisposable.dispose();\n    this.autoExpandNode = undefined;\n    this.dnd.drop(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, targetSector, originalEvent);\n  }\n  onDragEnd(originalEvent) {\n    var _this$dnd$onDragEnd, _this$dnd2;\n    (_this$dnd$onDragEnd = (_this$dnd2 = this.dnd).onDragEnd) === null || _this$dnd$onDragEnd === void 0 || _this$dnd$onDragEnd.call(_this$dnd2, originalEvent);\n  }\n  dispose() {\n    this.disposables.dispose();\n    this.dnd.dispose();\n  }\n}\nfunction asListOptions(modelProvider, options) {\n  return options && {\n    ...options,\n    identityProvider: options.identityProvider && {\n      getId(el) {\n        return options.identityProvider.getId(el.element);\n      }\n    },\n    dnd: options.dnd && new TreeNodeListDragAndDrop(modelProvider, options.dnd),\n    multipleSelectionController: options.multipleSelectionController && {\n      isSelectionSingleChangeEvent(e) {\n        return options.multipleSelectionController.isSelectionSingleChangeEvent({\n          ...e,\n          element: e.element\n        });\n      },\n      isSelectionRangeChangeEvent(e) {\n        return options.multipleSelectionController.isSelectionRangeChangeEvent({\n          ...e,\n          element: e.element\n        });\n      }\n    },\n    accessibilityProvider: options.accessibilityProvider && {\n      ...options.accessibilityProvider,\n      getSetSize(node) {\n        const model = modelProvider();\n        const ref = model.getNodeLocation(node);\n        const parentRef = model.getParentNodeLocation(ref);\n        const parentNode = model.getNode(parentRef);\n        return parentNode.visibleChildrenCount;\n      },\n      getPosInSet(node) {\n        return node.visibleChildIndex + 1;\n      },\n      isChecked: options.accessibilityProvider && options.accessibilityProvider.isChecked ? node => {\n        return options.accessibilityProvider.isChecked(node.element);\n      } : undefined,\n      getRole: options.accessibilityProvider && options.accessibilityProvider.getRole ? node => {\n        return options.accessibilityProvider.getRole(node.element);\n      } : () => 'treeitem',\n      getAriaLabel(e) {\n        return options.accessibilityProvider.getAriaLabel(e.element);\n      },\n      getWidgetAriaLabel() {\n        return options.accessibilityProvider.getWidgetAriaLabel();\n      },\n      getWidgetRole: options.accessibilityProvider && options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => 'tree',\n      getAriaLevel: options.accessibilityProvider && options.accessibilityProvider.getAriaLevel ? node => options.accessibilityProvider.getAriaLevel(node.element) : node => {\n        return node.depth;\n      },\n      getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {\n        return options.accessibilityProvider.getActiveDescendantId(node.element);\n      })\n    },\n    keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && {\n      ...options.keyboardNavigationLabelProvider,\n      getKeyboardNavigationLabel(node) {\n        return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(node.element);\n      }\n    }\n  };\n}\nexport class ComposedTreeDelegate {\n  constructor(delegate) {\n    this.delegate = delegate;\n  }\n  getHeight(element) {\n    return this.delegate.getHeight(element.element);\n  }\n  getTemplateId(element) {\n    return this.delegate.getTemplateId(element.element);\n  }\n  hasDynamicHeight(element) {\n    return !!this.delegate.hasDynamicHeight && this.delegate.hasDynamicHeight(element.element);\n  }\n  setDynamicHeight(element, height) {\n    var _this$delegate$setDyn, _this$delegate;\n    (_this$delegate$setDyn = (_this$delegate = this.delegate).setDynamicHeight) === null || _this$delegate$setDyn === void 0 || _this$delegate$setDyn.call(_this$delegate, element.element, height);\n  }\n}\nexport var RenderIndentGuides;\n(function (RenderIndentGuides) {\n  RenderIndentGuides[\"None\"] = \"none\";\n  RenderIndentGuides[\"OnHover\"] = \"onHover\";\n  RenderIndentGuides[\"Always\"] = \"always\";\n})(RenderIndentGuides || (RenderIndentGuides = {}));\nclass EventCollection {\n  get elements() {\n    return this._elements;\n  }\n  constructor(onDidChange) {\n    let _elements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    this._elements = _elements;\n    this.disposables = new DisposableStore();\n    this.onDidChange = Event.forEach(onDidChange, elements => this._elements = elements, this.disposables);\n  }\n  dispose() {\n    this.disposables.dispose();\n  }\n}\nexport class TreeRenderer {\n  constructor(renderer, modelProvider, onDidChangeCollapseState, activeNodes, renderedIndentGuides) {\n    var _renderer$onDidChange;\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    this.renderer = renderer;\n    this.modelProvider = modelProvider;\n    this.activeNodes = activeNodes;\n    this.renderedIndentGuides = renderedIndentGuides;\n    this.renderedElements = new Map();\n    this.renderedNodes = new Map();\n    this.indent = TreeRenderer.DefaultIndent;\n    this.hideTwistiesOfChildlessElements = false;\n    this.shouldRenderIndentGuides = false;\n    this.activeIndentNodes = new Set();\n    this.indentGuidesDisposable = Disposable.None;\n    this.disposables = new DisposableStore();\n    this.templateId = renderer.templateId;\n    this.updateOptions(options);\n    Event.map(onDidChangeCollapseState, e => e.node)(this.onDidChangeNodeTwistieState, this, this.disposables);\n    (_renderer$onDidChange = renderer.onDidChangeTwistieState) === null || _renderer$onDidChange === void 0 || _renderer$onDidChange.call(renderer, this.onDidChangeTwistieState, this, this.disposables);\n  }\n  updateOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (typeof options.indent !== 'undefined') {\n      const indent = clamp(options.indent, 0, 40);\n      if (indent !== this.indent) {\n        this.indent = indent;\n        for (const [node, templateData] of this.renderedNodes) {\n          this.renderTreeElement(node, templateData);\n        }\n      }\n    }\n    if (typeof options.renderIndentGuides !== 'undefined') {\n      const shouldRenderIndentGuides = options.renderIndentGuides !== RenderIndentGuides.None;\n      if (shouldRenderIndentGuides !== this.shouldRenderIndentGuides) {\n        this.shouldRenderIndentGuides = shouldRenderIndentGuides;\n        for (const [node, templateData] of this.renderedNodes) {\n          this._renderIndentGuides(node, templateData);\n        }\n        this.indentGuidesDisposable.dispose();\n        if (shouldRenderIndentGuides) {\n          const disposables = new DisposableStore();\n          this.activeNodes.onDidChange(this._onDidChangeActiveNodes, this, disposables);\n          this.indentGuidesDisposable = disposables;\n          this._onDidChangeActiveNodes(this.activeNodes.elements);\n        }\n      }\n    }\n    if (typeof options.hideTwistiesOfChildlessElements !== 'undefined') {\n      this.hideTwistiesOfChildlessElements = options.hideTwistiesOfChildlessElements;\n    }\n  }\n  renderTemplate(container) {\n    const el = append(container, $('.monaco-tl-row'));\n    const indent = append(el, $('.monaco-tl-indent'));\n    const twistie = append(el, $('.monaco-tl-twistie'));\n    const contents = append(el, $('.monaco-tl-contents'));\n    const templateData = this.renderer.renderTemplate(contents);\n    return {\n      container,\n      indent,\n      twistie,\n      indentGuidesDisposable: Disposable.None,\n      templateData\n    };\n  }\n  renderElement(node, index, templateData, height) {\n    this.renderedNodes.set(node, templateData);\n    this.renderedElements.set(node.element, node);\n    this.renderTreeElement(node, templateData);\n    this.renderer.renderElement(node, index, templateData.templateData, height);\n  }\n  disposeElement(node, index, templateData, height) {\n    var _this$renderer$dispos, _this$renderer;\n    templateData.indentGuidesDisposable.dispose();\n    (_this$renderer$dispos = (_this$renderer = this.renderer).disposeElement) === null || _this$renderer$dispos === void 0 || _this$renderer$dispos.call(_this$renderer, node, index, templateData.templateData, height);\n    if (typeof height === 'number') {\n      this.renderedNodes.delete(node);\n      this.renderedElements.delete(node.element);\n    }\n  }\n  disposeTemplate(templateData) {\n    this.renderer.disposeTemplate(templateData.templateData);\n  }\n  onDidChangeTwistieState(element) {\n    const node = this.renderedElements.get(element);\n    if (!node) {\n      return;\n    }\n    this.onDidChangeNodeTwistieState(node);\n  }\n  onDidChangeNodeTwistieState(node) {\n    const templateData = this.renderedNodes.get(node);\n    if (!templateData) {\n      return;\n    }\n    this._onDidChangeActiveNodes(this.activeNodes.elements);\n    this.renderTreeElement(node, templateData);\n  }\n  renderTreeElement(node, templateData) {\n    const indent = TreeRenderer.DefaultIndent + (node.depth - 1) * this.indent;\n    templateData.twistie.style.paddingLeft = \"\".concat(indent, \"px\");\n    templateData.indent.style.width = \"\".concat(indent + this.indent - 16, \"px\");\n    if (node.collapsible) {\n      templateData.container.setAttribute('aria-expanded', String(!node.collapsed));\n    } else {\n      templateData.container.removeAttribute('aria-expanded');\n    }\n    templateData.twistie.classList.remove(...ThemeIcon.asClassNameArray(Codicon.treeItemExpanded));\n    let twistieRendered = false;\n    if (this.renderer.renderTwistie) {\n      twistieRendered = this.renderer.renderTwistie(node.element, templateData.twistie);\n    }\n    if (node.collapsible && (!this.hideTwistiesOfChildlessElements || node.visibleChildrenCount > 0)) {\n      if (!twistieRendered) {\n        templateData.twistie.classList.add(...ThemeIcon.asClassNameArray(Codicon.treeItemExpanded));\n      }\n      templateData.twistie.classList.add('collapsible');\n      templateData.twistie.classList.toggle('collapsed', node.collapsed);\n    } else {\n      templateData.twistie.classList.remove('collapsible', 'collapsed');\n    }\n    this._renderIndentGuides(node, templateData);\n  }\n  _renderIndentGuides(node, templateData) {\n    clearNode(templateData.indent);\n    templateData.indentGuidesDisposable.dispose();\n    if (!this.shouldRenderIndentGuides) {\n      return;\n    }\n    const disposableStore = new DisposableStore();\n    const model = this.modelProvider();\n    while (true) {\n      const ref = model.getNodeLocation(node);\n      const parentRef = model.getParentNodeLocation(ref);\n      if (!parentRef) {\n        break;\n      }\n      const parent = model.getNode(parentRef);\n      const guide = $('.indent-guide', {\n        style: \"width: \".concat(this.indent, \"px\")\n      });\n      if (this.activeIndentNodes.has(parent)) {\n        guide.classList.add('active');\n      }\n      if (templateData.indent.childElementCount === 0) {\n        templateData.indent.appendChild(guide);\n      } else {\n        templateData.indent.insertBefore(guide, templateData.indent.firstElementChild);\n      }\n      this.renderedIndentGuides.add(parent, guide);\n      disposableStore.add(toDisposable(() => this.renderedIndentGuides.delete(parent, guide)));\n      node = parent;\n    }\n    templateData.indentGuidesDisposable = disposableStore;\n  }\n  _onDidChangeActiveNodes(nodes) {\n    if (!this.shouldRenderIndentGuides) {\n      return;\n    }\n    const set = new Set();\n    const model = this.modelProvider();\n    nodes.forEach(node => {\n      const ref = model.getNodeLocation(node);\n      try {\n        const parentRef = model.getParentNodeLocation(ref);\n        if (node.collapsible && node.children.length > 0 && !node.collapsed) {\n          set.add(node);\n        } else if (parentRef) {\n          set.add(model.getNode(parentRef));\n        }\n      } catch {\n        // noop\n      }\n    });\n    this.activeIndentNodes.forEach(node => {\n      if (!set.has(node)) {\n        this.renderedIndentGuides.forEach(node, line => line.classList.remove('active'));\n      }\n    });\n    set.forEach(node => {\n      if (!this.activeIndentNodes.has(node)) {\n        this.renderedIndentGuides.forEach(node, line => line.classList.add('active'));\n      }\n    });\n    this.activeIndentNodes = set;\n  }\n  dispose() {\n    this.renderedNodes.clear();\n    this.renderedElements.clear();\n    this.indentGuidesDisposable.dispose();\n    dispose(this.disposables);\n  }\n}\n_TreeRenderer = TreeRenderer;\n_TreeRenderer.DefaultIndent = 8;\nclass FindFilter {\n  get totalCount() {\n    return this._totalCount;\n  }\n  get matchCount() {\n    return this._matchCount;\n  }\n  constructor(tree, keyboardNavigationLabelProvider, _filter) {\n    this.tree = tree;\n    this.keyboardNavigationLabelProvider = keyboardNavigationLabelProvider;\n    this._filter = _filter;\n    this._totalCount = 0;\n    this._matchCount = 0;\n    this._pattern = '';\n    this._lowercasePattern = '';\n    this.disposables = new DisposableStore();\n    tree.onWillRefilter(this.reset, this, this.disposables);\n  }\n  filter(element, parentVisibility) {\n    let visibility = 1 /* TreeVisibility.Visible */;\n    if (this._filter) {\n      const result = this._filter.filter(element, parentVisibility);\n      if (typeof result === 'boolean') {\n        visibility = result ? 1 /* TreeVisibility.Visible */ : 0 /* TreeVisibility.Hidden */;\n      } else if (isFilterResult(result)) {\n        visibility = getVisibleState(result.visibility);\n      } else {\n        visibility = result;\n      }\n      if (visibility === 0 /* TreeVisibility.Hidden */) {\n        return false;\n      }\n    }\n    this._totalCount++;\n    if (!this._pattern) {\n      this._matchCount++;\n      return {\n        data: FuzzyScore.Default,\n        visibility\n      };\n    }\n    const label = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(element);\n    const labels = Array.isArray(label) ? label : [label];\n    for (const l of labels) {\n      const labelStr = l && l.toString();\n      if (typeof labelStr === 'undefined') {\n        return {\n          data: FuzzyScore.Default,\n          visibility\n        };\n      }\n      let score;\n      if (this.tree.findMatchType === TreeFindMatchType.Contiguous) {\n        const index = labelStr.toLowerCase().indexOf(this._lowercasePattern);\n        if (index > -1) {\n          score = [Number.MAX_SAFE_INTEGER, 0];\n          for (let i = this._lowercasePattern.length; i > 0; i--) {\n            score.push(index + i - 1);\n          }\n        }\n      } else {\n        score = fuzzyScore(this._pattern, this._lowercasePattern, 0, labelStr, labelStr.toLowerCase(), 0, {\n          firstMatchCanBeWeak: true,\n          boostFullMatch: true\n        });\n      }\n      if (score) {\n        this._matchCount++;\n        return labels.length === 1 ? {\n          data: score,\n          visibility\n        } : {\n          data: {\n            label: labelStr,\n            score: score\n          },\n          visibility\n        };\n      }\n    }\n    if (this.tree.findMode === TreeFindMode.Filter) {\n      if (typeof this.tree.options.defaultFindVisibility === 'number') {\n        return this.tree.options.defaultFindVisibility;\n      } else if (this.tree.options.defaultFindVisibility) {\n        return this.tree.options.defaultFindVisibility(element);\n      } else {\n        return 2 /* TreeVisibility.Recurse */;\n      }\n    } else {\n      return {\n        data: FuzzyScore.Default,\n        visibility\n      };\n    }\n  }\n  reset() {\n    this._totalCount = 0;\n    this._matchCount = 0;\n  }\n  dispose() {\n    dispose(this.disposables);\n  }\n}\nexport class ModeToggle extends Toggle {\n  constructor(opts) {\n    var _opts$isChecked, _opts$hoverDelegate;\n    super({\n      icon: Codicon.listFilter,\n      title: localize('filter', \"Filter\"),\n      isChecked: (_opts$isChecked = opts.isChecked) !== null && _opts$isChecked !== void 0 ? _opts$isChecked : false,\n      hoverDelegate: (_opts$hoverDelegate = opts.hoverDelegate) !== null && _opts$hoverDelegate !== void 0 ? _opts$hoverDelegate : getDefaultHoverDelegate('element'),\n      inputActiveOptionBorder: opts.inputActiveOptionBorder,\n      inputActiveOptionForeground: opts.inputActiveOptionForeground,\n      inputActiveOptionBackground: opts.inputActiveOptionBackground\n    });\n  }\n}\nexport class FuzzyToggle extends Toggle {\n  constructor(opts) {\n    var _opts$isChecked2, _opts$hoverDelegate2;\n    super({\n      icon: Codicon.searchFuzzy,\n      title: localize('fuzzySearch', \"Fuzzy Match\"),\n      isChecked: (_opts$isChecked2 = opts.isChecked) !== null && _opts$isChecked2 !== void 0 ? _opts$isChecked2 : false,\n      hoverDelegate: (_opts$hoverDelegate2 = opts.hoverDelegate) !== null && _opts$hoverDelegate2 !== void 0 ? _opts$hoverDelegate2 : getDefaultHoverDelegate('element'),\n      inputActiveOptionBorder: opts.inputActiveOptionBorder,\n      inputActiveOptionForeground: opts.inputActiveOptionForeground,\n      inputActiveOptionBackground: opts.inputActiveOptionBackground\n    });\n  }\n}\nconst unthemedFindWidgetStyles = {\n  inputBoxStyles: unthemedInboxStyles,\n  toggleStyles: unthemedToggleStyles,\n  listFilterWidgetBackground: undefined,\n  listFilterWidgetNoMatchesOutline: undefined,\n  listFilterWidgetOutline: undefined,\n  listFilterWidgetShadow: undefined\n};\nexport var TreeFindMode;\n(function (TreeFindMode) {\n  TreeFindMode[TreeFindMode[\"Highlight\"] = 0] = \"Highlight\";\n  TreeFindMode[TreeFindMode[\"Filter\"] = 1] = \"Filter\";\n})(TreeFindMode || (TreeFindMode = {}));\nexport var TreeFindMatchType;\n(function (TreeFindMatchType) {\n  TreeFindMatchType[TreeFindMatchType[\"Fuzzy\"] = 0] = \"Fuzzy\";\n  TreeFindMatchType[TreeFindMatchType[\"Contiguous\"] = 1] = \"Contiguous\";\n})(TreeFindMatchType || (TreeFindMatchType = {}));\nclass FindWidget extends Disposable {\n  set mode(mode) {\n    this.modeToggle.checked = mode === TreeFindMode.Filter;\n    this.findInput.inputBox.setPlaceHolder(mode === TreeFindMode.Filter ? localize('type to filter', \"Type to filter\") : localize('type to search', \"Type to search\"));\n  }\n  set matchType(matchType) {\n    this.matchTypeToggle.checked = matchType === TreeFindMatchType.Fuzzy;\n  }\n  constructor(container, tree, contextViewProvider, mode, matchType, options) {\n    var _options$styles;\n    super();\n    this.tree = tree;\n    this.elements = h('.monaco-tree-type-filter', [h('.monaco-tree-type-filter-grab.codicon.codicon-debug-gripper@grab', {\n      tabIndex: 0\n    }), h('.monaco-tree-type-filter-input@findInput'), h('.monaco-tree-type-filter-actionbar@actionbar')]);\n    this.width = 0;\n    this.right = 0;\n    this.top = 0;\n    this._onDidDisable = new Emitter();\n    container.appendChild(this.elements.root);\n    this._register(toDisposable(() => this.elements.root.remove()));\n    const styles = (_options$styles = options === null || options === void 0 ? void 0 : options.styles) !== null && _options$styles !== void 0 ? _options$styles : unthemedFindWidgetStyles;\n    if (styles.listFilterWidgetBackground) {\n      this.elements.root.style.backgroundColor = styles.listFilterWidgetBackground;\n    }\n    if (styles.listFilterWidgetShadow) {\n      this.elements.root.style.boxShadow = \"0 0 8px 2px \".concat(styles.listFilterWidgetShadow);\n    }\n    const toggleHoverDelegate = this._register(createInstantHoverDelegate());\n    this.modeToggle = this._register(new ModeToggle({\n      ...styles.toggleStyles,\n      isChecked: mode === TreeFindMode.Filter,\n      hoverDelegate: toggleHoverDelegate\n    }));\n    this.matchTypeToggle = this._register(new FuzzyToggle({\n      ...styles.toggleStyles,\n      isChecked: matchType === TreeFindMatchType.Fuzzy,\n      hoverDelegate: toggleHoverDelegate\n    }));\n    this.onDidChangeMode = Event.map(this.modeToggle.onChange, () => this.modeToggle.checked ? TreeFindMode.Filter : TreeFindMode.Highlight, this._store);\n    this.onDidChangeMatchType = Event.map(this.matchTypeToggle.onChange, () => this.matchTypeToggle.checked ? TreeFindMatchType.Fuzzy : TreeFindMatchType.Contiguous, this._store);\n    this.findInput = this._register(new FindInput(this.elements.findInput, contextViewProvider, {\n      label: localize('type to search', \"Type to search\"),\n      additionalToggles: [this.modeToggle, this.matchTypeToggle],\n      showCommonFindToggles: false,\n      inputBoxStyles: styles.inputBoxStyles,\n      toggleStyles: styles.toggleStyles,\n      history: options === null || options === void 0 ? void 0 : options.history\n    }));\n    this.actionbar = this._register(new ActionBar(this.elements.actionbar));\n    this.mode = mode;\n    const emitter = this._register(new DomEmitter(this.findInput.inputBox.inputElement, 'keydown'));\n    const onKeyDown = Event.chain(emitter.event, $ => $.map(e => new StandardKeyboardEvent(e)));\n    this._register(onKeyDown(e => {\n      // Using equals() so we reserve modified keys for future use\n      if (e.equals(3 /* KeyCode.Enter */)) {\n        // This is the only keyboard way to return to the tree from a history item that isn't the last one\n        e.preventDefault();\n        e.stopPropagation();\n        this.findInput.inputBox.addToHistory();\n        this.tree.domFocus();\n        return;\n      }\n      if (e.equals(18 /* KeyCode.DownArrow */)) {\n        e.preventDefault();\n        e.stopPropagation();\n        if (this.findInput.inputBox.isAtLastInHistory() || this.findInput.inputBox.isNowhereInHistory()) {\n          // Retain original pre-history DownArrow behavior\n          this.findInput.inputBox.addToHistory();\n          this.tree.domFocus();\n        } else {\n          // Downward through history\n          this.findInput.inputBox.showNextValue();\n        }\n        return;\n      }\n      if (e.equals(16 /* KeyCode.UpArrow */)) {\n        e.preventDefault();\n        e.stopPropagation();\n        // Upward through history\n        this.findInput.inputBox.showPreviousValue();\n        return;\n      }\n    }));\n    const closeAction = this._register(new Action('close', localize('close', \"Close\"), 'codicon codicon-close', true, () => this.dispose()));\n    this.actionbar.push(closeAction, {\n      icon: true,\n      label: false\n    });\n    const onGrabMouseDown = this._register(new DomEmitter(this.elements.grab, 'mousedown'));\n    this._register(onGrabMouseDown.event(e => {\n      const disposables = new DisposableStore();\n      const onWindowMouseMove = disposables.add(new DomEmitter(getWindow(e), 'mousemove'));\n      const onWindowMouseUp = disposables.add(new DomEmitter(getWindow(e), 'mouseup'));\n      const startRight = this.right;\n      const startX = e.pageX;\n      const startTop = this.top;\n      const startY = e.pageY;\n      this.elements.grab.classList.add('grabbing');\n      const transition = this.elements.root.style.transition;\n      this.elements.root.style.transition = 'unset';\n      const update = e => {\n        const deltaX = e.pageX - startX;\n        this.right = startRight - deltaX;\n        const deltaY = e.pageY - startY;\n        this.top = startTop + deltaY;\n        this.layout();\n      };\n      disposables.add(onWindowMouseMove.event(update));\n      disposables.add(onWindowMouseUp.event(e => {\n        update(e);\n        this.elements.grab.classList.remove('grabbing');\n        this.elements.root.style.transition = transition;\n        disposables.dispose();\n      }));\n    }));\n    const onGrabKeyDown = Event.chain(this._register(new DomEmitter(this.elements.grab, 'keydown')).event, $ => $.map(e => new StandardKeyboardEvent(e)));\n    this._register(onGrabKeyDown(e => {\n      let right;\n      let top;\n      if (e.keyCode === 15 /* KeyCode.LeftArrow */) {\n        right = Number.POSITIVE_INFINITY;\n      } else if (e.keyCode === 17 /* KeyCode.RightArrow */) {\n        right = 0;\n      } else if (e.keyCode === 10 /* KeyCode.Space */) {\n        right = this.right === 0 ? Number.POSITIVE_INFINITY : 0;\n      }\n      if (e.keyCode === 16 /* KeyCode.UpArrow */) {\n        top = 0;\n      } else if (e.keyCode === 18 /* KeyCode.DownArrow */) {\n        top = Number.POSITIVE_INFINITY;\n      }\n      if (right !== undefined) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.right = right;\n        this.layout();\n      }\n      if (top !== undefined) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.top = top;\n        const transition = this.elements.root.style.transition;\n        this.elements.root.style.transition = 'unset';\n        this.layout();\n        setTimeout(() => {\n          this.elements.root.style.transition = transition;\n        }, 0);\n      }\n    }));\n    this.onDidChangeValue = this.findInput.onDidChange;\n  }\n  layout() {\n    let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.width;\n    this.width = width;\n    this.right = clamp(this.right, 0, Math.max(0, width - 212));\n    this.elements.root.style.right = \"\".concat(this.right, \"px\");\n    this.top = clamp(this.top, 0, 24);\n    this.elements.root.style.top = \"\".concat(this.top, \"px\");\n  }\n  showMessage(message) {\n    this.findInput.showMessage(message);\n  }\n  clearMessage() {\n    this.findInput.clearMessage();\n  }\n  async dispose() {\n    this._onDidDisable.fire();\n    this.elements.root.classList.add('disabled');\n    await timeout(300);\n    super.dispose();\n  }\n}\nclass FindController {\n  get pattern() {\n    return this._pattern;\n  }\n  get mode() {\n    return this._mode;\n  }\n  set mode(mode) {\n    if (mode === this._mode) {\n      return;\n    }\n    this._mode = mode;\n    if (this.widget) {\n      this.widget.mode = this._mode;\n    }\n    this.tree.refilter();\n    this.render();\n    this._onDidChangeMode.fire(mode);\n  }\n  get matchType() {\n    return this._matchType;\n  }\n  set matchType(matchType) {\n    if (matchType === this._matchType) {\n      return;\n    }\n    this._matchType = matchType;\n    if (this.widget) {\n      this.widget.matchType = this._matchType;\n    }\n    this.tree.refilter();\n    this.render();\n    this._onDidChangeMatchType.fire(matchType);\n  }\n  constructor(tree, model, view, filter, contextViewProvider) {\n    var _tree$options$default, _tree$options$default2;\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    this.tree = tree;\n    this.view = view;\n    this.filter = filter;\n    this.contextViewProvider = contextViewProvider;\n    this.options = options;\n    this._pattern = '';\n    this.width = 0;\n    this._onDidChangeMode = new Emitter();\n    this.onDidChangeMode = this._onDidChangeMode.event;\n    this._onDidChangeMatchType = new Emitter();\n    this.onDidChangeMatchType = this._onDidChangeMatchType.event;\n    this._onDidChangePattern = new Emitter();\n    this._onDidChangeOpenState = new Emitter();\n    this.onDidChangeOpenState = this._onDidChangeOpenState.event;\n    this.enabledDisposables = new DisposableStore();\n    this.disposables = new DisposableStore();\n    this._mode = (_tree$options$default = tree.options.defaultFindMode) !== null && _tree$options$default !== void 0 ? _tree$options$default : TreeFindMode.Highlight;\n    this._matchType = (_tree$options$default2 = tree.options.defaultFindMatchType) !== null && _tree$options$default2 !== void 0 ? _tree$options$default2 : TreeFindMatchType.Fuzzy;\n    model.onDidSplice(this.onDidSpliceModel, this, this.disposables);\n  }\n  updateOptions() {\n    let optionsUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (optionsUpdate.defaultFindMode !== undefined) {\n      this.mode = optionsUpdate.defaultFindMode;\n    }\n    if (optionsUpdate.defaultFindMatchType !== undefined) {\n      this.matchType = optionsUpdate.defaultFindMatchType;\n    }\n  }\n  onDidSpliceModel() {\n    if (!this.widget || this.pattern.length === 0) {\n      return;\n    }\n    this.tree.refilter();\n    this.render();\n  }\n  render() {\n    const noMatches = this.filter.totalCount > 0 && this.filter.matchCount === 0;\n    if (this.pattern && noMatches) {\n      var _this$tree$options$sh;\n      alert(localize('replFindNoResults', \"No results\"));\n      if ((_this$tree$options$sh = this.tree.options.showNotFoundMessage) !== null && _this$tree$options$sh !== void 0 ? _this$tree$options$sh : true) {\n        var _this$widget;\n        (_this$widget = this.widget) === null || _this$widget === void 0 || _this$widget.showMessage({\n          type: 2 /* MessageType.WARNING */,\n          content: localize('not found', \"No elements found.\")\n        });\n      } else {\n        var _this$widget2;\n        (_this$widget2 = this.widget) === null || _this$widget2 === void 0 || _this$widget2.showMessage({\n          type: 2 /* MessageType.WARNING */\n        });\n      }\n    } else {\n      var _this$widget3;\n      (_this$widget3 = this.widget) === null || _this$widget3 === void 0 || _this$widget3.clearMessage();\n      if (this.pattern) {\n        alert(localize('replFindResults', \"{0} results\", this.filter.matchCount));\n      }\n    }\n  }\n  shouldAllowFocus(node) {\n    if (!this.widget || !this.pattern) {\n      return true;\n    }\n    if (this.filter.totalCount > 0 && this.filter.matchCount <= 1) {\n      return true;\n    }\n    return !FuzzyScore.isDefault(node.filterData);\n  }\n  layout(width) {\n    var _this$widget4;\n    this.width = width;\n    (_this$widget4 = this.widget) === null || _this$widget4 === void 0 || _this$widget4.layout(width);\n  }\n  dispose() {\n    this._history = undefined;\n    this._onDidChangePattern.dispose();\n    this.enabledDisposables.dispose();\n    this.disposables.dispose();\n  }\n}\nfunction stickyScrollNodeStateEquals(node1, node2) {\n  return node1.position === node2.position && stickyScrollNodeEquals(node1, node2);\n}\nfunction stickyScrollNodeEquals(node1, node2) {\n  return node1.node.element === node2.node.element && node1.startIndex === node2.startIndex && node1.height === node2.height && node1.endIndex === node2.endIndex;\n}\nclass StickyScrollState {\n  constructor() {\n    let stickyNodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    this.stickyNodes = stickyNodes;\n  }\n  get count() {\n    return this.stickyNodes.length;\n  }\n  equal(state) {\n    return equals(this.stickyNodes, state.stickyNodes, stickyScrollNodeStateEquals);\n  }\n  lastNodePartiallyVisible() {\n    if (this.count === 0) {\n      return false;\n    }\n    const lastStickyNode = this.stickyNodes[this.count - 1];\n    if (this.count === 1) {\n      return lastStickyNode.position !== 0;\n    }\n    const secondLastStickyNode = this.stickyNodes[this.count - 2];\n    return secondLastStickyNode.position + secondLastStickyNode.height !== lastStickyNode.position;\n  }\n  animationStateChanged(previousState) {\n    if (!equals(this.stickyNodes, previousState.stickyNodes, stickyScrollNodeEquals)) {\n      return false;\n    }\n    if (this.count === 0) {\n      return false;\n    }\n    const lastStickyNode = this.stickyNodes[this.count - 1];\n    const previousLastStickyNode = previousState.stickyNodes[previousState.count - 1];\n    return lastStickyNode.position !== previousLastStickyNode.position;\n  }\n}\nclass DefaultStickyScrollDelegate {\n  constrainStickyScrollNodes(stickyNodes, stickyScrollMaxItemCount, maxWidgetHeight) {\n    for (let i = 0; i < stickyNodes.length; i++) {\n      const stickyNode = stickyNodes[i];\n      const stickyNodeBottom = stickyNode.position + stickyNode.height;\n      if (stickyNodeBottom > maxWidgetHeight || i >= stickyScrollMaxItemCount) {\n        return stickyNodes.slice(0, i);\n      }\n    }\n    return stickyNodes;\n  }\n}\nclass StickyScrollController extends Disposable {\n  constructor(tree, model, view, renderers, treeDelegate) {\n    var _options$stickyScroll;\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    super();\n    this.tree = tree;\n    this.model = model;\n    this.view = view;\n    this.treeDelegate = treeDelegate;\n    this.maxWidgetViewRatio = 0.4;\n    const stickyScrollOptions = this.validateStickySettings(options);\n    this.stickyScrollMaxItemCount = stickyScrollOptions.stickyScrollMaxItemCount;\n    this.stickyScrollDelegate = (_options$stickyScroll = options.stickyScrollDelegate) !== null && _options$stickyScroll !== void 0 ? _options$stickyScroll : new DefaultStickyScrollDelegate();\n    this._widget = this._register(new StickyScrollWidget(view.getScrollableElement(), view, tree, renderers, treeDelegate, options.accessibilityProvider));\n    this.onDidChangeHasFocus = this._widget.onDidChangeHasFocus;\n    this.onContextMenu = this._widget.onContextMenu;\n    this._register(view.onDidScroll(() => this.update()));\n    this._register(view.onDidChangeContentHeight(() => this.update()));\n    this._register(tree.onDidChangeCollapseState(() => this.update()));\n    this.update();\n  }\n  get height() {\n    return this._widget.height;\n  }\n  getNodeAtHeight(height) {\n    let index;\n    if (height === 0) {\n      index = this.view.firstVisibleIndex;\n    } else {\n      index = this.view.indexAt(height + this.view.scrollTop);\n    }\n    if (index < 0 || index >= this.view.length) {\n      return undefined;\n    }\n    return this.view.element(index);\n  }\n  update() {\n    const firstVisibleNode = this.getNodeAtHeight(0);\n    // Don't render anything if there are no elements\n    if (!firstVisibleNode || this.tree.scrollTop === 0) {\n      this._widget.setState(undefined);\n      return;\n    }\n    const stickyState = this.findStickyState(firstVisibleNode);\n    this._widget.setState(stickyState);\n  }\n  findStickyState(firstVisibleNode) {\n    const stickyNodes = [];\n    let firstVisibleNodeUnderWidget = firstVisibleNode;\n    let stickyNodesHeight = 0;\n    let nextStickyNode = this.getNextStickyNode(firstVisibleNodeUnderWidget, undefined, stickyNodesHeight);\n    while (nextStickyNode) {\n      stickyNodes.push(nextStickyNode);\n      stickyNodesHeight += nextStickyNode.height;\n      if (stickyNodes.length <= this.stickyScrollMaxItemCount) {\n        firstVisibleNodeUnderWidget = this.getNextVisibleNode(nextStickyNode);\n        if (!firstVisibleNodeUnderWidget) {\n          break;\n        }\n      }\n      nextStickyNode = this.getNextStickyNode(firstVisibleNodeUnderWidget, nextStickyNode.node, stickyNodesHeight);\n    }\n    const contrainedStickyNodes = this.constrainStickyNodes(stickyNodes);\n    return contrainedStickyNodes.length ? new StickyScrollState(contrainedStickyNodes) : undefined;\n  }\n  getNextVisibleNode(previousStickyNode) {\n    return this.getNodeAtHeight(previousStickyNode.position + previousStickyNode.height);\n  }\n  getNextStickyNode(firstVisibleNodeUnderWidget, previousStickyNode, stickyNodesHeight) {\n    const nextStickyNode = this.getAncestorUnderPrevious(firstVisibleNodeUnderWidget, previousStickyNode);\n    if (!nextStickyNode) {\n      return undefined;\n    }\n    if (nextStickyNode === firstVisibleNodeUnderWidget) {\n      if (!this.nodeIsUncollapsedParent(firstVisibleNodeUnderWidget)) {\n        return undefined;\n      }\n      if (this.nodeTopAlignsWithStickyNodesBottom(firstVisibleNodeUnderWidget, stickyNodesHeight)) {\n        return undefined;\n      }\n    }\n    return this.createStickyScrollNode(nextStickyNode, stickyNodesHeight);\n  }\n  nodeTopAlignsWithStickyNodesBottom(node, stickyNodesHeight) {\n    const nodeIndex = this.getNodeIndex(node);\n    const elementTop = this.view.getElementTop(nodeIndex);\n    const stickyPosition = stickyNodesHeight;\n    return this.view.scrollTop === elementTop - stickyPosition;\n  }\n  createStickyScrollNode(node, currentStickyNodesHeight) {\n    const height = this.treeDelegate.getHeight(node);\n    const {\n      startIndex,\n      endIndex\n    } = this.getNodeRange(node);\n    const position = this.calculateStickyNodePosition(endIndex, currentStickyNodesHeight, height);\n    return {\n      node,\n      position,\n      height,\n      startIndex,\n      endIndex\n    };\n  }\n  getAncestorUnderPrevious(node) {\n    let previousAncestor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let currentAncestor = node;\n    let parentOfcurrentAncestor = this.getParentNode(currentAncestor);\n    while (parentOfcurrentAncestor) {\n      if (parentOfcurrentAncestor === previousAncestor) {\n        return currentAncestor;\n      }\n      currentAncestor = parentOfcurrentAncestor;\n      parentOfcurrentAncestor = this.getParentNode(currentAncestor);\n    }\n    if (previousAncestor === undefined) {\n      return currentAncestor;\n    }\n    return undefined;\n  }\n  calculateStickyNodePosition(lastDescendantIndex, stickyRowPositionTop, stickyNodeHeight) {\n    let lastChildRelativeTop = this.view.getRelativeTop(lastDescendantIndex);\n    // If the last descendant is only partially visible at the top of the view, getRelativeTop() returns null\n    // In that case, utilize the next node's relative top to calculate the sticky node's position\n    if (lastChildRelativeTop === null && this.view.firstVisibleIndex === lastDescendantIndex && lastDescendantIndex + 1 < this.view.length) {\n      const nodeHeight = this.treeDelegate.getHeight(this.view.element(lastDescendantIndex));\n      const nextNodeRelativeTop = this.view.getRelativeTop(lastDescendantIndex + 1);\n      lastChildRelativeTop = nextNodeRelativeTop ? nextNodeRelativeTop - nodeHeight / this.view.renderHeight : null;\n    }\n    if (lastChildRelativeTop === null) {\n      return stickyRowPositionTop;\n    }\n    const lastChildNode = this.view.element(lastDescendantIndex);\n    const lastChildHeight = this.treeDelegate.getHeight(lastChildNode);\n    const topOfLastChild = lastChildRelativeTop * this.view.renderHeight;\n    const bottomOfLastChild = topOfLastChild + lastChildHeight;\n    if (stickyRowPositionTop + stickyNodeHeight > bottomOfLastChild && stickyRowPositionTop <= bottomOfLastChild) {\n      return bottomOfLastChild - stickyNodeHeight;\n    }\n    return stickyRowPositionTop;\n  }\n  constrainStickyNodes(stickyNodes) {\n    if (stickyNodes.length === 0) {\n      return [];\n    }\n    // Check if sticky nodes need to be constrained\n    const maximumStickyWidgetHeight = this.view.renderHeight * this.maxWidgetViewRatio;\n    const lastStickyNode = stickyNodes[stickyNodes.length - 1];\n    if (stickyNodes.length <= this.stickyScrollMaxItemCount && lastStickyNode.position + lastStickyNode.height <= maximumStickyWidgetHeight) {\n      return stickyNodes;\n    }\n    // constrain sticky nodes\n    const constrainedStickyNodes = this.stickyScrollDelegate.constrainStickyScrollNodes(stickyNodes, this.stickyScrollMaxItemCount, maximumStickyWidgetHeight);\n    if (!constrainedStickyNodes.length) {\n      return [];\n    }\n    // Validate constraints\n    const lastConstrainedStickyNode = constrainedStickyNodes[constrainedStickyNodes.length - 1];\n    if (constrainedStickyNodes.length > this.stickyScrollMaxItemCount || lastConstrainedStickyNode.position + lastConstrainedStickyNode.height > maximumStickyWidgetHeight) {\n      throw new Error('stickyScrollDelegate violates constraints');\n    }\n    return constrainedStickyNodes;\n  }\n  getParentNode(node) {\n    const nodeLocation = this.model.getNodeLocation(node);\n    const parentLocation = this.model.getParentNodeLocation(nodeLocation);\n    return parentLocation ? this.model.getNode(parentLocation) : undefined;\n  }\n  nodeIsUncollapsedParent(node) {\n    const nodeLocation = this.model.getNodeLocation(node);\n    return this.model.getListRenderCount(nodeLocation) > 1;\n  }\n  getNodeIndex(node) {\n    const nodeLocation = this.model.getNodeLocation(node);\n    const nodeIndex = this.model.getListIndex(nodeLocation);\n    return nodeIndex;\n  }\n  getNodeRange(node) {\n    const nodeLocation = this.model.getNodeLocation(node);\n    const startIndex = this.model.getListIndex(nodeLocation);\n    if (startIndex < 0) {\n      throw new Error('Node not found in tree');\n    }\n    const renderCount = this.model.getListRenderCount(nodeLocation);\n    const endIndex = startIndex + renderCount - 1;\n    return {\n      startIndex,\n      endIndex\n    };\n  }\n  nodePositionTopBelowWidget(node) {\n    const ancestors = [];\n    let currentAncestor = this.getParentNode(node);\n    while (currentAncestor) {\n      ancestors.push(currentAncestor);\n      currentAncestor = this.getParentNode(currentAncestor);\n    }\n    let widgetHeight = 0;\n    for (let i = 0; i < ancestors.length && i < this.stickyScrollMaxItemCount; i++) {\n      widgetHeight += this.treeDelegate.getHeight(ancestors[i]);\n    }\n    return widgetHeight;\n  }\n  domFocus() {\n    this._widget.domFocus();\n  }\n  // Whether sticky scroll was the last focused part in the tree or not\n  focusedLast() {\n    return this._widget.focusedLast();\n  }\n  updateOptions() {\n    let optionsUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!optionsUpdate.stickyScrollMaxItemCount) {\n      return;\n    }\n    const validatedOptions = this.validateStickySettings(optionsUpdate);\n    if (this.stickyScrollMaxItemCount !== validatedOptions.stickyScrollMaxItemCount) {\n      this.stickyScrollMaxItemCount = validatedOptions.stickyScrollMaxItemCount;\n      this.update();\n    }\n  }\n  validateStickySettings(options) {\n    let stickyScrollMaxItemCount = 7;\n    if (typeof options.stickyScrollMaxItemCount === 'number') {\n      stickyScrollMaxItemCount = Math.max(options.stickyScrollMaxItemCount, 1);\n    }\n    return {\n      stickyScrollMaxItemCount\n    };\n  }\n}\nclass StickyScrollWidget {\n  constructor(container, view, tree, treeRenderers, treeDelegate, accessibilityProvider) {\n    this.view = view;\n    this.tree = tree;\n    this.treeRenderers = treeRenderers;\n    this.treeDelegate = treeDelegate;\n    this.accessibilityProvider = accessibilityProvider;\n    this._previousElements = [];\n    this._previousStateDisposables = new DisposableStore();\n    this._rootDomNode = $('.monaco-tree-sticky-container.empty');\n    container.appendChild(this._rootDomNode);\n    const shadow = $('.monaco-tree-sticky-container-shadow');\n    this._rootDomNode.appendChild(shadow);\n    this.stickyScrollFocus = new StickyScrollFocus(this._rootDomNode, view);\n    this.onDidChangeHasFocus = this.stickyScrollFocus.onDidChangeHasFocus;\n    this.onContextMenu = this.stickyScrollFocus.onContextMenu;\n  }\n  get height() {\n    if (!this._previousState) {\n      return 0;\n    }\n    const lastElement = this._previousState.stickyNodes[this._previousState.count - 1];\n    return lastElement.position + lastElement.height;\n  }\n  setState(state) {\n    const wasVisible = !!this._previousState && this._previousState.count > 0;\n    const isVisible = !!state && state.count > 0;\n    // If state has not changed, do nothing\n    if (!wasVisible && !isVisible || wasVisible && isVisible && this._previousState.equal(state)) {\n      return;\n    }\n    // Update visibility of the widget if changed\n    if (wasVisible !== isVisible) {\n      this.setVisible(isVisible);\n    }\n    if (!isVisible) {\n      this._previousState = undefined;\n      this._previousElements = [];\n      this._previousStateDisposables.clear();\n      return;\n    }\n    const lastStickyNode = state.stickyNodes[state.count - 1];\n    // If the new state is only a change in the last node's position, update the position of the last element\n    if (this._previousState && state.animationStateChanged(this._previousState)) {\n      this._previousElements[this._previousState.count - 1].style.top = \"\".concat(lastStickyNode.position, \"px\");\n    }\n    // create new dom elements\n    else {\n      this._previousStateDisposables.clear();\n      const elements = Array(state.count);\n      for (let stickyIndex = state.count - 1; stickyIndex >= 0; stickyIndex--) {\n        const stickyNode = state.stickyNodes[stickyIndex];\n        const {\n          element,\n          disposable\n        } = this.createElement(stickyNode, stickyIndex, state.count);\n        elements[stickyIndex] = element;\n        this._rootDomNode.appendChild(element);\n        this._previousStateDisposables.add(disposable);\n      }\n      this.stickyScrollFocus.updateElements(elements, state);\n      this._previousElements = elements;\n    }\n    this._previousState = state;\n    // Set the height of the widget to the bottom of the last sticky node\n    this._rootDomNode.style.height = \"\".concat(lastStickyNode.position + lastStickyNode.height, \"px\");\n  }\n  createElement(stickyNode, stickyIndex, stickyNodesTotal) {\n    const nodeIndex = stickyNode.startIndex;\n    // Sticky element container\n    const stickyElement = document.createElement('div');\n    stickyElement.style.top = \"\".concat(stickyNode.position, \"px\");\n    if (this.tree.options.setRowHeight !== false) {\n      stickyElement.style.height = \"\".concat(stickyNode.height, \"px\");\n    }\n    if (this.tree.options.setRowLineHeight !== false) {\n      stickyElement.style.lineHeight = \"\".concat(stickyNode.height, \"px\");\n    }\n    stickyElement.classList.add('monaco-tree-sticky-row');\n    stickyElement.classList.add('monaco-list-row');\n    stickyElement.setAttribute('data-index', \"\".concat(nodeIndex));\n    stickyElement.setAttribute('data-parity', nodeIndex % 2 === 0 ? 'even' : 'odd');\n    stickyElement.setAttribute('id', this.view.getElementID(nodeIndex));\n    const accessibilityDisposable = this.setAccessibilityAttributes(stickyElement, stickyNode.node.element, stickyIndex, stickyNodesTotal);\n    // Get the renderer for the node\n    const nodeTemplateId = this.treeDelegate.getTemplateId(stickyNode.node);\n    const renderer = this.treeRenderers.find(renderer => renderer.templateId === nodeTemplateId);\n    if (!renderer) {\n      throw new Error(\"No renderer found for template id \".concat(nodeTemplateId));\n    }\n    // To make sure we do not influence the original node, we create a copy of the node\n    // We need to check if it is already a unique instance of the node by the delegate\n    let nodeCopy = stickyNode.node;\n    if (nodeCopy === this.tree.getNode(this.tree.getNodeLocation(stickyNode.node))) {\n      nodeCopy = new Proxy(stickyNode.node, {});\n    }\n    // Render the element\n    const templateData = renderer.renderTemplate(stickyElement);\n    renderer.renderElement(nodeCopy, stickyNode.startIndex, templateData, stickyNode.height);\n    // Remove the element from the DOM when state is disposed\n    const disposable = toDisposable(() => {\n      accessibilityDisposable.dispose();\n      renderer.disposeElement(nodeCopy, stickyNode.startIndex, templateData, stickyNode.height);\n      renderer.disposeTemplate(templateData);\n      stickyElement.remove();\n    });\n    return {\n      element: stickyElement,\n      disposable\n    };\n  }\n  setAccessibilityAttributes(container, element, stickyIndex, stickyNodesTotal) {\n    if (!this.accessibilityProvider) {\n      return Disposable.None;\n    }\n    if (this.accessibilityProvider.getSetSize) {\n      container.setAttribute('aria-setsize', String(this.accessibilityProvider.getSetSize(element, stickyIndex, stickyNodesTotal)));\n    }\n    if (this.accessibilityProvider.getPosInSet) {\n      container.setAttribute('aria-posinset', String(this.accessibilityProvider.getPosInSet(element, stickyIndex)));\n    }\n    if (this.accessibilityProvider.getRole) {\n      var _this$accessibilityPr;\n      container.setAttribute('role', (_this$accessibilityPr = this.accessibilityProvider.getRole(element)) !== null && _this$accessibilityPr !== void 0 ? _this$accessibilityPr : 'treeitem');\n    }\n    const ariaLabel = this.accessibilityProvider.getAriaLabel(element);\n    const observable = ariaLabel && typeof ariaLabel !== 'string' ? ariaLabel : constObservable(ariaLabel);\n    const result = autorun(reader => {\n      const value = reader.readObservable(observable);\n      if (value) {\n        container.setAttribute('aria-label', value);\n      } else {\n        container.removeAttribute('aria-label');\n      }\n    });\n    if (typeof ariaLabel === 'string') {} else if (ariaLabel) {\n      container.setAttribute('aria-label', ariaLabel.get());\n    }\n    const ariaLevel = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(element);\n    if (typeof ariaLevel === 'number') {\n      container.setAttribute('aria-level', \"\".concat(ariaLevel));\n    }\n    // Sticky Scroll elements can not be selected\n    container.setAttribute('aria-selected', String(false));\n    return result;\n  }\n  setVisible(visible) {\n    this._rootDomNode.classList.toggle('empty', !visible);\n    if (!visible) {\n      this.stickyScrollFocus.updateElements([], undefined);\n    }\n  }\n  domFocus() {\n    this.stickyScrollFocus.domFocus();\n  }\n  focusedLast() {\n    return this.stickyScrollFocus.focusedLast();\n  }\n  dispose() {\n    this.stickyScrollFocus.dispose();\n    this._previousStateDisposables.dispose();\n    this._rootDomNode.remove();\n  }\n}\nclass StickyScrollFocus extends Disposable {\n  get domHasFocus() {\n    return this._domHasFocus;\n  }\n  set domHasFocus(hasFocus) {\n    if (hasFocus !== this._domHasFocus) {\n      this._onDidChangeHasFocus.fire(hasFocus);\n      this._domHasFocus = hasFocus;\n    }\n  }\n  constructor(container, view) {\n    super();\n    this.container = container;\n    this.view = view;\n    this.focusedIndex = -1;\n    this.elements = [];\n    this._onDidChangeHasFocus = new Emitter();\n    this.onDidChangeHasFocus = this._onDidChangeHasFocus.event;\n    this._onContextMenu = new Emitter();\n    this.onContextMenu = this._onContextMenu.event;\n    this._domHasFocus = false;\n    this._register(addDisposableListener(this.container, 'focus', () => this.onFocus()));\n    this._register(addDisposableListener(this.container, 'blur', () => this.onBlur()));\n    this._register(this.view.onDidFocus(() => this.toggleStickyScrollFocused(false)));\n    this._register(this.view.onKeyDown(e => this.onKeyDown(e)));\n    this._register(this.view.onMouseDown(e => this.onMouseDown(e)));\n    this._register(this.view.onContextMenu(e => this.handleContextMenu(e)));\n  }\n  handleContextMenu(e) {\n    const target = e.browserEvent.target;\n    if (!isStickyScrollContainer(target) && !isStickyScrollElement(target)) {\n      if (this.focusedLast()) {\n        this.view.domFocus();\n      }\n      return;\n    }\n    // The list handles the context menu triggered by a mouse event\n    // In that case only set the focus of the element clicked and leave the rest to the list to handle\n    if (!isKeyboardEvent(e.browserEvent)) {\n      if (!this.state) {\n        throw new Error('Context menu should not be triggered when state is undefined');\n      }\n      const stickyIndex = this.state.stickyNodes.findIndex(stickyNode => {\n        var _e$element;\n        return stickyNode.node.element === ((_e$element = e.element) === null || _e$element === void 0 ? void 0 : _e$element.element);\n      });\n      if (stickyIndex === -1) {\n        throw new Error('Context menu should not be triggered when element is not in sticky scroll widget');\n      }\n      this.container.focus();\n      this.setFocus(stickyIndex);\n      return;\n    }\n    if (!this.state || this.focusedIndex < 0) {\n      throw new Error('Context menu key should not be triggered when focus is not in sticky scroll widget');\n    }\n    const stickyNode = this.state.stickyNodes[this.focusedIndex];\n    const element = stickyNode.node.element;\n    const anchor = this.elements[this.focusedIndex];\n    this._onContextMenu.fire({\n      element,\n      anchor,\n      browserEvent: e.browserEvent,\n      isStickyScroll: true\n    });\n  }\n  onKeyDown(e) {\n    // Sticky Scroll Navigation\n    if (this.domHasFocus && this.state) {\n      // Move up\n      if (e.key === 'ArrowUp') {\n        this.setFocusedElement(Math.max(0, this.focusedIndex - 1));\n        e.preventDefault();\n        e.stopPropagation();\n      }\n      // Move down, if last sticky node is focused, move focus into first child of last sticky node\n      else if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {\n        if (this.focusedIndex >= this.state.count - 1) {\n          const nodeIndexToFocus = this.state.stickyNodes[this.state.count - 1].startIndex + 1;\n          this.view.domFocus();\n          this.view.setFocus([nodeIndexToFocus]);\n          this.scrollNodeUnderWidget(nodeIndexToFocus, this.state);\n        } else {\n          this.setFocusedElement(this.focusedIndex + 1);\n        }\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    }\n  }\n  onMouseDown(e) {\n    const target = e.browserEvent.target;\n    if (!isStickyScrollContainer(target) && !isStickyScrollElement(target)) {\n      return;\n    }\n    e.browserEvent.preventDefault();\n    e.browserEvent.stopPropagation();\n  }\n  updateElements(elements, state) {\n    if (state && state.count === 0) {\n      throw new Error('Sticky scroll state must be undefined when there are no sticky nodes');\n    }\n    if (state && state.count !== elements.length) {\n      throw new Error('Sticky scroll focus received illigel state');\n    }\n    const previousIndex = this.focusedIndex;\n    this.removeFocus();\n    this.elements = elements;\n    this.state = state;\n    if (state) {\n      const newFocusedIndex = clamp(previousIndex, 0, state.count - 1);\n      this.setFocus(newFocusedIndex);\n    } else {\n      if (this.domHasFocus) {\n        this.view.domFocus();\n      }\n    }\n    // must come last as it calls blur()\n    this.container.tabIndex = state ? 0 : -1;\n  }\n  setFocusedElement(stickyIndex) {\n    // doesn't imply that the widget has (or will have) focus\n    const state = this.state;\n    if (!state) {\n      throw new Error('Cannot set focus when state is undefined');\n    }\n    this.setFocus(stickyIndex);\n    if (stickyIndex < state.count - 1) {\n      return;\n    }\n    // If the last sticky node is not fully visible, scroll it into view\n    if (state.lastNodePartiallyVisible()) {\n      const lastStickyNode = state.stickyNodes[stickyIndex];\n      this.scrollNodeUnderWidget(lastStickyNode.endIndex + 1, state);\n    }\n  }\n  scrollNodeUnderWidget(nodeIndex, state) {\n    const lastStickyNode = state.stickyNodes[state.count - 1];\n    const secondLastStickyNode = state.count > 1 ? state.stickyNodes[state.count - 2] : undefined;\n    const elementScrollTop = this.view.getElementTop(nodeIndex);\n    const elementTargetViewTop = secondLastStickyNode ? secondLastStickyNode.position + secondLastStickyNode.height + lastStickyNode.height : lastStickyNode.height;\n    this.view.scrollTop = elementScrollTop - elementTargetViewTop;\n  }\n  domFocus() {\n    if (!this.state) {\n      throw new Error('Cannot focus when state is undefined');\n    }\n    this.container.focus();\n  }\n  focusedLast() {\n    if (!this.state) {\n      return false;\n    }\n    return this.view.getHTMLElement().classList.contains('sticky-scroll-focused');\n  }\n  removeFocus() {\n    if (this.focusedIndex === -1) {\n      return;\n    }\n    this.toggleElementFocus(this.elements[this.focusedIndex], false);\n    this.focusedIndex = -1;\n  }\n  setFocus(newFocusIndex) {\n    if (0 > newFocusIndex) {\n      throw new Error('addFocus() can not remove focus');\n    }\n    if (!this.state && newFocusIndex >= 0) {\n      throw new Error('Cannot set focus index when state is undefined');\n    }\n    if (this.state && newFocusIndex >= this.state.count) {\n      throw new Error('Cannot set focus index to an index that does not exist');\n    }\n    const oldIndex = this.focusedIndex;\n    if (oldIndex >= 0) {\n      this.toggleElementFocus(this.elements[oldIndex], false);\n    }\n    if (newFocusIndex >= 0) {\n      this.toggleElementFocus(this.elements[newFocusIndex], true);\n    }\n    this.focusedIndex = newFocusIndex;\n  }\n  toggleElementFocus(element, focused) {\n    this.toggleElementActiveFocus(element, focused && this.domHasFocus);\n    this.toggleElementPassiveFocus(element, focused);\n  }\n  toggleCurrentElementActiveFocus(focused) {\n    if (this.focusedIndex === -1) {\n      return;\n    }\n    this.toggleElementActiveFocus(this.elements[this.focusedIndex], focused);\n  }\n  toggleElementActiveFocus(element, focused) {\n    // active focus is set when sticky scroll has focus\n    element.classList.toggle('focused', focused);\n  }\n  toggleElementPassiveFocus(element, focused) {\n    // passive focus allows to show focus when sticky scroll does not have focus\n    // for example when the context menu has focus\n    element.classList.toggle('passive-focused', focused);\n  }\n  toggleStickyScrollFocused(focused) {\n    // Weather the last focus in the view was sticky scroll and not the list\n    // Is only removed when the focus is back in the tree an no longer in sticky scroll\n    this.view.getHTMLElement().classList.toggle('sticky-scroll-focused', focused);\n  }\n  onFocus() {\n    if (!this.state || this.elements.length === 0) {\n      throw new Error('Cannot focus when state is undefined or elements are empty');\n    }\n    this.domHasFocus = true;\n    this.toggleStickyScrollFocused(true);\n    this.toggleCurrentElementActiveFocus(true);\n    if (this.focusedIndex === -1) {\n      this.setFocus(0);\n    }\n  }\n  onBlur() {\n    this.domHasFocus = false;\n    this.toggleCurrentElementActiveFocus(false);\n  }\n  dispose() {\n    this.toggleStickyScrollFocused(false);\n    this._onDidChangeHasFocus.fire(false);\n    super.dispose();\n  }\n}\nfunction asTreeMouseEvent(event) {\n  let target = TreeMouseEventTarget.Unknown;\n  if (hasParentWithClass(event.browserEvent.target, 'monaco-tl-twistie', 'monaco-tl-row')) {\n    target = TreeMouseEventTarget.Twistie;\n  } else if (hasParentWithClass(event.browserEvent.target, 'monaco-tl-contents', 'monaco-tl-row')) {\n    target = TreeMouseEventTarget.Element;\n  } else if (hasParentWithClass(event.browserEvent.target, 'monaco-tree-type-filter', 'monaco-list')) {\n    target = TreeMouseEventTarget.Filter;\n  }\n  return {\n    browserEvent: event.browserEvent,\n    element: event.element ? event.element.element : null,\n    target\n  };\n}\nfunction asTreeContextMenuEvent(event) {\n  const isStickyScroll = isStickyScrollContainer(event.browserEvent.target);\n  return {\n    element: event.element ? event.element.element : null,\n    browserEvent: event.browserEvent,\n    anchor: event.anchor,\n    isStickyScroll\n  };\n}\nfunction dfs(node, fn) {\n  fn(node);\n  node.children.forEach(child => dfs(child, fn));\n}\n/**\n * The trait concept needs to exist at the tree level, because collapsed\n * tree nodes will not be known by the list.\n */\nclass Trait {\n  get nodeSet() {\n    if (!this._nodeSet) {\n      this._nodeSet = this.createNodeSet();\n    }\n    return this._nodeSet;\n  }\n  constructor(getFirstViewElementWithTrait, identityProvider) {\n    this.getFirstViewElementWithTrait = getFirstViewElementWithTrait;\n    this.identityProvider = identityProvider;\n    this.nodes = [];\n    this._onDidChange = new Emitter();\n    this.onDidChange = this._onDidChange.event;\n  }\n  set(nodes, browserEvent) {\n    if (!(browserEvent !== null && browserEvent !== void 0 && browserEvent.__forceEvent) && equals(this.nodes, nodes)) {\n      return;\n    }\n    this._set(nodes, false, browserEvent);\n  }\n  _set(nodes, silent, browserEvent) {\n    this.nodes = [...nodes];\n    this.elements = undefined;\n    this._nodeSet = undefined;\n    if (!silent) {\n      const that = this;\n      this._onDidChange.fire({\n        get elements() {\n          return that.get();\n        },\n        browserEvent\n      });\n    }\n  }\n  get() {\n    if (!this.elements) {\n      this.elements = this.nodes.map(node => node.element);\n    }\n    return [...this.elements];\n  }\n  getNodes() {\n    return this.nodes;\n  }\n  has(node) {\n    return this.nodeSet.has(node);\n  }\n  onDidModelSplice(_ref) {\n    let {\n      insertedNodes,\n      deletedNodes\n    } = _ref;\n    if (!this.identityProvider) {\n      const set = this.createNodeSet();\n      const visit = node => set.delete(node);\n      deletedNodes.forEach(node => dfs(node, visit));\n      this.set([...set.values()]);\n      return;\n    }\n    const deletedNodesIdSet = new Set();\n    const deletedNodesVisitor = node => deletedNodesIdSet.add(this.identityProvider.getId(node.element).toString());\n    deletedNodes.forEach(node => dfs(node, deletedNodesVisitor));\n    const insertedNodesMap = new Map();\n    const insertedNodesVisitor = node => insertedNodesMap.set(this.identityProvider.getId(node.element).toString(), node);\n    insertedNodes.forEach(node => dfs(node, insertedNodesVisitor));\n    const nodes = [];\n    for (const node of this.nodes) {\n      const id = this.identityProvider.getId(node.element).toString();\n      const wasDeleted = deletedNodesIdSet.has(id);\n      if (!wasDeleted) {\n        nodes.push(node);\n      } else {\n        const insertedNode = insertedNodesMap.get(id);\n        if (insertedNode && insertedNode.visible) {\n          nodes.push(insertedNode);\n        }\n      }\n    }\n    if (this.nodes.length > 0 && nodes.length === 0) {\n      const node = this.getFirstViewElementWithTrait();\n      if (node) {\n        nodes.push(node);\n      }\n    }\n    this._set(nodes, true);\n  }\n  createNodeSet() {\n    const set = new Set();\n    for (const node of this.nodes) {\n      set.add(node);\n    }\n    return set;\n  }\n}\nclass TreeNodeListMouseController extends MouseController {\n  constructor(list, tree, stickyScrollProvider) {\n    super(list);\n    this.tree = tree;\n    this.stickyScrollProvider = stickyScrollProvider;\n  }\n  onViewPointer(e) {\n    if (isButton(e.browserEvent.target) || isInputElement(e.browserEvent.target) || isMonacoEditor(e.browserEvent.target)) {\n      return;\n    }\n    if (e.browserEvent.isHandledByList) {\n      return;\n    }\n    const node = e.element;\n    if (!node) {\n      return super.onViewPointer(e);\n    }\n    if (this.isSelectionRangeChangeEvent(e) || this.isSelectionSingleChangeEvent(e)) {\n      return super.onViewPointer(e);\n    }\n    const target = e.browserEvent.target;\n    const onTwistie = target.classList.contains('monaco-tl-twistie') || target.classList.contains('monaco-icon-label') && target.classList.contains('folder-icon') && e.browserEvent.offsetX < 16;\n    const isStickyElement = isStickyScrollElement(e.browserEvent.target);\n    let expandOnlyOnTwistieClick = false;\n    if (isStickyElement) {\n      expandOnlyOnTwistieClick = true;\n    } else if (typeof this.tree.expandOnlyOnTwistieClick === 'function') {\n      expandOnlyOnTwistieClick = this.tree.expandOnlyOnTwistieClick(node.element);\n    } else {\n      expandOnlyOnTwistieClick = !!this.tree.expandOnlyOnTwistieClick;\n    }\n    if (!isStickyElement) {\n      if (expandOnlyOnTwistieClick && !onTwistie && e.browserEvent.detail !== 2) {\n        return super.onViewPointer(e);\n      }\n      if (!this.tree.expandOnDoubleClick && e.browserEvent.detail === 2) {\n        return super.onViewPointer(e);\n      }\n    } else {\n      this.handleStickyScrollMouseEvent(e, node);\n    }\n    if (node.collapsible && (!isStickyElement || onTwistie)) {\n      const location = this.tree.getNodeLocation(node);\n      const recursive = e.browserEvent.altKey;\n      this.tree.setFocus([location]);\n      this.tree.toggleCollapsed(location, recursive);\n      if (onTwistie) {\n        // Do not set this before calling a handler on the super class, because it will reject it as handled\n        e.browserEvent.isHandledByList = true;\n        return;\n      }\n    }\n    if (!isStickyElement) {\n      super.onViewPointer(e);\n    }\n  }\n  handleStickyScrollMouseEvent(e, node) {\n    if (isMonacoCustomToggle(e.browserEvent.target) || isActionItem(e.browserEvent.target)) {\n      return;\n    }\n    const stickyScrollController = this.stickyScrollProvider();\n    if (!stickyScrollController) {\n      throw new Error('Sticky scroll controller not found');\n    }\n    const nodeIndex = this.list.indexOf(node);\n    const elementScrollTop = this.list.getElementTop(nodeIndex);\n    const elementTargetViewTop = stickyScrollController.nodePositionTopBelowWidget(node);\n    this.tree.scrollTop = elementScrollTop - elementTargetViewTop;\n    this.list.domFocus();\n    this.list.setFocus([nodeIndex]);\n    this.list.setSelection([nodeIndex]);\n  }\n  onDoubleClick(e) {\n    const onTwistie = e.browserEvent.target.classList.contains('monaco-tl-twistie');\n    if (onTwistie || !this.tree.expandOnDoubleClick) {\n      return;\n    }\n    if (e.browserEvent.isHandledByList) {\n      return;\n    }\n    super.onDoubleClick(e);\n  }\n  // to make sure dom focus is not stolen (for example with context menu)\n  onMouseDown(e) {\n    const target = e.browserEvent.target;\n    if (!isStickyScrollContainer(target) && !isStickyScrollElement(target)) {\n      super.onMouseDown(e);\n      return;\n    }\n  }\n  onContextMenu(e) {\n    const target = e.browserEvent.target;\n    if (!isStickyScrollContainer(target) && !isStickyScrollElement(target)) {\n      super.onContextMenu(e);\n      return;\n    }\n  }\n}\n/**\n * We use this List subclass to restore selection and focus as nodes\n * get rendered in the list, possibly due to a node expand() call.\n */\nclass TreeNodeList extends List {\n  constructor(user, container, virtualDelegate, renderers, focusTrait, selectionTrait, anchorTrait, options) {\n    super(user, container, virtualDelegate, renderers, options);\n    this.focusTrait = focusTrait;\n    this.selectionTrait = selectionTrait;\n    this.anchorTrait = anchorTrait;\n  }\n  createMouseController(options) {\n    return new TreeNodeListMouseController(this, options.tree, options.stickyScrollProvider);\n  }\n  splice(start, deleteCount) {\n    let elements = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    super.splice(start, deleteCount, elements);\n    if (elements.length === 0) {\n      return;\n    }\n    const additionalFocus = [];\n    const additionalSelection = [];\n    let anchor;\n    elements.forEach((node, index) => {\n      if (this.focusTrait.has(node)) {\n        additionalFocus.push(start + index);\n      }\n      if (this.selectionTrait.has(node)) {\n        additionalSelection.push(start + index);\n      }\n      if (this.anchorTrait.has(node)) {\n        anchor = start + index;\n      }\n    });\n    if (additionalFocus.length > 0) {\n      super.setFocus(distinct([...super.getFocus(), ...additionalFocus]));\n    }\n    if (additionalSelection.length > 0) {\n      super.setSelection(distinct([...super.getSelection(), ...additionalSelection]));\n    }\n    if (typeof anchor === 'number') {\n      super.setAnchor(anchor);\n    }\n  }\n  setFocus(indexes, browserEvent) {\n    let fromAPI = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    super.setFocus(indexes, browserEvent);\n    if (!fromAPI) {\n      this.focusTrait.set(indexes.map(i => this.element(i)), browserEvent);\n    }\n  }\n  setSelection(indexes, browserEvent) {\n    let fromAPI = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    super.setSelection(indexes, browserEvent);\n    if (!fromAPI) {\n      this.selectionTrait.set(indexes.map(i => this.element(i)), browserEvent);\n    }\n  }\n  setAnchor(index) {\n    let fromAPI = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super.setAnchor(index);\n    if (!fromAPI) {\n      if (typeof index === 'undefined') {\n        this.anchorTrait.set([]);\n      } else {\n        this.anchorTrait.set([this.element(index)]);\n      }\n    }\n  }\n}\nexport class AbstractTree {\n  get onDidScroll() {\n    return this.view.onDidScroll;\n  }\n  get onDidChangeFocus() {\n    return this.eventBufferer.wrapEvent(this.focus.onDidChange);\n  }\n  get onDidChangeSelection() {\n    return this.eventBufferer.wrapEvent(this.selection.onDidChange);\n  }\n  get onMouseDblClick() {\n    return Event.filter(Event.map(this.view.onMouseDblClick, asTreeMouseEvent), e => e.target !== TreeMouseEventTarget.Filter);\n  }\n  get onMouseOver() {\n    return Event.map(this.view.onMouseOver, asTreeMouseEvent);\n  }\n  get onMouseOut() {\n    return Event.map(this.view.onMouseOut, asTreeMouseEvent);\n  }\n  get onContextMenu() {\n    var _this$stickyScrollCon, _this$stickyScrollCon2;\n    return Event.any(Event.filter(Event.map(this.view.onContextMenu, asTreeContextMenuEvent), e => !e.isStickyScroll), (_this$stickyScrollCon = (_this$stickyScrollCon2 = this.stickyScrollController) === null || _this$stickyScrollCon2 === void 0 ? void 0 : _this$stickyScrollCon2.onContextMenu) !== null && _this$stickyScrollCon !== void 0 ? _this$stickyScrollCon : Event.None);\n  }\n  get onPointer() {\n    return Event.map(this.view.onPointer, asTreeMouseEvent);\n  }\n  get onKeyDown() {\n    return this.view.onKeyDown;\n  }\n  get onDidFocus() {\n    return this.view.onDidFocus;\n  }\n  get onDidChangeModel() {\n    return Event.signal(this.model.onDidSplice);\n  }\n  get onDidChangeCollapseState() {\n    return this.model.onDidChangeCollapseState;\n  }\n  get findMode() {\n    var _this$findController$, _this$findController;\n    return (_this$findController$ = (_this$findController = this.findController) === null || _this$findController === void 0 ? void 0 : _this$findController.mode) !== null && _this$findController$ !== void 0 ? _this$findController$ : TreeFindMode.Highlight;\n  }\n  set findMode(findMode) {\n    if (this.findController) {\n      this.findController.mode = findMode;\n    }\n  }\n  get findMatchType() {\n    var _this$findController$2, _this$findController2;\n    return (_this$findController$2 = (_this$findController2 = this.findController) === null || _this$findController2 === void 0 ? void 0 : _this$findController2.matchType) !== null && _this$findController$2 !== void 0 ? _this$findController$2 : TreeFindMatchType.Fuzzy;\n  }\n  set findMatchType(findFuzzy) {\n    if (this.findController) {\n      this.findController.matchType = findFuzzy;\n    }\n  }\n  get expandOnDoubleClick() {\n    return typeof this._options.expandOnDoubleClick === 'undefined' ? true : this._options.expandOnDoubleClick;\n  }\n  get expandOnlyOnTwistieClick() {\n    return typeof this._options.expandOnlyOnTwistieClick === 'undefined' ? true : this._options.expandOnlyOnTwistieClick;\n  }\n  get onDidDispose() {\n    return this.view.onDidDispose;\n  }\n  constructor(_user, container, delegate, renderers) {\n    var _options$findWidgetEn;\n    let _options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    this._user = _user;\n    this._options = _options;\n    this.eventBufferer = new EventBufferer();\n    this.onDidChangeFindOpenState = Event.None;\n    this.onDidChangeStickyScrollFocused = Event.None;\n    this.disposables = new DisposableStore();\n    this._onWillRefilter = new Emitter();\n    this.onWillRefilter = this._onWillRefilter.event;\n    this._onDidUpdateOptions = new Emitter();\n    this.treeDelegate = new ComposedTreeDelegate(delegate);\n    const onDidChangeCollapseStateRelay = new Relay();\n    const onDidChangeActiveNodes = new Relay();\n    const activeNodes = this.disposables.add(new EventCollection(onDidChangeActiveNodes.event));\n    const renderedIndentGuides = new SetMap();\n    this.renderers = renderers.map(r => new TreeRenderer(r, () => this.model, onDidChangeCollapseStateRelay.event, activeNodes, renderedIndentGuides, _options));\n    for (const r of this.renderers) {\n      this.disposables.add(r);\n    }\n    let filter;\n    if (_options.keyboardNavigationLabelProvider) {\n      filter = new FindFilter(this, _options.keyboardNavigationLabelProvider, _options.filter);\n      _options = {\n        ..._options,\n        filter: filter\n      }; // TODO need typescript help here\n      this.disposables.add(filter);\n    }\n    this.focus = new Trait(() => this.view.getFocusedElements()[0], _options.identityProvider);\n    this.selection = new Trait(() => this.view.getSelectedElements()[0], _options.identityProvider);\n    this.anchor = new Trait(() => this.view.getAnchorElement(), _options.identityProvider);\n    this.view = new TreeNodeList(_user, container, this.treeDelegate, this.renderers, this.focus, this.selection, this.anchor, {\n      ...asListOptions(() => this.model, _options),\n      tree: this,\n      stickyScrollProvider: () => this.stickyScrollController\n    });\n    this.model = this.createModel(_user, this.view, _options);\n    onDidChangeCollapseStateRelay.input = this.model.onDidChangeCollapseState;\n    const onDidModelSplice = Event.forEach(this.model.onDidSplice, e => {\n      this.eventBufferer.bufferEvents(() => {\n        this.focus.onDidModelSplice(e);\n        this.selection.onDidModelSplice(e);\n      });\n    }, this.disposables);\n    // Make sure the `forEach` always runs\n    onDidModelSplice(() => null, null, this.disposables);\n    // Active nodes can change when the model changes or when focus or selection change.\n    // We debounce it with 0 delay since these events may fire in the same stack and we only\n    // want to run this once. It also doesn't matter if it runs on the next tick since it's only\n    // a nice to have UI feature.\n    const activeNodesEmitter = this.disposables.add(new Emitter());\n    const activeNodesDebounce = this.disposables.add(new Delayer(0));\n    this.disposables.add(Event.any(onDidModelSplice, this.focus.onDidChange, this.selection.onDidChange)(() => {\n      activeNodesDebounce.trigger(() => {\n        const set = new Set();\n        for (const node of this.focus.getNodes()) {\n          set.add(node);\n        }\n        for (const node of this.selection.getNodes()) {\n          set.add(node);\n        }\n        activeNodesEmitter.fire([...set.values()]);\n      });\n    }));\n    onDidChangeActiveNodes.input = activeNodesEmitter.event;\n    if (_options.keyboardSupport !== false) {\n      const onKeyDown = Event.chain(this.view.onKeyDown, $ => $.filter(e => !isInputElement(e.target)).map(e => new StandardKeyboardEvent(e)));\n      Event.chain(onKeyDown, $ => $.filter(e => e.keyCode === 15 /* KeyCode.LeftArrow */))(this.onLeftArrow, this, this.disposables);\n      Event.chain(onKeyDown, $ => $.filter(e => e.keyCode === 17 /* KeyCode.RightArrow */))(this.onRightArrow, this, this.disposables);\n      Event.chain(onKeyDown, $ => $.filter(e => e.keyCode === 10 /* KeyCode.Space */))(this.onSpace, this, this.disposables);\n    }\n    if (((_options$findWidgetEn = _options.findWidgetEnabled) !== null && _options$findWidgetEn !== void 0 ? _options$findWidgetEn : true) && _options.keyboardNavigationLabelProvider && _options.contextViewProvider) {\n      const opts = this.options.findWidgetStyles ? {\n        styles: this.options.findWidgetStyles\n      } : undefined;\n      this.findController = new FindController(this, this.model, this.view, filter, _options.contextViewProvider, opts);\n      this.focusNavigationFilter = node => this.findController.shouldAllowFocus(node);\n      this.onDidChangeFindOpenState = this.findController.onDidChangeOpenState;\n      this.disposables.add(this.findController);\n      this.onDidChangeFindMode = this.findController.onDidChangeMode;\n      this.onDidChangeFindMatchType = this.findController.onDidChangeMatchType;\n    } else {\n      this.onDidChangeFindMode = Event.None;\n      this.onDidChangeFindMatchType = Event.None;\n    }\n    if (_options.enableStickyScroll) {\n      this.stickyScrollController = new StickyScrollController(this, this.model, this.view, this.renderers, this.treeDelegate, _options);\n      this.onDidChangeStickyScrollFocused = this.stickyScrollController.onDidChangeHasFocus;\n    }\n    this.styleElement = createStyleSheet(this.view.getHTMLElement());\n    this.getHTMLElement().classList.toggle('always', this._options.renderIndentGuides === RenderIndentGuides.Always);\n  }\n  updateOptions() {\n    var _this$findController3;\n    let optionsUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._options = {\n      ...this._options,\n      ...optionsUpdate\n    };\n    for (const renderer of this.renderers) {\n      renderer.updateOptions(optionsUpdate);\n    }\n    this.view.updateOptions(this._options);\n    (_this$findController3 = this.findController) === null || _this$findController3 === void 0 || _this$findController3.updateOptions(optionsUpdate);\n    this.updateStickyScroll(optionsUpdate);\n    this._onDidUpdateOptions.fire(this._options);\n    this.getHTMLElement().classList.toggle('always', this._options.renderIndentGuides === RenderIndentGuides.Always);\n  }\n  get options() {\n    return this._options;\n  }\n  updateStickyScroll(optionsUpdate) {\n    var _this$stickyScrollCon3;\n    if (!this.stickyScrollController && this._options.enableStickyScroll) {\n      this.stickyScrollController = new StickyScrollController(this, this.model, this.view, this.renderers, this.treeDelegate, this._options);\n      this.onDidChangeStickyScrollFocused = this.stickyScrollController.onDidChangeHasFocus;\n    } else if (this.stickyScrollController && !this._options.enableStickyScroll) {\n      this.onDidChangeStickyScrollFocused = Event.None;\n      this.stickyScrollController.dispose();\n      this.stickyScrollController = undefined;\n    }\n    (_this$stickyScrollCon3 = this.stickyScrollController) === null || _this$stickyScrollCon3 === void 0 || _this$stickyScrollCon3.updateOptions(optionsUpdate);\n  }\n  // Widget\n  getHTMLElement() {\n    return this.view.getHTMLElement();\n  }\n  get scrollTop() {\n    return this.view.scrollTop;\n  }\n  set scrollTop(scrollTop) {\n    this.view.scrollTop = scrollTop;\n  }\n  get scrollHeight() {\n    return this.view.scrollHeight;\n  }\n  get renderHeight() {\n    return this.view.renderHeight;\n  }\n  get ariaLabel() {\n    return this.view.ariaLabel;\n  }\n  set ariaLabel(value) {\n    this.view.ariaLabel = value;\n  }\n  domFocus() {\n    var _this$stickyScrollCon4;\n    if ((_this$stickyScrollCon4 = this.stickyScrollController) !== null && _this$stickyScrollCon4 !== void 0 && _this$stickyScrollCon4.focusedLast()) {\n      this.stickyScrollController.domFocus();\n    } else {\n      this.view.domFocus();\n    }\n  }\n  layout(height, width) {\n    this.view.layout(height, width);\n    if (isNumber(width)) {\n      var _this$findController4;\n      (_this$findController4 = this.findController) === null || _this$findController4 === void 0 || _this$findController4.layout(width);\n    }\n  }\n  style(styles) {\n    var _styles$treeStickyScr, _styles$listFocusOutl;\n    const suffix = \".\".concat(this.view.domId);\n    const content = [];\n    if (styles.treeIndentGuidesStroke) {\n      content.push(\".monaco-list\".concat(suffix, \":hover .monaco-tl-indent > .indent-guide, .monaco-list\").concat(suffix, \".always .monaco-tl-indent > .indent-guide  { border-color: \").concat(styles.treeInactiveIndentGuidesStroke, \"; }\"));\n      content.push(\".monaco-list\".concat(suffix, \" .monaco-tl-indent > .indent-guide.active { border-color: \").concat(styles.treeIndentGuidesStroke, \"; }\"));\n    }\n    // Sticky Scroll Background\n    const stickyScrollBackground = (_styles$treeStickyScr = styles.treeStickyScrollBackground) !== null && _styles$treeStickyScr !== void 0 ? _styles$treeStickyScr : styles.listBackground;\n    if (stickyScrollBackground) {\n      content.push(\".monaco-list\".concat(suffix, \" .monaco-scrollable-element .monaco-tree-sticky-container { background-color: \").concat(stickyScrollBackground, \"; }\"));\n      content.push(\".monaco-list\".concat(suffix, \" .monaco-scrollable-element .monaco-tree-sticky-container .monaco-tree-sticky-row { background-color: \").concat(stickyScrollBackground, \"; }\"));\n    }\n    // Sticky Scroll Border\n    if (styles.treeStickyScrollBorder) {\n      content.push(\".monaco-list\".concat(suffix, \" .monaco-scrollable-element .monaco-tree-sticky-container { border-bottom: 1px solid \").concat(styles.treeStickyScrollBorder, \"; }\"));\n    }\n    // Sticky Scroll Shadow\n    if (styles.treeStickyScrollShadow) {\n      content.push(\".monaco-list\".concat(suffix, \" .monaco-scrollable-element .monaco-tree-sticky-container .monaco-tree-sticky-container-shadow { box-shadow: \").concat(styles.treeStickyScrollShadow, \" 0 6px 6px -6px inset; height: 3px; }\"));\n    }\n    // Sticky Scroll Focus\n    if (styles.listFocusForeground) {\n      content.push(\".monaco-list\".concat(suffix, \".sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused { color: \").concat(styles.listFocusForeground, \"; }\"));\n      content.push(\".monaco-list\".concat(suffix, \":not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused { color: inherit; }\"));\n    }\n    // Sticky Scroll Focus Outlines\n    const focusAndSelectionOutline = asCssValueWithDefault(styles.listFocusAndSelectionOutline, asCssValueWithDefault(styles.listSelectionOutline, (_styles$listFocusOutl = styles.listFocusOutline) !== null && _styles$listFocusOutl !== void 0 ? _styles$listFocusOutl : ''));\n    if (focusAndSelectionOutline) {\n      // default: listFocusOutline\n      content.push(\".monaco-list\".concat(suffix, \".sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused.selected { outline: 1px solid \").concat(focusAndSelectionOutline, \"; outline-offset: -1px;}\"));\n      content.push(\".monaco-list\".concat(suffix, \":not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused.selected { outline: inherit;}\"));\n    }\n    if (styles.listFocusOutline) {\n      // default: set\n      content.push(\".monaco-list\".concat(suffix, \".sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused { outline: 1px solid \").concat(styles.listFocusOutline, \"; outline-offset: -1px; }\"));\n      content.push(\".monaco-list\".concat(suffix, \":not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused { outline: inherit; }\"));\n      content.push(\".monaco-workbench.context-menu-visible .monaco-list\".concat(suffix, \".last-focused.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.passive-focused { outline: 1px solid \").concat(styles.listFocusOutline, \"; outline-offset: -1px; }\"));\n      content.push(\".monaco-workbench.context-menu-visible .monaco-list\".concat(suffix, \".last-focused.sticky-scroll-focused .monaco-list-rows .monaco-list-row.focused { outline: inherit; }\"));\n      content.push(\".monaco-workbench.context-menu-visible .monaco-list\".concat(suffix, \".last-focused:not(.sticky-scroll-focused) .monaco-tree-sticky-container .monaco-list-rows .monaco-list-row.focused { outline: inherit; }\"));\n    }\n    this.styleElement.textContent = content.join('\\n');\n    this.view.style(styles);\n  }\n  // Tree navigation\n  getParentElement(location) {\n    const parentRef = this.model.getParentNodeLocation(location);\n    const parentNode = this.model.getNode(parentRef);\n    return parentNode.element;\n  }\n  getFirstElementChild(location) {\n    return this.model.getFirstElementChild(location);\n  }\n  // Tree\n  getNode(location) {\n    return this.model.getNode(location);\n  }\n  getNodeLocation(node) {\n    return this.model.getNodeLocation(node);\n  }\n  collapse(location) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return this.model.setCollapsed(location, true, recursive);\n  }\n  expand(location) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return this.model.setCollapsed(location, false, recursive);\n  }\n  toggleCollapsed(location) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return this.model.setCollapsed(location, undefined, recursive);\n  }\n  isCollapsible(location) {\n    return this.model.isCollapsible(location);\n  }\n  setCollapsible(location, collapsible) {\n    return this.model.setCollapsible(location, collapsible);\n  }\n  isCollapsed(location) {\n    return this.model.isCollapsed(location);\n  }\n  refilter() {\n    this._onWillRefilter.fire(undefined);\n    this.model.refilter();\n  }\n  setSelection(elements, browserEvent) {\n    this.eventBufferer.bufferEvents(() => {\n      const nodes = elements.map(e => this.model.getNode(e));\n      this.selection.set(nodes, browserEvent);\n      const indexes = elements.map(e => this.model.getListIndex(e)).filter(i => i > -1);\n      this.view.setSelection(indexes, browserEvent, true);\n    });\n  }\n  getSelection() {\n    return this.selection.get();\n  }\n  setFocus(elements, browserEvent) {\n    this.eventBufferer.bufferEvents(() => {\n      const nodes = elements.map(e => this.model.getNode(e));\n      this.focus.set(nodes, browserEvent);\n      const indexes = elements.map(e => this.model.getListIndex(e)).filter(i => i > -1);\n      this.view.setFocus(indexes, browserEvent, true);\n    });\n  }\n  focusNext() {\n    let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let loop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let browserEvent = arguments.length > 2 ? arguments[2] : undefined;\n    let filter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : isKeyboardEvent(browserEvent) && browserEvent.altKey ? undefined : this.focusNavigationFilter;\n    this.view.focusNext(n, loop, browserEvent, filter);\n  }\n  focusPrevious() {\n    let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let loop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let browserEvent = arguments.length > 2 ? arguments[2] : undefined;\n    let filter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : isKeyboardEvent(browserEvent) && browserEvent.altKey ? undefined : this.focusNavigationFilter;\n    this.view.focusPrevious(n, loop, browserEvent, filter);\n  }\n  focusNextPage(browserEvent) {\n    let filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : isKeyboardEvent(browserEvent) && browserEvent.altKey ? undefined : this.focusNavigationFilter;\n    return this.view.focusNextPage(browserEvent, filter);\n  }\n  focusPreviousPage(browserEvent) {\n    let filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : isKeyboardEvent(browserEvent) && browserEvent.altKey ? undefined : this.focusNavigationFilter;\n    return this.view.focusPreviousPage(browserEvent, filter, () => {\n      var _this$stickyScrollCon5, _this$stickyScrollCon6;\n      return (_this$stickyScrollCon5 = (_this$stickyScrollCon6 = this.stickyScrollController) === null || _this$stickyScrollCon6 === void 0 ? void 0 : _this$stickyScrollCon6.height) !== null && _this$stickyScrollCon5 !== void 0 ? _this$stickyScrollCon5 : 0;\n    });\n  }\n  focusLast(browserEvent) {\n    let filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : isKeyboardEvent(browserEvent) && browserEvent.altKey ? undefined : this.focusNavigationFilter;\n    this.view.focusLast(browserEvent, filter);\n  }\n  focusFirst(browserEvent) {\n    let filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : isKeyboardEvent(browserEvent) && browserEvent.altKey ? undefined : this.focusNavigationFilter;\n    this.view.focusFirst(browserEvent, filter);\n  }\n  getFocus() {\n    return this.focus.get();\n  }\n  reveal(location, relativeTop) {\n    this.model.expandTo(location);\n    const index = this.model.getListIndex(location);\n    if (index === -1) {\n      return;\n    }\n    if (!this.stickyScrollController) {\n      this.view.reveal(index, relativeTop);\n    } else {\n      const paddingTop = this.stickyScrollController.nodePositionTopBelowWidget(this.getNode(location));\n      this.view.reveal(index, relativeTop, paddingTop);\n    }\n  }\n  // List\n  onLeftArrow(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    const nodes = this.view.getFocusedElements();\n    if (nodes.length === 0) {\n      return;\n    }\n    const node = nodes[0];\n    const location = this.model.getNodeLocation(node);\n    const didChange = this.model.setCollapsed(location, true);\n    if (!didChange) {\n      const parentLocation = this.model.getParentNodeLocation(location);\n      if (!parentLocation) {\n        return;\n      }\n      const parentListIndex = this.model.getListIndex(parentLocation);\n      this.view.reveal(parentListIndex);\n      this.view.setFocus([parentListIndex]);\n    }\n  }\n  onRightArrow(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    const nodes = this.view.getFocusedElements();\n    if (nodes.length === 0) {\n      return;\n    }\n    const node = nodes[0];\n    const location = this.model.getNodeLocation(node);\n    const didChange = this.model.setCollapsed(location, false);\n    if (!didChange) {\n      if (!node.children.some(child => child.visible)) {\n        return;\n      }\n      const [focusedIndex] = this.view.getFocus();\n      const firstChildIndex = focusedIndex + 1;\n      this.view.reveal(firstChildIndex);\n      this.view.setFocus([firstChildIndex]);\n    }\n  }\n  onSpace(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    const nodes = this.view.getFocusedElements();\n    if (nodes.length === 0) {\n      return;\n    }\n    const node = nodes[0];\n    const location = this.model.getNodeLocation(node);\n    const recursive = e.browserEvent.altKey;\n    this.model.setCollapsed(location, undefined, recursive);\n  }\n  dispose() {\n    var _this$stickyScrollCon7;\n    dispose(this.disposables);\n    (_this$stickyScrollCon7 = this.stickyScrollController) === null || _this$stickyScrollCon7 === void 0 || _this$stickyScrollCon7.dispose();\n    this.view.dispose();\n  }\n}","map":{"version":3,"names":["$","append","clearNode","createStyleSheet","getWindow","h","hasParentWithClass","asCssValueWithDefault","isKeyboardEvent","addDisposableListener","DomEmitter","StandardKeyboardEvent","ActionBar","FindInput","unthemedInboxStyles","ElementsDragAndDropData","isActionItem","isButton","isInputElement","isMonacoCustomToggle","isMonacoEditor","isStickyScrollContainer","isStickyScrollElement","List","MouseController","Toggle","unthemedToggleStyles","getVisibleState","isFilterResult","TreeMouseEventTarget","Action","distinct","equals","range","Delayer","disposableTimeout","timeout","Codicon","ThemeIcon","SetMap","Emitter","Event","EventBufferer","Relay","fuzzyScore","FuzzyScore","Disposable","DisposableStore","dispose","toDisposable","clamp","isNumber","localize","createInstantHoverDelegate","getDefaultHoverDelegate","autorun","constObservable","alert","TreeElementsDragAndDropData","constructor","data","elements","map","node","element","asTreeDragAndDropData","TreeNodeListDragAndDrop","modelProvider","dnd","autoExpandDisposable","None","disposables","getDragURI","getDragLabel","nodes","originalEvent","undefined","onDragStart","_this$dnd$onDragStart","_this$dnd","call","onDragOver","targetNode","targetIndex","targetSector","raw","arguments","length","result","didChangeAutoExpandNode","autoExpandNode","autoExpand","model","ref","getNodeLocation","isCollapsed","setCollapsed","accept","bubble","feedback","effect","parentRef","getParentNodeLocation","parentNode","getNode","parentIndex","getListIndex","start","getListRenderCount","drop","onDragEnd","_this$dnd$onDragEnd","_this$dnd2","asListOptions","options","identityProvider","getId","el","multipleSelectionController","isSelectionSingleChangeEvent","e","isSelectionRangeChangeEvent","accessibilityProvider","getSetSize","visibleChildrenCount","getPosInSet","visibleChildIndex","isChecked","getRole","getAriaLabel","getWidgetAriaLabel","getWidgetRole","getAriaLevel","depth","getActiveDescendantId","keyboardNavigationLabelProvider","getKeyboardNavigationLabel","ComposedTreeDelegate","delegate","getHeight","getTemplateId","hasDynamicHeight","setDynamicHeight","height","_this$delegate$setDyn","_this$delegate","RenderIndentGuides","EventCollection","_elements","onDidChange","forEach","TreeRenderer","renderer","onDidChangeCollapseState","activeNodes","renderedIndentGuides","_renderer$onDidChange","renderedElements","Map","renderedNodes","indent","DefaultIndent","hideTwistiesOfChildlessElements","shouldRenderIndentGuides","activeIndentNodes","Set","indentGuidesDisposable","templateId","updateOptions","onDidChangeNodeTwistieState","onDidChangeTwistieState","templateData","renderTreeElement","renderIndentGuides","_renderIndentGuides","_onDidChangeActiveNodes","renderTemplate","container","twistie","contents","renderElement","index","set","disposeElement","_this$renderer$dispos","_this$renderer","delete","disposeTemplate","get","style","paddingLeft","concat","width","collapsible","setAttribute","String","collapsed","removeAttribute","classList","remove","asClassNameArray","treeItemExpanded","twistieRendered","renderTwistie","add","toggle","disposableStore","parent","guide","has","childElementCount","appendChild","insertBefore","firstElementChild","children","line","clear","_TreeRenderer","FindFilter","totalCount","_totalCount","matchCount","_matchCount","tree","_filter","_pattern","_lowercasePattern","onWillRefilter","reset","filter","parentVisibility","visibility","Default","label","labels","Array","isArray","l","labelStr","toString","score","findMatchType","TreeFindMatchType","Contiguous","toLowerCase","indexOf","Number","MAX_SAFE_INTEGER","i","push","firstMatchCanBeWeak","boostFullMatch","findMode","TreeFindMode","Filter","defaultFindVisibility","ModeToggle","opts","_opts$isChecked","_opts$hoverDelegate","icon","listFilter","title","hoverDelegate","inputActiveOptionBorder","inputActiveOptionForeground","inputActiveOptionBackground","FuzzyToggle","_opts$isChecked2","_opts$hoverDelegate2","searchFuzzy","unthemedFindWidgetStyles","inputBoxStyles","toggleStyles","listFilterWidgetBackground","listFilterWidgetNoMatchesOutline","listFilterWidgetOutline","listFilterWidgetShadow","FindWidget","mode","modeToggle","checked","findInput","inputBox","setPlaceHolder","matchType","matchTypeToggle","Fuzzy","contextViewProvider","_options$styles","tabIndex","right","top","_onDidDisable","root","_register","styles","backgroundColor","boxShadow","toggleHoverDelegate","onDidChangeMode","onChange","Highlight","_store","onDidChangeMatchType","additionalToggles","showCommonFindToggles","history","actionbar","emitter","inputElement","onKeyDown","chain","event","preventDefault","stopPropagation","addToHistory","domFocus","isAtLastInHistory","isNowhereInHistory","showNextValue","showPreviousValue","closeAction","onGrabMouseDown","grab","onWindowMouseMove","onWindowMouseUp","startRight","startX","pageX","startTop","startY","pageY","transition","update","deltaX","deltaY","layout","onGrabKeyDown","keyCode","POSITIVE_INFINITY","setTimeout","onDidChangeValue","Math","max","showMessage","message","clearMessage","fire","FindController","pattern","_mode","widget","refilter","render","_onDidChangeMode","_matchType","_onDidChangeMatchType","view","_tree$options$default","_tree$options$default2","_onDidChangePattern","_onDidChangeOpenState","onDidChangeOpenState","enabledDisposables","defaultFindMode","defaultFindMatchType","onDidSplice","onDidSpliceModel","optionsUpdate","noMatches","_this$tree$options$sh","showNotFoundMessage","_this$widget","type","content","_this$widget2","_this$widget3","shouldAllowFocus","isDefault","filterData","_this$widget4","_history","stickyScrollNodeStateEquals","node1","node2","position","stickyScrollNodeEquals","startIndex","endIndex","StickyScrollState","stickyNodes","count","equal","state","lastNodePartiallyVisible","lastStickyNode","secondLastStickyNode","animationStateChanged","previousState","previousLastStickyNode","DefaultStickyScrollDelegate","constrainStickyScrollNodes","stickyScrollMaxItemCount","maxWidgetHeight","stickyNode","stickyNodeBottom","slice","StickyScrollController","renderers","treeDelegate","_options$stickyScroll","maxWidgetViewRatio","stickyScrollOptions","validateStickySettings","stickyScrollDelegate","_widget","StickyScrollWidget","getScrollableElement","onDidChangeHasFocus","onContextMenu","onDidScroll","onDidChangeContentHeight","getNodeAtHeight","firstVisibleIndex","indexAt","scrollTop","firstVisibleNode","setState","stickyState","findStickyState","firstVisibleNodeUnderWidget","stickyNodesHeight","nextStickyNode","getNextStickyNode","getNextVisibleNode","contrainedStickyNodes","constrainStickyNodes","previousStickyNode","getAncestorUnderPrevious","nodeIsUncollapsedParent","nodeTopAlignsWithStickyNodesBottom","createStickyScrollNode","nodeIndex","getNodeIndex","elementTop","getElementTop","stickyPosition","currentStickyNodesHeight","getNodeRange","calculateStickyNodePosition","previousAncestor","currentAncestor","parentOfcurrentAncestor","getParentNode","lastDescendantIndex","stickyRowPositionTop","stickyNodeHeight","lastChildRelativeTop","getRelativeTop","nodeHeight","nextNodeRelativeTop","renderHeight","lastChildNode","lastChildHeight","topOfLastChild","bottomOfLastChild","maximumStickyWidgetHeight","constrainedStickyNodes","lastConstrainedStickyNode","Error","nodeLocation","parentLocation","renderCount","nodePositionTopBelowWidget","ancestors","widgetHeight","focusedLast","validatedOptions","treeRenderers","_previousElements","_previousStateDisposables","_rootDomNode","shadow","stickyScrollFocus","StickyScrollFocus","_previousState","lastElement","wasVisible","isVisible","setVisible","stickyIndex","disposable","createElement","updateElements","stickyNodesTotal","stickyElement","document","setRowHeight","setRowLineHeight","lineHeight","getElementID","accessibilityDisposable","setAccessibilityAttributes","nodeTemplateId","find","nodeCopy","Proxy","_this$accessibilityPr","ariaLabel","observable","reader","value","readObservable","ariaLevel","visible","domHasFocus","_domHasFocus","hasFocus","_onDidChangeHasFocus","focusedIndex","_onContextMenu","onFocus","onBlur","onDidFocus","toggleStickyScrollFocused","onMouseDown","handleContextMenu","target","browserEvent","findIndex","_e$element","focus","setFocus","anchor","isStickyScroll","key","setFocusedElement","nodeIndexToFocus","scrollNodeUnderWidget","previousIndex","removeFocus","newFocusedIndex","elementScrollTop","elementTargetViewTop","getHTMLElement","contains","toggleElementFocus","newFocusIndex","oldIndex","focused","toggleElementActiveFocus","toggleElementPassiveFocus","toggleCurrentElementActiveFocus","asTreeMouseEvent","Unknown","Twistie","Element","asTreeContextMenuEvent","dfs","fn","child","Trait","nodeSet","_nodeSet","createNodeSet","getFirstViewElementWithTrait","_onDidChange","__forceEvent","_set","silent","that","getNodes","onDidModelSplice","_ref","insertedNodes","deletedNodes","visit","values","deletedNodesIdSet","deletedNodesVisitor","insertedNodesMap","insertedNodesVisitor","id","wasDeleted","insertedNode","TreeNodeListMouseController","list","stickyScrollProvider","onViewPointer","isHandledByList","onTwistie","offsetX","isStickyElement","expandOnlyOnTwistieClick","detail","expandOnDoubleClick","handleStickyScrollMouseEvent","location","recursive","altKey","toggleCollapsed","stickyScrollController","setSelection","onDoubleClick","TreeNodeList","user","virtualDelegate","focusTrait","selectionTrait","anchorTrait","createMouseController","splice","deleteCount","additionalFocus","additionalSelection","getFocus","getSelection","setAnchor","indexes","fromAPI","AbstractTree","onDidChangeFocus","eventBufferer","wrapEvent","onDidChangeSelection","selection","onMouseDblClick","onMouseOver","onMouseOut","_this$stickyScrollCon","_this$stickyScrollCon2","any","onPointer","onDidChangeModel","signal","_this$findController$","_this$findController","findController","_this$findController$2","_this$findController2","findFuzzy","_options","onDidDispose","_user","_options$findWidgetEn","onDidChangeFindOpenState","onDidChangeStickyScrollFocused","_onWillRefilter","_onDidUpdateOptions","onDidChangeCollapseStateRelay","onDidChangeActiveNodes","r","getFocusedElements","getSelectedElements","getAnchorElement","createModel","input","bufferEvents","activeNodesEmitter","activeNodesDebounce","trigger","keyboardSupport","onLeftArrow","onRightArrow","onSpace","findWidgetEnabled","findWidgetStyles","focusNavigationFilter","onDidChangeFindMode","onDidChangeFindMatchType","enableStickyScroll","styleElement","Always","_this$findController3","updateStickyScroll","_this$stickyScrollCon3","scrollHeight","_this$stickyScrollCon4","_this$findController4","_styles$treeStickyScr","_styles$listFocusOutl","suffix","domId","treeIndentGuidesStroke","treeInactiveIndentGuidesStroke","stickyScrollBackground","treeStickyScrollBackground","listBackground","treeStickyScrollBorder","treeStickyScrollShadow","listFocusForeground","focusAndSelectionOutline","listFocusAndSelectionOutline","listSelectionOutline","listFocusOutline","textContent","join","getParentElement","getFirstElementChild","collapse","expand","isCollapsible","setCollapsible","focusNext","n","loop","focusPrevious","focusNextPage","focusPreviousPage","_this$stickyScrollCon5","_this$stickyScrollCon6","focusLast","focusFirst","reveal","relativeTop","expandTo","paddingTop","didChange","parentListIndex","some","firstChildIndex","_this$stickyScrollCon7"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/base/browser/ui/tree/abstractTree.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { $, append, clearNode, createStyleSheet, getWindow, h, hasParentWithClass, asCssValueWithDefault, isKeyboardEvent, addDisposableListener } from '../../dom.js';\nimport { DomEmitter } from '../../event.js';\nimport { StandardKeyboardEvent } from '../../keyboardEvent.js';\nimport { ActionBar } from '../actionbar/actionbar.js';\nimport { FindInput } from '../findinput/findInput.js';\nimport { unthemedInboxStyles } from '../inputbox/inputBox.js';\nimport { ElementsDragAndDropData } from '../list/listView.js';\nimport { isActionItem, isButton, isInputElement, isMonacoCustomToggle, isMonacoEditor, isStickyScrollContainer, isStickyScrollElement, List, MouseController } from '../list/listWidget.js';\nimport { Toggle, unthemedToggleStyles } from '../toggle/toggle.js';\nimport { getVisibleState, isFilterResult } from './indexTreeModel.js';\nimport { TreeMouseEventTarget } from './tree.js';\nimport { Action } from '../../../common/actions.js';\nimport { distinct, equals, range } from '../../../common/arrays.js';\nimport { Delayer, disposableTimeout, timeout } from '../../../common/async.js';\nimport { Codicon } from '../../../common/codicons.js';\nimport { ThemeIcon } from '../../../common/themables.js';\nimport { SetMap } from '../../../common/map.js';\nimport { Emitter, Event, EventBufferer, Relay } from '../../../common/event.js';\nimport { fuzzyScore, FuzzyScore } from '../../../common/filters.js';\nimport { Disposable, DisposableStore, dispose, toDisposable } from '../../../common/lifecycle.js';\nimport { clamp } from '../../../common/numbers.js';\nimport { isNumber } from '../../../common/types.js';\nimport './media/tree.css';\nimport { localize } from '../../../../nls.js';\nimport { createInstantHoverDelegate, getDefaultHoverDelegate } from '../hover/hoverDelegateFactory.js';\nimport { autorun, constObservable } from '../../../common/observable.js';\nimport { alert } from '../aria/aria.js';\nclass TreeElementsDragAndDropData extends ElementsDragAndDropData {\n    constructor(data) {\n        super(data.elements.map(node => node.element));\n        this.data = data;\n    }\n}\nfunction asTreeDragAndDropData(data) {\n    if (data instanceof ElementsDragAndDropData) {\n        return new TreeElementsDragAndDropData(data);\n    }\n    return data;\n}\nclass TreeNodeListDragAndDrop {\n    constructor(modelProvider, dnd) {\n        this.modelProvider = modelProvider;\n        this.dnd = dnd;\n        this.autoExpandDisposable = Disposable.None;\n        this.disposables = new DisposableStore();\n    }\n    getDragURI(node) {\n        return this.dnd.getDragURI(node.element);\n    }\n    getDragLabel(nodes, originalEvent) {\n        if (this.dnd.getDragLabel) {\n            return this.dnd.getDragLabel(nodes.map(node => node.element), originalEvent);\n        }\n        return undefined;\n    }\n    onDragStart(data, originalEvent) {\n        this.dnd.onDragStart?.(asTreeDragAndDropData(data), originalEvent);\n    }\n    onDragOver(data, targetNode, targetIndex, targetSector, originalEvent, raw = true) {\n        const result = this.dnd.onDragOver(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, targetSector, originalEvent);\n        const didChangeAutoExpandNode = this.autoExpandNode !== targetNode;\n        if (didChangeAutoExpandNode) {\n            this.autoExpandDisposable.dispose();\n            this.autoExpandNode = targetNode;\n        }\n        if (typeof targetNode === 'undefined') {\n            return result;\n        }\n        if (didChangeAutoExpandNode && typeof result !== 'boolean' && result.autoExpand) {\n            this.autoExpandDisposable = disposableTimeout(() => {\n                const model = this.modelProvider();\n                const ref = model.getNodeLocation(targetNode);\n                if (model.isCollapsed(ref)) {\n                    model.setCollapsed(ref, false);\n                }\n                this.autoExpandNode = undefined;\n            }, 500, this.disposables);\n        }\n        if (typeof result === 'boolean' || !result.accept || typeof result.bubble === 'undefined' || result.feedback) {\n            if (!raw) {\n                const accept = typeof result === 'boolean' ? result : result.accept;\n                const effect = typeof result === 'boolean' ? undefined : result.effect;\n                return { accept, effect, feedback: [targetIndex] };\n            }\n            return result;\n        }\n        if (result.bubble === 1 /* TreeDragOverBubble.Up */) {\n            const model = this.modelProvider();\n            const ref = model.getNodeLocation(targetNode);\n            const parentRef = model.getParentNodeLocation(ref);\n            const parentNode = model.getNode(parentRef);\n            const parentIndex = parentRef && model.getListIndex(parentRef);\n            return this.onDragOver(data, parentNode, parentIndex, targetSector, originalEvent, false);\n        }\n        const model = this.modelProvider();\n        const ref = model.getNodeLocation(targetNode);\n        const start = model.getListIndex(ref);\n        const length = model.getListRenderCount(ref);\n        return { ...result, feedback: range(start, start + length) };\n    }\n    drop(data, targetNode, targetIndex, targetSector, originalEvent) {\n        this.autoExpandDisposable.dispose();\n        this.autoExpandNode = undefined;\n        this.dnd.drop(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, targetSector, originalEvent);\n    }\n    onDragEnd(originalEvent) {\n        this.dnd.onDragEnd?.(originalEvent);\n    }\n    dispose() {\n        this.disposables.dispose();\n        this.dnd.dispose();\n    }\n}\nfunction asListOptions(modelProvider, options) {\n    return options && {\n        ...options,\n        identityProvider: options.identityProvider && {\n            getId(el) {\n                return options.identityProvider.getId(el.element);\n            }\n        },\n        dnd: options.dnd && new TreeNodeListDragAndDrop(modelProvider, options.dnd),\n        multipleSelectionController: options.multipleSelectionController && {\n            isSelectionSingleChangeEvent(e) {\n                return options.multipleSelectionController.isSelectionSingleChangeEvent({ ...e, element: e.element });\n            },\n            isSelectionRangeChangeEvent(e) {\n                return options.multipleSelectionController.isSelectionRangeChangeEvent({ ...e, element: e.element });\n            }\n        },\n        accessibilityProvider: options.accessibilityProvider && {\n            ...options.accessibilityProvider,\n            getSetSize(node) {\n                const model = modelProvider();\n                const ref = model.getNodeLocation(node);\n                const parentRef = model.getParentNodeLocation(ref);\n                const parentNode = model.getNode(parentRef);\n                return parentNode.visibleChildrenCount;\n            },\n            getPosInSet(node) {\n                return node.visibleChildIndex + 1;\n            },\n            isChecked: options.accessibilityProvider && options.accessibilityProvider.isChecked ? (node) => {\n                return options.accessibilityProvider.isChecked(node.element);\n            } : undefined,\n            getRole: options.accessibilityProvider && options.accessibilityProvider.getRole ? (node) => {\n                return options.accessibilityProvider.getRole(node.element);\n            } : () => 'treeitem',\n            getAriaLabel(e) {\n                return options.accessibilityProvider.getAriaLabel(e.element);\n            },\n            getWidgetAriaLabel() {\n                return options.accessibilityProvider.getWidgetAriaLabel();\n            },\n            getWidgetRole: options.accessibilityProvider && options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => 'tree',\n            getAriaLevel: options.accessibilityProvider && options.accessibilityProvider.getAriaLevel ? (node) => options.accessibilityProvider.getAriaLevel(node.element) : (node) => {\n                return node.depth;\n            },\n            getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {\n                return options.accessibilityProvider.getActiveDescendantId(node.element);\n            })\n        },\n        keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && {\n            ...options.keyboardNavigationLabelProvider,\n            getKeyboardNavigationLabel(node) {\n                return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(node.element);\n            }\n        }\n    };\n}\nexport class ComposedTreeDelegate {\n    constructor(delegate) {\n        this.delegate = delegate;\n    }\n    getHeight(element) {\n        return this.delegate.getHeight(element.element);\n    }\n    getTemplateId(element) {\n        return this.delegate.getTemplateId(element.element);\n    }\n    hasDynamicHeight(element) {\n        return !!this.delegate.hasDynamicHeight && this.delegate.hasDynamicHeight(element.element);\n    }\n    setDynamicHeight(element, height) {\n        this.delegate.setDynamicHeight?.(element.element, height);\n    }\n}\nexport var RenderIndentGuides;\n(function (RenderIndentGuides) {\n    RenderIndentGuides[\"None\"] = \"none\";\n    RenderIndentGuides[\"OnHover\"] = \"onHover\";\n    RenderIndentGuides[\"Always\"] = \"always\";\n})(RenderIndentGuides || (RenderIndentGuides = {}));\nclass EventCollection {\n    get elements() {\n        return this._elements;\n    }\n    constructor(onDidChange, _elements = []) {\n        this._elements = _elements;\n        this.disposables = new DisposableStore();\n        this.onDidChange = Event.forEach(onDidChange, elements => this._elements = elements, this.disposables);\n    }\n    dispose() {\n        this.disposables.dispose();\n    }\n}\nexport class TreeRenderer {\n    static { this.DefaultIndent = 8; }\n    constructor(renderer, modelProvider, onDidChangeCollapseState, activeNodes, renderedIndentGuides, options = {}) {\n        this.renderer = renderer;\n        this.modelProvider = modelProvider;\n        this.activeNodes = activeNodes;\n        this.renderedIndentGuides = renderedIndentGuides;\n        this.renderedElements = new Map();\n        this.renderedNodes = new Map();\n        this.indent = TreeRenderer.DefaultIndent;\n        this.hideTwistiesOfChildlessElements = false;\n        this.shouldRenderIndentGuides = false;\n        this.activeIndentNodes = new Set();\n        this.indentGuidesDisposable = Disposable.None;\n        this.disposables = new DisposableStore();\n        this.templateId = renderer.templateId;\n        this.updateOptions(options);\n        Event.map(onDidChangeCollapseState, e => e.node)(this.onDidChangeNodeTwistieState, this, this.disposables);\n        renderer.onDidChangeTwistieState?.(this.onDidChangeTwistieState, this, this.disposables);\n    }\n    updateOptions(options = {}) {\n        if (typeof options.indent !== 'undefined') {\n            const indent = clamp(options.indent, 0, 40);\n            if (indent !== this.indent) {\n                this.indent = indent;\n                for (const [node, templateData] of this.renderedNodes) {\n                    this.renderTreeElement(node, templateData);\n                }\n            }\n        }\n        if (typeof options.renderIndentGuides !== 'undefined') {\n            const shouldRenderIndentGuides = options.renderIndentGuides !== RenderIndentGuides.None;\n            if (shouldRenderIndentGuides !== this.shouldRenderIndentGuides) {\n                this.shouldRenderIndentGuides = shouldRenderIndentGuides;\n                for (const [node, templateData] of this.renderedNodes) {\n                    this._renderIndentGuides(node, templateData);\n                }\n                this.indentGuidesDisposable.dispose();\n                if (shouldRenderIndentGuides) {\n                    const disposables = new DisposableStore();\n                    this.activeNodes.onDidChange(this._onDidChangeActiveNodes, this, disposables);\n                    this.indentGuidesDisposable = disposables;\n                    this._onDidChangeActiveNodes(this.activeNodes.elements);\n                }\n            }\n        }\n        if (typeof options.hideTwistiesOfChildlessElements !== 'undefined') {\n            this.hideTwistiesOfChildlessElements = options.hideTwistiesOfChildlessElements;\n        }\n    }\n    renderTemplate(container) {\n        const el = append(container, $('.monaco-tl-row'));\n        const indent = append(el, $('.monaco-tl-indent'));\n        const twistie = append(el, $('.monaco-tl-twistie'));\n        const contents = append(el, $('.monaco-tl-contents'));\n        const templateData = this.renderer.renderTemplate(contents);\n        return { container, indent, twistie, indentGuidesDisposable: Disposable.None, templateData };\n    }\n    renderElement(node, index, templateData, height) {\n        this.renderedNodes.set(node, templateData);\n        this.renderedElements.set(node.element, node);\n        this.renderTreeElement(node, templateData);\n        this.renderer.renderElement(node, index, templateData.templateData, height);\n    }\n    disposeElement(node, index, templateData, height) {\n        templateData.indentGuidesDisposable.dispose();\n        this.renderer.disposeElement?.(node, index, templateData.templateData, height);\n        if (typeof height === 'number') {\n            this.renderedNodes.delete(node);\n            this.renderedElements.delete(node.element);\n        }\n    }\n    disposeTemplate(templateData) {\n        this.renderer.disposeTemplate(templateData.templateData);\n    }\n    onDidChangeTwistieState(element) {\n        const node = this.renderedElements.get(element);\n        if (!node) {\n            return;\n        }\n        this.onDidChangeNodeTwistieState(node);\n    }\n    onDidChangeNodeTwistieState(node) {\n        const templateData = this.renderedNodes.get(node);\n        if (!templateData) {\n            return;\n        }\n        this._onDidChangeActiveNodes(this.activeNodes.elements);\n        this.renderTreeElement(node, templateData);\n    }\n    renderTreeElement(node, templateData) {\n        const indent = TreeRenderer.DefaultIndent + (node.depth - 1) * this.indent;\n        templateData.twistie.style.paddingLeft = `${indent}px`;\n        templateData.indent.style.width = `${indent + this.indent - 16}px`;\n        if (node.collapsible) {\n            templateData.container.setAttribute('aria-expanded', String(!node.collapsed));\n        }\n        else {\n            templateData.container.removeAttribute('aria-expanded');\n        }\n        templateData.twistie.classList.remove(...ThemeIcon.asClassNameArray(Codicon.treeItemExpanded));\n        let twistieRendered = false;\n        if (this.renderer.renderTwistie) {\n            twistieRendered = this.renderer.renderTwistie(node.element, templateData.twistie);\n        }\n        if (node.collapsible && (!this.hideTwistiesOfChildlessElements || node.visibleChildrenCount > 0)) {\n            if (!twistieRendered) {\n                templateData.twistie.classList.add(...ThemeIcon.asClassNameArray(Codicon.treeItemExpanded));\n            }\n            templateData.twistie.classList.add('collapsible');\n            templateData.twistie.classList.toggle('collapsed', node.collapsed);\n        }\n        else {\n            templateData.twistie.classList.remove('collapsible', 'collapsed');\n        }\n        this._renderIndentGuides(node, templateData);\n    }\n    _renderIndentGuides(node, templateData) {\n        clearNode(templateData.indent);\n        templateData.indentGuidesDisposable.dispose();\n        if (!this.shouldRenderIndentGuides) {\n            return;\n        }\n        const disposableStore = new DisposableStore();\n        const model = this.modelProvider();\n        while (true) {\n            const ref = model.getNodeLocation(node);\n            const parentRef = model.getParentNodeLocation(ref);\n            if (!parentRef) {\n                break;\n            }\n            const parent = model.getNode(parentRef);\n            const guide = $('.indent-guide', { style: `width: ${this.indent}px` });\n            if (this.activeIndentNodes.has(parent)) {\n                guide.classList.add('active');\n            }\n            if (templateData.indent.childElementCount === 0) {\n                templateData.indent.appendChild(guide);\n            }\n            else {\n                templateData.indent.insertBefore(guide, templateData.indent.firstElementChild);\n            }\n            this.renderedIndentGuides.add(parent, guide);\n            disposableStore.add(toDisposable(() => this.renderedIndentGuides.delete(parent, guide)));\n            node = parent;\n        }\n        templateData.indentGuidesDisposable = disposableStore;\n    }\n    _onDidChangeActiveNodes(nodes) {\n        if (!this.shouldRenderIndentGuides) {\n            return;\n        }\n        const set = new Set();\n        const model = this.modelProvider();\n        nodes.forEach(node => {\n            const ref = model.getNodeLocation(node);\n            try {\n                const parentRef = model.getParentNodeLocation(ref);\n                if (node.collapsible && node.children.length > 0 && !node.collapsed) {\n                    set.add(node);\n                }\n                else if (parentRef) {\n                    set.add(model.getNode(parentRef));\n                }\n            }\n            catch {\n                // noop\n            }\n        });\n        this.activeIndentNodes.forEach(node => {\n            if (!set.has(node)) {\n                this.renderedIndentGuides.forEach(node, line => line.classList.remove('active'));\n            }\n        });\n        set.forEach(node => {\n            if (!this.activeIndentNodes.has(node)) {\n                this.renderedIndentGuides.forEach(node, line => line.classList.add('active'));\n            }\n        });\n        this.activeIndentNodes = set;\n    }\n    dispose() {\n        this.renderedNodes.clear();\n        this.renderedElements.clear();\n        this.indentGuidesDisposable.dispose();\n        dispose(this.disposables);\n    }\n}\nclass FindFilter {\n    get totalCount() { return this._totalCount; }\n    get matchCount() { return this._matchCount; }\n    constructor(tree, keyboardNavigationLabelProvider, _filter) {\n        this.tree = tree;\n        this.keyboardNavigationLabelProvider = keyboardNavigationLabelProvider;\n        this._filter = _filter;\n        this._totalCount = 0;\n        this._matchCount = 0;\n        this._pattern = '';\n        this._lowercasePattern = '';\n        this.disposables = new DisposableStore();\n        tree.onWillRefilter(this.reset, this, this.disposables);\n    }\n    filter(element, parentVisibility) {\n        let visibility = 1 /* TreeVisibility.Visible */;\n        if (this._filter) {\n            const result = this._filter.filter(element, parentVisibility);\n            if (typeof result === 'boolean') {\n                visibility = result ? 1 /* TreeVisibility.Visible */ : 0 /* TreeVisibility.Hidden */;\n            }\n            else if (isFilterResult(result)) {\n                visibility = getVisibleState(result.visibility);\n            }\n            else {\n                visibility = result;\n            }\n            if (visibility === 0 /* TreeVisibility.Hidden */) {\n                return false;\n            }\n        }\n        this._totalCount++;\n        if (!this._pattern) {\n            this._matchCount++;\n            return { data: FuzzyScore.Default, visibility };\n        }\n        const label = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(element);\n        const labels = Array.isArray(label) ? label : [label];\n        for (const l of labels) {\n            const labelStr = l && l.toString();\n            if (typeof labelStr === 'undefined') {\n                return { data: FuzzyScore.Default, visibility };\n            }\n            let score;\n            if (this.tree.findMatchType === TreeFindMatchType.Contiguous) {\n                const index = labelStr.toLowerCase().indexOf(this._lowercasePattern);\n                if (index > -1) {\n                    score = [Number.MAX_SAFE_INTEGER, 0];\n                    for (let i = this._lowercasePattern.length; i > 0; i--) {\n                        score.push(index + i - 1);\n                    }\n                }\n            }\n            else {\n                score = fuzzyScore(this._pattern, this._lowercasePattern, 0, labelStr, labelStr.toLowerCase(), 0, { firstMatchCanBeWeak: true, boostFullMatch: true });\n            }\n            if (score) {\n                this._matchCount++;\n                return labels.length === 1 ?\n                    { data: score, visibility } :\n                    { data: { label: labelStr, score: score }, visibility };\n            }\n        }\n        if (this.tree.findMode === TreeFindMode.Filter) {\n            if (typeof this.tree.options.defaultFindVisibility === 'number') {\n                return this.tree.options.defaultFindVisibility;\n            }\n            else if (this.tree.options.defaultFindVisibility) {\n                return this.tree.options.defaultFindVisibility(element);\n            }\n            else {\n                return 2 /* TreeVisibility.Recurse */;\n            }\n        }\n        else {\n            return { data: FuzzyScore.Default, visibility };\n        }\n    }\n    reset() {\n        this._totalCount = 0;\n        this._matchCount = 0;\n    }\n    dispose() {\n        dispose(this.disposables);\n    }\n}\nexport class ModeToggle extends Toggle {\n    constructor(opts) {\n        super({\n            icon: Codicon.listFilter,\n            title: localize('filter', \"Filter\"),\n            isChecked: opts.isChecked ?? false,\n            hoverDelegate: opts.hoverDelegate ?? getDefaultHoverDelegate('element'),\n            inputActiveOptionBorder: opts.inputActiveOptionBorder,\n            inputActiveOptionForeground: opts.inputActiveOptionForeground,\n            inputActiveOptionBackground: opts.inputActiveOptionBackground\n        });\n    }\n}\nexport class FuzzyToggle extends Toggle {\n    constructor(opts) {\n        super({\n            icon: Codicon.searchFuzzy,\n            title: localize('fuzzySearch', \"Fuzzy Match\"),\n            isChecked: opts.isChecked ?? false,\n            hoverDelegate: opts.hoverDelegate ?? getDefaultHoverDelegate('element'),\n            inputActiveOptionBorder: opts.inputActiveOptionBorder,\n            inputActiveOptionForeground: opts.inputActiveOptionForeground,\n            inputActiveOptionBackground: opts.inputActiveOptionBackground\n        });\n    }\n}\nconst unthemedFindWidgetStyles = {\n    inputBoxStyles: unthemedInboxStyles,\n    toggleStyles: unthemedToggleStyles,\n    listFilterWidgetBackground: undefined,\n    listFilterWidgetNoMatchesOutline: undefined,\n    listFilterWidgetOutline: undefined,\n    listFilterWidgetShadow: undefined\n};\nexport var TreeFindMode;\n(function (TreeFindMode) {\n    TreeFindMode[TreeFindMode[\"Highlight\"] = 0] = \"Highlight\";\n    TreeFindMode[TreeFindMode[\"Filter\"] = 1] = \"Filter\";\n})(TreeFindMode || (TreeFindMode = {}));\nexport var TreeFindMatchType;\n(function (TreeFindMatchType) {\n    TreeFindMatchType[TreeFindMatchType[\"Fuzzy\"] = 0] = \"Fuzzy\";\n    TreeFindMatchType[TreeFindMatchType[\"Contiguous\"] = 1] = \"Contiguous\";\n})(TreeFindMatchType || (TreeFindMatchType = {}));\nclass FindWidget extends Disposable {\n    set mode(mode) {\n        this.modeToggle.checked = mode === TreeFindMode.Filter;\n        this.findInput.inputBox.setPlaceHolder(mode === TreeFindMode.Filter ? localize('type to filter', \"Type to filter\") : localize('type to search', \"Type to search\"));\n    }\n    set matchType(matchType) {\n        this.matchTypeToggle.checked = matchType === TreeFindMatchType.Fuzzy;\n    }\n    constructor(container, tree, contextViewProvider, mode, matchType, options) {\n        super();\n        this.tree = tree;\n        this.elements = h('.monaco-tree-type-filter', [\n            h('.monaco-tree-type-filter-grab.codicon.codicon-debug-gripper@grab', { tabIndex: 0 }),\n            h('.monaco-tree-type-filter-input@findInput'),\n            h('.monaco-tree-type-filter-actionbar@actionbar'),\n        ]);\n        this.width = 0;\n        this.right = 0;\n        this.top = 0;\n        this._onDidDisable = new Emitter();\n        container.appendChild(this.elements.root);\n        this._register(toDisposable(() => this.elements.root.remove()));\n        const styles = options?.styles ?? unthemedFindWidgetStyles;\n        if (styles.listFilterWidgetBackground) {\n            this.elements.root.style.backgroundColor = styles.listFilterWidgetBackground;\n        }\n        if (styles.listFilterWidgetShadow) {\n            this.elements.root.style.boxShadow = `0 0 8px 2px ${styles.listFilterWidgetShadow}`;\n        }\n        const toggleHoverDelegate = this._register(createInstantHoverDelegate());\n        this.modeToggle = this._register(new ModeToggle({ ...styles.toggleStyles, isChecked: mode === TreeFindMode.Filter, hoverDelegate: toggleHoverDelegate }));\n        this.matchTypeToggle = this._register(new FuzzyToggle({ ...styles.toggleStyles, isChecked: matchType === TreeFindMatchType.Fuzzy, hoverDelegate: toggleHoverDelegate }));\n        this.onDidChangeMode = Event.map(this.modeToggle.onChange, () => this.modeToggle.checked ? TreeFindMode.Filter : TreeFindMode.Highlight, this._store);\n        this.onDidChangeMatchType = Event.map(this.matchTypeToggle.onChange, () => this.matchTypeToggle.checked ? TreeFindMatchType.Fuzzy : TreeFindMatchType.Contiguous, this._store);\n        this.findInput = this._register(new FindInput(this.elements.findInput, contextViewProvider, {\n            label: localize('type to search', \"Type to search\"),\n            additionalToggles: [this.modeToggle, this.matchTypeToggle],\n            showCommonFindToggles: false,\n            inputBoxStyles: styles.inputBoxStyles,\n            toggleStyles: styles.toggleStyles,\n            history: options?.history\n        }));\n        this.actionbar = this._register(new ActionBar(this.elements.actionbar));\n        this.mode = mode;\n        const emitter = this._register(new DomEmitter(this.findInput.inputBox.inputElement, 'keydown'));\n        const onKeyDown = Event.chain(emitter.event, $ => $.map(e => new StandardKeyboardEvent(e)));\n        this._register(onKeyDown((e) => {\n            // Using equals() so we reserve modified keys for future use\n            if (e.equals(3 /* KeyCode.Enter */)) {\n                // This is the only keyboard way to return to the tree from a history item that isn't the last one\n                e.preventDefault();\n                e.stopPropagation();\n                this.findInput.inputBox.addToHistory();\n                this.tree.domFocus();\n                return;\n            }\n            if (e.equals(18 /* KeyCode.DownArrow */)) {\n                e.preventDefault();\n                e.stopPropagation();\n                if (this.findInput.inputBox.isAtLastInHistory() || this.findInput.inputBox.isNowhereInHistory()) {\n                    // Retain original pre-history DownArrow behavior\n                    this.findInput.inputBox.addToHistory();\n                    this.tree.domFocus();\n                }\n                else {\n                    // Downward through history\n                    this.findInput.inputBox.showNextValue();\n                }\n                return;\n            }\n            if (e.equals(16 /* KeyCode.UpArrow */)) {\n                e.preventDefault();\n                e.stopPropagation();\n                // Upward through history\n                this.findInput.inputBox.showPreviousValue();\n                return;\n            }\n        }));\n        const closeAction = this._register(new Action('close', localize('close', \"Close\"), 'codicon codicon-close', true, () => this.dispose()));\n        this.actionbar.push(closeAction, { icon: true, label: false });\n        const onGrabMouseDown = this._register(new DomEmitter(this.elements.grab, 'mousedown'));\n        this._register(onGrabMouseDown.event(e => {\n            const disposables = new DisposableStore();\n            const onWindowMouseMove = disposables.add(new DomEmitter(getWindow(e), 'mousemove'));\n            const onWindowMouseUp = disposables.add(new DomEmitter(getWindow(e), 'mouseup'));\n            const startRight = this.right;\n            const startX = e.pageX;\n            const startTop = this.top;\n            const startY = e.pageY;\n            this.elements.grab.classList.add('grabbing');\n            const transition = this.elements.root.style.transition;\n            this.elements.root.style.transition = 'unset';\n            const update = (e) => {\n                const deltaX = e.pageX - startX;\n                this.right = startRight - deltaX;\n                const deltaY = e.pageY - startY;\n                this.top = startTop + deltaY;\n                this.layout();\n            };\n            disposables.add(onWindowMouseMove.event(update));\n            disposables.add(onWindowMouseUp.event(e => {\n                update(e);\n                this.elements.grab.classList.remove('grabbing');\n                this.elements.root.style.transition = transition;\n                disposables.dispose();\n            }));\n        }));\n        const onGrabKeyDown = Event.chain(this._register(new DomEmitter(this.elements.grab, 'keydown')).event, $ => $.map(e => new StandardKeyboardEvent(e)));\n        this._register(onGrabKeyDown((e) => {\n            let right;\n            let top;\n            if (e.keyCode === 15 /* KeyCode.LeftArrow */) {\n                right = Number.POSITIVE_INFINITY;\n            }\n            else if (e.keyCode === 17 /* KeyCode.RightArrow */) {\n                right = 0;\n            }\n            else if (e.keyCode === 10 /* KeyCode.Space */) {\n                right = this.right === 0 ? Number.POSITIVE_INFINITY : 0;\n            }\n            if (e.keyCode === 16 /* KeyCode.UpArrow */) {\n                top = 0;\n            }\n            else if (e.keyCode === 18 /* KeyCode.DownArrow */) {\n                top = Number.POSITIVE_INFINITY;\n            }\n            if (right !== undefined) {\n                e.preventDefault();\n                e.stopPropagation();\n                this.right = right;\n                this.layout();\n            }\n            if (top !== undefined) {\n                e.preventDefault();\n                e.stopPropagation();\n                this.top = top;\n                const transition = this.elements.root.style.transition;\n                this.elements.root.style.transition = 'unset';\n                this.layout();\n                setTimeout(() => {\n                    this.elements.root.style.transition = transition;\n                }, 0);\n            }\n        }));\n        this.onDidChangeValue = this.findInput.onDidChange;\n    }\n    layout(width = this.width) {\n        this.width = width;\n        this.right = clamp(this.right, 0, Math.max(0, width - 212));\n        this.elements.root.style.right = `${this.right}px`;\n        this.top = clamp(this.top, 0, 24);\n        this.elements.root.style.top = `${this.top}px`;\n    }\n    showMessage(message) {\n        this.findInput.showMessage(message);\n    }\n    clearMessage() {\n        this.findInput.clearMessage();\n    }\n    async dispose() {\n        this._onDidDisable.fire();\n        this.elements.root.classList.add('disabled');\n        await timeout(300);\n        super.dispose();\n    }\n}\nclass FindController {\n    get pattern() { return this._pattern; }\n    get mode() { return this._mode; }\n    set mode(mode) {\n        if (mode === this._mode) {\n            return;\n        }\n        this._mode = mode;\n        if (this.widget) {\n            this.widget.mode = this._mode;\n        }\n        this.tree.refilter();\n        this.render();\n        this._onDidChangeMode.fire(mode);\n    }\n    get matchType() { return this._matchType; }\n    set matchType(matchType) {\n        if (matchType === this._matchType) {\n            return;\n        }\n        this._matchType = matchType;\n        if (this.widget) {\n            this.widget.matchType = this._matchType;\n        }\n        this.tree.refilter();\n        this.render();\n        this._onDidChangeMatchType.fire(matchType);\n    }\n    constructor(tree, model, view, filter, contextViewProvider, options = {}) {\n        this.tree = tree;\n        this.view = view;\n        this.filter = filter;\n        this.contextViewProvider = contextViewProvider;\n        this.options = options;\n        this._pattern = '';\n        this.width = 0;\n        this._onDidChangeMode = new Emitter();\n        this.onDidChangeMode = this._onDidChangeMode.event;\n        this._onDidChangeMatchType = new Emitter();\n        this.onDidChangeMatchType = this._onDidChangeMatchType.event;\n        this._onDidChangePattern = new Emitter();\n        this._onDidChangeOpenState = new Emitter();\n        this.onDidChangeOpenState = this._onDidChangeOpenState.event;\n        this.enabledDisposables = new DisposableStore();\n        this.disposables = new DisposableStore();\n        this._mode = tree.options.defaultFindMode ?? TreeFindMode.Highlight;\n        this._matchType = tree.options.defaultFindMatchType ?? TreeFindMatchType.Fuzzy;\n        model.onDidSplice(this.onDidSpliceModel, this, this.disposables);\n    }\n    updateOptions(optionsUpdate = {}) {\n        if (optionsUpdate.defaultFindMode !== undefined) {\n            this.mode = optionsUpdate.defaultFindMode;\n        }\n        if (optionsUpdate.defaultFindMatchType !== undefined) {\n            this.matchType = optionsUpdate.defaultFindMatchType;\n        }\n    }\n    onDidSpliceModel() {\n        if (!this.widget || this.pattern.length === 0) {\n            return;\n        }\n        this.tree.refilter();\n        this.render();\n    }\n    render() {\n        const noMatches = this.filter.totalCount > 0 && this.filter.matchCount === 0;\n        if (this.pattern && noMatches) {\n            alert(localize('replFindNoResults', \"No results\"));\n            if (this.tree.options.showNotFoundMessage ?? true) {\n                this.widget?.showMessage({ type: 2 /* MessageType.WARNING */, content: localize('not found', \"No elements found.\") });\n            }\n            else {\n                this.widget?.showMessage({ type: 2 /* MessageType.WARNING */ });\n            }\n        }\n        else {\n            this.widget?.clearMessage();\n            if (this.pattern) {\n                alert(localize('replFindResults', \"{0} results\", this.filter.matchCount));\n            }\n        }\n    }\n    shouldAllowFocus(node) {\n        if (!this.widget || !this.pattern) {\n            return true;\n        }\n        if (this.filter.totalCount > 0 && this.filter.matchCount <= 1) {\n            return true;\n        }\n        return !FuzzyScore.isDefault(node.filterData);\n    }\n    layout(width) {\n        this.width = width;\n        this.widget?.layout(width);\n    }\n    dispose() {\n        this._history = undefined;\n        this._onDidChangePattern.dispose();\n        this.enabledDisposables.dispose();\n        this.disposables.dispose();\n    }\n}\nfunction stickyScrollNodeStateEquals(node1, node2) {\n    return node1.position === node2.position && stickyScrollNodeEquals(node1, node2);\n}\nfunction stickyScrollNodeEquals(node1, node2) {\n    return node1.node.element === node2.node.element &&\n        node1.startIndex === node2.startIndex &&\n        node1.height === node2.height &&\n        node1.endIndex === node2.endIndex;\n}\nclass StickyScrollState {\n    constructor(stickyNodes = []) {\n        this.stickyNodes = stickyNodes;\n    }\n    get count() { return this.stickyNodes.length; }\n    equal(state) {\n        return equals(this.stickyNodes, state.stickyNodes, stickyScrollNodeStateEquals);\n    }\n    lastNodePartiallyVisible() {\n        if (this.count === 0) {\n            return false;\n        }\n        const lastStickyNode = this.stickyNodes[this.count - 1];\n        if (this.count === 1) {\n            return lastStickyNode.position !== 0;\n        }\n        const secondLastStickyNode = this.stickyNodes[this.count - 2];\n        return secondLastStickyNode.position + secondLastStickyNode.height !== lastStickyNode.position;\n    }\n    animationStateChanged(previousState) {\n        if (!equals(this.stickyNodes, previousState.stickyNodes, stickyScrollNodeEquals)) {\n            return false;\n        }\n        if (this.count === 0) {\n            return false;\n        }\n        const lastStickyNode = this.stickyNodes[this.count - 1];\n        const previousLastStickyNode = previousState.stickyNodes[previousState.count - 1];\n        return lastStickyNode.position !== previousLastStickyNode.position;\n    }\n}\nclass DefaultStickyScrollDelegate {\n    constrainStickyScrollNodes(stickyNodes, stickyScrollMaxItemCount, maxWidgetHeight) {\n        for (let i = 0; i < stickyNodes.length; i++) {\n            const stickyNode = stickyNodes[i];\n            const stickyNodeBottom = stickyNode.position + stickyNode.height;\n            if (stickyNodeBottom > maxWidgetHeight || i >= stickyScrollMaxItemCount) {\n                return stickyNodes.slice(0, i);\n            }\n        }\n        return stickyNodes;\n    }\n}\nclass StickyScrollController extends Disposable {\n    constructor(tree, model, view, renderers, treeDelegate, options = {}) {\n        super();\n        this.tree = tree;\n        this.model = model;\n        this.view = view;\n        this.treeDelegate = treeDelegate;\n        this.maxWidgetViewRatio = 0.4;\n        const stickyScrollOptions = this.validateStickySettings(options);\n        this.stickyScrollMaxItemCount = stickyScrollOptions.stickyScrollMaxItemCount;\n        this.stickyScrollDelegate = options.stickyScrollDelegate ?? new DefaultStickyScrollDelegate();\n        this._widget = this._register(new StickyScrollWidget(view.getScrollableElement(), view, tree, renderers, treeDelegate, options.accessibilityProvider));\n        this.onDidChangeHasFocus = this._widget.onDidChangeHasFocus;\n        this.onContextMenu = this._widget.onContextMenu;\n        this._register(view.onDidScroll(() => this.update()));\n        this._register(view.onDidChangeContentHeight(() => this.update()));\n        this._register(tree.onDidChangeCollapseState(() => this.update()));\n        this.update();\n    }\n    get height() {\n        return this._widget.height;\n    }\n    getNodeAtHeight(height) {\n        let index;\n        if (height === 0) {\n            index = this.view.firstVisibleIndex;\n        }\n        else {\n            index = this.view.indexAt(height + this.view.scrollTop);\n        }\n        if (index < 0 || index >= this.view.length) {\n            return undefined;\n        }\n        return this.view.element(index);\n    }\n    update() {\n        const firstVisibleNode = this.getNodeAtHeight(0);\n        // Don't render anything if there are no elements\n        if (!firstVisibleNode || this.tree.scrollTop === 0) {\n            this._widget.setState(undefined);\n            return;\n        }\n        const stickyState = this.findStickyState(firstVisibleNode);\n        this._widget.setState(stickyState);\n    }\n    findStickyState(firstVisibleNode) {\n        const stickyNodes = [];\n        let firstVisibleNodeUnderWidget = firstVisibleNode;\n        let stickyNodesHeight = 0;\n        let nextStickyNode = this.getNextStickyNode(firstVisibleNodeUnderWidget, undefined, stickyNodesHeight);\n        while (nextStickyNode) {\n            stickyNodes.push(nextStickyNode);\n            stickyNodesHeight += nextStickyNode.height;\n            if (stickyNodes.length <= this.stickyScrollMaxItemCount) {\n                firstVisibleNodeUnderWidget = this.getNextVisibleNode(nextStickyNode);\n                if (!firstVisibleNodeUnderWidget) {\n                    break;\n                }\n            }\n            nextStickyNode = this.getNextStickyNode(firstVisibleNodeUnderWidget, nextStickyNode.node, stickyNodesHeight);\n        }\n        const contrainedStickyNodes = this.constrainStickyNodes(stickyNodes);\n        return contrainedStickyNodes.length ? new StickyScrollState(contrainedStickyNodes) : undefined;\n    }\n    getNextVisibleNode(previousStickyNode) {\n        return this.getNodeAtHeight(previousStickyNode.position + previousStickyNode.height);\n    }\n    getNextStickyNode(firstVisibleNodeUnderWidget, previousStickyNode, stickyNodesHeight) {\n        const nextStickyNode = this.getAncestorUnderPrevious(firstVisibleNodeUnderWidget, previousStickyNode);\n        if (!nextStickyNode) {\n            return undefined;\n        }\n        if (nextStickyNode === firstVisibleNodeUnderWidget) {\n            if (!this.nodeIsUncollapsedParent(firstVisibleNodeUnderWidget)) {\n                return undefined;\n            }\n            if (this.nodeTopAlignsWithStickyNodesBottom(firstVisibleNodeUnderWidget, stickyNodesHeight)) {\n                return undefined;\n            }\n        }\n        return this.createStickyScrollNode(nextStickyNode, stickyNodesHeight);\n    }\n    nodeTopAlignsWithStickyNodesBottom(node, stickyNodesHeight) {\n        const nodeIndex = this.getNodeIndex(node);\n        const elementTop = this.view.getElementTop(nodeIndex);\n        const stickyPosition = stickyNodesHeight;\n        return this.view.scrollTop === elementTop - stickyPosition;\n    }\n    createStickyScrollNode(node, currentStickyNodesHeight) {\n        const height = this.treeDelegate.getHeight(node);\n        const { startIndex, endIndex } = this.getNodeRange(node);\n        const position = this.calculateStickyNodePosition(endIndex, currentStickyNodesHeight, height);\n        return { node, position, height, startIndex, endIndex };\n    }\n    getAncestorUnderPrevious(node, previousAncestor = undefined) {\n        let currentAncestor = node;\n        let parentOfcurrentAncestor = this.getParentNode(currentAncestor);\n        while (parentOfcurrentAncestor) {\n            if (parentOfcurrentAncestor === previousAncestor) {\n                return currentAncestor;\n            }\n            currentAncestor = parentOfcurrentAncestor;\n            parentOfcurrentAncestor = this.getParentNode(currentAncestor);\n        }\n        if (previousAncestor === undefined) {\n            return currentAncestor;\n        }\n        return undefined;\n    }\n    calculateStickyNodePosition(lastDescendantIndex, stickyRowPositionTop, stickyNodeHeight) {\n        let lastChildRelativeTop = this.view.getRelativeTop(lastDescendantIndex);\n        // If the last descendant is only partially visible at the top of the view, getRelativeTop() returns null\n        // In that case, utilize the next node's relative top to calculate the sticky node's position\n        if (lastChildRelativeTop === null && this.view.firstVisibleIndex === lastDescendantIndex && lastDescendantIndex + 1 < this.view.length) {\n            const nodeHeight = this.treeDelegate.getHeight(this.view.element(lastDescendantIndex));\n            const nextNodeRelativeTop = this.view.getRelativeTop(lastDescendantIndex + 1);\n            lastChildRelativeTop = nextNodeRelativeTop ? nextNodeRelativeTop - nodeHeight / this.view.renderHeight : null;\n        }\n        if (lastChildRelativeTop === null) {\n            return stickyRowPositionTop;\n        }\n        const lastChildNode = this.view.element(lastDescendantIndex);\n        const lastChildHeight = this.treeDelegate.getHeight(lastChildNode);\n        const topOfLastChild = lastChildRelativeTop * this.view.renderHeight;\n        const bottomOfLastChild = topOfLastChild + lastChildHeight;\n        if (stickyRowPositionTop + stickyNodeHeight > bottomOfLastChild && stickyRowPositionTop <= bottomOfLastChild) {\n            return bottomOfLastChild - stickyNodeHeight;\n        }\n        return stickyRowPositionTop;\n    }\n    constrainStickyNodes(stickyNodes) {\n        if (stickyNodes.length === 0) {\n            return [];\n        }\n        // Check if sticky nodes need to be constrained\n        const maximumStickyWidgetHeight = this.view.renderHeight * this.maxWidgetViewRatio;\n        const lastStickyNode = stickyNodes[stickyNodes.length - 1];\n        if (stickyNodes.length <= this.stickyScrollMaxItemCount && lastStickyNode.position + lastStickyNode.height <= maximumStickyWidgetHeight) {\n            return stickyNodes;\n        }\n        // constrain sticky nodes\n        const constrainedStickyNodes = this.stickyScrollDelegate.constrainStickyScrollNodes(stickyNodes, this.stickyScrollMaxItemCount, maximumStickyWidgetHeight);\n        if (!constrainedStickyNodes.length) {\n            return [];\n        }\n        // Validate constraints\n        const lastConstrainedStickyNode = constrainedStickyNodes[constrainedStickyNodes.length - 1];\n        if (constrainedStickyNodes.length > this.stickyScrollMaxItemCount || lastConstrainedStickyNode.position + lastConstrainedStickyNode.height > maximumStickyWidgetHeight) {\n            throw new Error('stickyScrollDelegate violates constraints');\n        }\n        return constrainedStickyNodes;\n    }\n    getParentNode(node) {\n        const nodeLocation = this.model.getNodeLocation(node);\n        const parentLocation = this.model.getParentNodeLocation(nodeLocation);\n        return parentLocation ? this.model.getNode(parentLocation) : undefined;\n    }\n    nodeIsUncollapsedParent(node) {\n        const nodeLocation = this.model.getNodeLocation(node);\n        return this.model.getListRenderCount(nodeLocation) > 1;\n    }\n    getNodeIndex(node) {\n        const nodeLocation = this.model.getNodeLocation(node);\n        const nodeIndex = this.model.getListIndex(nodeLocation);\n        return nodeIndex;\n    }\n    getNodeRange(node) {\n        const nodeLocation = this.model.getNodeLocation(node);\n        const startIndex = this.model.getListIndex(nodeLocation);\n        if (startIndex < 0) {\n            throw new Error('Node not found in tree');\n        }\n        const renderCount = this.model.getListRenderCount(nodeLocation);\n        const endIndex = startIndex + renderCount - 1;\n        return { startIndex, endIndex };\n    }\n    nodePositionTopBelowWidget(node) {\n        const ancestors = [];\n        let currentAncestor = this.getParentNode(node);\n        while (currentAncestor) {\n            ancestors.push(currentAncestor);\n            currentAncestor = this.getParentNode(currentAncestor);\n        }\n        let widgetHeight = 0;\n        for (let i = 0; i < ancestors.length && i < this.stickyScrollMaxItemCount; i++) {\n            widgetHeight += this.treeDelegate.getHeight(ancestors[i]);\n        }\n        return widgetHeight;\n    }\n    domFocus() {\n        this._widget.domFocus();\n    }\n    // Whether sticky scroll was the last focused part in the tree or not\n    focusedLast() {\n        return this._widget.focusedLast();\n    }\n    updateOptions(optionsUpdate = {}) {\n        if (!optionsUpdate.stickyScrollMaxItemCount) {\n            return;\n        }\n        const validatedOptions = this.validateStickySettings(optionsUpdate);\n        if (this.stickyScrollMaxItemCount !== validatedOptions.stickyScrollMaxItemCount) {\n            this.stickyScrollMaxItemCount = validatedOptions.stickyScrollMaxItemCount;\n            this.update();\n        }\n    }\n    validateStickySettings(options) {\n        let stickyScrollMaxItemCount = 7;\n        if (typeof options.stickyScrollMaxItemCount === 'number') {\n            stickyScrollMaxItemCount = Math.max(options.stickyScrollMaxItemCount, 1);\n        }\n        return { stickyScrollMaxItemCount };\n    }\n}\nclass StickyScrollWidget {\n    constructor(container, view, tree, treeRenderers, treeDelegate, accessibilityProvider) {\n        this.view = view;\n        this.tree = tree;\n        this.treeRenderers = treeRenderers;\n        this.treeDelegate = treeDelegate;\n        this.accessibilityProvider = accessibilityProvider;\n        this._previousElements = [];\n        this._previousStateDisposables = new DisposableStore();\n        this._rootDomNode = $('.monaco-tree-sticky-container.empty');\n        container.appendChild(this._rootDomNode);\n        const shadow = $('.monaco-tree-sticky-container-shadow');\n        this._rootDomNode.appendChild(shadow);\n        this.stickyScrollFocus = new StickyScrollFocus(this._rootDomNode, view);\n        this.onDidChangeHasFocus = this.stickyScrollFocus.onDidChangeHasFocus;\n        this.onContextMenu = this.stickyScrollFocus.onContextMenu;\n    }\n    get height() {\n        if (!this._previousState) {\n            return 0;\n        }\n        const lastElement = this._previousState.stickyNodes[this._previousState.count - 1];\n        return lastElement.position + lastElement.height;\n    }\n    setState(state) {\n        const wasVisible = !!this._previousState && this._previousState.count > 0;\n        const isVisible = !!state && state.count > 0;\n        // If state has not changed, do nothing\n        if ((!wasVisible && !isVisible) || (wasVisible && isVisible && this._previousState.equal(state))) {\n            return;\n        }\n        // Update visibility of the widget if changed\n        if (wasVisible !== isVisible) {\n            this.setVisible(isVisible);\n        }\n        if (!isVisible) {\n            this._previousState = undefined;\n            this._previousElements = [];\n            this._previousStateDisposables.clear();\n            return;\n        }\n        const lastStickyNode = state.stickyNodes[state.count - 1];\n        // If the new state is only a change in the last node's position, update the position of the last element\n        if (this._previousState && state.animationStateChanged(this._previousState)) {\n            this._previousElements[this._previousState.count - 1].style.top = `${lastStickyNode.position}px`;\n        }\n        // create new dom elements\n        else {\n            this._previousStateDisposables.clear();\n            const elements = Array(state.count);\n            for (let stickyIndex = state.count - 1; stickyIndex >= 0; stickyIndex--) {\n                const stickyNode = state.stickyNodes[stickyIndex];\n                const { element, disposable } = this.createElement(stickyNode, stickyIndex, state.count);\n                elements[stickyIndex] = element;\n                this._rootDomNode.appendChild(element);\n                this._previousStateDisposables.add(disposable);\n            }\n            this.stickyScrollFocus.updateElements(elements, state);\n            this._previousElements = elements;\n        }\n        this._previousState = state;\n        // Set the height of the widget to the bottom of the last sticky node\n        this._rootDomNode.style.height = `${lastStickyNode.position + lastStickyNode.height}px`;\n    }\n    createElement(stickyNode, stickyIndex, stickyNodesTotal) {\n        const nodeIndex = stickyNode.startIndex;\n        // Sticky element container\n        const stickyElement = document.createElement('div');\n        stickyElement.style.top = `${stickyNode.position}px`;\n        if (this.tree.options.setRowHeight !== false) {\n            stickyElement.style.height = `${stickyNode.height}px`;\n        }\n        if (this.tree.options.setRowLineHeight !== false) {\n            stickyElement.style.lineHeight = `${stickyNode.height}px`;\n        }\n        stickyElement.classList.add('monaco-tree-sticky-row');\n        stickyElement.classList.add('monaco-list-row');\n        stickyElement.setAttribute('data-index', `${nodeIndex}`);\n        stickyElement.setAttribute('data-parity', nodeIndex % 2 === 0 ? 'even' : 'odd');\n        stickyElement.setAttribute('id', this.view.getElementID(nodeIndex));\n        const accessibilityDisposable = this.setAccessibilityAttributes(stickyElement, stickyNode.node.element, stickyIndex, stickyNodesTotal);\n        // Get the renderer for the node\n        const nodeTemplateId = this.treeDelegate.getTemplateId(stickyNode.node);\n        const renderer = this.treeRenderers.find((renderer) => renderer.templateId === nodeTemplateId);\n        if (!renderer) {\n            throw new Error(`No renderer found for template id ${nodeTemplateId}`);\n        }\n        // To make sure we do not influence the original node, we create a copy of the node\n        // We need to check if it is already a unique instance of the node by the delegate\n        let nodeCopy = stickyNode.node;\n        if (nodeCopy === this.tree.getNode(this.tree.getNodeLocation(stickyNode.node))) {\n            nodeCopy = new Proxy(stickyNode.node, {});\n        }\n        // Render the element\n        const templateData = renderer.renderTemplate(stickyElement);\n        renderer.renderElement(nodeCopy, stickyNode.startIndex, templateData, stickyNode.height);\n        // Remove the element from the DOM when state is disposed\n        const disposable = toDisposable(() => {\n            accessibilityDisposable.dispose();\n            renderer.disposeElement(nodeCopy, stickyNode.startIndex, templateData, stickyNode.height);\n            renderer.disposeTemplate(templateData);\n            stickyElement.remove();\n        });\n        return { element: stickyElement, disposable };\n    }\n    setAccessibilityAttributes(container, element, stickyIndex, stickyNodesTotal) {\n        if (!this.accessibilityProvider) {\n            return Disposable.None;\n        }\n        if (this.accessibilityProvider.getSetSize) {\n            container.setAttribute('aria-setsize', String(this.accessibilityProvider.getSetSize(element, stickyIndex, stickyNodesTotal)));\n        }\n        if (this.accessibilityProvider.getPosInSet) {\n            container.setAttribute('aria-posinset', String(this.accessibilityProvider.getPosInSet(element, stickyIndex)));\n        }\n        if (this.accessibilityProvider.getRole) {\n            container.setAttribute('role', this.accessibilityProvider.getRole(element) ?? 'treeitem');\n        }\n        const ariaLabel = this.accessibilityProvider.getAriaLabel(element);\n        const observable = (ariaLabel && typeof ariaLabel !== 'string') ? ariaLabel : constObservable(ariaLabel);\n        const result = autorun(reader => {\n            const value = reader.readObservable(observable);\n            if (value) {\n                container.setAttribute('aria-label', value);\n            }\n            else {\n                container.removeAttribute('aria-label');\n            }\n        });\n        if (typeof ariaLabel === 'string') {\n        }\n        else if (ariaLabel) {\n            container.setAttribute('aria-label', ariaLabel.get());\n        }\n        const ariaLevel = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(element);\n        if (typeof ariaLevel === 'number') {\n            container.setAttribute('aria-level', `${ariaLevel}`);\n        }\n        // Sticky Scroll elements can not be selected\n        container.setAttribute('aria-selected', String(false));\n        return result;\n    }\n    setVisible(visible) {\n        this._rootDomNode.classList.toggle('empty', !visible);\n        if (!visible) {\n            this.stickyScrollFocus.updateElements([], undefined);\n        }\n    }\n    domFocus() {\n        this.stickyScrollFocus.domFocus();\n    }\n    focusedLast() {\n        return this.stickyScrollFocus.focusedLast();\n    }\n    dispose() {\n        this.stickyScrollFocus.dispose();\n        this._previousStateDisposables.dispose();\n        this._rootDomNode.remove();\n    }\n}\nclass StickyScrollFocus extends Disposable {\n    get domHasFocus() { return this._domHasFocus; }\n    set domHasFocus(hasFocus) {\n        if (hasFocus !== this._domHasFocus) {\n            this._onDidChangeHasFocus.fire(hasFocus);\n            this._domHasFocus = hasFocus;\n        }\n    }\n    constructor(container, view) {\n        super();\n        this.container = container;\n        this.view = view;\n        this.focusedIndex = -1;\n        this.elements = [];\n        this._onDidChangeHasFocus = new Emitter();\n        this.onDidChangeHasFocus = this._onDidChangeHasFocus.event;\n        this._onContextMenu = new Emitter();\n        this.onContextMenu = this._onContextMenu.event;\n        this._domHasFocus = false;\n        this._register(addDisposableListener(this.container, 'focus', () => this.onFocus()));\n        this._register(addDisposableListener(this.container, 'blur', () => this.onBlur()));\n        this._register(this.view.onDidFocus(() => this.toggleStickyScrollFocused(false)));\n        this._register(this.view.onKeyDown((e) => this.onKeyDown(e)));\n        this._register(this.view.onMouseDown((e) => this.onMouseDown(e)));\n        this._register(this.view.onContextMenu((e) => this.handleContextMenu(e)));\n    }\n    handleContextMenu(e) {\n        const target = e.browserEvent.target;\n        if (!isStickyScrollContainer(target) && !isStickyScrollElement(target)) {\n            if (this.focusedLast()) {\n                this.view.domFocus();\n            }\n            return;\n        }\n        // The list handles the context menu triggered by a mouse event\n        // In that case only set the focus of the element clicked and leave the rest to the list to handle\n        if (!isKeyboardEvent(e.browserEvent)) {\n            if (!this.state) {\n                throw new Error('Context menu should not be triggered when state is undefined');\n            }\n            const stickyIndex = this.state.stickyNodes.findIndex(stickyNode => stickyNode.node.element === e.element?.element);\n            if (stickyIndex === -1) {\n                throw new Error('Context menu should not be triggered when element is not in sticky scroll widget');\n            }\n            this.container.focus();\n            this.setFocus(stickyIndex);\n            return;\n        }\n        if (!this.state || this.focusedIndex < 0) {\n            throw new Error('Context menu key should not be triggered when focus is not in sticky scroll widget');\n        }\n        const stickyNode = this.state.stickyNodes[this.focusedIndex];\n        const element = stickyNode.node.element;\n        const anchor = this.elements[this.focusedIndex];\n        this._onContextMenu.fire({ element, anchor, browserEvent: e.browserEvent, isStickyScroll: true });\n    }\n    onKeyDown(e) {\n        // Sticky Scroll Navigation\n        if (this.domHasFocus && this.state) {\n            // Move up\n            if (e.key === 'ArrowUp') {\n                this.setFocusedElement(Math.max(0, this.focusedIndex - 1));\n                e.preventDefault();\n                e.stopPropagation();\n            }\n            // Move down, if last sticky node is focused, move focus into first child of last sticky node\n            else if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {\n                if (this.focusedIndex >= this.state.count - 1) {\n                    const nodeIndexToFocus = this.state.stickyNodes[this.state.count - 1].startIndex + 1;\n                    this.view.domFocus();\n                    this.view.setFocus([nodeIndexToFocus]);\n                    this.scrollNodeUnderWidget(nodeIndexToFocus, this.state);\n                }\n                else {\n                    this.setFocusedElement(this.focusedIndex + 1);\n                }\n                e.preventDefault();\n                e.stopPropagation();\n            }\n        }\n    }\n    onMouseDown(e) {\n        const target = e.browserEvent.target;\n        if (!isStickyScrollContainer(target) && !isStickyScrollElement(target)) {\n            return;\n        }\n        e.browserEvent.preventDefault();\n        e.browserEvent.stopPropagation();\n    }\n    updateElements(elements, state) {\n        if (state && state.count === 0) {\n            throw new Error('Sticky scroll state must be undefined when there are no sticky nodes');\n        }\n        if (state && state.count !== elements.length) {\n            throw new Error('Sticky scroll focus received illigel state');\n        }\n        const previousIndex = this.focusedIndex;\n        this.removeFocus();\n        this.elements = elements;\n        this.state = state;\n        if (state) {\n            const newFocusedIndex = clamp(previousIndex, 0, state.count - 1);\n            this.setFocus(newFocusedIndex);\n        }\n        else {\n            if (this.domHasFocus) {\n                this.view.domFocus();\n            }\n        }\n        // must come last as it calls blur()\n        this.container.tabIndex = state ? 0 : -1;\n    }\n    setFocusedElement(stickyIndex) {\n        // doesn't imply that the widget has (or will have) focus\n        const state = this.state;\n        if (!state) {\n            throw new Error('Cannot set focus when state is undefined');\n        }\n        this.setFocus(stickyIndex);\n        if (stickyIndex < state.count - 1) {\n            return;\n        }\n        // If the last sticky node is not fully visible, scroll it into view\n        if (state.lastNodePartiallyVisible()) {\n            const lastStickyNode = state.stickyNodes[stickyIndex];\n            this.scrollNodeUnderWidget(lastStickyNode.endIndex + 1, state);\n        }\n    }\n    scrollNodeUnderWidget(nodeIndex, state) {\n        const lastStickyNode = state.stickyNodes[state.count - 1];\n        const secondLastStickyNode = state.count > 1 ? state.stickyNodes[state.count - 2] : undefined;\n        const elementScrollTop = this.view.getElementTop(nodeIndex);\n        const elementTargetViewTop = secondLastStickyNode ? secondLastStickyNode.position + secondLastStickyNode.height + lastStickyNode.height : lastStickyNode.height;\n        this.view.scrollTop = elementScrollTop - elementTargetViewTop;\n    }\n    domFocus() {\n        if (!this.state) {\n            throw new Error('Cannot focus when state is undefined');\n        }\n        this.container.focus();\n    }\n    focusedLast() {\n        if (!this.state) {\n            return false;\n        }\n        return this.view.getHTMLElement().classList.contains('sticky-scroll-focused');\n    }\n    removeFocus() {\n        if (this.focusedIndex === -1) {\n            return;\n        }\n        this.toggleElementFocus(this.elements[this.focusedIndex], false);\n        this.focusedIndex = -1;\n    }\n    setFocus(newFocusIndex) {\n        if (0 > newFocusIndex) {\n            throw new Error('addFocus() can not remove focus');\n        }\n        if (!this.state && newFocusIndex >= 0) {\n            throw new Error('Cannot set focus index when state is undefined');\n        }\n        if (this.state && newFocusIndex >= this.state.count) {\n            throw new Error('Cannot set focus index to an index that does not exist');\n        }\n        const oldIndex = this.focusedIndex;\n        if (oldIndex >= 0) {\n            this.toggleElementFocus(this.elements[oldIndex], false);\n        }\n        if (newFocusIndex >= 0) {\n            this.toggleElementFocus(this.elements[newFocusIndex], true);\n        }\n        this.focusedIndex = newFocusIndex;\n    }\n    toggleElementFocus(element, focused) {\n        this.toggleElementActiveFocus(element, focused && this.domHasFocus);\n        this.toggleElementPassiveFocus(element, focused);\n    }\n    toggleCurrentElementActiveFocus(focused) {\n        if (this.focusedIndex === -1) {\n            return;\n        }\n        this.toggleElementActiveFocus(this.elements[this.focusedIndex], focused);\n    }\n    toggleElementActiveFocus(element, focused) {\n        // active focus is set when sticky scroll has focus\n        element.classList.toggle('focused', focused);\n    }\n    toggleElementPassiveFocus(element, focused) {\n        // passive focus allows to show focus when sticky scroll does not have focus\n        // for example when the context menu has focus\n        element.classList.toggle('passive-focused', focused);\n    }\n    toggleStickyScrollFocused(focused) {\n        // Weather the last focus in the view was sticky scroll and not the list\n        // Is only removed when the focus is back in the tree an no longer in sticky scroll\n        this.view.getHTMLElement().classList.toggle('sticky-scroll-focused', focused);\n    }\n    onFocus() {\n        if (!this.state || this.elements.length === 0) {\n            throw new Error('Cannot focus when state is undefined or elements are empty');\n        }\n        this.domHasFocus = true;\n        this.toggleStickyScrollFocused(true);\n        this.toggleCurrentElementActiveFocus(true);\n        if (this.focusedIndex === -1) {\n            this.setFocus(0);\n        }\n    }\n    onBlur() {\n        this.domHasFocus = false;\n        this.toggleCurrentElementActiveFocus(false);\n    }\n    dispose() {\n        this.toggleStickyScrollFocused(false);\n        this._onDidChangeHasFocus.fire(false);\n        super.dispose();\n    }\n}\nfunction asTreeMouseEvent(event) {\n    let target = TreeMouseEventTarget.Unknown;\n    if (hasParentWithClass(event.browserEvent.target, 'monaco-tl-twistie', 'monaco-tl-row')) {\n        target = TreeMouseEventTarget.Twistie;\n    }\n    else if (hasParentWithClass(event.browserEvent.target, 'monaco-tl-contents', 'monaco-tl-row')) {\n        target = TreeMouseEventTarget.Element;\n    }\n    else if (hasParentWithClass(event.browserEvent.target, 'monaco-tree-type-filter', 'monaco-list')) {\n        target = TreeMouseEventTarget.Filter;\n    }\n    return {\n        browserEvent: event.browserEvent,\n        element: event.element ? event.element.element : null,\n        target\n    };\n}\nfunction asTreeContextMenuEvent(event) {\n    const isStickyScroll = isStickyScrollContainer(event.browserEvent.target);\n    return {\n        element: event.element ? event.element.element : null,\n        browserEvent: event.browserEvent,\n        anchor: event.anchor,\n        isStickyScroll\n    };\n}\nfunction dfs(node, fn) {\n    fn(node);\n    node.children.forEach(child => dfs(child, fn));\n}\n/**\n * The trait concept needs to exist at the tree level, because collapsed\n * tree nodes will not be known by the list.\n */\nclass Trait {\n    get nodeSet() {\n        if (!this._nodeSet) {\n            this._nodeSet = this.createNodeSet();\n        }\n        return this._nodeSet;\n    }\n    constructor(getFirstViewElementWithTrait, identityProvider) {\n        this.getFirstViewElementWithTrait = getFirstViewElementWithTrait;\n        this.identityProvider = identityProvider;\n        this.nodes = [];\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n    }\n    set(nodes, browserEvent) {\n        if (!browserEvent?.__forceEvent && equals(this.nodes, nodes)) {\n            return;\n        }\n        this._set(nodes, false, browserEvent);\n    }\n    _set(nodes, silent, browserEvent) {\n        this.nodes = [...nodes];\n        this.elements = undefined;\n        this._nodeSet = undefined;\n        if (!silent) {\n            const that = this;\n            this._onDidChange.fire({ get elements() { return that.get(); }, browserEvent });\n        }\n    }\n    get() {\n        if (!this.elements) {\n            this.elements = this.nodes.map(node => node.element);\n        }\n        return [...this.elements];\n    }\n    getNodes() {\n        return this.nodes;\n    }\n    has(node) {\n        return this.nodeSet.has(node);\n    }\n    onDidModelSplice({ insertedNodes, deletedNodes }) {\n        if (!this.identityProvider) {\n            const set = this.createNodeSet();\n            const visit = (node) => set.delete(node);\n            deletedNodes.forEach(node => dfs(node, visit));\n            this.set([...set.values()]);\n            return;\n        }\n        const deletedNodesIdSet = new Set();\n        const deletedNodesVisitor = (node) => deletedNodesIdSet.add(this.identityProvider.getId(node.element).toString());\n        deletedNodes.forEach(node => dfs(node, deletedNodesVisitor));\n        const insertedNodesMap = new Map();\n        const insertedNodesVisitor = (node) => insertedNodesMap.set(this.identityProvider.getId(node.element).toString(), node);\n        insertedNodes.forEach(node => dfs(node, insertedNodesVisitor));\n        const nodes = [];\n        for (const node of this.nodes) {\n            const id = this.identityProvider.getId(node.element).toString();\n            const wasDeleted = deletedNodesIdSet.has(id);\n            if (!wasDeleted) {\n                nodes.push(node);\n            }\n            else {\n                const insertedNode = insertedNodesMap.get(id);\n                if (insertedNode && insertedNode.visible) {\n                    nodes.push(insertedNode);\n                }\n            }\n        }\n        if (this.nodes.length > 0 && nodes.length === 0) {\n            const node = this.getFirstViewElementWithTrait();\n            if (node) {\n                nodes.push(node);\n            }\n        }\n        this._set(nodes, true);\n    }\n    createNodeSet() {\n        const set = new Set();\n        for (const node of this.nodes) {\n            set.add(node);\n        }\n        return set;\n    }\n}\nclass TreeNodeListMouseController extends MouseController {\n    constructor(list, tree, stickyScrollProvider) {\n        super(list);\n        this.tree = tree;\n        this.stickyScrollProvider = stickyScrollProvider;\n    }\n    onViewPointer(e) {\n        if (isButton(e.browserEvent.target) ||\n            isInputElement(e.browserEvent.target) ||\n            isMonacoEditor(e.browserEvent.target)) {\n            return;\n        }\n        if (e.browserEvent.isHandledByList) {\n            return;\n        }\n        const node = e.element;\n        if (!node) {\n            return super.onViewPointer(e);\n        }\n        if (this.isSelectionRangeChangeEvent(e) || this.isSelectionSingleChangeEvent(e)) {\n            return super.onViewPointer(e);\n        }\n        const target = e.browserEvent.target;\n        const onTwistie = target.classList.contains('monaco-tl-twistie')\n            || (target.classList.contains('monaco-icon-label') && target.classList.contains('folder-icon') && e.browserEvent.offsetX < 16);\n        const isStickyElement = isStickyScrollElement(e.browserEvent.target);\n        let expandOnlyOnTwistieClick = false;\n        if (isStickyElement) {\n            expandOnlyOnTwistieClick = true;\n        }\n        else if (typeof this.tree.expandOnlyOnTwistieClick === 'function') {\n            expandOnlyOnTwistieClick = this.tree.expandOnlyOnTwistieClick(node.element);\n        }\n        else {\n            expandOnlyOnTwistieClick = !!this.tree.expandOnlyOnTwistieClick;\n        }\n        if (!isStickyElement) {\n            if (expandOnlyOnTwistieClick && !onTwistie && e.browserEvent.detail !== 2) {\n                return super.onViewPointer(e);\n            }\n            if (!this.tree.expandOnDoubleClick && e.browserEvent.detail === 2) {\n                return super.onViewPointer(e);\n            }\n        }\n        else {\n            this.handleStickyScrollMouseEvent(e, node);\n        }\n        if (node.collapsible && (!isStickyElement || onTwistie)) {\n            const location = this.tree.getNodeLocation(node);\n            const recursive = e.browserEvent.altKey;\n            this.tree.setFocus([location]);\n            this.tree.toggleCollapsed(location, recursive);\n            if (onTwistie) {\n                // Do not set this before calling a handler on the super class, because it will reject it as handled\n                e.browserEvent.isHandledByList = true;\n                return;\n            }\n        }\n        if (!isStickyElement) {\n            super.onViewPointer(e);\n        }\n    }\n    handleStickyScrollMouseEvent(e, node) {\n        if (isMonacoCustomToggle(e.browserEvent.target) || isActionItem(e.browserEvent.target)) {\n            return;\n        }\n        const stickyScrollController = this.stickyScrollProvider();\n        if (!stickyScrollController) {\n            throw new Error('Sticky scroll controller not found');\n        }\n        const nodeIndex = this.list.indexOf(node);\n        const elementScrollTop = this.list.getElementTop(nodeIndex);\n        const elementTargetViewTop = stickyScrollController.nodePositionTopBelowWidget(node);\n        this.tree.scrollTop = elementScrollTop - elementTargetViewTop;\n        this.list.domFocus();\n        this.list.setFocus([nodeIndex]);\n        this.list.setSelection([nodeIndex]);\n    }\n    onDoubleClick(e) {\n        const onTwistie = e.browserEvent.target.classList.contains('monaco-tl-twistie');\n        if (onTwistie || !this.tree.expandOnDoubleClick) {\n            return;\n        }\n        if (e.browserEvent.isHandledByList) {\n            return;\n        }\n        super.onDoubleClick(e);\n    }\n    // to make sure dom focus is not stolen (for example with context menu)\n    onMouseDown(e) {\n        const target = e.browserEvent.target;\n        if (!isStickyScrollContainer(target) && !isStickyScrollElement(target)) {\n            super.onMouseDown(e);\n            return;\n        }\n    }\n    onContextMenu(e) {\n        const target = e.browserEvent.target;\n        if (!isStickyScrollContainer(target) && !isStickyScrollElement(target)) {\n            super.onContextMenu(e);\n            return;\n        }\n    }\n}\n/**\n * We use this List subclass to restore selection and focus as nodes\n * get rendered in the list, possibly due to a node expand() call.\n */\nclass TreeNodeList extends List {\n    constructor(user, container, virtualDelegate, renderers, focusTrait, selectionTrait, anchorTrait, options) {\n        super(user, container, virtualDelegate, renderers, options);\n        this.focusTrait = focusTrait;\n        this.selectionTrait = selectionTrait;\n        this.anchorTrait = anchorTrait;\n    }\n    createMouseController(options) {\n        return new TreeNodeListMouseController(this, options.tree, options.stickyScrollProvider);\n    }\n    splice(start, deleteCount, elements = []) {\n        super.splice(start, deleteCount, elements);\n        if (elements.length === 0) {\n            return;\n        }\n        const additionalFocus = [];\n        const additionalSelection = [];\n        let anchor;\n        elements.forEach((node, index) => {\n            if (this.focusTrait.has(node)) {\n                additionalFocus.push(start + index);\n            }\n            if (this.selectionTrait.has(node)) {\n                additionalSelection.push(start + index);\n            }\n            if (this.anchorTrait.has(node)) {\n                anchor = start + index;\n            }\n        });\n        if (additionalFocus.length > 0) {\n            super.setFocus(distinct([...super.getFocus(), ...additionalFocus]));\n        }\n        if (additionalSelection.length > 0) {\n            super.setSelection(distinct([...super.getSelection(), ...additionalSelection]));\n        }\n        if (typeof anchor === 'number') {\n            super.setAnchor(anchor);\n        }\n    }\n    setFocus(indexes, browserEvent, fromAPI = false) {\n        super.setFocus(indexes, browserEvent);\n        if (!fromAPI) {\n            this.focusTrait.set(indexes.map(i => this.element(i)), browserEvent);\n        }\n    }\n    setSelection(indexes, browserEvent, fromAPI = false) {\n        super.setSelection(indexes, browserEvent);\n        if (!fromAPI) {\n            this.selectionTrait.set(indexes.map(i => this.element(i)), browserEvent);\n        }\n    }\n    setAnchor(index, fromAPI = false) {\n        super.setAnchor(index);\n        if (!fromAPI) {\n            if (typeof index === 'undefined') {\n                this.anchorTrait.set([]);\n            }\n            else {\n                this.anchorTrait.set([this.element(index)]);\n            }\n        }\n    }\n}\nexport class AbstractTree {\n    get onDidScroll() { return this.view.onDidScroll; }\n    get onDidChangeFocus() { return this.eventBufferer.wrapEvent(this.focus.onDidChange); }\n    get onDidChangeSelection() { return this.eventBufferer.wrapEvent(this.selection.onDidChange); }\n    get onMouseDblClick() { return Event.filter(Event.map(this.view.onMouseDblClick, asTreeMouseEvent), e => e.target !== TreeMouseEventTarget.Filter); }\n    get onMouseOver() { return Event.map(this.view.onMouseOver, asTreeMouseEvent); }\n    get onMouseOut() { return Event.map(this.view.onMouseOut, asTreeMouseEvent); }\n    get onContextMenu() { return Event.any(Event.filter(Event.map(this.view.onContextMenu, asTreeContextMenuEvent), e => !e.isStickyScroll), this.stickyScrollController?.onContextMenu ?? Event.None); }\n    get onPointer() { return Event.map(this.view.onPointer, asTreeMouseEvent); }\n    get onKeyDown() { return this.view.onKeyDown; }\n    get onDidFocus() { return this.view.onDidFocus; }\n    get onDidChangeModel() { return Event.signal(this.model.onDidSplice); }\n    get onDidChangeCollapseState() { return this.model.onDidChangeCollapseState; }\n    get findMode() { return this.findController?.mode ?? TreeFindMode.Highlight; }\n    set findMode(findMode) { if (this.findController) {\n        this.findController.mode = findMode;\n    } }\n    get findMatchType() { return this.findController?.matchType ?? TreeFindMatchType.Fuzzy; }\n    set findMatchType(findFuzzy) { if (this.findController) {\n        this.findController.matchType = findFuzzy;\n    } }\n    get expandOnDoubleClick() { return typeof this._options.expandOnDoubleClick === 'undefined' ? true : this._options.expandOnDoubleClick; }\n    get expandOnlyOnTwistieClick() { return typeof this._options.expandOnlyOnTwistieClick === 'undefined' ? true : this._options.expandOnlyOnTwistieClick; }\n    get onDidDispose() { return this.view.onDidDispose; }\n    constructor(_user, container, delegate, renderers, _options = {}) {\n        this._user = _user;\n        this._options = _options;\n        this.eventBufferer = new EventBufferer();\n        this.onDidChangeFindOpenState = Event.None;\n        this.onDidChangeStickyScrollFocused = Event.None;\n        this.disposables = new DisposableStore();\n        this._onWillRefilter = new Emitter();\n        this.onWillRefilter = this._onWillRefilter.event;\n        this._onDidUpdateOptions = new Emitter();\n        this.treeDelegate = new ComposedTreeDelegate(delegate);\n        const onDidChangeCollapseStateRelay = new Relay();\n        const onDidChangeActiveNodes = new Relay();\n        const activeNodes = this.disposables.add(new EventCollection(onDidChangeActiveNodes.event));\n        const renderedIndentGuides = new SetMap();\n        this.renderers = renderers.map(r => new TreeRenderer(r, () => this.model, onDidChangeCollapseStateRelay.event, activeNodes, renderedIndentGuides, _options));\n        for (const r of this.renderers) {\n            this.disposables.add(r);\n        }\n        let filter;\n        if (_options.keyboardNavigationLabelProvider) {\n            filter = new FindFilter(this, _options.keyboardNavigationLabelProvider, _options.filter);\n            _options = { ..._options, filter: filter }; // TODO need typescript help here\n            this.disposables.add(filter);\n        }\n        this.focus = new Trait(() => this.view.getFocusedElements()[0], _options.identityProvider);\n        this.selection = new Trait(() => this.view.getSelectedElements()[0], _options.identityProvider);\n        this.anchor = new Trait(() => this.view.getAnchorElement(), _options.identityProvider);\n        this.view = new TreeNodeList(_user, container, this.treeDelegate, this.renderers, this.focus, this.selection, this.anchor, { ...asListOptions(() => this.model, _options), tree: this, stickyScrollProvider: () => this.stickyScrollController });\n        this.model = this.createModel(_user, this.view, _options);\n        onDidChangeCollapseStateRelay.input = this.model.onDidChangeCollapseState;\n        const onDidModelSplice = Event.forEach(this.model.onDidSplice, e => {\n            this.eventBufferer.bufferEvents(() => {\n                this.focus.onDidModelSplice(e);\n                this.selection.onDidModelSplice(e);\n            });\n        }, this.disposables);\n        // Make sure the `forEach` always runs\n        onDidModelSplice(() => null, null, this.disposables);\n        // Active nodes can change when the model changes or when focus or selection change.\n        // We debounce it with 0 delay since these events may fire in the same stack and we only\n        // want to run this once. It also doesn't matter if it runs on the next tick since it's only\n        // a nice to have UI feature.\n        const activeNodesEmitter = this.disposables.add(new Emitter());\n        const activeNodesDebounce = this.disposables.add(new Delayer(0));\n        this.disposables.add(Event.any(onDidModelSplice, this.focus.onDidChange, this.selection.onDidChange)(() => {\n            activeNodesDebounce.trigger(() => {\n                const set = new Set();\n                for (const node of this.focus.getNodes()) {\n                    set.add(node);\n                }\n                for (const node of this.selection.getNodes()) {\n                    set.add(node);\n                }\n                activeNodesEmitter.fire([...set.values()]);\n            });\n        }));\n        onDidChangeActiveNodes.input = activeNodesEmitter.event;\n        if (_options.keyboardSupport !== false) {\n            const onKeyDown = Event.chain(this.view.onKeyDown, $ => $.filter(e => !isInputElement(e.target))\n                .map(e => new StandardKeyboardEvent(e)));\n            Event.chain(onKeyDown, $ => $.filter(e => e.keyCode === 15 /* KeyCode.LeftArrow */))(this.onLeftArrow, this, this.disposables);\n            Event.chain(onKeyDown, $ => $.filter(e => e.keyCode === 17 /* KeyCode.RightArrow */))(this.onRightArrow, this, this.disposables);\n            Event.chain(onKeyDown, $ => $.filter(e => e.keyCode === 10 /* KeyCode.Space */))(this.onSpace, this, this.disposables);\n        }\n        if ((_options.findWidgetEnabled ?? true) && _options.keyboardNavigationLabelProvider && _options.contextViewProvider) {\n            const opts = this.options.findWidgetStyles ? { styles: this.options.findWidgetStyles } : undefined;\n            this.findController = new FindController(this, this.model, this.view, filter, _options.contextViewProvider, opts);\n            this.focusNavigationFilter = node => this.findController.shouldAllowFocus(node);\n            this.onDidChangeFindOpenState = this.findController.onDidChangeOpenState;\n            this.disposables.add(this.findController);\n            this.onDidChangeFindMode = this.findController.onDidChangeMode;\n            this.onDidChangeFindMatchType = this.findController.onDidChangeMatchType;\n        }\n        else {\n            this.onDidChangeFindMode = Event.None;\n            this.onDidChangeFindMatchType = Event.None;\n        }\n        if (_options.enableStickyScroll) {\n            this.stickyScrollController = new StickyScrollController(this, this.model, this.view, this.renderers, this.treeDelegate, _options);\n            this.onDidChangeStickyScrollFocused = this.stickyScrollController.onDidChangeHasFocus;\n        }\n        this.styleElement = createStyleSheet(this.view.getHTMLElement());\n        this.getHTMLElement().classList.toggle('always', this._options.renderIndentGuides === RenderIndentGuides.Always);\n    }\n    updateOptions(optionsUpdate = {}) {\n        this._options = { ...this._options, ...optionsUpdate };\n        for (const renderer of this.renderers) {\n            renderer.updateOptions(optionsUpdate);\n        }\n        this.view.updateOptions(this._options);\n        this.findController?.updateOptions(optionsUpdate);\n        this.updateStickyScroll(optionsUpdate);\n        this._onDidUpdateOptions.fire(this._options);\n        this.getHTMLElement().classList.toggle('always', this._options.renderIndentGuides === RenderIndentGuides.Always);\n    }\n    get options() {\n        return this._options;\n    }\n    updateStickyScroll(optionsUpdate) {\n        if (!this.stickyScrollController && this._options.enableStickyScroll) {\n            this.stickyScrollController = new StickyScrollController(this, this.model, this.view, this.renderers, this.treeDelegate, this._options);\n            this.onDidChangeStickyScrollFocused = this.stickyScrollController.onDidChangeHasFocus;\n        }\n        else if (this.stickyScrollController && !this._options.enableStickyScroll) {\n            this.onDidChangeStickyScrollFocused = Event.None;\n            this.stickyScrollController.dispose();\n            this.stickyScrollController = undefined;\n        }\n        this.stickyScrollController?.updateOptions(optionsUpdate);\n    }\n    // Widget\n    getHTMLElement() {\n        return this.view.getHTMLElement();\n    }\n    get scrollTop() {\n        return this.view.scrollTop;\n    }\n    set scrollTop(scrollTop) {\n        this.view.scrollTop = scrollTop;\n    }\n    get scrollHeight() {\n        return this.view.scrollHeight;\n    }\n    get renderHeight() {\n        return this.view.renderHeight;\n    }\n    get ariaLabel() {\n        return this.view.ariaLabel;\n    }\n    set ariaLabel(value) {\n        this.view.ariaLabel = value;\n    }\n    domFocus() {\n        if (this.stickyScrollController?.focusedLast()) {\n            this.stickyScrollController.domFocus();\n        }\n        else {\n            this.view.domFocus();\n        }\n    }\n    layout(height, width) {\n        this.view.layout(height, width);\n        if (isNumber(width)) {\n            this.findController?.layout(width);\n        }\n    }\n    style(styles) {\n        const suffix = `.${this.view.domId}`;\n        const content = [];\n        if (styles.treeIndentGuidesStroke) {\n            content.push(`.monaco-list${suffix}:hover .monaco-tl-indent > .indent-guide, .monaco-list${suffix}.always .monaco-tl-indent > .indent-guide  { border-color: ${styles.treeInactiveIndentGuidesStroke}; }`);\n            content.push(`.monaco-list${suffix} .monaco-tl-indent > .indent-guide.active { border-color: ${styles.treeIndentGuidesStroke}; }`);\n        }\n        // Sticky Scroll Background\n        const stickyScrollBackground = styles.treeStickyScrollBackground ?? styles.listBackground;\n        if (stickyScrollBackground) {\n            content.push(`.monaco-list${suffix} .monaco-scrollable-element .monaco-tree-sticky-container { background-color: ${stickyScrollBackground}; }`);\n            content.push(`.monaco-list${suffix} .monaco-scrollable-element .monaco-tree-sticky-container .monaco-tree-sticky-row { background-color: ${stickyScrollBackground}; }`);\n        }\n        // Sticky Scroll Border\n        if (styles.treeStickyScrollBorder) {\n            content.push(`.monaco-list${suffix} .monaco-scrollable-element .monaco-tree-sticky-container { border-bottom: 1px solid ${styles.treeStickyScrollBorder}; }`);\n        }\n        // Sticky Scroll Shadow\n        if (styles.treeStickyScrollShadow) {\n            content.push(`.monaco-list${suffix} .monaco-scrollable-element .monaco-tree-sticky-container .monaco-tree-sticky-container-shadow { box-shadow: ${styles.treeStickyScrollShadow} 0 6px 6px -6px inset; height: 3px; }`);\n        }\n        // Sticky Scroll Focus\n        if (styles.listFocusForeground) {\n            content.push(`.monaco-list${suffix}.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused { color: ${styles.listFocusForeground}; }`);\n            content.push(`.monaco-list${suffix}:not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused { color: inherit; }`);\n        }\n        // Sticky Scroll Focus Outlines\n        const focusAndSelectionOutline = asCssValueWithDefault(styles.listFocusAndSelectionOutline, asCssValueWithDefault(styles.listSelectionOutline, styles.listFocusOutline ?? ''));\n        if (focusAndSelectionOutline) { // default: listFocusOutline\n            content.push(`.monaco-list${suffix}.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused.selected { outline: 1px solid ${focusAndSelectionOutline}; outline-offset: -1px;}`);\n            content.push(`.monaco-list${suffix}:not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused.selected { outline: inherit;}`);\n        }\n        if (styles.listFocusOutline) { // default: set\n            content.push(`.monaco-list${suffix}.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused { outline: 1px solid ${styles.listFocusOutline}; outline-offset: -1px; }`);\n            content.push(`.monaco-list${suffix}:not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused { outline: inherit; }`);\n            content.push(`.monaco-workbench.context-menu-visible .monaco-list${suffix}.last-focused.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.passive-focused { outline: 1px solid ${styles.listFocusOutline}; outline-offset: -1px; }`);\n            content.push(`.monaco-workbench.context-menu-visible .monaco-list${suffix}.last-focused.sticky-scroll-focused .monaco-list-rows .monaco-list-row.focused { outline: inherit; }`);\n            content.push(`.monaco-workbench.context-menu-visible .monaco-list${suffix}.last-focused:not(.sticky-scroll-focused) .monaco-tree-sticky-container .monaco-list-rows .monaco-list-row.focused { outline: inherit; }`);\n        }\n        this.styleElement.textContent = content.join('\\n');\n        this.view.style(styles);\n    }\n    // Tree navigation\n    getParentElement(location) {\n        const parentRef = this.model.getParentNodeLocation(location);\n        const parentNode = this.model.getNode(parentRef);\n        return parentNode.element;\n    }\n    getFirstElementChild(location) {\n        return this.model.getFirstElementChild(location);\n    }\n    // Tree\n    getNode(location) {\n        return this.model.getNode(location);\n    }\n    getNodeLocation(node) {\n        return this.model.getNodeLocation(node);\n    }\n    collapse(location, recursive = false) {\n        return this.model.setCollapsed(location, true, recursive);\n    }\n    expand(location, recursive = false) {\n        return this.model.setCollapsed(location, false, recursive);\n    }\n    toggleCollapsed(location, recursive = false) {\n        return this.model.setCollapsed(location, undefined, recursive);\n    }\n    isCollapsible(location) {\n        return this.model.isCollapsible(location);\n    }\n    setCollapsible(location, collapsible) {\n        return this.model.setCollapsible(location, collapsible);\n    }\n    isCollapsed(location) {\n        return this.model.isCollapsed(location);\n    }\n    refilter() {\n        this._onWillRefilter.fire(undefined);\n        this.model.refilter();\n    }\n    setSelection(elements, browserEvent) {\n        this.eventBufferer.bufferEvents(() => {\n            const nodes = elements.map(e => this.model.getNode(e));\n            this.selection.set(nodes, browserEvent);\n            const indexes = elements.map(e => this.model.getListIndex(e)).filter(i => i > -1);\n            this.view.setSelection(indexes, browserEvent, true);\n        });\n    }\n    getSelection() {\n        return this.selection.get();\n    }\n    setFocus(elements, browserEvent) {\n        this.eventBufferer.bufferEvents(() => {\n            const nodes = elements.map(e => this.model.getNode(e));\n            this.focus.set(nodes, browserEvent);\n            const indexes = elements.map(e => this.model.getListIndex(e)).filter(i => i > -1);\n            this.view.setFocus(indexes, browserEvent, true);\n        });\n    }\n    focusNext(n = 1, loop = false, browserEvent, filter = (isKeyboardEvent(browserEvent) && browserEvent.altKey) ? undefined : this.focusNavigationFilter) {\n        this.view.focusNext(n, loop, browserEvent, filter);\n    }\n    focusPrevious(n = 1, loop = false, browserEvent, filter = (isKeyboardEvent(browserEvent) && browserEvent.altKey) ? undefined : this.focusNavigationFilter) {\n        this.view.focusPrevious(n, loop, browserEvent, filter);\n    }\n    focusNextPage(browserEvent, filter = (isKeyboardEvent(browserEvent) && browserEvent.altKey) ? undefined : this.focusNavigationFilter) {\n        return this.view.focusNextPage(browserEvent, filter);\n    }\n    focusPreviousPage(browserEvent, filter = (isKeyboardEvent(browserEvent) && browserEvent.altKey) ? undefined : this.focusNavigationFilter) {\n        return this.view.focusPreviousPage(browserEvent, filter, () => this.stickyScrollController?.height ?? 0);\n    }\n    focusLast(browserEvent, filter = (isKeyboardEvent(browserEvent) && browserEvent.altKey) ? undefined : this.focusNavigationFilter) {\n        this.view.focusLast(browserEvent, filter);\n    }\n    focusFirst(browserEvent, filter = (isKeyboardEvent(browserEvent) && browserEvent.altKey) ? undefined : this.focusNavigationFilter) {\n        this.view.focusFirst(browserEvent, filter);\n    }\n    getFocus() {\n        return this.focus.get();\n    }\n    reveal(location, relativeTop) {\n        this.model.expandTo(location);\n        const index = this.model.getListIndex(location);\n        if (index === -1) {\n            return;\n        }\n        if (!this.stickyScrollController) {\n            this.view.reveal(index, relativeTop);\n        }\n        else {\n            const paddingTop = this.stickyScrollController.nodePositionTopBelowWidget(this.getNode(location));\n            this.view.reveal(index, relativeTop, paddingTop);\n        }\n    }\n    // List\n    onLeftArrow(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const nodes = this.view.getFocusedElements();\n        if (nodes.length === 0) {\n            return;\n        }\n        const node = nodes[0];\n        const location = this.model.getNodeLocation(node);\n        const didChange = this.model.setCollapsed(location, true);\n        if (!didChange) {\n            const parentLocation = this.model.getParentNodeLocation(location);\n            if (!parentLocation) {\n                return;\n            }\n            const parentListIndex = this.model.getListIndex(parentLocation);\n            this.view.reveal(parentListIndex);\n            this.view.setFocus([parentListIndex]);\n        }\n    }\n    onRightArrow(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const nodes = this.view.getFocusedElements();\n        if (nodes.length === 0) {\n            return;\n        }\n        const node = nodes[0];\n        const location = this.model.getNodeLocation(node);\n        const didChange = this.model.setCollapsed(location, false);\n        if (!didChange) {\n            if (!node.children.some(child => child.visible)) {\n                return;\n            }\n            const [focusedIndex] = this.view.getFocus();\n            const firstChildIndex = focusedIndex + 1;\n            this.view.reveal(firstChildIndex);\n            this.view.setFocus([firstChildIndex]);\n        }\n    }\n    onSpace(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const nodes = this.view.getFocusedElements();\n        if (nodes.length === 0) {\n            return;\n        }\n        const node = nodes[0];\n        const location = this.model.getNodeLocation(node);\n        const recursive = e.browserEvent.altKey;\n        this.model.setCollapsed(location, undefined, recursive);\n    }\n    dispose() {\n        dispose(this.disposables);\n        this.stickyScrollController?.dispose();\n        this.view.dispose();\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}