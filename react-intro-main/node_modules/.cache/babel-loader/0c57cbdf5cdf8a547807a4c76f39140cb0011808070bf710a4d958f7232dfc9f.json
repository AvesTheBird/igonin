{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Shape from '../Shape';\nimport Rectangle from '../Rectangle';\nimport { DEFAULT_STARTSIZE, DIRECTION, LINE_ARCSIZE, NONE, RECTANGLE_ROUNDING_FACTOR } from '../../../util/Constants';\n/**\n * Extends {@link Shape} to implement a swimlane shape.\n * This shape is registered under {@link mxConstants.SHAPE_SWIMLANE} in {@link mxCellRenderer}.\n * Use the {@link mxConstants.STYLE_STYLE_STARTSIZE} to define the size of the title\n * region, `'swimLaneFillColor'` for the content area fill,\n * `'separatorColor'` to draw an additional vertical separator and\n * {@link mxConstants.STYLE_SWIMLANE_LINE} to hide the line between the title region and\n * the content area.\n * The {@link 'horizontal'} affects the orientation of this shape,\n * not only its label.\n *\n * @class SwimlaneShape\n * @extends {Shape}\n */\nclass SwimlaneShape extends Shape {\n  constructor(bounds, fill, stroke, strokeWidth = 1) {\n    super();\n    /**\n     * Default imagewidth and imageheight if an image but no imagewidth\n     * and imageheight are defined in the style. Value is 16.\n     * @type {number}\n     * @default 16\n     */\n    this.imageSize = 16;\n    this.imageSrc = null;\n    this.bounds = bounds;\n    this.fill = fill;\n    this.stroke = stroke;\n    this.strokeWidth = strokeWidth;\n  }\n  /**\n   * Adds roundable support.\n   * @param {mxAbstractCanvas2D} c\n   * @param {number} x\n   * @param {number} y\n   * @param {number} w\n   * @param {number} h\n   * @returns {boolean}\n   */\n  isRoundable(c, x, y, w, h) {\n    return true;\n  }\n  /**\n   * Returns the bounding box for the gradient box for this shape.\n   */\n  getTitleSize() {\n    return Math.max(0, this.style?.startSize ?? DEFAULT_STARTSIZE);\n  }\n  /**\n   * Returns the bounding box for the gradient box for this shape.\n   */\n  getLabelBounds(rect) {\n    const start = this.getTitleSize();\n    const bounds = new Rectangle(rect.x, rect.y, rect.width, rect.height);\n    const horizontal = this.isHorizontal();\n    const flipH = this.style?.flipH ?? false;\n    const flipV = this.style?.flipV ?? false;\n    // East is default\n    const shapeVertical = this.direction === DIRECTION.NORTH || this.direction === DIRECTION.SOUTH;\n    const realHorizontal = horizontal == !shapeVertical;\n    const realFlipH = !realHorizontal && flipH !== (this.direction === DIRECTION.SOUTH || this.direction === DIRECTION.WEST);\n    const realFlipV = realHorizontal && flipV !== (this.direction === DIRECTION.SOUTH || this.direction === DIRECTION.WEST);\n    // Shape is horizontal\n    if (!shapeVertical) {\n      const tmp = Math.min(bounds.height, start * this.scale);\n      if (realFlipH || realFlipV) {\n        bounds.y += bounds.height - tmp;\n      }\n      bounds.height = tmp;\n    } else {\n      const tmp = Math.min(bounds.width, start * this.scale);\n      if (realFlipH || realFlipV) {\n        bounds.x += bounds.width - tmp;\n      }\n      bounds.width = tmp;\n    }\n    return bounds;\n  }\n  /**\n   * Returns the bounding box for the gradient box for this shape.\n   */\n  getGradientBounds(c, x, y, w, h) {\n    let start = this.getTitleSize();\n    if (this.isHorizontal()) {\n      start = Math.min(start, h);\n      return new Rectangle(x, y, w, start);\n    }\n    start = Math.min(start, w);\n    return new Rectangle(x, y, start, h);\n  }\n  /**\n   * Returns the arcsize for the swimlane.\n   */\n  getSwimlaneArcSize(w, h, start) {\n    if (this.style?.absoluteArcSize ?? false) {\n      return Math.min(w / 2, Math.min(h / 2, this.style?.arcSize ?? LINE_ARCSIZE / 2));\n    }\n    const f = (this.style?.arcSize ?? RECTANGLE_ROUNDING_FACTOR * 100) / 100;\n    return start * f * 3;\n  }\n  /**\n   * Paints the swimlane vertex shape.\n   */\n  isHorizontal() {\n    return this.style?.horizontal ?? true;\n  }\n  /**\n   * Paints the swimlane vertex shape.\n   */\n  paintVertexShape(c, x, y, w, h) {\n    let start = this.getTitleSize();\n    const fill = this.style?.swimlaneFillColor ?? NONE;\n    const swimlaneLine = this.style?.swimlaneLine ?? true;\n    let r = 0;\n    if (this.isHorizontal()) {\n      start = Math.min(start, h);\n    } else {\n      start = Math.min(start, w);\n    }\n    c.translate(x, y);\n    if (!this.isRounded) {\n      this.paintSwimlane(c, x, y, w, h, start, fill, swimlaneLine);\n    } else {\n      r = this.getSwimlaneArcSize(w, h, start);\n      r = Math.min((this.isHorizontal() ? h : w) - start, Math.min(start, r));\n      this.paintRoundedSwimlane(c, x, y, w, h, start, r, fill, swimlaneLine);\n    }\n    const sep = this.style?.separatorColor ?? NONE;\n    this.paintSeparator(c, x, y, w, h, start, sep);\n    if (this.imageSrc) {\n      const bounds = this.getImageBounds(x, y, w, h);\n      c.image(bounds.x - x, bounds.y - y, bounds.width, bounds.height, this.imageSrc, false, false, false);\n    }\n    if (this.glass) {\n      c.setShadow(false);\n      this.paintGlassEffect(c, 0, 0, w, start, r);\n    }\n  }\n  /**\n   * Paints the swimlane vertex shape.\n   */\n  paintSwimlane(c, x, y, w, h, start, fill, swimlaneLine) {\n    c.begin();\n    let events = true;\n    if (this.style && this.style.pointerEvents != null) {\n      events = this.style.pointerEvents;\n    }\n    if (!events && this.fill === NONE) {\n      c.pointerEvents = false;\n    }\n    if (this.isHorizontal()) {\n      c.moveTo(0, start);\n      c.lineTo(0, 0);\n      c.lineTo(w, 0);\n      c.lineTo(w, start);\n      c.fillAndStroke();\n      if (start < h) {\n        if (fill === NONE || !events) {\n          c.pointerEvents = false;\n        }\n        if (fill !== NONE) {\n          c.setFillColor(fill);\n        }\n        c.begin();\n        c.moveTo(0, start);\n        c.lineTo(0, h);\n        c.lineTo(w, h);\n        c.lineTo(w, start);\n        if (fill === NONE) {\n          c.stroke();\n        } else {\n          c.fillAndStroke();\n        }\n      }\n    } else {\n      c.moveTo(start, 0);\n      c.lineTo(0, 0);\n      c.lineTo(0, h);\n      c.lineTo(start, h);\n      c.fillAndStroke();\n      if (start < w) {\n        if (fill === NONE || !events) {\n          c.pointerEvents = false;\n        }\n        if (fill !== NONE) {\n          c.setFillColor(fill);\n        }\n        c.begin();\n        c.moveTo(start, 0);\n        c.lineTo(w, 0);\n        c.lineTo(w, h);\n        c.lineTo(start, h);\n        if (fill === NONE) {\n          c.stroke();\n        } else {\n          c.fillAndStroke();\n        }\n      }\n    }\n    if (swimlaneLine) {\n      this.paintDivider(c, x, y, w, h, start, fill === NONE);\n    }\n  }\n  /**\n   * Paints the swimlane vertex shape.\n   */\n  paintRoundedSwimlane(c, x, y, w, h, start, r, fill, swimlaneLine) {\n    c.begin();\n    let events = true;\n    if (this.style && this.style.pointerEvents != null) {\n      events = this.style.pointerEvents;\n    }\n    if (!events && this.fill === NONE) {\n      c.pointerEvents = false;\n    }\n    if (this.isHorizontal()) {\n      c.moveTo(w, start);\n      c.lineTo(w, r);\n      c.quadTo(w, 0, w - Math.min(w / 2, r), 0);\n      c.lineTo(Math.min(w / 2, r), 0);\n      c.quadTo(0, 0, 0, r);\n      c.lineTo(0, start);\n      c.fillAndStroke();\n      if (start < h) {\n        if (fill === NONE || !events) {\n          c.pointerEvents = false;\n        }\n        if (fill !== NONE) {\n          c.setFillColor(fill);\n        }\n        c.begin();\n        c.moveTo(0, start);\n        c.lineTo(0, h - r);\n        c.quadTo(0, h, Math.min(w / 2, r), h);\n        c.lineTo(w - Math.min(w / 2, r), h);\n        c.quadTo(w, h, w, h - r);\n        c.lineTo(w, start);\n        if (fill === NONE) {\n          c.stroke();\n        } else {\n          c.fillAndStroke();\n        }\n      }\n    } else {\n      c.moveTo(start, 0);\n      c.lineTo(r, 0);\n      c.quadTo(0, 0, 0, Math.min(h / 2, r));\n      c.lineTo(0, h - Math.min(h / 2, r));\n      c.quadTo(0, h, r, h);\n      c.lineTo(start, h);\n      c.fillAndStroke();\n      if (start < w) {\n        if (fill === NONE || !events) {\n          c.pointerEvents = false;\n        }\n        if (fill !== NONE) {\n          c.setFillColor(fill);\n        }\n        c.begin();\n        c.moveTo(start, h);\n        c.lineTo(w - r, h);\n        c.quadTo(w, h, w, h - Math.min(h / 2, r));\n        c.lineTo(w, Math.min(h / 2, r));\n        c.quadTo(w, 0, w - r, 0);\n        c.lineTo(start, 0);\n        if (fill === NONE) {\n          c.stroke();\n        } else {\n          c.fillAndStroke();\n        }\n      }\n    }\n    if (swimlaneLine) {\n      this.paintDivider(c, x, y, w, h, start, fill === NONE);\n    }\n  }\n  /**\n   * Paints the divider between swimlane title and content area.\n   */\n  paintDivider(c, x, y, w, h, start, shadow) {\n    if (!shadow) {\n      c.setShadow(false);\n    }\n    c.begin();\n    if (this.isHorizontal()) {\n      c.moveTo(0, start);\n      c.lineTo(w, start);\n    } else {\n      c.moveTo(start, 0);\n      c.lineTo(start, h);\n    }\n    c.stroke();\n  }\n  /**\n   * Paints the vertical or horizontal separator line between swimlanes.\n   */\n  paintSeparator(c, x, y, w, h, start, color) {\n    if (color !== NONE) {\n      c.setStrokeColor(color);\n      c.setDashed(true);\n      c.begin();\n      if (this.isHorizontal()) {\n        c.moveTo(w, start);\n        c.lineTo(w, h);\n      } else {\n        c.moveTo(start, 0);\n        c.lineTo(w, 0);\n      }\n      c.stroke();\n      c.setDashed(false);\n    }\n  }\n  /**\n   * Paints the swimlane vertex shape.\n   */\n  getImageBounds(x, y, w, h) {\n    if (this.isHorizontal()) {\n      return new Rectangle(x + w - this.imageSize, y, this.imageSize, this.imageSize);\n    }\n    return new Rectangle(x, y, this.imageSize, this.imageSize);\n  }\n}\nexport default SwimlaneShape;","map":{"version":3,"names":["Shape","Rectangle","DEFAULT_STARTSIZE","DIRECTION","LINE_ARCSIZE","NONE","RECTANGLE_ROUNDING_FACTOR","SwimlaneShape","constructor","bounds","fill","stroke","strokeWidth","imageSize","imageSrc","isRoundable","c","x","y","w","h","getTitleSize","Math","max","style","startSize","getLabelBounds","rect","start","width","height","horizontal","isHorizontal","flipH","flipV","shapeVertical","direction","NORTH","SOUTH","realHorizontal","realFlipH","WEST","realFlipV","tmp","min","scale","getGradientBounds","getSwimlaneArcSize","absoluteArcSize","arcSize","f","paintVertexShape","swimlaneFillColor","swimlaneLine","r","translate","isRounded","paintSwimlane","paintRoundedSwimlane","sep","separatorColor","paintSeparator","getImageBounds","image","glass","setShadow","paintGlassEffect","begin","events","pointerEvents","moveTo","lineTo","fillAndStroke","setFillColor","paintDivider","quadTo","shadow","color","setStrokeColor","setDashed"],"sources":["D:/OSPanel/domains/old/react/react-intro-main/node_modules/@maxgraph/core/dist/view/geometry/node/SwimlaneShape.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Shape from '../Shape';\nimport Rectangle from '../Rectangle';\nimport { DEFAULT_STARTSIZE, DIRECTION, LINE_ARCSIZE, NONE, RECTANGLE_ROUNDING_FACTOR, } from '../../../util/Constants';\n/**\n * Extends {@link Shape} to implement a swimlane shape.\n * This shape is registered under {@link mxConstants.SHAPE_SWIMLANE} in {@link mxCellRenderer}.\n * Use the {@link mxConstants.STYLE_STYLE_STARTSIZE} to define the size of the title\n * region, `'swimLaneFillColor'` for the content area fill,\n * `'separatorColor'` to draw an additional vertical separator and\n * {@link mxConstants.STYLE_SWIMLANE_LINE} to hide the line between the title region and\n * the content area.\n * The {@link 'horizontal'} affects the orientation of this shape,\n * not only its label.\n *\n * @class SwimlaneShape\n * @extends {Shape}\n */\nclass SwimlaneShape extends Shape {\n    constructor(bounds, fill, stroke, strokeWidth = 1) {\n        super();\n        /**\n         * Default imagewidth and imageheight if an image but no imagewidth\n         * and imageheight are defined in the style. Value is 16.\n         * @type {number}\n         * @default 16\n         */\n        this.imageSize = 16;\n        this.imageSrc = null;\n        this.bounds = bounds;\n        this.fill = fill;\n        this.stroke = stroke;\n        this.strokeWidth = strokeWidth;\n    }\n    /**\n     * Adds roundable support.\n     * @param {mxAbstractCanvas2D} c\n     * @param {number} x\n     * @param {number} y\n     * @param {number} w\n     * @param {number} h\n     * @returns {boolean}\n     */\n    isRoundable(c, x, y, w, h) {\n        return true;\n    }\n    /**\n     * Returns the bounding box for the gradient box for this shape.\n     */\n    getTitleSize() {\n        return Math.max(0, this.style?.startSize ?? DEFAULT_STARTSIZE);\n    }\n    /**\n     * Returns the bounding box for the gradient box for this shape.\n     */\n    getLabelBounds(rect) {\n        const start = this.getTitleSize();\n        const bounds = new Rectangle(rect.x, rect.y, rect.width, rect.height);\n        const horizontal = this.isHorizontal();\n        const flipH = this.style?.flipH ?? false;\n        const flipV = this.style?.flipV ?? false;\n        // East is default\n        const shapeVertical = this.direction === DIRECTION.NORTH || this.direction === DIRECTION.SOUTH;\n        const realHorizontal = horizontal == !shapeVertical;\n        const realFlipH = !realHorizontal &&\n            flipH !== (this.direction === DIRECTION.SOUTH || this.direction === DIRECTION.WEST);\n        const realFlipV = realHorizontal &&\n            flipV !== (this.direction === DIRECTION.SOUTH || this.direction === DIRECTION.WEST);\n        // Shape is horizontal\n        if (!shapeVertical) {\n            const tmp = Math.min(bounds.height, start * this.scale);\n            if (realFlipH || realFlipV) {\n                bounds.y += bounds.height - tmp;\n            }\n            bounds.height = tmp;\n        }\n        else {\n            const tmp = Math.min(bounds.width, start * this.scale);\n            if (realFlipH || realFlipV) {\n                bounds.x += bounds.width - tmp;\n            }\n            bounds.width = tmp;\n        }\n        return bounds;\n    }\n    /**\n     * Returns the bounding box for the gradient box for this shape.\n     */\n    getGradientBounds(c, x, y, w, h) {\n        let start = this.getTitleSize();\n        if (this.isHorizontal()) {\n            start = Math.min(start, h);\n            return new Rectangle(x, y, w, start);\n        }\n        start = Math.min(start, w);\n        return new Rectangle(x, y, start, h);\n    }\n    /**\n     * Returns the arcsize for the swimlane.\n     */\n    getSwimlaneArcSize(w, h, start) {\n        if (this.style?.absoluteArcSize ?? false) {\n            return Math.min(w / 2, Math.min(h / 2, this.style?.arcSize ?? LINE_ARCSIZE / 2));\n        }\n        const f = (this.style?.arcSize ?? RECTANGLE_ROUNDING_FACTOR * 100) / 100;\n        return start * f * 3;\n    }\n    /**\n     * Paints the swimlane vertex shape.\n     */\n    isHorizontal() {\n        return this.style?.horizontal ?? true;\n    }\n    /**\n     * Paints the swimlane vertex shape.\n     */\n    paintVertexShape(c, x, y, w, h) {\n        let start = this.getTitleSize();\n        const fill = this.style?.swimlaneFillColor ?? NONE;\n        const swimlaneLine = this.style?.swimlaneLine ?? true;\n        let r = 0;\n        if (this.isHorizontal()) {\n            start = Math.min(start, h);\n        }\n        else {\n            start = Math.min(start, w);\n        }\n        c.translate(x, y);\n        if (!this.isRounded) {\n            this.paintSwimlane(c, x, y, w, h, start, fill, swimlaneLine);\n        }\n        else {\n            r = this.getSwimlaneArcSize(w, h, start);\n            r = Math.min((this.isHorizontal() ? h : w) - start, Math.min(start, r));\n            this.paintRoundedSwimlane(c, x, y, w, h, start, r, fill, swimlaneLine);\n        }\n        const sep = this.style?.separatorColor ?? NONE;\n        this.paintSeparator(c, x, y, w, h, start, sep);\n        if (this.imageSrc) {\n            const bounds = this.getImageBounds(x, y, w, h);\n            c.image(bounds.x - x, bounds.y - y, bounds.width, bounds.height, this.imageSrc, false, false, false);\n        }\n        if (this.glass) {\n            c.setShadow(false);\n            this.paintGlassEffect(c, 0, 0, w, start, r);\n        }\n    }\n    /**\n     * Paints the swimlane vertex shape.\n     */\n    paintSwimlane(c, x, y, w, h, start, fill, swimlaneLine) {\n        c.begin();\n        let events = true;\n        if (this.style && this.style.pointerEvents != null) {\n            events = this.style.pointerEvents;\n        }\n        if (!events && this.fill === NONE) {\n            c.pointerEvents = false;\n        }\n        if (this.isHorizontal()) {\n            c.moveTo(0, start);\n            c.lineTo(0, 0);\n            c.lineTo(w, 0);\n            c.lineTo(w, start);\n            c.fillAndStroke();\n            if (start < h) {\n                if (fill === NONE || !events) {\n                    c.pointerEvents = false;\n                }\n                if (fill !== NONE) {\n                    c.setFillColor(fill);\n                }\n                c.begin();\n                c.moveTo(0, start);\n                c.lineTo(0, h);\n                c.lineTo(w, h);\n                c.lineTo(w, start);\n                if (fill === NONE) {\n                    c.stroke();\n                }\n                else {\n                    c.fillAndStroke();\n                }\n            }\n        }\n        else {\n            c.moveTo(start, 0);\n            c.lineTo(0, 0);\n            c.lineTo(0, h);\n            c.lineTo(start, h);\n            c.fillAndStroke();\n            if (start < w) {\n                if (fill === NONE || !events) {\n                    c.pointerEvents = false;\n                }\n                if (fill !== NONE) {\n                    c.setFillColor(fill);\n                }\n                c.begin();\n                c.moveTo(start, 0);\n                c.lineTo(w, 0);\n                c.lineTo(w, h);\n                c.lineTo(start, h);\n                if (fill === NONE) {\n                    c.stroke();\n                }\n                else {\n                    c.fillAndStroke();\n                }\n            }\n        }\n        if (swimlaneLine) {\n            this.paintDivider(c, x, y, w, h, start, fill === NONE);\n        }\n    }\n    /**\n     * Paints the swimlane vertex shape.\n     */\n    paintRoundedSwimlane(c, x, y, w, h, start, r, fill, swimlaneLine) {\n        c.begin();\n        let events = true;\n        if (this.style && this.style.pointerEvents != null) {\n            events = this.style.pointerEvents;\n        }\n        if (!events && this.fill === NONE) {\n            c.pointerEvents = false;\n        }\n        if (this.isHorizontal()) {\n            c.moveTo(w, start);\n            c.lineTo(w, r);\n            c.quadTo(w, 0, w - Math.min(w / 2, r), 0);\n            c.lineTo(Math.min(w / 2, r), 0);\n            c.quadTo(0, 0, 0, r);\n            c.lineTo(0, start);\n            c.fillAndStroke();\n            if (start < h) {\n                if (fill === NONE || !events) {\n                    c.pointerEvents = false;\n                }\n                if (fill !== NONE) {\n                    c.setFillColor(fill);\n                }\n                c.begin();\n                c.moveTo(0, start);\n                c.lineTo(0, h - r);\n                c.quadTo(0, h, Math.min(w / 2, r), h);\n                c.lineTo(w - Math.min(w / 2, r), h);\n                c.quadTo(w, h, w, h - r);\n                c.lineTo(w, start);\n                if (fill === NONE) {\n                    c.stroke();\n                }\n                else {\n                    c.fillAndStroke();\n                }\n            }\n        }\n        else {\n            c.moveTo(start, 0);\n            c.lineTo(r, 0);\n            c.quadTo(0, 0, 0, Math.min(h / 2, r));\n            c.lineTo(0, h - Math.min(h / 2, r));\n            c.quadTo(0, h, r, h);\n            c.lineTo(start, h);\n            c.fillAndStroke();\n            if (start < w) {\n                if (fill === NONE || !events) {\n                    c.pointerEvents = false;\n                }\n                if (fill !== NONE) {\n                    c.setFillColor(fill);\n                }\n                c.begin();\n                c.moveTo(start, h);\n                c.lineTo(w - r, h);\n                c.quadTo(w, h, w, h - Math.min(h / 2, r));\n                c.lineTo(w, Math.min(h / 2, r));\n                c.quadTo(w, 0, w - r, 0);\n                c.lineTo(start, 0);\n                if (fill === NONE) {\n                    c.stroke();\n                }\n                else {\n                    c.fillAndStroke();\n                }\n            }\n        }\n        if (swimlaneLine) {\n            this.paintDivider(c, x, y, w, h, start, fill === NONE);\n        }\n    }\n    /**\n     * Paints the divider between swimlane title and content area.\n     */\n    paintDivider(c, x, y, w, h, start, shadow) {\n        if (!shadow) {\n            c.setShadow(false);\n        }\n        c.begin();\n        if (this.isHorizontal()) {\n            c.moveTo(0, start);\n            c.lineTo(w, start);\n        }\n        else {\n            c.moveTo(start, 0);\n            c.lineTo(start, h);\n        }\n        c.stroke();\n    }\n    /**\n     * Paints the vertical or horizontal separator line between swimlanes.\n     */\n    paintSeparator(c, x, y, w, h, start, color) {\n        if (color !== NONE) {\n            c.setStrokeColor(color);\n            c.setDashed(true);\n            c.begin();\n            if (this.isHorizontal()) {\n                c.moveTo(w, start);\n                c.lineTo(w, h);\n            }\n            else {\n                c.moveTo(start, 0);\n                c.lineTo(w, 0);\n            }\n            c.stroke();\n            c.setDashed(false);\n        }\n    }\n    /**\n     * Paints the swimlane vertex shape.\n     */\n    getImageBounds(x, y, w, h) {\n        if (this.isHorizontal()) {\n            return new Rectangle(x + w - this.imageSize, y, this.imageSize, this.imageSize);\n        }\n        return new Rectangle(x, y, this.imageSize, this.imageSize);\n    }\n}\nexport default SwimlaneShape;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}