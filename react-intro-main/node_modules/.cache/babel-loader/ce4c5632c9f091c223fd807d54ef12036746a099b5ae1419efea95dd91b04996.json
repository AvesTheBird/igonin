{"ast":null,"code":"/*\nCopyright 2023-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectCodec from '../ObjectCodec';\nimport ChildChange from '../../view/undoable_changes/ChildChange';\nimport { NODETYPE } from '../../util/Constants';\n/**\n * Codec for {@link ChildChange}s.\n *\n * This class is created and registered dynamically at load time and used implicitly via {@link Codec} and the {@link CodecRegistry}.\n *\n * Transient Fields:\n *\n * - model\n * - previous\n * - previousIndex\n * - child\n *\n * Reference Fields:\n *\n * - parent\n */\nexport class ChildChangeCodec extends ObjectCodec {\n  constructor() {\n    const __dummy = undefined;\n    super(new ChildChange(__dummy, __dummy, __dummy), ['model', 'child', 'previousIndex'], ['parent', 'previous']);\n  }\n  /**\n   * Returns `true` for the child attribute if the child cell had a previous parent or if we're reading the\n   * child as an attribute rather than a child node, in which case it's always a reference.\n   */\n  isReference(obj, attr, value, isWrite) {\n    if (attr === 'child' && (!isWrite || obj.model.contains(obj.previous))) {\n      return true;\n    }\n    return this.idrefs.indexOf(attr) >= 0;\n  }\n  /**\n   * Excludes references to parent or previous if not in the model.\n   */\n  isExcluded(obj, attr, value, write) {\n    return super.isExcluded(obj, attr, value, write) || write && value != null && (attr === 'previous' || attr === 'parent') && !obj.model.contains(value);\n  }\n  /**\n   * Encodes the child recursively and adds the result to the given node.\n   */\n  afterEncode(enc, obj, node) {\n    if (this.isReference(obj, 'child', obj.child, true)) {\n      // Encodes as reference (id)\n      node.setAttribute('child', enc.getId(obj.child));\n    } else {\n      // At this point, the encoder is no longer able to know which cells\n      // are new, so we have to encode the complete cell hierarchy and\n      // ignore the ones that are already there at decoding time. Note:\n      // This can only be resolved by moving the notify event into the\n      // execute of the edit.\n      enc.encodeCell(obj.child, node);\n    }\n    return node;\n  }\n  /**\n   * Decodes any child nodes as using the respective codec from the registry.\n   */\n  beforeDecode(dec, _node, obj) {\n    if (_node.firstChild != null && _node.firstChild.nodeType === NODETYPE.ELEMENT) {\n      // Makes sure the original node isn't modified\n      const node = _node.cloneNode(true);\n      let tmp = node.firstChild;\n      obj.child = dec.decodeCell(tmp, false);\n      let tmp2 = tmp.nextSibling;\n      tmp.parentNode.removeChild(tmp);\n      tmp = tmp2;\n      while (tmp != null) {\n        tmp2 = tmp.nextSibling;\n        if (tmp.nodeType === NODETYPE.ELEMENT) {\n          // Ignores all existing cells because those do not need to\n          // be re-inserted into the model. Since the encoded version\n          // of these cells contains the new parent, this would leave\n          // to an inconsistent state on the model (i.e. a parent\n          // change without a call to parentForCellChanged).\n          const id = tmp.getAttribute('id');\n          if (dec.lookup(id) == null) {\n            dec.decodeCell(tmp);\n          }\n        }\n        tmp.parentNode.removeChild(tmp);\n        tmp = tmp2;\n      }\n      return node;\n    } else {\n      const childRef = _node.getAttribute('child');\n      obj.child = dec.getObject(childRef);\n      return _node;\n    }\n  }\n  /**\n   * Restores object state in the child change.\n   */\n  afterDecode(dec, node, obj) {\n    // Cells are decoded here after a complete transaction so the previous\n    // parent must be restored on the cell for the case where the cell was\n    // added. This is needed for the local model to identify the cell as a\n    // new cell and register the ID.\n    if (obj.child != null) {\n      if (obj.child.parent != null && obj.previous != null && obj.child.parent !== obj.previous) {\n        obj.previous = obj.child.parent;\n      }\n      obj.child.parent = obj.previous;\n      obj.previous = obj.parent;\n      obj.previousIndex = obj.index;\n    }\n    return obj;\n  }\n}","map":{"version":3,"names":["ObjectCodec","ChildChange","NODETYPE","ChildChangeCodec","constructor","__dummy","undefined","isReference","obj","attr","value","isWrite","model","contains","previous","idrefs","indexOf","isExcluded","write","afterEncode","enc","node","child","setAttribute","getId","encodeCell","beforeDecode","dec","_node","firstChild","nodeType","ELEMENT","cloneNode","tmp","decodeCell","tmp2","nextSibling","parentNode","removeChild","id","getAttribute","lookup","childRef","getObject","afterDecode","parent","previousIndex","index"],"sources":["D:/ospanel/domains/react/react-intro/node_modules/@maxgraph/core/dist/serialization/codecs/ChildChangeCodec.js"],"sourcesContent":["/*\nCopyright 2023-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectCodec from '../ObjectCodec';\nimport ChildChange from '../../view/undoable_changes/ChildChange';\nimport { NODETYPE } from '../../util/Constants';\n/**\n * Codec for {@link ChildChange}s.\n *\n * This class is created and registered dynamically at load time and used implicitly via {@link Codec} and the {@link CodecRegistry}.\n *\n * Transient Fields:\n *\n * - model\n * - previous\n * - previousIndex\n * - child\n *\n * Reference Fields:\n *\n * - parent\n */\nexport class ChildChangeCodec extends ObjectCodec {\n    constructor() {\n        const __dummy = undefined;\n        super(new ChildChange(__dummy, __dummy, __dummy), ['model', 'child', 'previousIndex'], ['parent', 'previous']);\n    }\n    /**\n     * Returns `true` for the child attribute if the child cell had a previous parent or if we're reading the\n     * child as an attribute rather than a child node, in which case it's always a reference.\n     */\n    isReference(obj, attr, value, isWrite) {\n        if (attr === 'child' && (!isWrite || obj.model.contains(obj.previous))) {\n            return true;\n        }\n        return this.idrefs.indexOf(attr) >= 0;\n    }\n    /**\n     * Excludes references to parent or previous if not in the model.\n     */\n    isExcluded(obj, attr, value, write) {\n        return (super.isExcluded(obj, attr, value, write) ||\n            (write &&\n                value != null &&\n                (attr === 'previous' || attr === 'parent') &&\n                !obj.model.contains(value)));\n    }\n    /**\n     * Encodes the child recursively and adds the result to the given node.\n     */\n    afterEncode(enc, obj, node) {\n        if (this.isReference(obj, 'child', obj.child, true)) {\n            // Encodes as reference (id)\n            node.setAttribute('child', enc.getId(obj.child));\n        }\n        else {\n            // At this point, the encoder is no longer able to know which cells\n            // are new, so we have to encode the complete cell hierarchy and\n            // ignore the ones that are already there at decoding time. Note:\n            // This can only be resolved by moving the notify event into the\n            // execute of the edit.\n            enc.encodeCell(obj.child, node);\n        }\n        return node;\n    }\n    /**\n     * Decodes any child nodes as using the respective codec from the registry.\n     */\n    beforeDecode(dec, _node, obj) {\n        if (_node.firstChild != null && _node.firstChild.nodeType === NODETYPE.ELEMENT) {\n            // Makes sure the original node isn't modified\n            const node = _node.cloneNode(true);\n            let tmp = node.firstChild;\n            obj.child = dec.decodeCell(tmp, false);\n            let tmp2 = tmp.nextSibling;\n            tmp.parentNode.removeChild(tmp);\n            tmp = tmp2;\n            while (tmp != null) {\n                tmp2 = tmp.nextSibling;\n                if (tmp.nodeType === NODETYPE.ELEMENT) {\n                    // Ignores all existing cells because those do not need to\n                    // be re-inserted into the model. Since the encoded version\n                    // of these cells contains the new parent, this would leave\n                    // to an inconsistent state on the model (i.e. a parent\n                    // change without a call to parentForCellChanged).\n                    const id = tmp.getAttribute('id');\n                    if (dec.lookup(id) == null) {\n                        dec.decodeCell(tmp);\n                    }\n                }\n                tmp.parentNode.removeChild(tmp);\n                tmp = tmp2;\n            }\n            return node;\n        }\n        else {\n            const childRef = _node.getAttribute('child');\n            obj.child = dec.getObject(childRef);\n            return _node;\n        }\n    }\n    /**\n     * Restores object state in the child change.\n     */\n    afterDecode(dec, node, obj) {\n        // Cells are decoded here after a complete transaction so the previous\n        // parent must be restored on the cell for the case where the cell was\n        // added. This is needed for the local model to identify the cell as a\n        // new cell and register the ID.\n        if (obj.child != null) {\n            if (obj.child.parent != null &&\n                obj.previous != null &&\n                obj.child.parent !== obj.previous) {\n                obj.previous = obj.child.parent;\n            }\n            obj.child.parent = obj.previous;\n            obj.previous = obj.parent;\n            obj.previousIndex = obj.index;\n        }\n        return obj;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}