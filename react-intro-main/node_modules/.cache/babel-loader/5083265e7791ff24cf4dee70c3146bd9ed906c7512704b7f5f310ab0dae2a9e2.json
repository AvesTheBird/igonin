{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../base/common/event.js';\nimport { toDisposable } from '../../base/common/lifecycle.js';\nimport { shouldSynchronizeModel } from './model.js';\nimport { score } from './languageSelector.js';\nfunction isExclusive(selector) {\n  if (typeof selector === 'string') {\n    return false;\n  } else if (Array.isArray(selector)) {\n    return selector.every(isExclusive);\n  } else {\n    return !!selector.exclusive; // TODO: microsoft/TypeScript#42768\n  }\n}\nclass MatchCandidate {\n  constructor(uri, languageId, notebookUri, notebookType, recursive) {\n    this.uri = uri;\n    this.languageId = languageId;\n    this.notebookUri = notebookUri;\n    this.notebookType = notebookType;\n    this.recursive = recursive;\n  }\n  equals(other) {\n    var _this$notebookUri, _other$notebookUri;\n    return this.notebookType === other.notebookType && this.languageId === other.languageId && this.uri.toString() === other.uri.toString() && ((_this$notebookUri = this.notebookUri) === null || _this$notebookUri === void 0 ? void 0 : _this$notebookUri.toString()) === ((_other$notebookUri = other.notebookUri) === null || _other$notebookUri === void 0 ? void 0 : _other$notebookUri.toString()) && this.recursive === other.recursive;\n  }\n}\nexport class LanguageFeatureRegistry {\n  constructor(_notebookInfoResolver) {\n    this._notebookInfoResolver = _notebookInfoResolver;\n    this._clock = 0;\n    this._entries = [];\n    this._onDidChange = new Emitter();\n    this.onDidChange = this._onDidChange.event;\n  }\n  register(selector, provider) {\n    let entry = {\n      selector,\n      provider,\n      _score: -1,\n      _time: this._clock++\n    };\n    this._entries.push(entry);\n    this._lastCandidate = undefined;\n    this._onDidChange.fire(this._entries.length);\n    return toDisposable(() => {\n      if (entry) {\n        const idx = this._entries.indexOf(entry);\n        if (idx >= 0) {\n          this._entries.splice(idx, 1);\n          this._lastCandidate = undefined;\n          this._onDidChange.fire(this._entries.length);\n          entry = undefined;\n        }\n      }\n    });\n  }\n  has(model) {\n    return this.all(model).length > 0;\n  }\n  all(model) {\n    if (!model) {\n      return [];\n    }\n    this._updateScores(model, false);\n    const result = [];\n    // from registry\n    for (const entry of this._entries) {\n      if (entry._score > 0) {\n        result.push(entry.provider);\n      }\n    }\n    return result;\n  }\n  ordered(model) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const result = [];\n    this._orderedForEach(model, recursive, entry => result.push(entry.provider));\n    return result;\n  }\n  orderedGroups(model) {\n    const result = [];\n    let lastBucket;\n    let lastBucketScore;\n    this._orderedForEach(model, false, entry => {\n      if (lastBucket && lastBucketScore === entry._score) {\n        lastBucket.push(entry.provider);\n      } else {\n        lastBucketScore = entry._score;\n        lastBucket = [entry.provider];\n        result.push(lastBucket);\n      }\n    });\n    return result;\n  }\n  _orderedForEach(model, recursive, callback) {\n    this._updateScores(model, recursive);\n    for (const entry of this._entries) {\n      if (entry._score > 0) {\n        callback(entry);\n      }\n    }\n  }\n  _updateScores(model, recursive) {\n    var _this$_notebookInfoRe, _this$_lastCandidate;\n    const notebookInfo = (_this$_notebookInfoRe = this._notebookInfoResolver) === null || _this$_notebookInfoRe === void 0 ? void 0 : _this$_notebookInfoRe.call(this, model.uri);\n    // use the uri (scheme, pattern) of the notebook info iff we have one\n    // otherwise it's the model's/document's uri\n    const candidate = notebookInfo ? new MatchCandidate(model.uri, model.getLanguageId(), notebookInfo.uri, notebookInfo.type, recursive) : new MatchCandidate(model.uri, model.getLanguageId(), undefined, undefined, recursive);\n    if ((_this$_lastCandidate = this._lastCandidate) !== null && _this$_lastCandidate !== void 0 && _this$_lastCandidate.equals(candidate)) {\n      // nothing has changed\n      return;\n    }\n    this._lastCandidate = candidate;\n    for (const entry of this._entries) {\n      entry._score = score(entry.selector, candidate.uri, candidate.languageId, shouldSynchronizeModel(model), candidate.notebookUri, candidate.notebookType);\n      if (isExclusive(entry.selector) && entry._score > 0) {\n        if (recursive) {\n          entry._score = 0;\n        } else {\n          // support for one exclusive selector that overwrites\n          // any other selector\n          for (const entry of this._entries) {\n            entry._score = 0;\n          }\n          entry._score = 1000;\n          break;\n        }\n      }\n    }\n    // needs sorting\n    this._entries.sort(LanguageFeatureRegistry._compareByScoreAndTime);\n  }\n  static _compareByScoreAndTime(a, b) {\n    if (a._score < b._score) {\n      return 1;\n    } else if (a._score > b._score) {\n      return -1;\n    }\n    // De-prioritize built-in providers\n    if (isBuiltinSelector(a.selector) && !isBuiltinSelector(b.selector)) {\n      return 1;\n    } else if (!isBuiltinSelector(a.selector) && isBuiltinSelector(b.selector)) {\n      return -1;\n    }\n    if (a._time < b._time) {\n      return 1;\n    } else if (a._time > b._time) {\n      return -1;\n    } else {\n      return 0;\n    }\n  }\n}\nfunction isBuiltinSelector(selector) {\n  if (typeof selector === 'string') {\n    return false;\n  }\n  if (Array.isArray(selector)) {\n    return selector.some(isBuiltinSelector);\n  }\n  return Boolean(selector.isBuiltin);\n}","map":{"version":3,"names":["Emitter","toDisposable","shouldSynchronizeModel","score","isExclusive","selector","Array","isArray","every","exclusive","MatchCandidate","constructor","uri","languageId","notebookUri","notebookType","recursive","equals","other","_this$notebookUri","_other$notebookUri","toString","LanguageFeatureRegistry","_notebookInfoResolver","_clock","_entries","_onDidChange","onDidChange","event","register","provider","entry","_score","_time","push","_lastCandidate","undefined","fire","length","idx","indexOf","splice","has","model","all","_updateScores","result","ordered","arguments","_orderedForEach","orderedGroups","lastBucket","lastBucketScore","callback","_this$_notebookInfoRe","_this$_lastCandidate","notebookInfo","call","candidate","getLanguageId","type","sort","_compareByScoreAndTime","a","b","isBuiltinSelector","some","Boolean","isBuiltin"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/editor/common/languageFeatureRegistry.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../base/common/event.js';\nimport { toDisposable } from '../../base/common/lifecycle.js';\nimport { shouldSynchronizeModel } from './model.js';\nimport { score } from './languageSelector.js';\nfunction isExclusive(selector) {\n    if (typeof selector === 'string') {\n        return false;\n    }\n    else if (Array.isArray(selector)) {\n        return selector.every(isExclusive);\n    }\n    else {\n        return !!selector.exclusive; // TODO: microsoft/TypeScript#42768\n    }\n}\nclass MatchCandidate {\n    constructor(uri, languageId, notebookUri, notebookType, recursive) {\n        this.uri = uri;\n        this.languageId = languageId;\n        this.notebookUri = notebookUri;\n        this.notebookType = notebookType;\n        this.recursive = recursive;\n    }\n    equals(other) {\n        return this.notebookType === other.notebookType\n            && this.languageId === other.languageId\n            && this.uri.toString() === other.uri.toString()\n            && this.notebookUri?.toString() === other.notebookUri?.toString()\n            && this.recursive === other.recursive;\n    }\n}\nexport class LanguageFeatureRegistry {\n    constructor(_notebookInfoResolver) {\n        this._notebookInfoResolver = _notebookInfoResolver;\n        this._clock = 0;\n        this._entries = [];\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n    }\n    register(selector, provider) {\n        let entry = {\n            selector,\n            provider,\n            _score: -1,\n            _time: this._clock++\n        };\n        this._entries.push(entry);\n        this._lastCandidate = undefined;\n        this._onDidChange.fire(this._entries.length);\n        return toDisposable(() => {\n            if (entry) {\n                const idx = this._entries.indexOf(entry);\n                if (idx >= 0) {\n                    this._entries.splice(idx, 1);\n                    this._lastCandidate = undefined;\n                    this._onDidChange.fire(this._entries.length);\n                    entry = undefined;\n                }\n            }\n        });\n    }\n    has(model) {\n        return this.all(model).length > 0;\n    }\n    all(model) {\n        if (!model) {\n            return [];\n        }\n        this._updateScores(model, false);\n        const result = [];\n        // from registry\n        for (const entry of this._entries) {\n            if (entry._score > 0) {\n                result.push(entry.provider);\n            }\n        }\n        return result;\n    }\n    ordered(model, recursive = false) {\n        const result = [];\n        this._orderedForEach(model, recursive, entry => result.push(entry.provider));\n        return result;\n    }\n    orderedGroups(model) {\n        const result = [];\n        let lastBucket;\n        let lastBucketScore;\n        this._orderedForEach(model, false, entry => {\n            if (lastBucket && lastBucketScore === entry._score) {\n                lastBucket.push(entry.provider);\n            }\n            else {\n                lastBucketScore = entry._score;\n                lastBucket = [entry.provider];\n                result.push(lastBucket);\n            }\n        });\n        return result;\n    }\n    _orderedForEach(model, recursive, callback) {\n        this._updateScores(model, recursive);\n        for (const entry of this._entries) {\n            if (entry._score > 0) {\n                callback(entry);\n            }\n        }\n    }\n    _updateScores(model, recursive) {\n        const notebookInfo = this._notebookInfoResolver?.(model.uri);\n        // use the uri (scheme, pattern) of the notebook info iff we have one\n        // otherwise it's the model's/document's uri\n        const candidate = notebookInfo\n            ? new MatchCandidate(model.uri, model.getLanguageId(), notebookInfo.uri, notebookInfo.type, recursive)\n            : new MatchCandidate(model.uri, model.getLanguageId(), undefined, undefined, recursive);\n        if (this._lastCandidate?.equals(candidate)) {\n            // nothing has changed\n            return;\n        }\n        this._lastCandidate = candidate;\n        for (const entry of this._entries) {\n            entry._score = score(entry.selector, candidate.uri, candidate.languageId, shouldSynchronizeModel(model), candidate.notebookUri, candidate.notebookType);\n            if (isExclusive(entry.selector) && entry._score > 0) {\n                if (recursive) {\n                    entry._score = 0;\n                }\n                else {\n                    // support for one exclusive selector that overwrites\n                    // any other selector\n                    for (const entry of this._entries) {\n                        entry._score = 0;\n                    }\n                    entry._score = 1000;\n                    break;\n                }\n            }\n        }\n        // needs sorting\n        this._entries.sort(LanguageFeatureRegistry._compareByScoreAndTime);\n    }\n    static _compareByScoreAndTime(a, b) {\n        if (a._score < b._score) {\n            return 1;\n        }\n        else if (a._score > b._score) {\n            return -1;\n        }\n        // De-prioritize built-in providers\n        if (isBuiltinSelector(a.selector) && !isBuiltinSelector(b.selector)) {\n            return 1;\n        }\n        else if (!isBuiltinSelector(a.selector) && isBuiltinSelector(b.selector)) {\n            return -1;\n        }\n        if (a._time < b._time) {\n            return 1;\n        }\n        else if (a._time > b._time) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    }\n}\nfunction isBuiltinSelector(selector) {\n    if (typeof selector === 'string') {\n        return false;\n    }\n    if (Array.isArray(selector)) {\n        return selector.some(isBuiltinSelector);\n    }\n    return Boolean(selector.isBuiltin);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}