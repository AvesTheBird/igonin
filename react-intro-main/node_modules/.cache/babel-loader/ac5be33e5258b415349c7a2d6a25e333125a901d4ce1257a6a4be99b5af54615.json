{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../../geometry/Point';\nimport { contains } from '../../../util/mathUtils';\nimport { scaleCellState, scalePointArray } from './shared';\nexport const SegmentConnector = (state, sourceScaled, targetScaled, controlHints, result) => {\n  // Creates array of all way- and terminal points\n  // TODO: Figure out what to do when there are nulls in `pts`!\n  const pts = scalePointArray(state.absolutePoints, state.view.scale);\n  const source = scaleCellState(sourceScaled, state.view.scale);\n  const target = scaleCellState(targetScaled, state.view.scale);\n  const tol = 1;\n  // Whether the first segment outgoing from the source end is horizontal\n  let lastPushed = result.length > 0 ? result[0] : null;\n  let horizontal = true;\n  let hint = null;\n  // Adds waypoints only if outside of tolerance\n  function pushPoint(pt) {\n    pt.x = Math.round(pt.x * state.view.scale * 10) / 10;\n    pt.y = Math.round(pt.y * state.view.scale * 10) / 10;\n    if (lastPushed == null || Math.abs(lastPushed.x - pt.x) >= tol || Math.abs(lastPushed.y - pt.y) >= Math.max(1, state.view.scale)) {\n      result.push(pt);\n      lastPushed = pt;\n    }\n    return lastPushed;\n  }\n  // Adds the first point\n  let pt = pts[0];\n  if (pt == null && source != null) {\n    pt = new Point(state.view.getRoutingCenterX(source), state.view.getRoutingCenterY(source));\n  } else if (pt != null) {\n    pt = pt.clone();\n  }\n  const lastInx = pts.length - 1;\n  let pe = null;\n  // Adds the waypoints\n  if (controlHints != null && controlHints.length > 0) {\n    // Converts all hints and removes nulls\n    let hints = [];\n    for (let i = 0; i < controlHints.length; i += 1) {\n      const tmp = state.view.transformControlPoint(state, controlHints[i], true);\n      if (tmp != null) {\n        hints.push(tmp);\n      }\n    }\n    if (hints.length === 0) {\n      return;\n    }\n    // Aligns source and target hint to fixed points\n    if (pt != null && hints[0] != null) {\n      if (Math.abs(hints[0].x - pt.x) < tol) {\n        hints[0].x = pt.x;\n      }\n      if (Math.abs(hints[0].y - pt.y) < tol) {\n        hints[0].y = pt.y;\n      }\n    }\n    pe = pts[lastInx];\n    if (pe != null && hints[hints.length - 1] != null) {\n      if (Math.abs(hints[hints.length - 1].x - pe.x) < tol) {\n        hints[hints.length - 1].x = pe.x;\n      }\n      if (Math.abs(hints[hints.length - 1].y - pe.y) < tol) {\n        hints[hints.length - 1].y = pe.y;\n      }\n    }\n    hint = hints[0];\n    let currentTerm = source;\n    let currentPt = pts[0];\n    let hozChan = false;\n    let vertChan = false;\n    let currentHint = hint;\n    if (currentPt != null) {\n      currentTerm = null;\n    }\n    // Check for alignment with fixed points and with channels\n    // at source and target segments only\n    for (let i = 0; i < 2; i += 1) {\n      const fixedVertAlign = currentPt != null && currentPt.x === currentHint.x;\n      const fixedHozAlign = currentPt != null && currentPt.y === currentHint.y;\n      const inHozChan = currentTerm != null && currentHint.y >= currentTerm.y && currentHint.y <= currentTerm.y + currentTerm.height;\n      const inVertChan = currentTerm != null && currentHint.x >= currentTerm.x && currentHint.x <= currentTerm.x + currentTerm.width;\n      hozChan = fixedHozAlign || currentPt == null && inHozChan;\n      vertChan = fixedVertAlign || currentPt == null && inVertChan;\n      // If the current hint falls in both the hor and vert channels in the case\n      // of a floating port, or if the hint is exactly co-incident with a\n      // fixed point, ignore the source and try to work out the orientation\n      // from the target end\n      if (!(i == 0 && (hozChan && vertChan || fixedVertAlign && fixedHozAlign))) {\n        if (currentPt != null && !fixedHozAlign && !fixedVertAlign && (inHozChan || inVertChan)) {\n          horizontal = !inHozChan;\n          break;\n        }\n        if (vertChan || hozChan) {\n          horizontal = hozChan;\n          if (i === 1) {\n            // Work back from target end\n            horizontal = hints.length % 2 === 0 ? hozChan : vertChan;\n          }\n          break;\n        }\n      }\n      currentTerm = target;\n      currentPt = pts[lastInx];\n      if (currentPt != null) {\n        currentTerm = null;\n      }\n      currentHint = hints[hints.length - 1];\n      if (fixedVertAlign && fixedHozAlign) {\n        hints = hints.slice(1);\n      }\n    }\n    if (horizontal && (pts[0] != null && pts[0].y !== hint.y || pts[0] == null && source != null && (hint.y < source.y || hint.y > source.y + source.height))) {\n      pushPoint(new Point(pt.x, hint.y));\n    } else if (!horizontal && (pts[0] != null && pts[0].x !== hint.x || pts[0] == null && source != null && (hint.x < source.x || hint.x > source.x + source.width))) {\n      pushPoint(new Point(hint.x, pt.y));\n    }\n    if (horizontal) {\n      pt.y = hint.y;\n    } else {\n      pt.x = hint.x;\n    }\n    for (let i = 0; i < hints.length; i += 1) {\n      horizontal = !horizontal;\n      hint = hints[i];\n      //        MaxLog.show();\n      //        MaxLog.debug('hint', i, hint.x, hint.y);\n      if (horizontal) {\n        pt.y = hint.y;\n      } else {\n        pt.x = hint.x;\n      }\n      pushPoint(pt.clone());\n    }\n  } else {\n    hint = pt;\n    // FIXME: First click in connect preview toggles orientation\n    horizontal = true;\n  }\n  // Adds the last point\n  pt = pts[lastInx];\n  if (pt == null && target != null) {\n    pt = new Point(state.view.getRoutingCenterX(target), state.view.getRoutingCenterY(target));\n  }\n  if (pt != null) {\n    if (hint != null) {\n      if (horizontal && (pts[lastInx] != null && pts[lastInx].y !== hint.y || pts[lastInx] == null && target != null && (hint.y < target.y || hint.y > target.y + target.height))) {\n        pushPoint(new Point(pt.x, hint.y));\n      } else if (!horizontal && (pts[lastInx] != null && pts[lastInx].x !== hint.x || pts[lastInx] == null && target != null && (hint.x < target.x || hint.x > target.x + target.width))) {\n        pushPoint(new Point(hint.x, pt.y));\n      }\n    }\n  }\n  // Removes bends inside the source terminal for floating ports\n  if (pts[0] == null && source != null) {\n    while (result.length > 1 && result[1] != null && contains(source, result[1].x, result[1].y)) {\n      result.splice(1, 1);\n    }\n  }\n  // Removes bends inside the target terminal\n  if (pts[lastInx] == null && target != null) {\n    while (result.length > 1 && result[result.length - 1] != null && contains(target, result[result.length - 1].x, result[result.length - 1].y)) {\n      result.splice(result.length - 1, 1);\n    }\n  }\n  // Removes last point if inside tolerance with end point\n  if (pe != null && result[result.length - 1] != null && Math.abs(pe.x - result[result.length - 1].x) <= tol && Math.abs(pe.y - result[result.length - 1].y) <= tol) {\n    result.splice(result.length - 1, 1);\n    // Lines up second last point in result with end point\n    if (result[result.length - 1] != null) {\n      if (Math.abs(result[result.length - 1].x - pe.x) < tol) {\n        result[result.length - 1].x = pe.x;\n      }\n      if (Math.abs(result[result.length - 1].y - pe.y) < tol) {\n        result[result.length - 1].y = pe.y;\n      }\n    }\n  }\n};","map":{"version":3,"names":["Point","contains","scaleCellState","scalePointArray","SegmentConnector","state","sourceScaled","targetScaled","controlHints","result","pts","absolutePoints","view","scale","source","target","tol","lastPushed","length","horizontal","hint","pushPoint","pt","x","Math","round","y","abs","max","push","getRoutingCenterX","getRoutingCenterY","clone","lastInx","pe","hints","i","tmp","transformControlPoint","currentTerm","currentPt","hozChan","vertChan","currentHint","fixedVertAlign","fixedHozAlign","inHozChan","height","inVertChan","width","slice","splice"],"sources":["D:/ospanel/domains/проекты open server/old/react/react-intro-main/node_modules/@maxgraph/core/dist/view/style/edge/Segment.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../../geometry/Point';\nimport { contains } from '../../../util/mathUtils';\nimport { scaleCellState, scalePointArray } from './shared';\nexport const SegmentConnector = (state, sourceScaled, targetScaled, controlHints, result) => {\n    // Creates array of all way- and terminal points\n    // TODO: Figure out what to do when there are nulls in `pts`!\n    const pts = scalePointArray(state.absolutePoints, state.view.scale);\n    const source = scaleCellState(sourceScaled, state.view.scale);\n    const target = scaleCellState(targetScaled, state.view.scale);\n    const tol = 1;\n    // Whether the first segment outgoing from the source end is horizontal\n    let lastPushed = result.length > 0 ? result[0] : null;\n    let horizontal = true;\n    let hint = null;\n    // Adds waypoints only if outside of tolerance\n    function pushPoint(pt) {\n        pt.x = Math.round(pt.x * state.view.scale * 10) / 10;\n        pt.y = Math.round(pt.y * state.view.scale * 10) / 10;\n        if (lastPushed == null ||\n            Math.abs(lastPushed.x - pt.x) >= tol ||\n            Math.abs(lastPushed.y - pt.y) >= Math.max(1, state.view.scale)) {\n            result.push(pt);\n            lastPushed = pt;\n        }\n        return lastPushed;\n    }\n    // Adds the first point\n    let pt = pts[0];\n    if (pt == null && source != null) {\n        pt = new Point(state.view.getRoutingCenterX(source), state.view.getRoutingCenterY(source));\n    }\n    else if (pt != null) {\n        pt = pt.clone();\n    }\n    const lastInx = pts.length - 1;\n    let pe = null;\n    // Adds the waypoints\n    if (controlHints != null && controlHints.length > 0) {\n        // Converts all hints and removes nulls\n        let hints = [];\n        for (let i = 0; i < controlHints.length; i += 1) {\n            const tmp = state.view.transformControlPoint(state, controlHints[i], true);\n            if (tmp != null) {\n                hints.push(tmp);\n            }\n        }\n        if (hints.length === 0) {\n            return;\n        }\n        // Aligns source and target hint to fixed points\n        if (pt != null && hints[0] != null) {\n            if (Math.abs(hints[0].x - pt.x) < tol) {\n                hints[0].x = pt.x;\n            }\n            if (Math.abs(hints[0].y - pt.y) < tol) {\n                hints[0].y = pt.y;\n            }\n        }\n        pe = pts[lastInx];\n        if (pe != null && hints[hints.length - 1] != null) {\n            if (Math.abs(hints[hints.length - 1].x - pe.x) < tol) {\n                hints[hints.length - 1].x = pe.x;\n            }\n            if (Math.abs(hints[hints.length - 1].y - pe.y) < tol) {\n                hints[hints.length - 1].y = pe.y;\n            }\n        }\n        hint = hints[0];\n        let currentTerm = source;\n        let currentPt = pts[0];\n        let hozChan = false;\n        let vertChan = false;\n        let currentHint = hint;\n        if (currentPt != null) {\n            currentTerm = null;\n        }\n        // Check for alignment with fixed points and with channels\n        // at source and target segments only\n        for (let i = 0; i < 2; i += 1) {\n            const fixedVertAlign = currentPt != null && currentPt.x === currentHint.x;\n            const fixedHozAlign = currentPt != null && currentPt.y === currentHint.y;\n            const inHozChan = currentTerm != null &&\n                currentHint.y >= currentTerm.y &&\n                currentHint.y <= currentTerm.y + currentTerm.height;\n            const inVertChan = currentTerm != null &&\n                currentHint.x >= currentTerm.x &&\n                currentHint.x <= currentTerm.x + currentTerm.width;\n            hozChan = fixedHozAlign || (currentPt == null && inHozChan);\n            vertChan = fixedVertAlign || (currentPt == null && inVertChan);\n            // If the current hint falls in both the hor and vert channels in the case\n            // of a floating port, or if the hint is exactly co-incident with a\n            // fixed point, ignore the source and try to work out the orientation\n            // from the target end\n            if (!(i == 0 && ((hozChan && vertChan) || (fixedVertAlign && fixedHozAlign)))) {\n                if (currentPt != null &&\n                    !fixedHozAlign &&\n                    !fixedVertAlign &&\n                    (inHozChan || inVertChan)) {\n                    horizontal = !inHozChan;\n                    break;\n                }\n                if (vertChan || hozChan) {\n                    horizontal = hozChan;\n                    if (i === 1) {\n                        // Work back from target end\n                        horizontal = hints.length % 2 === 0 ? hozChan : vertChan;\n                    }\n                    break;\n                }\n            }\n            currentTerm = target;\n            currentPt = pts[lastInx];\n            if (currentPt != null) {\n                currentTerm = null;\n            }\n            currentHint = hints[hints.length - 1];\n            if (fixedVertAlign && fixedHozAlign) {\n                hints = hints.slice(1);\n            }\n        }\n        if (horizontal &&\n            ((pts[0] != null && pts[0].y !== hint.y) ||\n                (pts[0] == null &&\n                    source != null &&\n                    (hint.y < source.y || hint.y > source.y + source.height)))) {\n            pushPoint(new Point(pt.x, hint.y));\n        }\n        else if (!horizontal &&\n            ((pts[0] != null && pts[0].x !== hint.x) ||\n                (pts[0] == null &&\n                    source != null &&\n                    (hint.x < source.x || hint.x > source.x + source.width)))) {\n            pushPoint(new Point(hint.x, pt.y));\n        }\n        if (horizontal) {\n            pt.y = hint.y;\n        }\n        else {\n            pt.x = hint.x;\n        }\n        for (let i = 0; i < hints.length; i += 1) {\n            horizontal = !horizontal;\n            hint = hints[i];\n            //        MaxLog.show();\n            //        MaxLog.debug('hint', i, hint.x, hint.y);\n            if (horizontal) {\n                pt.y = hint.y;\n            }\n            else {\n                pt.x = hint.x;\n            }\n            pushPoint(pt.clone());\n        }\n    }\n    else {\n        hint = pt;\n        // FIXME: First click in connect preview toggles orientation\n        horizontal = true;\n    }\n    // Adds the last point\n    pt = pts[lastInx];\n    if (pt == null && target != null) {\n        pt = new Point(state.view.getRoutingCenterX(target), state.view.getRoutingCenterY(target));\n    }\n    if (pt != null) {\n        if (hint != null) {\n            if (horizontal &&\n                ((pts[lastInx] != null && pts[lastInx].y !== hint.y) ||\n                    (pts[lastInx] == null &&\n                        target != null &&\n                        (hint.y < target.y || hint.y > target.y + target.height)))) {\n                pushPoint(new Point(pt.x, hint.y));\n            }\n            else if (!horizontal &&\n                ((pts[lastInx] != null && pts[lastInx].x !== hint.x) ||\n                    (pts[lastInx] == null &&\n                        target != null &&\n                        (hint.x < target.x || hint.x > target.x + target.width)))) {\n                pushPoint(new Point(hint.x, pt.y));\n            }\n        }\n    }\n    // Removes bends inside the source terminal for floating ports\n    if (pts[0] == null && source != null) {\n        while (result.length > 1 &&\n            result[1] != null &&\n            contains(source, result[1].x, result[1].y)) {\n            result.splice(1, 1);\n        }\n    }\n    // Removes bends inside the target terminal\n    if (pts[lastInx] == null && target != null) {\n        while (result.length > 1 &&\n            result[result.length - 1] != null &&\n            contains(target, result[result.length - 1].x, result[result.length - 1].y)) {\n            result.splice(result.length - 1, 1);\n        }\n    }\n    // Removes last point if inside tolerance with end point\n    if (pe != null &&\n        result[result.length - 1] != null &&\n        Math.abs(pe.x - result[result.length - 1].x) <= tol &&\n        Math.abs(pe.y - result[result.length - 1].y) <= tol) {\n        result.splice(result.length - 1, 1);\n        // Lines up second last point in result with end point\n        if (result[result.length - 1] != null) {\n            if (Math.abs(result[result.length - 1].x - pe.x) < tol) {\n                result[result.length - 1].x = pe.x;\n            }\n            if (Math.abs(result[result.length - 1].y - pe.y) < tol) {\n                result[result.length - 1].y = pe.y;\n            }\n        }\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}