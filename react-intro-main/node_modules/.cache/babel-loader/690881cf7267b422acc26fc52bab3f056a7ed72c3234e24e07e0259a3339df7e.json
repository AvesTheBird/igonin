{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { CompactTreeLayout } from './CompactTreeLayout';\n/**\n * Extends {@link mxGraphLayout} to implement a radial tree algorithm. This\n * layout is suitable for graphs that have no cycles (trees). Vertices that are\n * not connected to the tree will be ignored by this layout.\n *\n * ```javascript\n * var layout = new mxRadialTreeLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * ```\n */\nclass RadialTreeLayout extends CompactTreeLayout {\n  constructor(graph) {\n    super(graph, false);\n    this.centerX = null;\n    this.centerY = null;\n    /**\n     * The initial offset to compute the angle position.\n     * @default 0.5\n     */\n    this.angleOffset = 0.5;\n    /**\n     * The X co-ordinate of the root cell\n     * @default 0\n     */\n    this.rootx = 0;\n    /**\n     * The Y co-ordinate of the root cell\n     * @default 0\n     */\n    this.rooty = 0;\n    /**\n     * Holds the levelDistance.\n     * @default 120\n     */\n    this.levelDistance = 120;\n    /**\n     * Holds the nodeDistance.\n     * @default 10\n     */\n    this.nodeDistance = 10;\n    /**\n     * Specifies if the radios should be computed automatically\n     * @default false\n     */\n    this.autoRadius = false;\n    /**\n     * Specifies if edges should be sorted according to the order of their\n     * opposite terminal cell in the model.\n     * @default false\n     */\n    this.sortEdges = false;\n    /**\n     * Array of leftmost x coordinate of each row\n     */\n    this.rowMinX = {};\n    /**\n     * Array of rightmost x coordinate of each row\n     */\n    this.rowMaxX = {};\n    /**\n     * Array of x coordinate of leftmost vertex of each row\n     */\n    this.rowMinCenX = {};\n    /**\n     * Array of x coordinate of rightmost vertex of each row\n     */\n    this.rowMaxCenX = {};\n    /**\n     * Array of y deltas of each row behind root vertex, also the radius in the tree\n     */\n    this.rowRadi = {};\n    /**\n     * Array of vertices on each row\n     */\n    this.row = [];\n  }\n  /**\n   * Returns a boolean indicating if the given {@link mxCell} should be ignored as a vertex.\n   *\n   * @param vertex {@link mxCell} whose ignored state should be returned.\n   * @return true if the cell has no connections.\n   */\n  isVertexIgnored(vertex) {\n    return super.isVertexIgnored(vertex) || this.graph.getConnections(vertex).length === 0;\n  }\n  /**\n   * Implements {@link GraphLayout#execute}.\n   *\n   * If the parent has any connected edges, then it is used as the root of\n   * the tree. Else, {@link Graph#findTreeRoots} will be used to find a suitable\n   * root node within the set of children of the given parent.\n   *\n   * @param parent    {@link mxCell} whose children should be laid out.\n   * @param root      Optional {@link mxCell} that will be used as the root of the tree.\n   */\n  execute(parent) {\n    let root = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    this.parent = parent;\n    this.useBoundingBox = false;\n    this.edgeRouting = false;\n    // this.horizontal = false;\n    super.execute(parent, root || undefined);\n    let bounds = null;\n    const rootBounds = this.getVertexBounds(this.root);\n    this.centerX = rootBounds.x + rootBounds.width / 2;\n    this.centerY = rootBounds.y + rootBounds.height / 2;\n    // Calculate the bounds of the involved vertices directly from the values set in the compact tree\n    for (const vertex in this.visited) {\n      const vertexBounds = this.getVertexBounds(this.visited[vertex]);\n      bounds = bounds != null ? bounds : vertexBounds.clone();\n      bounds.add(vertexBounds);\n    }\n    this.calcRowDims([this.node], 0);\n    let maxLeftGrad = 0;\n    let maxRightGrad = 0;\n    // Find the steepest left and right gradients\n    for (let i = 0; i < this.row.length; i += 1) {\n      const leftGrad = (this.centerX - this.rowMinX[i] - this.nodeDistance) / this.rowRadi[i];\n      const rightGrad = (this.rowMaxX[i] - this.centerX - this.nodeDistance) / this.rowRadi[i];\n      maxLeftGrad = Math.max(maxLeftGrad, leftGrad);\n      maxRightGrad = Math.max(maxRightGrad, rightGrad);\n    }\n    // Extend out row so they meet the maximum gradient and convert to polar co-ords\n    for (let i = 0; i < this.row.length; i += 1) {\n      const xLeftLimit = this.centerX - this.nodeDistance - maxLeftGrad * this.rowRadi[i];\n      const xRightLimit = this.centerX + this.nodeDistance + maxRightGrad * this.rowRadi[i];\n      const fullWidth = xRightLimit - xLeftLimit;\n      for (let j = 0; j < this.row[i].length; j++) {\n        const row = this.row[i];\n        const node = row[j];\n        const vertexBounds = this.getVertexBounds(node.cell);\n        const xProportion = (vertexBounds.x + vertexBounds.width / 2 - xLeftLimit) / fullWidth;\n        const theta = 2 * Math.PI * xProportion;\n        node.theta = theta;\n      }\n    }\n    // Post-process from outside inwards to try to align parents with children\n    for (let i = this.row.length - 2; i >= 0; i--) {\n      const row = this.row[i];\n      for (let j = 0; j < row.length; j++) {\n        const node = row[j];\n        let {\n          child\n        } = node;\n        let counter = 0;\n        let totalTheta = 0;\n        while (child != null) {\n          totalTheta += child.theta;\n          counter++;\n          child = child.next;\n        }\n        if (counter > 0) {\n          const averTheta = totalTheta / counter;\n          if (averTheta > node.theta && j < row.length - 1) {\n            const nextTheta = row[j + 1].theta;\n            node.theta = Math.min(averTheta, nextTheta - Math.PI / 10);\n          } else if (averTheta < node.theta && j > 0) {\n            const lastTheta = row[j - 1].theta;\n            node.theta = Math.max(averTheta, lastTheta + Math.PI / 10);\n          }\n        }\n      }\n    }\n    // Set locations\n    for (let i = 0; i < this.row.length; i += 1) {\n      for (let j = 0; j < this.row[i].length; j++) {\n        const row = this.row[i];\n        const node = row[j];\n        const vertexBounds = this.getVertexBounds(node.cell);\n        this.setVertexLocation(node.cell, this.centerX - vertexBounds.width / 2 + this.rowRadi[i] * Math.cos(node.theta), this.centerY - vertexBounds.height / 2 + this.rowRadi[i] * Math.sin(node.theta));\n      }\n    }\n  }\n  /**\n   * Recursive function to calculate the dimensions of each row\n   *\n   * @param row      Array of internal nodes, the children of which are to be processed.\n   * @param rowNum   Integer indicating which row is being processed.\n   */\n  calcRowDims(row, rowNum) {\n    if (row == null || row.length === 0) {\n      return;\n    }\n    // Place root's children proportionally around the first level\n    this.rowMinX[rowNum] = this.centerX;\n    this.rowMaxX[rowNum] = this.centerX;\n    this.rowMinCenX[rowNum] = this.centerX;\n    this.rowMaxCenX[rowNum] = this.centerX;\n    this.row[rowNum] = [];\n    let rowHasChildren = false;\n    for (let i = 0; i < row.length; i += 1) {\n      let child = row[i] != null ? row[i].child : null;\n      while (child != null) {\n        const {\n          cell\n        } = child;\n        const vertexBounds = this.getVertexBounds(cell);\n        this.rowMinX[rowNum] = Math.min(vertexBounds.x, this.rowMinX[rowNum]);\n        this.rowMaxX[rowNum] = Math.max(vertexBounds.x + vertexBounds.width, this.rowMaxX[rowNum]);\n        this.rowMinCenX[rowNum] = Math.min(vertexBounds.x + vertexBounds.width / 2, this.rowMinCenX[rowNum]);\n        this.rowMaxCenX[rowNum] = Math.max(vertexBounds.x + vertexBounds.width / 2, this.rowMaxCenX[rowNum]);\n        this.rowRadi[rowNum] = vertexBounds.y - this.getVertexBounds(this.root).y;\n        if (child.child != null) {\n          rowHasChildren = true;\n        }\n        this.row[rowNum].push(child);\n        child = child.next;\n      }\n    }\n    if (rowHasChildren) {\n      this.calcRowDims(this.row[rowNum], rowNum + 1);\n    }\n  }\n}\nexport default RadialTreeLayout;","map":{"version":3,"names":["CompactTreeLayout","RadialTreeLayout","constructor","graph","centerX","centerY","angleOffset","rootx","rooty","levelDistance","nodeDistance","autoRadius","sortEdges","rowMinX","rowMaxX","rowMinCenX","rowMaxCenX","rowRadi","row","isVertexIgnored","vertex","getConnections","length","execute","parent","root","arguments","undefined","useBoundingBox","edgeRouting","bounds","rootBounds","getVertexBounds","x","width","y","height","visited","vertexBounds","clone","add","calcRowDims","node","maxLeftGrad","maxRightGrad","i","leftGrad","rightGrad","Math","max","xLeftLimit","xRightLimit","fullWidth","j","cell","xProportion","theta","PI","child","counter","totalTheta","next","averTheta","nextTheta","min","lastTheta","setVertexLocation","cos","sin","rowNum","rowHasChildren","push"],"sources":["D:/ospanel/domains/old/react/react-intro/node_modules/@maxgraph/core/dist/view/layout/RadialTreeLayout.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { CompactTreeLayout, } from './CompactTreeLayout';\n/**\n * Extends {@link mxGraphLayout} to implement a radial tree algorithm. This\n * layout is suitable for graphs that have no cycles (trees). Vertices that are\n * not connected to the tree will be ignored by this layout.\n *\n * ```javascript\n * var layout = new mxRadialTreeLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * ```\n */\nclass RadialTreeLayout extends CompactTreeLayout {\n    constructor(graph) {\n        super(graph, false);\n        this.centerX = null;\n        this.centerY = null;\n        /**\n         * The initial offset to compute the angle position.\n         * @default 0.5\n         */\n        this.angleOffset = 0.5;\n        /**\n         * The X co-ordinate of the root cell\n         * @default 0\n         */\n        this.rootx = 0;\n        /**\n         * The Y co-ordinate of the root cell\n         * @default 0\n         */\n        this.rooty = 0;\n        /**\n         * Holds the levelDistance.\n         * @default 120\n         */\n        this.levelDistance = 120;\n        /**\n         * Holds the nodeDistance.\n         * @default 10\n         */\n        this.nodeDistance = 10;\n        /**\n         * Specifies if the radios should be computed automatically\n         * @default false\n         */\n        this.autoRadius = false;\n        /**\n         * Specifies if edges should be sorted according to the order of their\n         * opposite terminal cell in the model.\n         * @default false\n         */\n        this.sortEdges = false;\n        /**\n         * Array of leftmost x coordinate of each row\n         */\n        this.rowMinX = {};\n        /**\n         * Array of rightmost x coordinate of each row\n         */\n        this.rowMaxX = {};\n        /**\n         * Array of x coordinate of leftmost vertex of each row\n         */\n        this.rowMinCenX = {};\n        /**\n         * Array of x coordinate of rightmost vertex of each row\n         */\n        this.rowMaxCenX = {};\n        /**\n         * Array of y deltas of each row behind root vertex, also the radius in the tree\n         */\n        this.rowRadi = {};\n        /**\n         * Array of vertices on each row\n         */\n        this.row = [];\n    }\n    /**\n     * Returns a boolean indicating if the given {@link mxCell} should be ignored as a vertex.\n     *\n     * @param vertex {@link mxCell} whose ignored state should be returned.\n     * @return true if the cell has no connections.\n     */\n    isVertexIgnored(vertex) {\n        return (super.isVertexIgnored(vertex) || this.graph.getConnections(vertex).length === 0);\n    }\n    /**\n     * Implements {@link GraphLayout#execute}.\n     *\n     * If the parent has any connected edges, then it is used as the root of\n     * the tree. Else, {@link Graph#findTreeRoots} will be used to find a suitable\n     * root node within the set of children of the given parent.\n     *\n     * @param parent    {@link mxCell} whose children should be laid out.\n     * @param root      Optional {@link mxCell} that will be used as the root of the tree.\n     */\n    execute(parent, root = null) {\n        this.parent = parent;\n        this.useBoundingBox = false;\n        this.edgeRouting = false;\n        // this.horizontal = false;\n        super.execute(parent, root || undefined);\n        let bounds = null;\n        const rootBounds = this.getVertexBounds(this.root);\n        this.centerX = rootBounds.x + rootBounds.width / 2;\n        this.centerY = rootBounds.y + rootBounds.height / 2;\n        // Calculate the bounds of the involved vertices directly from the values set in the compact tree\n        for (const vertex in this.visited) {\n            const vertexBounds = this.getVertexBounds(this.visited[vertex]);\n            bounds = bounds != null ? bounds : vertexBounds.clone();\n            bounds.add(vertexBounds);\n        }\n        this.calcRowDims([this.node], 0);\n        let maxLeftGrad = 0;\n        let maxRightGrad = 0;\n        // Find the steepest left and right gradients\n        for (let i = 0; i < this.row.length; i += 1) {\n            const leftGrad = (this.centerX - this.rowMinX[i] - this.nodeDistance) / this.rowRadi[i];\n            const rightGrad = (this.rowMaxX[i] - this.centerX - this.nodeDistance) / this.rowRadi[i];\n            maxLeftGrad = Math.max(maxLeftGrad, leftGrad);\n            maxRightGrad = Math.max(maxRightGrad, rightGrad);\n        }\n        // Extend out row so they meet the maximum gradient and convert to polar co-ords\n        for (let i = 0; i < this.row.length; i += 1) {\n            const xLeftLimit = this.centerX - this.nodeDistance - maxLeftGrad * this.rowRadi[i];\n            const xRightLimit = this.centerX + this.nodeDistance + maxRightGrad * this.rowRadi[i];\n            const fullWidth = xRightLimit - xLeftLimit;\n            for (let j = 0; j < this.row[i].length; j++) {\n                const row = this.row[i];\n                const node = row[j];\n                const vertexBounds = this.getVertexBounds(node.cell);\n                const xProportion = (vertexBounds.x + vertexBounds.width / 2 - xLeftLimit) / fullWidth;\n                const theta = 2 * Math.PI * xProportion;\n                node.theta = theta;\n            }\n        }\n        // Post-process from outside inwards to try to align parents with children\n        for (let i = this.row.length - 2; i >= 0; i--) {\n            const row = this.row[i];\n            for (let j = 0; j < row.length; j++) {\n                const node = row[j];\n                let { child } = node;\n                let counter = 0;\n                let totalTheta = 0;\n                while (child != null) {\n                    totalTheta += child.theta;\n                    counter++;\n                    child = child.next;\n                }\n                if (counter > 0) {\n                    const averTheta = totalTheta / counter;\n                    if (averTheta > node.theta && j < row.length - 1) {\n                        const nextTheta = row[j + 1].theta;\n                        node.theta = Math.min(averTheta, nextTheta - Math.PI / 10);\n                    }\n                    else if (averTheta < node.theta && j > 0) {\n                        const lastTheta = row[j - 1].theta;\n                        node.theta = Math.max(averTheta, lastTheta + Math.PI / 10);\n                    }\n                }\n            }\n        }\n        // Set locations\n        for (let i = 0; i < this.row.length; i += 1) {\n            for (let j = 0; j < this.row[i].length; j++) {\n                const row = this.row[i];\n                const node = row[j];\n                const vertexBounds = this.getVertexBounds(node.cell);\n                this.setVertexLocation(node.cell, this.centerX -\n                    vertexBounds.width / 2 +\n                    this.rowRadi[i] * Math.cos(node.theta), this.centerY -\n                    vertexBounds.height / 2 +\n                    this.rowRadi[i] * Math.sin(node.theta));\n            }\n        }\n    }\n    /**\n     * Recursive function to calculate the dimensions of each row\n     *\n     * @param row      Array of internal nodes, the children of which are to be processed.\n     * @param rowNum   Integer indicating which row is being processed.\n     */\n    calcRowDims(row, rowNum) {\n        if (row == null || row.length === 0) {\n            return;\n        }\n        // Place root's children proportionally around the first level\n        this.rowMinX[rowNum] = this.centerX;\n        this.rowMaxX[rowNum] = this.centerX;\n        this.rowMinCenX[rowNum] = this.centerX;\n        this.rowMaxCenX[rowNum] = this.centerX;\n        this.row[rowNum] = [];\n        let rowHasChildren = false;\n        for (let i = 0; i < row.length; i += 1) {\n            let child = row[i] != null ? row[i].child : null;\n            while (child != null) {\n                const { cell } = child;\n                const vertexBounds = this.getVertexBounds(cell);\n                this.rowMinX[rowNum] = Math.min(vertexBounds.x, this.rowMinX[rowNum]);\n                this.rowMaxX[rowNum] = Math.max(vertexBounds.x + vertexBounds.width, this.rowMaxX[rowNum]);\n                this.rowMinCenX[rowNum] = Math.min(vertexBounds.x + vertexBounds.width / 2, this.rowMinCenX[rowNum]);\n                this.rowMaxCenX[rowNum] = Math.max(vertexBounds.x + vertexBounds.width / 2, this.rowMaxCenX[rowNum]);\n                this.rowRadi[rowNum] = vertexBounds.y - this.getVertexBounds(this.root).y;\n                if (child.child != null) {\n                    rowHasChildren = true;\n                }\n                this.row[rowNum].push(child);\n                child = child.next;\n            }\n        }\n        if (rowHasChildren) {\n            this.calcRowDims(this.row[rowNum], rowNum + 1);\n        }\n    }\n}\nexport default RadialTreeLayout;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,iBAAiB,QAAS,qBAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,gBAAgB,SAASD,iBAAiB,CAAC;EAC7CE,WAAWA,CAACC,KAAK,EAAE;IACf,KAAK,CAACA,KAAK,EAAE,KAAK,CAAC;IACnB,IAAI,CAACC,OAAO,GAAG,IAAI;IACnB,IAAI,CAACC,OAAO,GAAG,IAAI;IACnB;AACR;AACA;AACA;IACQ,IAAI,CAACC,WAAW,GAAG,GAAG;IACtB;AACR;AACA;AACA;IACQ,IAAI,CAACC,KAAK,GAAG,CAAC;IACd;AACR;AACA;AACA;IACQ,IAAI,CAACC,KAAK,GAAG,CAAC;IACd;AACR;AACA;AACA;IACQ,IAAI,CAACC,aAAa,GAAG,GAAG;IACxB;AACR;AACA;AACA;IACQ,IAAI,CAACC,YAAY,GAAG,EAAE;IACtB;AACR;AACA;AACA;IACQ,IAAI,CAACC,UAAU,GAAG,KAAK;IACvB;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACC,SAAS,GAAG,KAAK;IACtB;AACR;AACA;IACQ,IAAI,CAACC,OAAO,GAAG,CAAC,CAAC;IACjB;AACR;AACA;IACQ,IAAI,CAACC,OAAO,GAAG,CAAC,CAAC;IACjB;AACR;AACA;IACQ,IAAI,CAACC,UAAU,GAAG,CAAC,CAAC;IACpB;AACR;AACA;IACQ,IAAI,CAACC,UAAU,GAAG,CAAC,CAAC;IACpB;AACR;AACA;IACQ,IAAI,CAACC,OAAO,GAAG,CAAC,CAAC;IACjB;AACR;AACA;IACQ,IAAI,CAACC,GAAG,GAAG,EAAE;EACjB;EACA;AACJ;AACA;AACA;AACA;AACA;EACIC,eAAeA,CAACC,MAAM,EAAE;IACpB,OAAQ,KAAK,CAACD,eAAe,CAACC,MAAM,CAAC,IAAI,IAAI,CAACjB,KAAK,CAACkB,cAAc,CAACD,MAAM,CAAC,CAACE,MAAM,KAAK,CAAC;EAC3F;EACA;AACJ;A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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}