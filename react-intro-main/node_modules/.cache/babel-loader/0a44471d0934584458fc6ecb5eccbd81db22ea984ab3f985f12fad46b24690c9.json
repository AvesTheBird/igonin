{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2018, JGraph Ltd\nCopyright (c) 2006-2018, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport HierarchicalLayoutStage from './HierarchicalLayoutStage';\nimport { DIRECTION } from '../../../util/Constants';\nimport MaxLog from '../../../gui/MaxLog';\nimport WeightedCellSorter from '../util/WeightedCellSorter';\nimport Dictionary from '../../../util/Dictionary';\nimport Point from '../../geometry/Point';\nimport HierarchicalEdgeStyle from '../datatypes/HierarchicalEdgeStyle';\n/**\n * Sets the horizontal locations of node and edge dummy nodes on each layer.\n * Uses median down and up weighings as well as heuristics to straighten edges as\n * far as possible.\n *\n * Constructor: mxCoordinateAssignment\n *\n * Creates a coordinate assignment.\n *\n * Arguments:\n *\n * intraCellSpacing - the minimum buffer between cells on the same rank\n * interRankCellSpacing - the minimum distance between cells on adjacent ranks\n * orientation - the position of the root node(s) relative to the graph\n * initialX - the leftmost coordinate node placement starts at\n */\nclass CoordinateAssignment extends HierarchicalLayoutStage {\n  constructor(layout, intraCellSpacing = 30, interRankCellSpacing = 100, orientation, initialX, parallelEdgeSpacing = 10) {\n    super();\n    /**\n     * The minimum buffer between cells on the same rank. Default is 30.\n     */\n    this.intraCellSpacing = 30;\n    /**\n     * The minimum distance between cells on adjacent ranks. Default is 100.\n     */\n    this.interRankCellSpacing = 100;\n    /**\n     * The distance between each parallel edge on each ranks for long edges.\n     * Default is 10.\n     */\n    this.parallelEdgeSpacing = 10;\n    /**\n     * The number of heuristic iterations to run. Default is 8.\n     */\n    this.maxIterations = 8;\n    /**\n     * The preferred horizontal distance between edges exiting a vertex Default is 5.\n     */\n    this.prefHozEdgeSep = 5;\n    /**\n     * The preferred vertical offset between edges exiting a vertex Default is 2.\n     */\n    this.prefVertEdgeOff = 2;\n    /**\n     * The minimum distance for an edge jetty from a vertex Default is 12.\n     */\n    this.minEdgeJetty = 12;\n    /**\n     * The size of the vertical buffer in the center of inter-rank channels\n     * where edge control points should not be placed Default is 4.\n     */\n    this.channelBuffer = 4;\n    /**\n     * Map of internal edges and (x,y) pair of positions of the start and end jetty\n     * for that edge where it connects to the source and target vertices.\n     * Note this should technically be a WeakHashMap, but since JS does not\n     * have an equivalent, housekeeping must be performed before using.\n     * i.e. check all edges are still in the model and clear the values.\n     * Note that the y co-ord is the offset of the jetty, not the\n     * absolute point\n     */\n    this.jettyPositions = null;\n    /**\n     * The position of the root ( start ) node(s) relative to the rest of the\n     * laid out graph. Default is <mxConstants.DIRECTION.NORTH>.\n     */\n    this.orientation = DIRECTION.NORTH;\n    /**\n     * The maximum x value this positioning lays up to\n     */\n    this.limitX = null;\n    /**\n     * The sum of x-displacements for the current iteration\n     */\n    this.currentXDelta = null;\n    /**\n     * The rank that has the widest x position\n     */\n    this.widestRank = null;\n    /**\n     * Internal cache of top-most values of Y for each rank\n     */\n    this.rankTopY = null;\n    /**\n     * Internal cache of bottom-most value of Y for each rank\n     */\n    this.rankBottomY = null;\n    /**\n     * The X-coordinate of the edge of the widest rank\n     */\n    this.widestRankValue = null;\n    /**\n     * The width of all the ranks\n     */\n    this.rankWidths = null;\n    /**\n     * The Y-coordinate of all the ranks\n     */\n    this.rankY = null;\n    /**\n     * Whether or not to perform local optimisations and iterate multiple times\n     * through the algorithm. Default is true.\n     */\n    this.fineTuning = true;\n    /**\n     * A store of connections to the layer above for speed\n     */\n    this.nextLayerConnectedCache = null;\n    /**\n     * A store of connections to the layer below for speed\n     */\n    this.previousLayerConnectedCache = null;\n    /**\n     * Padding added to resized parents Default is 10.\n     */\n    this.groupPadding = 10;\n    this.layout = layout;\n    this.intraCellSpacing = intraCellSpacing;\n    this.interRankCellSpacing = interRankCellSpacing;\n    this.orientation = orientation;\n    this.initialX = initialX;\n    this.parallelEdgeSpacing = parallelEdgeSpacing;\n  }\n  /**\n   * Utility method to display current positions\n   */\n  printStatus() {\n    const model = this.layout.getDataModel();\n    const ranks = model.ranks;\n    MaxLog.show();\n    MaxLog.writeln('======Coord assignment debug=======');\n    for (let j = 0; j < ranks.length; j++) {\n      MaxLog.write('Rank ', String(j), ' : ');\n      const rank = ranks[j];\n      for (let k = 0; k < rank.length; k++) {\n        const cell = rank[k];\n        MaxLog.write(String(cell.getGeneralPurposeVariable(j)), '  ');\n      }\n      MaxLog.writeln();\n    }\n    MaxLog.writeln('====================================');\n  }\n  /**\n   * A basic horizontal coordinate assignment algorithm\n   */\n  execute(parent) {\n    this.jettyPositions = Object();\n    const model = this.layout.getDataModel();\n    this.currentXDelta = 0.0;\n    this.initialCoords(this.layout.getGraph(), model);\n    //  this.printStatus();\n    if (this.fineTuning) {\n      this.minNode(model);\n    }\n    let bestXDelta = 100000000.0;\n    if (this.fineTuning) {\n      for (let i = 0; i < this.maxIterations; i += 1) {\n        //      this.printStatus();\n        // Median Heuristic\n        if (i !== 0) {\n          this.medianPos(i, model);\n          this.minNode(model);\n        }\n        // if the total offset is less for the current positioning,\n        // there are less heavily angled edges and so the current\n        // positioning is used\n        const ranks = model.ranks;\n        if (this.currentXDelta < bestXDelta) {\n          for (let j = 0; j < ranks.length; j++) {\n            const rank = ranks[j];\n            for (let k = 0; k < rank.length; k++) {\n              const cell = rank[k];\n              cell.setX(j, cell.getGeneralPurposeVariable(j));\n            }\n          }\n          bestXDelta = this.currentXDelta;\n        } else {\n          // Restore the best positions\n          for (let j = 0; j < ranks.length; j++) {\n            const rank = ranks[j];\n            for (let k = 0; k < rank.length; k++) {\n              const cell = rank[k];\n              cell.setGeneralPurposeVariable(j, cell.getX(j));\n            }\n          }\n        }\n        this.minPath(this.layout.getGraph(), model);\n        this.currentXDelta = 0;\n      }\n    }\n    this.setCellLocations(this.layout.getGraph(), model);\n  }\n  /**\n   * Performs one median positioning sweep in both directions\n   */\n  minNode(model) {\n    // Queue all nodes\n    const nodeList = [];\n    // Need to be able to map from cell to cellWrapper\n    const map = new Dictionary();\n    const rank = [];\n    for (let i = 0; i <= model.maxRank; i += 1) {\n      rank[i] = model.ranks[i];\n      for (let j = 0; j < rank[i].length; j += 1) {\n        // Use the weight to store the rank and visited to store whether\n        // or not the cell is in the list\n        const node = rank[i][j];\n        const nodeWrapper = new WeightedCellSorter(node, i);\n        nodeWrapper.rankIndex = j;\n        nodeWrapper.visited = true;\n        nodeList.push(nodeWrapper);\n        map.put(node, nodeWrapper);\n      }\n    }\n    // Set a limit of the maximum number of times we will access the queue\n    // in case a loop appears\n    const maxTries = nodeList.length * 10;\n    let count = 0;\n    // Don't move cell within this value of their median\n    const tolerance = 1;\n    while (nodeList.length > 0 && count <= maxTries) {\n      const cellWrapper = nodeList.shift();\n      const cell = cellWrapper.cell;\n      const rankValue = cellWrapper.weightedValue;\n      const rankIndex = parseInt(String(cellWrapper.rankIndex));\n      const nextLayerConnectedCells = cell.getNextLayerConnectedCells(rankValue);\n      const previousLayerConnectedCells = cell.getPreviousLayerConnectedCells(rankValue);\n      const numNextLayerConnected = nextLayerConnectedCells.length;\n      const numPreviousLayerConnected = previousLayerConnectedCells.length;\n      const medianNextLevel = this.medianXValue(nextLayerConnectedCells, rankValue + 1);\n      const medianPreviousLevel = this.medianXValue(previousLayerConnectedCells, rankValue - 1);\n      const numConnectedNeighbours = numNextLayerConnected + numPreviousLayerConnected;\n      const currentPosition = cell.getGeneralPurposeVariable(rankValue);\n      let cellMedian = currentPosition;\n      if (numConnectedNeighbours > 0) {\n        cellMedian = (medianNextLevel * numNextLayerConnected + medianPreviousLevel * numPreviousLayerConnected) / numConnectedNeighbours;\n      }\n      // Flag storing whether or not position has changed\n      let positionChanged = false;\n      if (cellMedian < currentPosition - tolerance) {\n        if (rankIndex === 0) {\n          cell.setGeneralPurposeVariable(rankValue, cellMedian);\n          positionChanged = true;\n        } else {\n          const leftCell = rank[rankValue][rankIndex - 1];\n          let leftLimit = leftCell.getGeneralPurposeVariable(rankValue);\n          leftLimit = leftLimit + leftCell.width / 2 + this.intraCellSpacing + cell.width / 2;\n          if (leftLimit < cellMedian) {\n            cell.setGeneralPurposeVariable(rankValue, cellMedian);\n            positionChanged = true;\n          } else if (leftLimit < cell.getGeneralPurposeVariable(rankValue) - tolerance) {\n            cell.setGeneralPurposeVariable(rankValue, leftLimit);\n            positionChanged = true;\n          }\n        }\n      } else if (cellMedian > currentPosition + tolerance) {\n        const rankSize = rank[rankValue].length;\n        if (rankIndex === rankSize - 1) {\n          cell.setGeneralPurposeVariable(rankValue, cellMedian);\n          positionChanged = true;\n        } else {\n          const rightCell = rank[rankValue][rankIndex + 1];\n          let rightLimit = rightCell.getGeneralPurposeVariable(rankValue);\n          rightLimit = rightLimit - rightCell.width / 2 - this.intraCellSpacing - cell.width / 2;\n          if (rightLimit > cellMedian) {\n            cell.setGeneralPurposeVariable(rankValue, cellMedian);\n            positionChanged = true;\n          } else if (rightLimit > cell.getGeneralPurposeVariable(rankValue) + tolerance) {\n            cell.setGeneralPurposeVariable(rankValue, rightLimit);\n            positionChanged = true;\n          }\n        }\n      }\n      if (positionChanged) {\n        // Add connected nodes to map and list\n        for (let i = 0; i < nextLayerConnectedCells.length; i += 1) {\n          const connectedCell = nextLayerConnectedCells[i];\n          const connectedCellWrapper = map.get(connectedCell);\n          if (connectedCellWrapper != null) {\n            if (connectedCellWrapper.visited == false) {\n              connectedCellWrapper.visited = true;\n              nodeList.push(connectedCellWrapper);\n            }\n          }\n        }\n        // Add connected nodes to map and list\n        for (let i = 0; i < previousLayerConnectedCells.length; i += 1) {\n          const connectedCell = previousLayerConnectedCells[i];\n          const connectedCellWrapper = map.get(connectedCell);\n          if (connectedCellWrapper != null) {\n            if (connectedCellWrapper.visited == false) {\n              connectedCellWrapper.visited = true;\n              nodeList.push(connectedCellWrapper);\n            }\n          }\n        }\n      }\n      cellWrapper.visited = false;\n      count += 1;\n    }\n  }\n  /**\n   * Performs one median positioning sweep in one direction\n   *\n   * @param i the iteration of the whole process\n   * @param model an internal model of the hierarchical layout\n   */\n  medianPos(i, model) {\n    // Reverse sweep direction each time through this method\n    const downwardSweep = i % 2 === 0;\n    if (downwardSweep) {\n      for (let j = model.maxRank; j > 0; j--) {\n        this.rankMedianPosition(j - 1, model, j);\n      }\n    } else {\n      for (let j = 0; j < model.maxRank - 1; j++) {\n        this.rankMedianPosition(j + 1, model, j);\n      }\n    }\n  }\n  /**\n   * Performs median minimisation over one rank.\n   *\n   * @param rankValue the layer number of this rank\n   * @param model an internal model of the hierarchical layout\n   * @param nextRankValue the layer number whose connected cels are to be laid out\n   * relative to\n   */\n  rankMedianPosition(rankValue, model, nextRankValue) {\n    const ranks = model.ranks;\n    const rank = ranks[rankValue];\n    // Form an array of the order in which the cell are to be processed\n    // , the order is given by the weighted sum of the in or out edges,\n    // depending on whether we're traveling up or down the hierarchy.\n    const weightedValues = [];\n    const cellMap = {};\n    for (let i = 0; i < rank.length; i += 1) {\n      const currentCell = rank[i];\n      weightedValues[i] = new WeightedCellSorter(currentCell);\n      weightedValues[i].rankIndex = i;\n      cellMap[currentCell.id] = weightedValues[i];\n      let nextLayerConnectedCells = null;\n      if (nextRankValue < rankValue) {\n        nextLayerConnectedCells = currentCell.getPreviousLayerConnectedCells(rankValue);\n      } else {\n        nextLayerConnectedCells = currentCell.getNextLayerConnectedCells(rankValue);\n      }\n      // Calculate the weighing based on this node type and those this\n      // node is connected to on the next layer\n      weightedValues[i].weightedValue = this.calculatedWeightedValue(currentCell, nextLayerConnectedCells);\n    }\n    weightedValues.sort(WeightedCellSorter.compare);\n    // Set the new position of each node within the rank using\n    // its temp variable\n    for (let i = 0; i < weightedValues.length; i += 1) {\n      let numConnectionsNextLevel = 0;\n      const cell = weightedValues[i].cell;\n      let nextLayerConnectedCells = null;\n      let medianNextLevel = 0;\n      if (nextRankValue < rankValue) {\n        nextLayerConnectedCells = cell.getPreviousLayerConnectedCells(rankValue).slice();\n      } else {\n        nextLayerConnectedCells = cell.getNextLayerConnectedCells(rankValue).slice();\n      }\n      if (nextLayerConnectedCells != null) {\n        numConnectionsNextLevel = nextLayerConnectedCells.length;\n        if (numConnectionsNextLevel > 0) {\n          medianNextLevel = this.medianXValue(nextLayerConnectedCells, nextRankValue);\n        } else {\n          // For case of no connections on the next level set the\n          // median to be the current position and try to be\n          // positioned there\n          medianNextLevel = cell.getGeneralPurposeVariable(rankValue);\n        }\n      }\n      let leftBuffer = 0.0;\n      let leftLimit = -100000000.0;\n      for (let j = weightedValues[i].rankIndex - 1; j >= 0;) {\n        const weightedValue = cellMap[rank[j].id];\n        if (weightedValue != null) {\n          const leftCell = weightedValue.cell;\n          if (weightedValue.visited) {\n            // The left limit is the right hand limit of that\n            // cell plus any allowance for unallocated cells\n            // in-between\n            leftLimit = leftCell.getGeneralPurposeVariable(rankValue) + leftCell.width / 2.0 + this.intraCellSpacing + leftBuffer + cell.width / 2.0;\n            j = -1;\n          } else {\n            leftBuffer += leftCell.width + this.intraCellSpacing;\n            j--;\n          }\n        }\n      }\n      let rightBuffer = 0.0;\n      let rightLimit = 100000000.0;\n      for (let j = weightedValues[i].rankIndex + 1; j < weightedValues.length;) {\n        const weightedValue = cellMap[rank[j].id];\n        if (weightedValue != null) {\n          const rightCell = weightedValue.cell;\n          if (weightedValue.visited) {\n            // The left limit is the right hand limit of that\n            // cell plus any allowance for unallocated cells\n            // in-between\n            rightLimit = rightCell.getGeneralPurposeVariable(rankValue) - rightCell.width / 2.0 - this.intraCellSpacing - rightBuffer - cell.width / 2.0;\n            j = weightedValues.length;\n          } else {\n            rightBuffer += rightCell.width + this.intraCellSpacing;\n            j++;\n          }\n        }\n      }\n      if (medianNextLevel >= leftLimit && medianNextLevel <= rightLimit) {\n        cell.setGeneralPurposeVariable(rankValue, medianNextLevel);\n      } else if (medianNextLevel < leftLimit) {\n        // Couldn't place at median value, place as close to that\n        // value as possible\n        cell.setGeneralPurposeVariable(rankValue, leftLimit);\n        this.currentXDelta = this.currentXDelta + leftLimit - medianNextLevel;\n      } else if (medianNextLevel > rightLimit) {\n        // Couldn't place at median value, place as close to that\n        // value as possible\n        cell.setGeneralPurposeVariable(rankValue, rightLimit);\n        this.currentXDelta = this.currentXDelta + medianNextLevel - rightLimit;\n      }\n      weightedValues[i].visited = true;\n    }\n  }\n  /**\n   * Calculates the priority the specified cell has based on the type of its\n   * cell and the cells it is connected to on the next layer\n   *\n   * @param currentCell the cell whose weight is to be calculated\n   * @param collection the cells the specified cell is connected to\n   */\n  calculatedWeightedValue(currentCell, collection) {\n    let totalWeight = 0;\n    for (let i = 0; i < collection.length; i += 1) {\n      const cell = collection[i];\n      if (currentCell.isVertex() && cell.isVertex()) {\n        totalWeight += 1;\n      } else if (currentCell.isEdge() && cell.isEdge()) {\n        totalWeight += 8;\n      } else {\n        totalWeight += 2;\n      }\n    }\n    return totalWeight;\n  }\n  /**\n   * Calculates the median position of the connected cell on the specified\n   * rank\n   *\n   * @param connectedCells the cells the candidate connects to on this level\n   * @param rankValue the layer number of this rank\n   */\n  medianXValue(connectedCells, rankValue) {\n    if (connectedCells.length === 0) {\n      return 0;\n    }\n    const medianValues = [];\n    for (let i = 0; i < connectedCells.length; i += 1) {\n      medianValues[i] = connectedCells[i].getGeneralPurposeVariable(rankValue);\n    }\n    medianValues.sort((a, b) => a - b);\n    if (connectedCells.length % 2 === 1) {\n      // For odd numbers of adjacent vertices return the median\n      return medianValues[Math.floor(connectedCells.length / 2)];\n    }\n    const medianPoint = connectedCells.length / 2;\n    const leftMedian = medianValues[medianPoint - 1];\n    const rightMedian = medianValues[medianPoint];\n    return (leftMedian + rightMedian) / 2;\n  }\n  /**\n   * Sets up the layout in an initial positioning. The ranks are all centered\n   * as much as possible along the middle vertex in each rank. The other cells\n   * are then placed as close as possible on either side.\n   *\n   * @param facade the facade describing the input graph\n   * @param model an internal model of the hierarchical layout\n   */\n  initialCoords(facade, model) {\n    this.calculateWidestRank(facade, model);\n    // Sweep up and down from the widest rank\n    for (let i = this.widestRank; i >= 0; i--) {\n      if (i < model.maxRank) {\n        this.rankCoordinates(i, facade, model);\n      }\n    }\n    for (let i = this.widestRank + 1; i <= model.maxRank; i += 1) {\n      if (i > 0) {\n        this.rankCoordinates(i, facade, model);\n      }\n    }\n  }\n  /**\n   * Sets up the layout in an initial positioning. All the first cells in each\n   * rank are moved to the left and the rest of the rank inserted as close\n   * together as their size and buffering permits. This method works on just\n   * the specified rank.\n   *\n   * @param rankValue the current rank being processed\n   * @param graph the facade describing the input graph\n   * @param model an internal model of the hierarchical layout\n   */\n  rankCoordinates(rankValue, graph, model) {\n    const ranks = model.ranks;\n    const rank = ranks[rankValue];\n    let maxY = 0.0;\n    let localX = this.initialX + (this.widestRankValue - this.rankWidths[rankValue]) / 2;\n    // Store whether or not any of the cells' bounds were unavailable so\n    // to only issue the warning once for all cells\n    let boundsWarning = false;\n    for (let i = 0; i < rank.length; i += 1) {\n      const node = rank[i];\n      if (node.isVertex()) {\n        const bounds = this.layout.getVertexBounds(node.cell);\n        if (bounds != null) {\n          if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.SOUTH) {\n            node.width = bounds.width;\n            node.height = bounds.height;\n          } else {\n            node.width = bounds.height;\n            node.height = bounds.width;\n          }\n        } else {\n          boundsWarning = true;\n        }\n        maxY = Math.max(maxY, node.height);\n      } else if (node.isEdge()) {\n        // The width is the number of additional parallel edges\n        // time the parallel edge spacing\n        let numEdges = 1;\n        if (node.edges != null) {\n          numEdges = node.edges.length;\n        } else {\n          MaxLog.warn('edge.edges is null');\n        }\n        node.width = (numEdges - 1) * this.parallelEdgeSpacing;\n      }\n      // Set the initial x-value as being the best result so far\n      localX += node.width / 2.0;\n      node.setX(rankValue, localX);\n      node.setGeneralPurposeVariable(rankValue, localX);\n      localX += node.width / 2.0;\n      localX += this.intraCellSpacing;\n    }\n    if (boundsWarning == true) {\n      MaxLog.warn('At least one cell has no bounds');\n    }\n  }\n  /**\n   * Calculates the width rank in the hierarchy. Also set the y value of each\n   * rank whilst performing the calculation\n   *\n   * @param graph the facade describing the input graph\n   * @param model an internal model of the hierarchical layout\n   */\n  calculateWidestRank(graph, model) {\n    // Starting y co-ordinate\n    let y = -this.interRankCellSpacing;\n    // Track the widest cell on the last rank since the y\n    // difference depends on it\n    let lastRankMaxCellHeight = 0.0;\n    this.rankWidths = [];\n    this.rankY = [];\n    for (let rankValue = model.maxRank; rankValue >= 0; rankValue -= 1) {\n      // Keep track of the widest cell on this rank\n      let maxCellHeight = 0.0;\n      const ranks = model.ranks;\n      const rank = ranks[rankValue];\n      let localX = this.initialX;\n      // Store whether or not any of the cells' bounds were unavailable so\n      // to only issue the warning once for all cells\n      let boundsWarning = false;\n      for (let i = 0; i < rank.length; i += 1) {\n        const node = rank[i];\n        if (node.isVertex()) {\n          const bounds = this.layout.getVertexBounds(node.cell);\n          if (bounds != null) {\n            if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.SOUTH) {\n              node.width = bounds.width;\n              node.height = bounds.height;\n            } else {\n              node.width = bounds.height;\n              node.height = bounds.width;\n            }\n          } else {\n            boundsWarning = true;\n          }\n          maxCellHeight = Math.max(maxCellHeight, node.height);\n        } else if (node.isEdge()) {\n          // The width is the number of additional parallel edges\n          // time the parallel edge spacing\n          let numEdges = 1;\n          if (node.edges != null) {\n            numEdges = node.edges.length;\n          } else {\n            MaxLog.warn('edge.edges is null');\n          }\n          node.width = (numEdges - 1) * this.parallelEdgeSpacing;\n        }\n        // Set the initial x-value as being the best result so far\n        localX += node.width / 2.0;\n        node.setX(rankValue, localX);\n        node.setGeneralPurposeVariable(rankValue, localX);\n        localX += node.width / 2.0;\n        localX += this.intraCellSpacing;\n        if (localX > this.widestRankValue) {\n          this.widestRankValue = localX;\n          this.widestRank = rankValue;\n        }\n        this.rankWidths[rankValue] = localX;\n      }\n      if (boundsWarning == true) {\n        MaxLog.warn('At least one cell has no bounds');\n      }\n      this.rankY[rankValue] = y;\n      const distanceToNextRank = maxCellHeight / 2.0 + lastRankMaxCellHeight / 2.0 + this.interRankCellSpacing;\n      lastRankMaxCellHeight = maxCellHeight;\n      if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.WEST) {\n        y += distanceToNextRank;\n      } else {\n        y -= distanceToNextRank;\n      }\n      for (let i = 0; i < rank.length; i += 1) {\n        const cell = rank[i];\n        cell.setY(rankValue, y);\n      }\n    }\n  }\n  /**\n   * Straightens out chains of virtual nodes where possibleacade to those stored after this layout\n   * processing step has completed.\n   *\n   * @param graph the facade describing the input graph\n   * @param model an internal model of the hierarchical layout\n   */\n  minPath(graph, model) {\n    // Work down and up each edge with at least 2 control points\n    // trying to straighten each one out. If the same number of\n    // straight segments are formed in both directions, the\n    // preferred direction used is the one where the final\n    // control points have the least offset from the connectable\n    // region of the terminating vertices\n    const edges = model.edgeMapper.getValues();\n    for (let j = 0; j < edges.length; j++) {\n      const cell = edges[j];\n      if (cell.maxRank - cell.minRank - 1 < 1) {\n        continue;\n      }\n      // At least two virtual nodes in the edge\n      // Check first whether the edge is already straight\n      let referenceX = cell.getGeneralPurposeVariable(cell.minRank + 1);\n      let edgeStraight = true;\n      let refSegCount = 0;\n      for (let i = cell.minRank + 2; i < cell.maxRank; i += 1) {\n        const x = cell.getGeneralPurposeVariable(i);\n        if (referenceX !== x) {\n          edgeStraight = false;\n          referenceX = x;\n        } else {\n          refSegCount += 1;\n        }\n      }\n      if (!edgeStraight) {\n        let upSegCount = 0;\n        let downSegCount = 0;\n        const upXPositions = [];\n        const downXPositions = [];\n        let i = 0;\n        let currentX = cell.getGeneralPurposeVariable(cell.minRank + 1);\n        for (i = cell.minRank + 1; i < cell.maxRank - 1; i += 1) {\n          // Attempt to straight out the control point on the\n          // next segment up with the current control point.\n          const nextX = cell.getX(i + 1);\n          if (currentX === nextX) {\n            upXPositions[i - cell.minRank - 1] = currentX;\n            upSegCount += 1;\n          } else if (this.repositionValid(model, cell, i + 1, currentX)) {\n            upXPositions[i - cell.minRank - 1] = currentX;\n            upSegCount += 1;\n            // Leave currentX at same value\n          } else {\n            upXPositions[i - cell.minRank - 1] = nextX;\n            currentX = nextX;\n          }\n        }\n        currentX = cell.getX(i);\n        for (let i = cell.maxRank - 1; i > cell.minRank + 1; i--) {\n          // Attempt to straight out the control point on the\n          // next segment down with the current control point.\n          const nextX = cell.getX(i - 1);\n          if (currentX === nextX) {\n            downXPositions[i - cell.minRank - 2] = currentX;\n            downSegCount += 1;\n          } else if (this.repositionValid(model, cell, i - 1, currentX)) {\n            downXPositions[i - cell.minRank - 2] = currentX;\n            downSegCount += 1;\n            // Leave currentX at same value\n          } else {\n            downXPositions[i - cell.minRank - 2] = cell.getX(i - 1);\n            currentX = nextX;\n          }\n        }\n        if (downSegCount > refSegCount || upSegCount > refSegCount) {\n          if (downSegCount >= upSegCount) {\n            // Apply down calculation values\n            for (let i = cell.maxRank - 2; i > cell.minRank; i--) {\n              cell.setX(i, downXPositions[i - cell.minRank - 1]);\n            }\n          } else if (upSegCount > downSegCount) {\n            // Apply up calculation values\n            for (let i = cell.minRank + 2; i < cell.maxRank; i += 1) {\n              cell.setX(i, upXPositions[i - cell.minRank - 2]);\n            }\n          } else {\n            // Neither direction provided a favourable result\n            // But both calculations are better than the\n            // existing solution, so apply the one with minimal\n            // offset to attached vertices at either end.\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Determines whether or not a node may be moved to the specified x\n   * position on the specified rank\n   *\n   * @param model the layout model\n   * @param cell the cell being analysed\n   * @param rank the layer of the cell\n   * @param position the x position being sought\n   */\n  repositionValid(model, cell, rank, position) {\n    const ranks = model.ranks;\n    const rankArray = ranks[rank];\n    let rankIndex = -1;\n    for (let i = 0; i < rankArray.length; i += 1) {\n      if (cell === rankArray[i]) {\n        rankIndex = i;\n        break;\n      }\n    }\n    if (rankIndex < 0) {\n      return false;\n    }\n    const currentX = cell.getGeneralPurposeVariable(rank);\n    if (position < currentX) {\n      // Trying to move node to the left.\n      if (rankIndex === 0) {\n        // Left-most node, can move anywhere\n        return true;\n      }\n      const leftCell = rankArray[rankIndex - 1];\n      let leftLimit = leftCell.getGeneralPurposeVariable(rank);\n      leftLimit = leftLimit + leftCell.width / 2 + this.intraCellSpacing + cell.width / 2;\n      return leftLimit <= position;\n    }\n    if (position > currentX) {\n      // Trying to move node to the right.\n      if (rankIndex === rankArray.length - 1) {\n        // Right-most node, can move anywhere\n        return true;\n      }\n      const rightCell = rankArray[rankIndex + 1];\n      let rightLimit = rightCell.getGeneralPurposeVariable(rank);\n      rightLimit = rightLimit - rightCell.width / 2 - this.intraCellSpacing - cell.width / 2;\n      return rightLimit >= position;\n    }\n    return true;\n  }\n  /**\n   * Sets the cell locations in the facade to those stored after this layout\n   * processing step has completed.\n   *\n   * @param graph the input graph\n   * @param model the layout model\n   */\n  setCellLocations(graph, model) {\n    this.rankTopY = [];\n    this.rankBottomY = [];\n    const ranks = model.ranks;\n    for (let i = 0; i < ranks.length; i += 1) {\n      this.rankTopY[i] = Number.MAX_VALUE;\n      this.rankBottomY[i] = -Number.MAX_VALUE;\n    }\n    const vertices = model.vertexMapper.getValues();\n    // Process vertices all first, since they define the lower and\n    // limits of each rank. Between these limits lie the channels\n    // where the edges can be routed across the graph\n    for (let i = 0; i < vertices.length; i += 1) {\n      this.setVertexLocation(vertices[i]);\n    }\n    // Post process edge styles. Needs the vertex locations set for initial\n    // values of the top and bottoms of each rank\n    if (this.layout.edgeStyle === HierarchicalEdgeStyle.ORTHOGONAL || this.layout.edgeStyle === HierarchicalEdgeStyle.POLYLINE || this.layout.edgeStyle === HierarchicalEdgeStyle.CURVE) {\n      this.localEdgeProcessing(model);\n    }\n    const edges = model.edgeMapper.getValues();\n    for (let i = 0; i < edges.length; i += 1) {\n      this.setEdgePosition(edges[i]);\n    }\n  }\n  /**\n   * Separates the x position of edges as they connect to vertices\n   *\n   * @param model the layout model\n   */\n  localEdgeProcessing(model) {\n    // Iterate through each vertex, look at the edges connected in\n    // both directions.\n    const ranks = model.ranks;\n    for (let rankIndex = 0; rankIndex < ranks.length; rankIndex += 1) {\n      const rank = ranks[rankIndex];\n      for (let cellIndex = 0; cellIndex < rank.length; cellIndex += 1) {\n        const cell = rank[cellIndex];\n        if (cell.isVertex()) {\n          let currentCells = cell.getPreviousLayerConnectedCells(rankIndex);\n          let currentRank = rankIndex - 1;\n          // Two loops, last connected cells, and next\n          for (let k = 0; k < 2; k += 1) {\n            if (currentRank > -1 && currentRank < ranks.length && currentCells != null && currentCells.length > 0) {\n              const sortedCells = [];\n              for (let j = 0; j < currentCells.length; j++) {\n                const sorter = new WeightedCellSorter(currentCells[j], currentCells[j].getX(currentRank));\n                sortedCells.push(sorter);\n              }\n              sortedCells.sort(WeightedCellSorter.compare);\n              let leftLimit = cell.x[0] - cell.width / 2;\n              let rightLimit = leftLimit + cell.width;\n              // Connected edge count starts at 1 to allow for buffer\n              // with edge of vertex\n              let connectedEdgeCount = 0;\n              let connectedEdgeGroupCount = 0;\n              const connectedEdges = [];\n              // Calculate width requirements for all connected edges\n              for (let j = 0; j < sortedCells.length; j++) {\n                const innerCell = sortedCells[j].cell;\n                let connections;\n                if (innerCell.isVertex()) {\n                  // Get the connecting edge\n                  if (k === 0) {\n                    connections = cell.connectsAsSource;\n                  } else {\n                    connections = cell.connectsAsTarget;\n                  }\n                  for (let connIndex = 0; connIndex < connections.length; connIndex += 1) {\n                    if (connections[connIndex].source === innerCell || connections[connIndex].target === innerCell) {\n                      connectedEdgeCount += connections[connIndex].edges.length;\n                      connectedEdgeGroupCount += 1;\n                      connectedEdges.push(connections[connIndex]);\n                    }\n                  }\n                } else {\n                  connectedEdgeCount += innerCell.edges.length;\n                  connectedEdgeGroupCount += 1;\n                  connectedEdges.push(innerCell);\n                }\n              }\n              const requiredWidth = (connectedEdgeCount + 1) * this.prefHozEdgeSep;\n              // Add a buffer on the edges of the vertex if the edge count allows\n              if (cell.width > requiredWidth + 2 * this.prefHozEdgeSep) {\n                leftLimit += this.prefHozEdgeSep;\n                rightLimit -= this.prefHozEdgeSep;\n              }\n              const availableWidth = rightLimit - leftLimit;\n              const edgeSpacing = availableWidth / connectedEdgeCount;\n              let currentX = leftLimit + edgeSpacing / 2.0;\n              let currentYOffset = this.minEdgeJetty - this.prefVertEdgeOff;\n              let maxYOffset = 0;\n              for (let j = 0; j < connectedEdges.length; j++) {\n                const numActualEdges = connectedEdges[j].edges.length;\n                const jettyPositions = this.jettyPositions;\n                let pos = jettyPositions[connectedEdges[j].ids[0]];\n                if (pos == null) {\n                  pos = [];\n                  jettyPositions[connectedEdges[j].ids[0]] = pos;\n                }\n                if (j < connectedEdgeCount / 2) {\n                  currentYOffset += this.prefVertEdgeOff;\n                } else if (j > connectedEdgeCount / 2) {\n                  currentYOffset -= this.prefVertEdgeOff;\n                }\n                // Ignore the case if equals, this means the second of 2\n                // jettys with the same y (even number of edges)\n                for (let m = 0; m < numActualEdges; m += 1) {\n                  pos[m * 4 + k * 2] = currentX;\n                  currentX += edgeSpacing;\n                  pos[m * 4 + k * 2 + 1] = currentYOffset;\n                }\n                maxYOffset = Math.max(maxYOffset, currentYOffset);\n              }\n            }\n            currentCells = cell.getNextLayerConnectedCells(rankIndex);\n            currentRank = rankIndex + 1;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Fixes the control points\n   */\n  setEdgePosition(cell) {\n    // For parallel edges we need to seperate out the points a\n    // little\n    let offsetX = 0;\n    // Only set the edge control points once\n    if (cell.temp[0] !== 101207) {\n      let {\n        maxRank\n      } = cell;\n      let {\n        minRank\n      } = cell;\n      if (maxRank === minRank) {\n        maxRank = cell.source.maxRank;\n        minRank = cell.target.minRank;\n      }\n      let parallelEdgeCount = 0;\n      const jettyPositions = this.jettyPositions;\n      const jettys = jettyPositions[cell.ids[0]];\n      const source = cell.isReversed ? cell.target.cell : cell.source.cell;\n      const {\n        graph\n      } = this.layout;\n      const layoutReversed = this.orientation === DIRECTION.EAST || this.orientation === DIRECTION.SOUTH;\n      for (let i = 0; i < cell.edges.length; i += 1) {\n        const realEdge = cell.edges[i];\n        const realSource = this.layout.getVisibleTerminal(realEdge, true);\n        // List oldPoints = graph.getPoints(realEdge);\n        const newPoints = [];\n        // Single length reversed edges end up with the jettys in the wrong\n        // places. Since single length edges only have jettys, not segment\n        // control points, we just say the edge isn't reversed in this section\n        let reversed = cell.isReversed;\n        if (realSource !== source) {\n          // The real edges include all core model edges and these can go\n          // in both directions. If the source of the hierarchical model edge\n          // isn't the source of the specific real edge in this iteration\n          // treat if as reversed\n          reversed = !reversed;\n        }\n        // First jetty of edge\n        if (jettys != null) {\n          const arrayOffset = reversed ? 2 : 0;\n          const rankBottomY = this.rankBottomY;\n          const rankTopY = this.rankTopY;\n          let y = reversed ? layoutReversed ? rankBottomY[minRank] : rankTopY[minRank] : layoutReversed ? rankTopY[maxRank] : rankBottomY[maxRank];\n          let jetty = jettys[parallelEdgeCount * 4 + 1 + arrayOffset];\n          if (reversed !== layoutReversed) {\n            jetty = -jetty;\n          }\n          y += jetty;\n          let x = jettys[parallelEdgeCount * 4 + arrayOffset];\n          const modelSource = realEdge.getTerminal(true);\n          if (this.layout.isPort(modelSource) && modelSource.getParent() === realSource) {\n            const state = graph.view.getState(modelSource);\n            if (state != null) {\n              x = state.x;\n            } else {\n              x = realSource.geometry.x + cell.source.width * modelSource.geometry.x;\n            }\n          }\n          if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.SOUTH) {\n            newPoints.push(new Point(x, y));\n            if (this.layout.edgeStyle === HierarchicalEdgeStyle.CURVE) {\n              newPoints.push(new Point(x, y + jetty));\n            }\n          } else {\n            newPoints.push(new Point(y, x));\n            if (this.layout.edgeStyle === HierarchicalEdgeStyle.CURVE) {\n              newPoints.push(new Point(y + jetty, x));\n            }\n          }\n        }\n        // Declare variables to define loop through edge points and\n        // change direction if edge is reversed\n        let loopStart = cell.x.length - 1;\n        let loopLimit = -1;\n        let loopDelta = -1;\n        let currentRank = cell.maxRank - 1;\n        if (reversed) {\n          loopStart = 0;\n          loopLimit = cell.x.length;\n          loopDelta = 1;\n          currentRank = cell.minRank + 1;\n        }\n        // Reversed edges need the points inserted in\n        // reverse order\n        for (let j = loopStart; cell.maxRank !== cell.minRank && j !== loopLimit; j += loopDelta) {\n          // The horizontal position in a vertical layout\n          const positionX = cell.x[j] + offsetX;\n          // Work out the vertical positions in a vertical layout\n          // in the edge buffer channels above and below this rank\n          const rankTopY = this.rankTopY;\n          const rankBottomY = this.rankBottomY;\n          let topChannelY = (rankTopY[currentRank] + rankBottomY[currentRank + 1]) / 2.0;\n          let bottomChannelY = (rankTopY[currentRank - 1] + rankBottomY[currentRank]) / 2.0;\n          if (reversed) {\n            const tmp = topChannelY;\n            topChannelY = bottomChannelY;\n            bottomChannelY = tmp;\n          }\n          if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.SOUTH) {\n            newPoints.push(new Point(positionX, topChannelY));\n            newPoints.push(new Point(positionX, bottomChannelY));\n          } else {\n            newPoints.push(new Point(topChannelY, positionX));\n            newPoints.push(new Point(bottomChannelY, positionX));\n          }\n          this.limitX = Math.max(this.limitX, positionX);\n          currentRank += loopDelta;\n        }\n        // Second jetty of edge\n        if (jettys != null) {\n          const arrayOffset = reversed ? 2 : 0;\n          const rankTopY = this.rankTopY;\n          const rankBottomY = this.rankBottomY;\n          const rankY = reversed ? layoutReversed ? rankTopY[maxRank] : rankBottomY[maxRank] : layoutReversed ? rankBottomY[minRank] : rankTopY[minRank];\n          let jetty = jettys[parallelEdgeCount * 4 + 3 - arrayOffset];\n          if (reversed !== layoutReversed) {\n            jetty = -jetty;\n          }\n          const y = rankY - jetty;\n          let x = jettys[parallelEdgeCount * 4 + 2 - arrayOffset];\n          const modelTarget = realEdge.getTerminal(false);\n          const realTarget = this.layout.getVisibleTerminal(realEdge, false);\n          if (this.layout.isPort(modelTarget) && modelTarget.getParent() === realTarget) {\n            const state = graph.view.getState(modelTarget);\n            if (state != null) {\n              x = state.x;\n            } else {\n              x = realTarget.geometry.x + cell.target.width * modelTarget.geometry.x;\n            }\n          }\n          if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.SOUTH) {\n            if (this.layout.edgeStyle === HierarchicalEdgeStyle.CURVE) {\n              newPoints.push(new Point(x, y - jetty));\n            }\n            newPoints.push(new Point(x, y));\n          } else {\n            if (this.layout.edgeStyle === HierarchicalEdgeStyle.CURVE) {\n              newPoints.push(new Point(y - jetty, x));\n            }\n            newPoints.push(new Point(y, x));\n          }\n        }\n        if (cell.isReversed) {\n          this.processReversedEdge(cell, realEdge);\n        }\n        this.layout.setEdgePoints(realEdge, newPoints);\n        // Increase offset so next edge is drawn next to\n        // this one\n        if (offsetX === 0.0) {\n          offsetX = this.parallelEdgeSpacing;\n        } else if (offsetX > 0) {\n          offsetX = -offsetX;\n        } else {\n          offsetX = -offsetX + this.parallelEdgeSpacing;\n        }\n        parallelEdgeCount++;\n      }\n      cell.temp[0] = 101207;\n    }\n  }\n  /**\n   * Fixes the position of the specified vertex.\n   *\n   * @param cell the vertex to position\n   */\n  setVertexLocation(cell) {\n    const realCell = cell.cell;\n    const positionX = cell.x[0] - cell.width / 2;\n    const positionY = cell.y[0] - cell.height / 2;\n    const rankTopY = this.rankTopY;\n    const rankBottomY = this.rankBottomY;\n    rankTopY[cell.minRank] = Math.min(rankTopY[cell.minRank], positionY);\n    rankBottomY[cell.minRank] = Math.max(rankBottomY[cell.minRank], positionY + cell.height);\n    if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.SOUTH) {\n      this.layout.setVertexLocation(realCell, positionX, positionY);\n    } else {\n      this.layout.setVertexLocation(realCell, positionY, positionX);\n    }\n    this.limitX = Math.max(this.limitX, positionX + cell.width);\n  }\n  /**\n   * Hook to add additional processing\n   *\n   * @param edge the hierarchical model edge\n   * @param realEdge the real edge in the graph\n   */\n  processReversedEdge(edge, realEdge) {\n    // hook for subclassers\n  }\n}\nexport default CoordinateAssignment;","map":{"version":3,"names":["HierarchicalLayoutStage","DIRECTION","MaxLog","WeightedCellSorter","Dictionary","Point","HierarchicalEdgeStyle","CoordinateAssignment","constructor","layout","intraCellSpacing","interRankCellSpacing","orientation","initialX","parallelEdgeSpacing","maxIterations","prefHozEdgeSep","prefVertEdgeOff","minEdgeJetty","channelBuffer","jettyPositions","NORTH","limitX","currentXDelta","widestRank","rankTopY","rankBottomY","widestRankValue","rankWidths","rankY","fineTuning","nextLayerConnectedCache","previousLayerConnectedCache","groupPadding","printStatus","model","getDataModel","ranks","show","writeln","j","length","write","String","rank","k","cell","getGeneralPurposeVariable","execute","parent","Object","initialCoords","getGraph","minNode","bestXDelta","i","medianPos","setX","setGeneralPurposeVariable","getX","minPath","setCellLocations","nodeList","map","maxRank","node","nodeWrapper","rankIndex","visited","push","put","maxTries","count","tolerance","cellWrapper","shift","rankValue","weightedValue","parseInt","nextLayerConnectedCells","getNextLayerConnectedCells","previousLayerConnectedCells","getPreviousLayerConnectedCells","numNextLayerConnected","numPreviousLayerConnected","medianNextLevel","medianXValue","medianPreviousLevel","numConnectedNeighbours","currentPosition","cellMedian","positionChanged","leftCell","leftLimit","width","rankSize","rightCell","rightLimit","connectedCell","connectedCellWrapper","get","downwardSweep","rankMedianPosition","nextRankValue","weightedValues","cellMap","currentCell","id","calculatedWeightedValue","sort","compare","numConnectionsNextLevel","slice","leftBuffer","rightBuffer","collection","totalWeight","isVertex","isEdge","connectedCells","medianValues","a","b","Math","floor","medianPoint","leftMedian","rightMedian","facade","calculateWidestRank","rankCoordinates","graph","maxY","localX","boundsWarning","bounds","getVertexBounds","SOUTH","height","max","numEdges","edges","warn","y","lastRankMaxCellHeight","maxCellHeight","distanceToNextRank","WEST","setY","edgeMapper","getValues","minRank","referenceX","edgeStraight","refSegCount","x","upSegCount","downSegCount","upXPositions","downXPositions","currentX","nextX","repositionValid","position","rankArray","Number","MAX_VALUE","vertices","vertexMapper","setVertexLocation","edgeStyle","ORTHOGONAL","POLYLINE","CURVE","localEdgeProcessing","setEdgePosition","cellIndex","currentCells","currentRank","sortedCells","sorter","connectedEdgeCount","connectedEdgeGroupCount","connectedEdges","innerCell","connections","connectsAsSource","connectsAsTarget","connIndex","source","target","requiredWidth","availableWidth","edgeSpacing","currentYOffset","maxYOffset","numActualEdges","pos","ids","m","offsetX","temp","parallelEdgeCount","jettys","isReversed","layoutReversed","EAST","realEdge","realSource","getVisibleTerminal","newPoints","reversed","arrayOffset","jetty","modelSource","getTerminal","isPort","getParent","state","view","getState","geometry","loopStart","loopLimit","loopDelta","positionX","topChannelY","bottomChannelY","tmp","modelTarget","realTarget","processReversedEdge","setEdgePoints","realCell","positionY","min","edge"],"sources":["D:/ospanel/domains/old/react/react-intro-main/node_modules/@maxgraph/core/dist/view/layout/hierarchical/CoordinateAssignment.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2018, JGraph Ltd\nCopyright (c) 2006-2018, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport HierarchicalLayoutStage from './HierarchicalLayoutStage';\nimport { DIRECTION } from '../../../util/Constants';\nimport MaxLog from '../../../gui/MaxLog';\nimport WeightedCellSorter from '../util/WeightedCellSorter';\nimport Dictionary from '../../../util/Dictionary';\nimport Point from '../../geometry/Point';\nimport HierarchicalEdgeStyle from '../datatypes/HierarchicalEdgeStyle';\n/**\n * Sets the horizontal locations of node and edge dummy nodes on each layer.\n * Uses median down and up weighings as well as heuristics to straighten edges as\n * far as possible.\n *\n * Constructor: mxCoordinateAssignment\n *\n * Creates a coordinate assignment.\n *\n * Arguments:\n *\n * intraCellSpacing - the minimum buffer between cells on the same rank\n * interRankCellSpacing - the minimum distance between cells on adjacent ranks\n * orientation - the position of the root node(s) relative to the graph\n * initialX - the leftmost coordinate node placement starts at\n */\nclass CoordinateAssignment extends HierarchicalLayoutStage {\n    constructor(layout, intraCellSpacing = 30, interRankCellSpacing = 100, orientation, initialX, parallelEdgeSpacing = 10) {\n        super();\n        /**\n         * The minimum buffer between cells on the same rank. Default is 30.\n         */\n        this.intraCellSpacing = 30;\n        /**\n         * The minimum distance between cells on adjacent ranks. Default is 100.\n         */\n        this.interRankCellSpacing = 100;\n        /**\n         * The distance between each parallel edge on each ranks for long edges.\n         * Default is 10.\n         */\n        this.parallelEdgeSpacing = 10;\n        /**\n         * The number of heuristic iterations to run. Default is 8.\n         */\n        this.maxIterations = 8;\n        /**\n         * The preferred horizontal distance between edges exiting a vertex Default is 5.\n         */\n        this.prefHozEdgeSep = 5;\n        /**\n         * The preferred vertical offset between edges exiting a vertex Default is 2.\n         */\n        this.prefVertEdgeOff = 2;\n        /**\n         * The minimum distance for an edge jetty from a vertex Default is 12.\n         */\n        this.minEdgeJetty = 12;\n        /**\n         * The size of the vertical buffer in the center of inter-rank channels\n         * where edge control points should not be placed Default is 4.\n         */\n        this.channelBuffer = 4;\n        /**\n         * Map of internal edges and (x,y) pair of positions of the start and end jetty\n         * for that edge where it connects to the source and target vertices.\n         * Note this should technically be a WeakHashMap, but since JS does not\n         * have an equivalent, housekeeping must be performed before using.\n         * i.e. check all edges are still in the model and clear the values.\n         * Note that the y co-ord is the offset of the jetty, not the\n         * absolute point\n         */\n        this.jettyPositions = null;\n        /**\n         * The position of the root ( start ) node(s) relative to the rest of the\n         * laid out graph. Default is <mxConstants.DIRECTION.NORTH>.\n         */\n        this.orientation = DIRECTION.NORTH;\n        /**\n         * The maximum x value this positioning lays up to\n         */\n        this.limitX = null;\n        /**\n         * The sum of x-displacements for the current iteration\n         */\n        this.currentXDelta = null;\n        /**\n         * The rank that has the widest x position\n         */\n        this.widestRank = null;\n        /**\n         * Internal cache of top-most values of Y for each rank\n         */\n        this.rankTopY = null;\n        /**\n         * Internal cache of bottom-most value of Y for each rank\n         */\n        this.rankBottomY = null;\n        /**\n         * The X-coordinate of the edge of the widest rank\n         */\n        this.widestRankValue = null;\n        /**\n         * The width of all the ranks\n         */\n        this.rankWidths = null;\n        /**\n         * The Y-coordinate of all the ranks\n         */\n        this.rankY = null;\n        /**\n         * Whether or not to perform local optimisations and iterate multiple times\n         * through the algorithm. Default is true.\n         */\n        this.fineTuning = true;\n        /**\n         * A store of connections to the layer above for speed\n         */\n        this.nextLayerConnectedCache = null;\n        /**\n         * A store of connections to the layer below for speed\n         */\n        this.previousLayerConnectedCache = null;\n        /**\n         * Padding added to resized parents Default is 10.\n         */\n        this.groupPadding = 10;\n        this.layout = layout;\n        this.intraCellSpacing = intraCellSpacing;\n        this.interRankCellSpacing = interRankCellSpacing;\n        this.orientation = orientation;\n        this.initialX = initialX;\n        this.parallelEdgeSpacing = parallelEdgeSpacing;\n    }\n    /**\n     * Utility method to display current positions\n     */\n    printStatus() {\n        const model = this.layout.getDataModel();\n        const ranks = model.ranks;\n        MaxLog.show();\n        MaxLog.writeln('======Coord assignment debug=======');\n        for (let j = 0; j < ranks.length; j++) {\n            MaxLog.write('Rank ', String(j), ' : ');\n            const rank = ranks[j];\n            for (let k = 0; k < rank.length; k++) {\n                const cell = rank[k];\n                MaxLog.write(String(cell.getGeneralPurposeVariable(j)), '  ');\n            }\n            MaxLog.writeln();\n        }\n        MaxLog.writeln('====================================');\n    }\n    /**\n     * A basic horizontal coordinate assignment algorithm\n     */\n    execute(parent) {\n        this.jettyPositions = Object();\n        const model = this.layout.getDataModel();\n        this.currentXDelta = 0.0;\n        this.initialCoords(this.layout.getGraph(), model);\n        //  this.printStatus();\n        if (this.fineTuning) {\n            this.minNode(model);\n        }\n        let bestXDelta = 100000000.0;\n        if (this.fineTuning) {\n            for (let i = 0; i < this.maxIterations; i += 1) {\n                //      this.printStatus();\n                // Median Heuristic\n                if (i !== 0) {\n                    this.medianPos(i, model);\n                    this.minNode(model);\n                }\n                // if the total offset is less for the current positioning,\n                // there are less heavily angled edges and so the current\n                // positioning is used\n                const ranks = model.ranks;\n                if (this.currentXDelta < bestXDelta) {\n                    for (let j = 0; j < ranks.length; j++) {\n                        const rank = ranks[j];\n                        for (let k = 0; k < rank.length; k++) {\n                            const cell = rank[k];\n                            cell.setX(j, cell.getGeneralPurposeVariable(j));\n                        }\n                    }\n                    bestXDelta = this.currentXDelta;\n                }\n                else {\n                    // Restore the best positions\n                    for (let j = 0; j < ranks.length; j++) {\n                        const rank = ranks[j];\n                        for (let k = 0; k < rank.length; k++) {\n                            const cell = rank[k];\n                            cell.setGeneralPurposeVariable(j, cell.getX(j));\n                        }\n                    }\n                }\n                this.minPath(this.layout.getGraph(), model);\n                this.currentXDelta = 0;\n            }\n        }\n        this.setCellLocations(this.layout.getGraph(), model);\n    }\n    /**\n     * Performs one median positioning sweep in both directions\n     */\n    minNode(model) {\n        // Queue all nodes\n        const nodeList = [];\n        // Need to be able to map from cell to cellWrapper\n        const map = new Dictionary();\n        const rank = [];\n        for (let i = 0; i <= model.maxRank; i += 1) {\n            rank[i] = model.ranks[i];\n            for (let j = 0; j < rank[i].length; j += 1) {\n                // Use the weight to store the rank and visited to store whether\n                // or not the cell is in the list\n                const node = rank[i][j];\n                const nodeWrapper = new WeightedCellSorter(node, i);\n                nodeWrapper.rankIndex = j;\n                nodeWrapper.visited = true;\n                nodeList.push(nodeWrapper);\n                map.put(node, nodeWrapper);\n            }\n        }\n        // Set a limit of the maximum number of times we will access the queue\n        // in case a loop appears\n        const maxTries = nodeList.length * 10;\n        let count = 0;\n        // Don't move cell within this value of their median\n        const tolerance = 1;\n        while (nodeList.length > 0 && count <= maxTries) {\n            const cellWrapper = nodeList.shift();\n            const cell = (cellWrapper.cell);\n            const rankValue = cellWrapper.weightedValue;\n            const rankIndex = parseInt(String(cellWrapper.rankIndex));\n            const nextLayerConnectedCells = (cell.getNextLayerConnectedCells(rankValue));\n            const previousLayerConnectedCells = (cell.getPreviousLayerConnectedCells(rankValue));\n            const numNextLayerConnected = nextLayerConnectedCells.length;\n            const numPreviousLayerConnected = previousLayerConnectedCells.length;\n            const medianNextLevel = this.medianXValue(nextLayerConnectedCells, rankValue + 1);\n            const medianPreviousLevel = this.medianXValue(previousLayerConnectedCells, rankValue - 1);\n            const numConnectedNeighbours = numNextLayerConnected + numPreviousLayerConnected;\n            const currentPosition = cell.getGeneralPurposeVariable(rankValue);\n            let cellMedian = currentPosition;\n            if (numConnectedNeighbours > 0) {\n                cellMedian =\n                    (medianNextLevel * numNextLayerConnected +\n                        medianPreviousLevel * numPreviousLayerConnected) /\n                        numConnectedNeighbours;\n            }\n            // Flag storing whether or not position has changed\n            let positionChanged = false;\n            if (cellMedian < currentPosition - tolerance) {\n                if (rankIndex === 0) {\n                    cell.setGeneralPurposeVariable(rankValue, cellMedian);\n                    positionChanged = true;\n                }\n                else {\n                    const leftCell = rank[rankValue][rankIndex - 1];\n                    let leftLimit = leftCell.getGeneralPurposeVariable(rankValue);\n                    leftLimit =\n                        leftLimit + leftCell.width / 2 + this.intraCellSpacing + cell.width / 2;\n                    if (leftLimit < cellMedian) {\n                        cell.setGeneralPurposeVariable(rankValue, cellMedian);\n                        positionChanged = true;\n                    }\n                    else if (leftLimit <\n                        cell.getGeneralPurposeVariable(rankValue) - tolerance) {\n                        cell.setGeneralPurposeVariable(rankValue, leftLimit);\n                        positionChanged = true;\n                    }\n                }\n            }\n            else if (cellMedian > currentPosition + tolerance) {\n                const rankSize = rank[rankValue].length;\n                if (rankIndex === rankSize - 1) {\n                    cell.setGeneralPurposeVariable(rankValue, cellMedian);\n                    positionChanged = true;\n                }\n                else {\n                    const rightCell = rank[rankValue][rankIndex + 1];\n                    let rightLimit = rightCell.getGeneralPurposeVariable(rankValue);\n                    rightLimit =\n                        rightLimit - rightCell.width / 2 - this.intraCellSpacing - cell.width / 2;\n                    if (rightLimit > cellMedian) {\n                        cell.setGeneralPurposeVariable(rankValue, cellMedian);\n                        positionChanged = true;\n                    }\n                    else if (rightLimit >\n                        cell.getGeneralPurposeVariable(rankValue) + tolerance) {\n                        cell.setGeneralPurposeVariable(rankValue, rightLimit);\n                        positionChanged = true;\n                    }\n                }\n            }\n            if (positionChanged) {\n                // Add connected nodes to map and list\n                for (let i = 0; i < nextLayerConnectedCells.length; i += 1) {\n                    const connectedCell = nextLayerConnectedCells[i];\n                    const connectedCellWrapper = map.get(connectedCell);\n                    if (connectedCellWrapper != null) {\n                        if (connectedCellWrapper.visited == false) {\n                            connectedCellWrapper.visited = true;\n                            nodeList.push(connectedCellWrapper);\n                        }\n                    }\n                }\n                // Add connected nodes to map and list\n                for (let i = 0; i < previousLayerConnectedCells.length; i += 1) {\n                    const connectedCell = previousLayerConnectedCells[i];\n                    const connectedCellWrapper = map.get(connectedCell);\n                    if (connectedCellWrapper != null) {\n                        if (connectedCellWrapper.visited == false) {\n                            connectedCellWrapper.visited = true;\n                            nodeList.push(connectedCellWrapper);\n                        }\n                    }\n                }\n            }\n            cellWrapper.visited = false;\n            count += 1;\n        }\n    }\n    /**\n     * Performs one median positioning sweep in one direction\n     *\n     * @param i the iteration of the whole process\n     * @param model an internal model of the hierarchical layout\n     */\n    medianPos(i, model) {\n        // Reverse sweep direction each time through this method\n        const downwardSweep = i % 2 === 0;\n        if (downwardSweep) {\n            for (let j = model.maxRank; j > 0; j--) {\n                this.rankMedianPosition(j - 1, model, j);\n            }\n        }\n        else {\n            for (let j = 0; j < model.maxRank - 1; j++) {\n                this.rankMedianPosition(j + 1, model, j);\n            }\n        }\n    }\n    /**\n     * Performs median minimisation over one rank.\n     *\n     * @param rankValue the layer number of this rank\n     * @param model an internal model of the hierarchical layout\n     * @param nextRankValue the layer number whose connected cels are to be laid out\n     * relative to\n     */\n    rankMedianPosition(rankValue, model, nextRankValue) {\n        const ranks = model.ranks;\n        const rank = ranks[rankValue];\n        // Form an array of the order in which the cell are to be processed\n        // , the order is given by the weighted sum of the in or out edges,\n        // depending on whether we're traveling up or down the hierarchy.\n        const weightedValues = [];\n        const cellMap = {};\n        for (let i = 0; i < rank.length; i += 1) {\n            const currentCell = rank[i];\n            weightedValues[i] = new WeightedCellSorter(currentCell);\n            weightedValues[i].rankIndex = i;\n            cellMap[currentCell.id] = weightedValues[i];\n            let nextLayerConnectedCells = null;\n            if (nextRankValue < rankValue) {\n                nextLayerConnectedCells = currentCell.getPreviousLayerConnectedCells(rankValue);\n            }\n            else {\n                nextLayerConnectedCells = currentCell.getNextLayerConnectedCells(rankValue);\n            }\n            // Calculate the weighing based on this node type and those this\n            // node is connected to on the next layer\n            weightedValues[i].weightedValue = this.calculatedWeightedValue(currentCell, nextLayerConnectedCells);\n        }\n        weightedValues.sort(WeightedCellSorter.compare);\n        // Set the new position of each node within the rank using\n        // its temp variable\n        for (let i = 0; i < weightedValues.length; i += 1) {\n            let numConnectionsNextLevel = 0;\n            const cell = weightedValues[i].cell;\n            let nextLayerConnectedCells = null;\n            let medianNextLevel = 0;\n            if (nextRankValue < rankValue) {\n                nextLayerConnectedCells = cell.getPreviousLayerConnectedCells(rankValue).slice();\n            }\n            else {\n                nextLayerConnectedCells = cell.getNextLayerConnectedCells(rankValue).slice();\n            }\n            if (nextLayerConnectedCells != null) {\n                numConnectionsNextLevel = nextLayerConnectedCells.length;\n                if (numConnectionsNextLevel > 0) {\n                    medianNextLevel = this.medianXValue(nextLayerConnectedCells, nextRankValue);\n                }\n                else {\n                    // For case of no connections on the next level set the\n                    // median to be the current position and try to be\n                    // positioned there\n                    medianNextLevel = cell.getGeneralPurposeVariable(rankValue);\n                }\n            }\n            let leftBuffer = 0.0;\n            let leftLimit = -100000000.0;\n            for (let j = weightedValues[i].rankIndex - 1; j >= 0;) {\n                const weightedValue = cellMap[rank[j].id];\n                if (weightedValue != null) {\n                    const leftCell = weightedValue.cell;\n                    if (weightedValue.visited) {\n                        // The left limit is the right hand limit of that\n                        // cell plus any allowance for unallocated cells\n                        // in-between\n                        leftLimit =\n                            leftCell.getGeneralPurposeVariable(rankValue) +\n                                leftCell.width / 2.0 +\n                                this.intraCellSpacing +\n                                leftBuffer +\n                                cell.width / 2.0;\n                        j = -1;\n                    }\n                    else {\n                        leftBuffer += leftCell.width + this.intraCellSpacing;\n                        j--;\n                    }\n                }\n            }\n            let rightBuffer = 0.0;\n            let rightLimit = 100000000.0;\n            for (let j = weightedValues[i].rankIndex + 1; j < weightedValues.length;) {\n                const weightedValue = cellMap[rank[j].id];\n                if (weightedValue != null) {\n                    const rightCell = weightedValue.cell;\n                    if (weightedValue.visited) {\n                        // The left limit is the right hand limit of that\n                        // cell plus any allowance for unallocated cells\n                        // in-between\n                        rightLimit =\n                            rightCell.getGeneralPurposeVariable(rankValue) -\n                                rightCell.width / 2.0 -\n                                this.intraCellSpacing -\n                                rightBuffer -\n                                cell.width / 2.0;\n                        j = weightedValues.length;\n                    }\n                    else {\n                        rightBuffer += rightCell.width + this.intraCellSpacing;\n                        j++;\n                    }\n                }\n            }\n            if (medianNextLevel >= leftLimit && medianNextLevel <= rightLimit) {\n                cell.setGeneralPurposeVariable(rankValue, medianNextLevel);\n            }\n            else if (medianNextLevel < leftLimit) {\n                // Couldn't place at median value, place as close to that\n                // value as possible\n                cell.setGeneralPurposeVariable(rankValue, leftLimit);\n                this.currentXDelta = this.currentXDelta + leftLimit - medianNextLevel;\n            }\n            else if (medianNextLevel > rightLimit) {\n                // Couldn't place at median value, place as close to that\n                // value as possible\n                cell.setGeneralPurposeVariable(rankValue, rightLimit);\n                this.currentXDelta = this.currentXDelta + medianNextLevel - rightLimit;\n            }\n            weightedValues[i].visited = true;\n        }\n    }\n    /**\n     * Calculates the priority the specified cell has based on the type of its\n     * cell and the cells it is connected to on the next layer\n     *\n     * @param currentCell the cell whose weight is to be calculated\n     * @param collection the cells the specified cell is connected to\n     */\n    calculatedWeightedValue(currentCell, collection) {\n        let totalWeight = 0;\n        for (let i = 0; i < collection.length; i += 1) {\n            const cell = collection[i];\n            if (currentCell.isVertex() && cell.isVertex()) {\n                totalWeight += 1;\n            }\n            else if (currentCell.isEdge() && cell.isEdge()) {\n                totalWeight += 8;\n            }\n            else {\n                totalWeight += 2;\n            }\n        }\n        return totalWeight;\n    }\n    /**\n     * Calculates the median position of the connected cell on the specified\n     * rank\n     *\n     * @param connectedCells the cells the candidate connects to on this level\n     * @param rankValue the layer number of this rank\n     */\n    medianXValue(connectedCells, rankValue) {\n        if (connectedCells.length === 0) {\n            return 0;\n        }\n        const medianValues = [];\n        for (let i = 0; i < connectedCells.length; i += 1) {\n            medianValues[i] = connectedCells[i].getGeneralPurposeVariable(rankValue);\n        }\n        medianValues.sort((a, b) => a - b);\n        if (connectedCells.length % 2 === 1) {\n            // For odd numbers of adjacent vertices return the median\n            return medianValues[Math.floor(connectedCells.length / 2)];\n        }\n        const medianPoint = connectedCells.length / 2;\n        const leftMedian = medianValues[medianPoint - 1];\n        const rightMedian = medianValues[medianPoint];\n        return (leftMedian + rightMedian) / 2;\n    }\n    /**\n     * Sets up the layout in an initial positioning. The ranks are all centered\n     * as much as possible along the middle vertex in each rank. The other cells\n     * are then placed as close as possible on either side.\n     *\n     * @param facade the facade describing the input graph\n     * @param model an internal model of the hierarchical layout\n     */\n    initialCoords(facade, model) {\n        this.calculateWidestRank(facade, model);\n        // Sweep up and down from the widest rank\n        for (let i = this.widestRank; i >= 0; i--) {\n            if (i < model.maxRank) {\n                this.rankCoordinates(i, facade, model);\n            }\n        }\n        for (let i = this.widestRank + 1; i <= model.maxRank; i += 1) {\n            if (i > 0) {\n                this.rankCoordinates(i, facade, model);\n            }\n        }\n    }\n    /**\n     * Sets up the layout in an initial positioning. All the first cells in each\n     * rank are moved to the left and the rest of the rank inserted as close\n     * together as their size and buffering permits. This method works on just\n     * the specified rank.\n     *\n     * @param rankValue the current rank being processed\n     * @param graph the facade describing the input graph\n     * @param model an internal model of the hierarchical layout\n     */\n    rankCoordinates(rankValue, graph, model) {\n        const ranks = model.ranks;\n        const rank = ranks[rankValue];\n        let maxY = 0.0;\n        let localX = this.initialX +\n            (this.widestRankValue - this.rankWidths[rankValue]) / 2;\n        // Store whether or not any of the cells' bounds were unavailable so\n        // to only issue the warning once for all cells\n        let boundsWarning = false;\n        for (let i = 0; i < rank.length; i += 1) {\n            const node = rank[i];\n            if (node.isVertex()) {\n                const bounds = this.layout.getVertexBounds(node.cell);\n                if (bounds != null) {\n                    if (this.orientation === DIRECTION.NORTH ||\n                        this.orientation === DIRECTION.SOUTH) {\n                        node.width = bounds.width;\n                        node.height = bounds.height;\n                    }\n                    else {\n                        node.width = bounds.height;\n                        node.height = bounds.width;\n                    }\n                }\n                else {\n                    boundsWarning = true;\n                }\n                maxY = Math.max(maxY, node.height);\n            }\n            else if (node.isEdge()) {\n                // The width is the number of additional parallel edges\n                // time the parallel edge spacing\n                let numEdges = 1;\n                if (node.edges != null) {\n                    numEdges = node.edges.length;\n                }\n                else {\n                    MaxLog.warn('edge.edges is null');\n                }\n                node.width = (numEdges - 1) * this.parallelEdgeSpacing;\n            }\n            // Set the initial x-value as being the best result so far\n            localX += node.width / 2.0;\n            node.setX(rankValue, localX);\n            node.setGeneralPurposeVariable(rankValue, localX);\n            localX += node.width / 2.0;\n            localX += this.intraCellSpacing;\n        }\n        if (boundsWarning == true) {\n            MaxLog.warn('At least one cell has no bounds');\n        }\n    }\n    /**\n     * Calculates the width rank in the hierarchy. Also set the y value of each\n     * rank whilst performing the calculation\n     *\n     * @param graph the facade describing the input graph\n     * @param model an internal model of the hierarchical layout\n     */\n    calculateWidestRank(graph, model) {\n        // Starting y co-ordinate\n        let y = -this.interRankCellSpacing;\n        // Track the widest cell on the last rank since the y\n        // difference depends on it\n        let lastRankMaxCellHeight = 0.0;\n        this.rankWidths = [];\n        this.rankY = [];\n        for (let rankValue = model.maxRank; rankValue >= 0; rankValue -= 1) {\n            // Keep track of the widest cell on this rank\n            let maxCellHeight = 0.0;\n            const ranks = model.ranks;\n            const rank = ranks[rankValue];\n            let localX = this.initialX;\n            // Store whether or not any of the cells' bounds were unavailable so\n            // to only issue the warning once for all cells\n            let boundsWarning = false;\n            for (let i = 0; i < rank.length; i += 1) {\n                const node = rank[i];\n                if (node.isVertex()) {\n                    const bounds = this.layout.getVertexBounds(node.cell);\n                    if (bounds != null) {\n                        if (this.orientation === DIRECTION.NORTH ||\n                            this.orientation === DIRECTION.SOUTH) {\n                            node.width = bounds.width;\n                            node.height = bounds.height;\n                        }\n                        else {\n                            node.width = bounds.height;\n                            node.height = bounds.width;\n                        }\n                    }\n                    else {\n                        boundsWarning = true;\n                    }\n                    maxCellHeight = Math.max(maxCellHeight, node.height);\n                }\n                else if (node.isEdge()) {\n                    // The width is the number of additional parallel edges\n                    // time the parallel edge spacing\n                    let numEdges = 1;\n                    if (node.edges != null) {\n                        numEdges = node.edges.length;\n                    }\n                    else {\n                        MaxLog.warn('edge.edges is null');\n                    }\n                    node.width = (numEdges - 1) * this.parallelEdgeSpacing;\n                }\n                // Set the initial x-value as being the best result so far\n                localX += node.width / 2.0;\n                node.setX(rankValue, localX);\n                node.setGeneralPurposeVariable(rankValue, localX);\n                localX += node.width / 2.0;\n                localX += this.intraCellSpacing;\n                if (localX > this.widestRankValue) {\n                    this.widestRankValue = localX;\n                    this.widestRank = rankValue;\n                }\n                this.rankWidths[rankValue] = localX;\n            }\n            if (boundsWarning == true) {\n                MaxLog.warn('At least one cell has no bounds');\n            }\n            this.rankY[rankValue] = y;\n            const distanceToNextRank = maxCellHeight / 2.0 + lastRankMaxCellHeight / 2.0 + this.interRankCellSpacing;\n            lastRankMaxCellHeight = maxCellHeight;\n            if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.WEST) {\n                y += distanceToNextRank;\n            }\n            else {\n                y -= distanceToNextRank;\n            }\n            for (let i = 0; i < rank.length; i += 1) {\n                const cell = rank[i];\n                cell.setY(rankValue, y);\n            }\n        }\n    }\n    /**\n     * Straightens out chains of virtual nodes where possibleacade to those stored after this layout\n     * processing step has completed.\n     *\n     * @param graph the facade describing the input graph\n     * @param model an internal model of the hierarchical layout\n     */\n    minPath(graph, model) {\n        // Work down and up each edge with at least 2 control points\n        // trying to straighten each one out. If the same number of\n        // straight segments are formed in both directions, the\n        // preferred direction used is the one where the final\n        // control points have the least offset from the connectable\n        // region of the terminating vertices\n        const edges = model.edgeMapper.getValues();\n        for (let j = 0; j < edges.length; j++) {\n            const cell = edges[j];\n            if (cell.maxRank - cell.minRank - 1 < 1) {\n                continue;\n            }\n            // At least two virtual nodes in the edge\n            // Check first whether the edge is already straight\n            let referenceX = cell.getGeneralPurposeVariable(cell.minRank + 1);\n            let edgeStraight = true;\n            let refSegCount = 0;\n            for (let i = cell.minRank + 2; i < cell.maxRank; i += 1) {\n                const x = cell.getGeneralPurposeVariable(i);\n                if (referenceX !== x) {\n                    edgeStraight = false;\n                    referenceX = x;\n                }\n                else {\n                    refSegCount += 1;\n                }\n            }\n            if (!edgeStraight) {\n                let upSegCount = 0;\n                let downSegCount = 0;\n                const upXPositions = [];\n                const downXPositions = [];\n                let i = 0;\n                let currentX = cell.getGeneralPurposeVariable(cell.minRank + 1);\n                for (i = cell.minRank + 1; i < cell.maxRank - 1; i += 1) {\n                    // Attempt to straight out the control point on the\n                    // next segment up with the current control point.\n                    const nextX = cell.getX(i + 1);\n                    if (currentX === nextX) {\n                        upXPositions[i - cell.minRank - 1] = currentX;\n                        upSegCount += 1;\n                    }\n                    else if (this.repositionValid(model, cell, i + 1, currentX)) {\n                        upXPositions[i - cell.minRank - 1] = currentX;\n                        upSegCount += 1;\n                        // Leave currentX at same value\n                    }\n                    else {\n                        upXPositions[i - cell.minRank - 1] = nextX;\n                        currentX = nextX;\n                    }\n                }\n                currentX = cell.getX(i);\n                for (let i = cell.maxRank - 1; i > cell.minRank + 1; i--) {\n                    // Attempt to straight out the control point on the\n                    // next segment down with the current control point.\n                    const nextX = cell.getX(i - 1);\n                    if (currentX === nextX) {\n                        downXPositions[i - cell.minRank - 2] = currentX;\n                        downSegCount += 1;\n                    }\n                    else if (this.repositionValid(model, cell, i - 1, currentX)) {\n                        downXPositions[i - cell.minRank - 2] = currentX;\n                        downSegCount += 1;\n                        // Leave currentX at same value\n                    }\n                    else {\n                        downXPositions[i - cell.minRank - 2] = cell.getX(i - 1);\n                        currentX = nextX;\n                    }\n                }\n                if (downSegCount > refSegCount || upSegCount > refSegCount) {\n                    if (downSegCount >= upSegCount) {\n                        // Apply down calculation values\n                        for (let i = cell.maxRank - 2; i > cell.minRank; i--) {\n                            cell.setX(i, downXPositions[i - cell.minRank - 1]);\n                        }\n                    }\n                    else if (upSegCount > downSegCount) {\n                        // Apply up calculation values\n                        for (let i = cell.minRank + 2; i < cell.maxRank; i += 1) {\n                            cell.setX(i, upXPositions[i - cell.minRank - 2]);\n                        }\n                    }\n                    else {\n                        // Neither direction provided a favourable result\n                        // But both calculations are better than the\n                        // existing solution, so apply the one with minimal\n                        // offset to attached vertices at either end.\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Determines whether or not a node may be moved to the specified x\n     * position on the specified rank\n     *\n     * @param model the layout model\n     * @param cell the cell being analysed\n     * @param rank the layer of the cell\n     * @param position the x position being sought\n     */\n    repositionValid(model, cell, rank, position) {\n        const ranks = model.ranks;\n        const rankArray = ranks[rank];\n        let rankIndex = -1;\n        for (let i = 0; i < rankArray.length; i += 1) {\n            if (cell === rankArray[i]) {\n                rankIndex = i;\n                break;\n            }\n        }\n        if (rankIndex < 0) {\n            return false;\n        }\n        const currentX = cell.getGeneralPurposeVariable(rank);\n        if (position < currentX) {\n            // Trying to move node to the left.\n            if (rankIndex === 0) {\n                // Left-most node, can move anywhere\n                return true;\n            }\n            const leftCell = rankArray[rankIndex - 1];\n            let leftLimit = leftCell.getGeneralPurposeVariable(rank);\n            leftLimit = leftLimit + leftCell.width / 2 + this.intraCellSpacing + cell.width / 2;\n            return leftLimit <= position;\n        }\n        if (position > currentX) {\n            // Trying to move node to the right.\n            if (rankIndex === rankArray.length - 1) {\n                // Right-most node, can move anywhere\n                return true;\n            }\n            const rightCell = rankArray[rankIndex + 1];\n            let rightLimit = rightCell.getGeneralPurposeVariable(rank);\n            rightLimit =\n                rightLimit - rightCell.width / 2 - this.intraCellSpacing - cell.width / 2;\n            return rightLimit >= position;\n        }\n        return true;\n    }\n    /**\n     * Sets the cell locations in the facade to those stored after this layout\n     * processing step has completed.\n     *\n     * @param graph the input graph\n     * @param model the layout model\n     */\n    setCellLocations(graph, model) {\n        this.rankTopY = [];\n        this.rankBottomY = [];\n        const ranks = model.ranks;\n        for (let i = 0; i < ranks.length; i += 1) {\n            this.rankTopY[i] = Number.MAX_VALUE;\n            this.rankBottomY[i] = -Number.MAX_VALUE;\n        }\n        const vertices = model.vertexMapper.getValues();\n        // Process vertices all first, since they define the lower and\n        // limits of each rank. Between these limits lie the channels\n        // where the edges can be routed across the graph\n        for (let i = 0; i < vertices.length; i += 1) {\n            this.setVertexLocation(vertices[i]);\n        }\n        // Post process edge styles. Needs the vertex locations set for initial\n        // values of the top and bottoms of each rank\n        if (this.layout.edgeStyle === HierarchicalEdgeStyle.ORTHOGONAL ||\n            this.layout.edgeStyle === HierarchicalEdgeStyle.POLYLINE ||\n            this.layout.edgeStyle === HierarchicalEdgeStyle.CURVE) {\n            this.localEdgeProcessing(model);\n        }\n        const edges = model.edgeMapper.getValues();\n        for (let i = 0; i < edges.length; i += 1) {\n            this.setEdgePosition(edges[i]);\n        }\n    }\n    /**\n     * Separates the x position of edges as they connect to vertices\n     *\n     * @param model the layout model\n     */\n    localEdgeProcessing(model) {\n        // Iterate through each vertex, look at the edges connected in\n        // both directions.\n        const ranks = model.ranks;\n        for (let rankIndex = 0; rankIndex < ranks.length; rankIndex += 1) {\n            const rank = ranks[rankIndex];\n            for (let cellIndex = 0; cellIndex < rank.length; cellIndex += 1) {\n                const cell = rank[cellIndex];\n                if (cell.isVertex()) {\n                    let currentCells = cell.getPreviousLayerConnectedCells(rankIndex);\n                    let currentRank = rankIndex - 1;\n                    // Two loops, last connected cells, and next\n                    for (let k = 0; k < 2; k += 1) {\n                        if (currentRank > -1 &&\n                            currentRank < ranks.length &&\n                            currentCells != null &&\n                            currentCells.length > 0) {\n                            const sortedCells = [];\n                            for (let j = 0; j < currentCells.length; j++) {\n                                const sorter = new WeightedCellSorter(currentCells[j], currentCells[j].getX(currentRank));\n                                sortedCells.push(sorter);\n                            }\n                            sortedCells.sort(WeightedCellSorter.compare);\n                            let leftLimit = cell.x[0] - cell.width / 2;\n                            let rightLimit = leftLimit + cell.width;\n                            // Connected edge count starts at 1 to allow for buffer\n                            // with edge of vertex\n                            let connectedEdgeCount = 0;\n                            let connectedEdgeGroupCount = 0;\n                            const connectedEdges = [];\n                            // Calculate width requirements for all connected edges\n                            for (let j = 0; j < sortedCells.length; j++) {\n                                const innerCell = sortedCells[j].cell;\n                                let connections;\n                                if (innerCell.isVertex()) {\n                                    // Get the connecting edge\n                                    if (k === 0) {\n                                        connections = cell.connectsAsSource;\n                                    }\n                                    else {\n                                        connections = cell.connectsAsTarget;\n                                    }\n                                    for (let connIndex = 0; connIndex < connections.length; connIndex += 1) {\n                                        if (connections[connIndex].source === innerCell ||\n                                            connections[connIndex].target === innerCell) {\n                                            connectedEdgeCount += connections[connIndex].edges.length;\n                                            connectedEdgeGroupCount += 1;\n                                            connectedEdges.push(connections[connIndex]);\n                                        }\n                                    }\n                                }\n                                else {\n                                    connectedEdgeCount += innerCell.edges.length;\n                                    connectedEdgeGroupCount += 1;\n                                    connectedEdges.push(innerCell);\n                                }\n                            }\n                            const requiredWidth = (connectedEdgeCount + 1) * this.prefHozEdgeSep;\n                            // Add a buffer on the edges of the vertex if the edge count allows\n                            if (cell.width > requiredWidth + 2 * this.prefHozEdgeSep) {\n                                leftLimit += this.prefHozEdgeSep;\n                                rightLimit -= this.prefHozEdgeSep;\n                            }\n                            const availableWidth = rightLimit - leftLimit;\n                            const edgeSpacing = availableWidth / connectedEdgeCount;\n                            let currentX = leftLimit + edgeSpacing / 2.0;\n                            let currentYOffset = this.minEdgeJetty - this.prefVertEdgeOff;\n                            let maxYOffset = 0;\n                            for (let j = 0; j < connectedEdges.length; j++) {\n                                const numActualEdges = connectedEdges[j].edges.length;\n                                const jettyPositions = this.jettyPositions;\n                                let pos = jettyPositions[connectedEdges[j].ids[0]];\n                                if (pos == null) {\n                                    pos = [];\n                                    jettyPositions[connectedEdges[j].ids[0]] = pos;\n                                }\n                                if (j < connectedEdgeCount / 2) {\n                                    currentYOffset += this.prefVertEdgeOff;\n                                }\n                                else if (j > connectedEdgeCount / 2) {\n                                    currentYOffset -= this.prefVertEdgeOff;\n                                }\n                                // Ignore the case if equals, this means the second of 2\n                                // jettys with the same y (even number of edges)\n                                for (let m = 0; m < numActualEdges; m += 1) {\n                                    pos[m * 4 + k * 2] = currentX;\n                                    currentX += edgeSpacing;\n                                    pos[m * 4 + k * 2 + 1] = currentYOffset;\n                                }\n                                maxYOffset = Math.max(maxYOffset, currentYOffset);\n                            }\n                        }\n                        currentCells = cell.getNextLayerConnectedCells(rankIndex);\n                        currentRank = rankIndex + 1;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Fixes the control points\n     */\n    setEdgePosition(cell) {\n        // For parallel edges we need to seperate out the points a\n        // little\n        let offsetX = 0;\n        // Only set the edge control points once\n        if (cell.temp[0] !== 101207) {\n            let { maxRank } = cell;\n            let { minRank } = cell;\n            if (maxRank === minRank) {\n                maxRank = cell.source.maxRank;\n                minRank = cell.target.minRank;\n            }\n            let parallelEdgeCount = 0;\n            const jettyPositions = this.jettyPositions;\n            const jettys = jettyPositions[cell.ids[0]];\n            const source = cell.isReversed\n                ? cell.target.cell\n                : cell.source.cell;\n            const { graph } = this.layout;\n            const layoutReversed = this.orientation === DIRECTION.EAST || this.orientation === DIRECTION.SOUTH;\n            for (let i = 0; i < cell.edges.length; i += 1) {\n                const realEdge = cell.edges[i];\n                const realSource = this.layout.getVisibleTerminal(realEdge, true);\n                // List oldPoints = graph.getPoints(realEdge);\n                const newPoints = [];\n                // Single length reversed edges end up with the jettys in the wrong\n                // places. Since single length edges only have jettys, not segment\n                // control points, we just say the edge isn't reversed in this section\n                let reversed = cell.isReversed;\n                if (realSource !== source) {\n                    // The real edges include all core model edges and these can go\n                    // in both directions. If the source of the hierarchical model edge\n                    // isn't the source of the specific real edge in this iteration\n                    // treat if as reversed\n                    reversed = !reversed;\n                }\n                // First jetty of edge\n                if (jettys != null) {\n                    const arrayOffset = reversed ? 2 : 0;\n                    const rankBottomY = this.rankBottomY;\n                    const rankTopY = this.rankTopY;\n                    let y = reversed\n                        ? layoutReversed\n                            ? rankBottomY[minRank]\n                            : rankTopY[minRank]\n                        : layoutReversed\n                            ? rankTopY[maxRank]\n                            : rankBottomY[maxRank];\n                    let jetty = jettys[parallelEdgeCount * 4 + 1 + arrayOffset];\n                    if (reversed !== layoutReversed) {\n                        jetty = -jetty;\n                    }\n                    y += jetty;\n                    let x = jettys[parallelEdgeCount * 4 + arrayOffset];\n                    const modelSource = realEdge.getTerminal(true);\n                    if (this.layout.isPort(modelSource) && modelSource.getParent() === realSource) {\n                        const state = graph.view.getState(modelSource);\n                        if (state != null) {\n                            x = state.x;\n                        }\n                        else {\n                            x =\n                                realSource.geometry.x +\n                                    cell.source.width *\n                                        modelSource.geometry.x;\n                        }\n                    }\n                    if (this.orientation === DIRECTION.NORTH ||\n                        this.orientation === DIRECTION.SOUTH) {\n                        newPoints.push(new Point(x, y));\n                        if (this.layout.edgeStyle === HierarchicalEdgeStyle.CURVE) {\n                            newPoints.push(new Point(x, y + jetty));\n                        }\n                    }\n                    else {\n                        newPoints.push(new Point(y, x));\n                        if (this.layout.edgeStyle === HierarchicalEdgeStyle.CURVE) {\n                            newPoints.push(new Point(y + jetty, x));\n                        }\n                    }\n                }\n                // Declare variables to define loop through edge points and\n                // change direction if edge is reversed\n                let loopStart = cell.x.length - 1;\n                let loopLimit = -1;\n                let loopDelta = -1;\n                let currentRank = cell.maxRank - 1;\n                if (reversed) {\n                    loopStart = 0;\n                    loopLimit = cell.x.length;\n                    loopDelta = 1;\n                    currentRank = cell.minRank + 1;\n                }\n                // Reversed edges need the points inserted in\n                // reverse order\n                for (let j = loopStart; cell.maxRank !== cell.minRank && j !== loopLimit; j += loopDelta) {\n                    // The horizontal position in a vertical layout\n                    const positionX = cell.x[j] + offsetX;\n                    // Work out the vertical positions in a vertical layout\n                    // in the edge buffer channels above and below this rank\n                    const rankTopY = this.rankTopY;\n                    const rankBottomY = this.rankBottomY;\n                    let topChannelY = (rankTopY[currentRank] + rankBottomY[currentRank + 1]) / 2.0;\n                    let bottomChannelY = (rankTopY[currentRank - 1] + rankBottomY[currentRank]) / 2.0;\n                    if (reversed) {\n                        const tmp = topChannelY;\n                        topChannelY = bottomChannelY;\n                        bottomChannelY = tmp;\n                    }\n                    if (this.orientation === DIRECTION.NORTH ||\n                        this.orientation === DIRECTION.SOUTH) {\n                        newPoints.push(new Point(positionX, topChannelY));\n                        newPoints.push(new Point(positionX, bottomChannelY));\n                    }\n                    else {\n                        newPoints.push(new Point(topChannelY, positionX));\n                        newPoints.push(new Point(bottomChannelY, positionX));\n                    }\n                    this.limitX = Math.max(this.limitX, positionX);\n                    currentRank += loopDelta;\n                }\n                // Second jetty of edge\n                if (jettys != null) {\n                    const arrayOffset = reversed ? 2 : 0;\n                    const rankTopY = this.rankTopY;\n                    const rankBottomY = this.rankBottomY;\n                    const rankY = reversed\n                        ? layoutReversed\n                            ? rankTopY[maxRank]\n                            : rankBottomY[maxRank]\n                        : layoutReversed\n                            ? rankBottomY[minRank]\n                            : rankTopY[minRank];\n                    let jetty = jettys[parallelEdgeCount * 4 + 3 - arrayOffset];\n                    if (reversed !== layoutReversed) {\n                        jetty = -jetty;\n                    }\n                    const y = rankY - jetty;\n                    let x = jettys[parallelEdgeCount * 4 + 2 - arrayOffset];\n                    const modelTarget = realEdge.getTerminal(false);\n                    const realTarget = this.layout.getVisibleTerminal(realEdge, false);\n                    if (this.layout.isPort(modelTarget) && modelTarget.getParent() === realTarget) {\n                        const state = graph.view.getState(modelTarget);\n                        if (state != null) {\n                            x = state.x;\n                        }\n                        else {\n                            x =\n                                realTarget.geometry.x +\n                                    cell.target.width *\n                                        modelTarget.geometry.x;\n                        }\n                    }\n                    if (this.orientation === DIRECTION.NORTH ||\n                        this.orientation === DIRECTION.SOUTH) {\n                        if (this.layout.edgeStyle === HierarchicalEdgeStyle.CURVE) {\n                            newPoints.push(new Point(x, y - jetty));\n                        }\n                        newPoints.push(new Point(x, y));\n                    }\n                    else {\n                        if (this.layout.edgeStyle === HierarchicalEdgeStyle.CURVE) {\n                            newPoints.push(new Point(y - jetty, x));\n                        }\n                        newPoints.push(new Point(y, x));\n                    }\n                }\n                if (cell.isReversed) {\n                    this.processReversedEdge(cell, realEdge);\n                }\n                this.layout.setEdgePoints(realEdge, newPoints);\n                // Increase offset so next edge is drawn next to\n                // this one\n                if (offsetX === 0.0) {\n                    offsetX = this.parallelEdgeSpacing;\n                }\n                else if (offsetX > 0) {\n                    offsetX = -offsetX;\n                }\n                else {\n                    offsetX = -offsetX + this.parallelEdgeSpacing;\n                }\n                parallelEdgeCount++;\n            }\n            cell.temp[0] = 101207;\n        }\n    }\n    /**\n     * Fixes the position of the specified vertex.\n     *\n     * @param cell the vertex to position\n     */\n    setVertexLocation(cell) {\n        const realCell = cell.cell;\n        const positionX = cell.x[0] - cell.width / 2;\n        const positionY = cell.y[0] - cell.height / 2;\n        const rankTopY = this.rankTopY;\n        const rankBottomY = this.rankBottomY;\n        rankTopY[cell.minRank] = Math.min(rankTopY[cell.minRank], positionY);\n        rankBottomY[cell.minRank] = Math.max(rankBottomY[cell.minRank], positionY + cell.height);\n        if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.SOUTH) {\n            this.layout.setVertexLocation(realCell, positionX, positionY);\n        }\n        else {\n            this.layout.setVertexLocation(realCell, positionY, positionX);\n        }\n        this.limitX = Math.max(this.limitX, positionX + cell.width);\n    }\n    /**\n     * Hook to add additional processing\n     *\n     * @param edge the hierarchical model edge\n     * @param realEdge the real edge in the graph\n     */\n    processReversedEdge(edge, realEdge) {\n        // hook for subclassers\n    }\n}\nexport default CoordinateAssignment;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,uBAAuB,MAAM,2BAA2B;AAC/D,SAASC,SAAS,QAAQ,yBAAyB;AACnD,OAAOC,MAAM,MAAM,qBAAqB;AACxC,OAAOC,kBAAkB,MAAM,4BAA4B;AAC3D,OAAOC,UAAU,MAAM,0BAA0B;AACjD,OAAOC,KAAK,MAAM,sBAAsB;AACxC,OAAOC,qBAAqB,MAAM,oCAAoC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,oBAAoB,SAASP,uBAAuB,CAAC;EACvDQ,WAAWA,CAACC,MAAM,EAAEC,gBAAgB,GAAG,EAAE,EAAEC,oBAAoB,GAAG,GAAG,EAAEC,WAAW,EAAEC,QAAQ,EAAEC,mBAAmB,GAAG,EAAE,EAAE;IACpH,KAAK,CAAC,CAAC;IACP;AACR;AACA;IACQ,IAAI,CAACJ,gBAAgB,GAAG,EAAE;IAC1B;AACR;AACA;IACQ,IAAI,CAACC,oBAAoB,GAAG,GAAG;IAC/B;AACR;AACA;AACA;IACQ,IAAI,CAACG,mBAAmB,GAAG,EAAE;IAC7B;AACR;AACA;IACQ,IAAI,CAACC,aAAa,GAAG,CAAC;IACtB;AACR;AACA;IACQ,IAAI,CAACC,cAAc,GAAG,CAAC;IACvB;AACR;AACA;IACQ,IAAI,CAACC,eAAe,GAAG,CAAC;IACxB;AACR;AACA;IACQ,IAAI,CAACC,YAAY,GAAG,EAAE;IACtB;AACR;AACA;AACA;IACQ,IAAI,CAACC,aAAa,GAAG,CAAC;IACtB;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,cAAc,GAAG,IAAI;IAC1B;AACR;AACA;AACA;IACQ,IAAI,CAACR,WAAW,GAAGX,SAAS,CAACoB,KAAK;IAClC;AACR;AACA;IACQ,IAAI,CAACC,MAAM,GAAG,IAAI;IAClB;AACR;AACA;IACQ,IAAI,CAACC,aAAa,GAAG,IAAI;IACzB;AACR;AACA;IACQ,IAAI,CAACC,UAAU,GAAG,IAAI;IACtB;AACR;AACA;IACQ,IAAI,CAACC,QAAQ,GAAG,IAAI;IACpB;AACR;AACA;IACQ,IAAI,CAACC,WAAW,GAAG,IAAI;IACvB;AACR;AACA;IACQ,IAAI,CAACC,eAAe,GAAG,IAAI;IAC3B;AACR;AACA;IACQ,IAAI,CAACC,UAAU,GAAG,IAAI;IACtB;AACR;AACA;IACQ,IAAI,CAACC,KAAK,GAAG,IAAI;IACjB;AACR;AACA;AACA;IACQ,IAAI,CAACC,UAAU,GAAG,IAAI;IACtB;AACR;AACA;IACQ,IAAI,CAACC,uBAAuB,GAAG,IAAI;IACnC;AACR;AACA;IACQ,IAAI,CAACC,2BAA2B,GAAG,IAAI;IACvC;AACR;AACA;IACQ,IAAI,CAACC,YAAY,GAAG,EAAE;IACtB,IAAI,CAACxB,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACC,oBAAoB,GAAGA,oBAAoB;IAChD,IAAI,CAACC,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,mBAAmB,GAAGA,mBAAmB;EAClD;EACA;AACJ;AACA;EACIoB,WAAWA,CAAA,EAAG;IACV,MAAMC,KAAK,GAAG,IAAI,CAAC1B,MAAM,CAAC2B,YAAY,CAAC,CAAC;IACxC,MAAMC,KAAK,GAAGF,KAAK,CAACE,KAAK;IACzBnC,MAAM,CAACoC,IAAI,CAAC,CAAC;IACbpC,MAAM,CAACqC,OAAO,CAAC,qCAAqC,CAAC;IACrD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,KAAK,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;MACnCtC,MAAM,CAACwC,KAAK,CAAC,OAAO,EAAEC,MAAM,CAACH,CAAC,CAAC,EAAE,KAAK,CAAC;MACvC,MAAMI,IAAI,GAAGP,KAAK,CAACG,CAAC,CAAC;MACrB,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,IAAI,CAACH,MAAM,EAAEI,CAAC,EAAE,EAAE;QAClC,MAAMC,IAAI,GAAGF,IAAI,CAACC,CAAC,CAAC;QACpB3C,MAAM,CAACwC,KAAK,CAACC,MAAM,CAACG,IAAI,CAACC,yBAAyB,CAACP,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC;MACjE;MACAtC,MAAM,CAACqC,OAAO,CAAC,CAAC;IACpB;IACArC,MAAM,CAACqC,OAAO,CAAC,sCAAsC,CAAC;EAC1D;EACA;AACJ;AACA;EACIS,OAAOA,CAACC,MAAM,EAAE;IACZ,IAAI,CAAC7B,cAAc,GAAG8B,MAAM,CAAC,CAAC;IAC9B,MAAMf,KAAK,GAAG,IAAI,CAAC1B,MAAM,CAAC2B,YAAY,CAAC,CAAC;IACxC,IAAI,CAACb,aAAa,GAAG,GAAG;IACxB,IAAI,CAAC4B,aAAa,CAAC,IAAI,CAAC1C,MAAM,CAAC2C,QAAQ,CAAC,CAAC,EAAEjB,KAAK,CAAC;IACjD;IACA,IAAI,IAAI,CAACL,UAAU,EAAE;MACjB,IAAI,CAACuB,OAAO,CAAClB,KAAK,CAAC;IACvB;IACA,IAAImB,UAAU,GAAG,WAAW;IAC5B,IAAI,IAAI,CAACxB,UAAU,EAAE;MACjB,KAAK,IAAIyB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACxC,aAAa,EAAEwC,CAAC,IAAI,CAAC,EAAE;QAC5C;QACA;QACA,IAAIA,CAAC,KAAK,CAAC,EAAE;UACT,IAAI,CAACC,SAAS,CAACD,CAAC,EAAEpB,KAAK,CAAC;UACxB,IAAI,CAACkB,OAAO,CAAClB,KAAK,CAAC;QACvB;QACA;QACA;QACA;QACA,MAAME,KAAK,GAAGF,KAAK,CAACE,KAAK;QACzB,IAAI,IAAI,CAACd,aAAa,GAAG+B,UAAU,EAAE;UACjC,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,KAAK,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;YACnC,MAAMI,IAAI,GAAGP,KAAK,CAACG,CAAC,CAAC;YACrB,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,IAAI,CAACH,MAAM,EAAEI,CAAC,EAAE,EAAE;cAClC,MAAMC,IAAI,GAAGF,IAAI,CAACC,CAAC,CAAC;cACpBC,IAAI,CAACW,IAAI,CAACjB,CAAC,EAAEM,IAAI,CAACC,yBAAyB,CAACP,CAAC,CAAC,CAAC;YACnD;UACJ;UACAc,UAAU,GAAG,IAAI,CAAC/B,aAAa;QACnC,CAAC,MACI;UACD;UACA,KAAK,IAAIiB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,KAAK,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;YACnC,MAAMI,IAAI,GAAGP,KAAK,CAACG,CAAC,CAAC;YACrB,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,IAAI,CAACH,MAAM,EAAEI,CAAC,EAAE,EAAE;cAClC,MAAMC,IAAI,GAAGF,IAAI,CAACC,CAAC,CAAC;cACpBC,IAAI,CAACY,yBAAyB,CAAClB,CAAC,EAAEM,IAAI,CAACa,IAAI,CAACnB,CAAC,CAAC,CAAC;YACnD;UACJ;QACJ;QACA,IAAI,CAACoB,OAAO,CAAC,IAAI,CAACnD,MAAM,CAAC2C,QAAQ,CAAC,CAAC,EAAEjB,KAAK,CAAC;QAC3C,IAAI,CAACZ,aAAa,GAAG,CAAC;MAC1B;IACJ;IACA,IAAI,CAACsC,gBAAgB,CAAC,IAAI,CAACpD,MAAM,CAAC2C,QAAQ,CAAC,CAAC,EAAEjB,KAAK,CAAC;EACxD;EACA;AACJ;AACA;EACIkB,OAAOA,CAAClB,KAAK,EAAE;IACX;IACA,MAAM2B,QAAQ,GAAG,EAAE;IACnB;IACA,MAAMC,GAAG,GAAG,IAAI3D,UAAU,CAAC,CAAC;IAC5B,MAAMwC,IAAI,GAAG,EAAE;IACf,KAAK,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIpB,KAAK,CAAC6B,OAAO,EAAET,CAAC,IAAI,CAAC,EAAE;MACxCX,IAAI,CAACW,CAAC,CAAC,GAAGpB,KAAK,CAACE,KAAK,CAACkB,CAAC,CAAC;MACxB,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGI,IAAI,CAACW,CAAC,CAAC,CAACd,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;QACxC;QACA;QACA,MAAMyB,IAAI,GAAGrB,IAAI,CAACW,CAAC,CAAC,CAACf,CAAC,CAAC;QACvB,MAAM0B,WAAW,GAAG,IAAI/D,kBAAkB,CAAC8D,IAAI,EAAEV,CAAC,CAAC;QACnDW,WAAW,CAACC,SAAS,GAAG3B,CAAC;QACzB0B,WAAW,CAACE,OAAO,GAAG,IAAI;QAC1BN,QAAQ,CAACO,IAAI,CAACH,WAAW,CAAC;QAC1BH,GAAG,CAACO,GAAG,CAACL,IAAI,EAAEC,WAAW,CAAC;MAC9B;IACJ;IACA;IACA;IACA,MAAMK,QAAQ,GAAGT,QAAQ,CAACrB,MAAM,GAAG,EAAE;IACrC,IAAI+B,KAAK,GAAG,CAAC;IACb;IACA,MAAMC,SAAS,GAAG,CAAC;IACnB,OAAOX,QAAQ,CAACrB,MAAM,GAAG,CAAC,IAAI+B,KAAK,IAAID,QAAQ,EAAE;MAC7C,MAAMG,WAAW,GAAGZ,QAAQ,CAACa,KAAK,CAAC,CAAC;MACpC,MAAM7B,IAAI,GAAI4B,WAAW,CAAC5B,IAAK;MAC/B,MAAM8B,SAAS,GAAGF,WAAW,CAACG,aAAa;MAC3C,MAAMV,SAAS,GAAGW,QAAQ,CAACnC,MAAM,CAAC+B,WAAW,CAACP,SAAS,CAAC,CAAC;MACzD,MAAMY,uBAAuB,GAAIjC,IAAI,CAACkC,0BAA0B,CAACJ,SAAS,CAAE;MAC5E,MAAMK,2BAA2B,GAAInC,IAAI,CAACoC,8BAA8B,CAACN,SAAS,CAAE;MACpF,MAAMO,qBAAqB,GAAGJ,uBAAuB,CAACtC,MAAM;MAC5D,MAAM2C,yBAAyB,GAAGH,2BAA2B,CAACxC,MAAM;MACpE,MAAM4C,eAAe,GAAG,IAAI,CAACC,YAAY,CAACP,uBAAuB,EAAEH,SAAS,GAAG,CAAC,CAAC;MACjF,MAAMW,mBAAmB,GAAG,IAAI,CAACD,YAAY,CAACL,2BAA2B,EAAEL,SAAS,GAAG,CAAC,CAAC;MACzF,MAAMY,sBAAsB,GAAGL,qBAAqB,GAAGC,yBAAyB;MAChF,MAAMK,eAAe,GAAG3C,IAAI,CAACC,yBAAyB,CAAC6B,SAAS,CAAC;MACjE,IAAIc,UAAU,GAAGD,eAAe;MAChC,IAAID,sBAAsB,GAAG,CAAC,EAAE;QAC5BE,UAAU,GACN,CAACL,eAAe,GAAGF,qBAAqB,GACpCI,mBAAmB,GAAGH,yBAAyB,IAC/CI,sBAAsB;MAClC;MACA;MACA,IAAIG,eAAe,GAAG,KAAK;MAC3B,IAAID,UAAU,GAAGD,eAAe,GAAGhB,SAAS,EAAE;QAC1C,IAAIN,SAAS,KAAK,CAAC,EAAE;UACjBrB,IAAI,CAACY,yBAAyB,CAACkB,SAAS,EAAEc,UAAU,CAAC;UACrDC,eAAe,GAAG,IAAI;QAC1B,CAAC,MACI;UACD,MAAMC,QAAQ,GAAGhD,IAAI,CAACgC,SAAS,CAAC,CAACT,SAAS,GAAG,CAAC,CAAC;UAC/C,IAAI0B,SAAS,GAAGD,QAAQ,CAAC7C,yBAAyB,CAAC6B,SAAS,CAAC;UAC7DiB,SAAS,GACLA,SAAS,GAAGD,QAAQ,CAACE,KAAK,GAAG,CAAC,GAAG,IAAI,CAACpF,gBAAgB,GAAGoC,IAAI,CAACgD,KAAK,GAAG,CAAC;UAC3E,IAAID,SAAS,GAAGH,UAAU,EAAE;YACxB5C,IAAI,CAACY,yBAAyB,CAACkB,SAAS,EAAEc,UAAU,CAAC;YACrDC,eAAe,GAAG,IAAI;UAC1B,CAAC,MACI,IAAIE,SAAS,GACd/C,IAAI,CAACC,yBAAyB,CAAC6B,SAAS,CAAC,GAAGH,SAAS,EAAE;YACvD3B,IAAI,CAACY,yBAAyB,CAACkB,SAAS,EAAEiB,SAAS,CAAC;YACpDF,eAAe,GAAG,IAAI;UAC1B;QACJ;MACJ,CAAC,MACI,IAAID,UAAU,GAAGD,eAAe,GAAGhB,SAAS,EAAE;QAC/C,MAAMsB,QAAQ,GAAGnD,IAAI,CAACgC,SAAS,CAAC,CAACnC,MAAM;QACvC,IAAI0B,SAAS,KAAK4B,QAAQ,GAAG,CAAC,EAAE;UAC5BjD,IAAI,CAACY,yBAAyB,CAACkB,SAAS,EAAEc,UAAU,CAAC;UACrDC,eAAe,GAAG,IAAI;QAC1B,CAAC,MACI;UACD,MAAMK,SAAS,GAAGpD,IAAI,CAACgC,SAAS,CAAC,CAACT,SAAS,GAAG,CAAC,CAAC;UAChD,IAAI8B,UAAU,GAAGD,SAAS,CAACjD,yBAAyB,CAAC6B,SAAS,CAAC;UAC/DqB,UAAU,GACNA,UAAU,GAAGD,SAAS,CAACF,KAAK,GAAG,CAAC,GAAG,IAAI,CAACpF,gBAAgB,GAAGoC,IAAI,CAACgD,KAAK,GAAG,CAAC;UAC7E,IAAIG,UAAU,GAAGP,UAAU,EAAE;YACzB5C,IAAI,CAACY,yBAAyB,CAACkB,SAAS,EAAEc,UAAU,CAAC;YACrDC,eAAe,GAAG,IAAI;UAC1B,CAAC,MACI,IAAIM,UAAU,GACfnD,IAAI,CAACC,yBAAyB,CAAC6B,SAAS,CAAC,GAAGH,SAAS,EAAE;YACvD3B,IAAI,CAACY,yBAAyB,CAACkB,SAAS,EAAEqB,UAAU,CAAC;YACrDN,eAAe,GAAG,IAAI;UAC1B;QACJ;MACJ;MACA,IAAIA,eAAe,EAAE;QACjB;QACA,KAAK,IAAIpC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwB,uBAAuB,CAACtC,MAAM,EAAEc,CAAC,IAAI,CAAC,EAAE;UACxD,MAAM2C,aAAa,GAAGnB,uBAAuB,CAACxB,CAAC,CAAC;UAChD,MAAM4C,oBAAoB,GAAGpC,GAAG,CAACqC,GAAG,CAACF,aAAa,CAAC;UACnD,IAAIC,oBAAoB,IAAI,IAAI,EAAE;YAC9B,IAAIA,oBAAoB,CAAC/B,OAAO,IAAI,KAAK,EAAE;cACvC+B,oBAAoB,CAAC/B,OAAO,GAAG,IAAI;cACnCN,QAAQ,CAACO,IAAI,CAAC8B,oBAAoB,CAAC;YACvC;UACJ;QACJ;QACA;QACA,KAAK,IAAI5C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0B,2BAA2B,CAACxC,MAAM,EAAEc,CAAC,IAAI,CAAC,EAAE;UAC5D,MAAM2C,aAAa,GAAGjB,2BAA2B,CAAC1B,CAAC,CAAC;UACpD,MAAM4C,oBAAoB,GAAGpC,GAAG,CAACqC,GAAG,CAACF,aAAa,CAAC;UACnD,IAAIC,oBAAoB,IAAI,IAAI,EAAE;YAC9B,IAAIA,oBAAoB,CAAC/B,OAAO,IAAI,KAAK,EAAE;cACvC+B,oBAAoB,CAAC/B,OAAO,GAAG,IAAI;cACnCN,QAAQ,CAACO,IAAI,CAAC8B,oBAAoB,CAAC;YACvC;UACJ;QACJ;MACJ;MACAzB,WAAW,CAACN,OAAO,GAAG,KAAK;MAC3BI,KAAK,IAAI,CAAC;IACd;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;EACIhB,SAASA,CAACD,CAAC,EAAEpB,KAAK,EAAE;IAChB;IACA,MAAMkE,aAAa,GAAG9C,CAAC,GAAG,CAAC,KAAK,CAAC;IACjC,IAAI8C,aAAa,EAAE;MACf,KAAK,IAAI7D,CAAC,GAAGL,KAAK,CAAC6B,OAAO,EAAExB,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QACpC,IAAI,CAAC8D,kBAAkB,CAAC9D,CAAC,GAAG,CAAC,EAAEL,KAAK,EAAEK,CAAC,CAAC;MAC5C;IACJ,CAAC,MACI;MACD,KAAK,IAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,KAAK,CAAC6B,OAAO,GAAG,CAAC,EAAExB,CAAC,EAAE,EAAE;QACxC,IAAI,CAAC8D,kBAAkB,CAAC9D,CAAC,GAAG,CAAC,EAAEL,KAAK,EAAEK,CAAC,CAAC;MAC5C;IACJ;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI8D,kBAAkBA,CAAC1B,SAAS,EAAEzC,KAAK,EAAEoE,aAAa,EAAE;IAChD,MAAMlE,KAAK,GAAGF,KAAK,CAACE,KAAK;IACzB,MAAMO,IAAI,GAAGP,KAAK,CAACuC,SAAS,CAAC;IAC7B;IACA;IACA;IACA,MAAM4B,cAAc,GAAG,EAAE;IACzB,MAAMC,OAAO,GAAG,CAAC,CAAC;IAClB,KAAK,IAAIlD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,IAAI,CAACH,MAAM,EAAEc,CAAC,IAAI,CAAC,EAAE;MACrC,MAAMmD,WAAW,GAAG9D,IAAI,CAACW,CAAC,CAAC;MAC3BiD,cAAc,CAACjD,CAAC,CAAC,GAAG,IAAIpD,kBAAkB,CAACuG,WAAW,CAAC;MACvDF,cAAc,CAACjD,CAAC,CAAC,CAACY,SAAS,GAAGZ,CAAC;MAC/BkD,OAAO,CAACC,WAAW,CAACC,EAAE,CAAC,GAAGH,cAAc,CAACjD,CAAC,CAAC;MAC3C,IAAIwB,uBAAuB,GAAG,IAAI;MAClC,IAAIwB,aAAa,GAAG3B,SAAS,EAAE;QAC3BG,uBAAuB,GAAG2B,WAAW,CAACxB,8BAA8B,CAACN,SAAS,CAAC;MACnF,CAAC,MACI;QACDG,uBAAuB,GAAG2B,WAAW,CAAC1B,0BAA0B,CAACJ,SAAS,CAAC;MAC/E;MACA;MACA;MACA4B,cAAc,CAACjD,CAAC,CAAC,CAACsB,aAAa,GAAG,IAAI,CAAC+B,uBAAuB,CAACF,WAAW,EAAE3B,uBAAuB,CAAC;IACxG;IACAyB,cAAc,CAACK,IAAI,CAAC1G,kBAAkB,CAAC2G,OAAO,CAAC;IAC/C;IACA;IACA,KAAK,IAAIvD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiD,cAAc,CAAC/D,MAAM,EAAEc,CAAC,IAAI,CAAC,EAAE;MAC/C,IAAIwD,uBAAuB,GAAG,CAAC;MAC/B,MAAMjE,IAAI,GAAG0D,cAAc,CAACjD,CAAC,CAAC,CAACT,IAAI;MACnC,IAAIiC,uBAAuB,GAAG,IAAI;MAClC,IAAIM,eAAe,GAAG,CAAC;MACvB,IAAIkB,aAAa,GAAG3B,SAAS,EAAE;QAC3BG,uBAAuB,GAAGjC,IAAI,CAACoC,8BAA8B,CAACN,SAAS,CAAC,CAACoC,KAAK,CAAC,CAAC;MACpF,CAAC,MACI;QACDjC,uBAAuB,GAAGjC,IAAI,CAACkC,0BAA0B,CAACJ,SAAS,CAAC,CAACoC,KAAK,CAAC,CAAC;MAChF;MACA,IAAIjC,uBAAuB,IAAI,IAAI,EAAE;QACjCgC,uBAAuB,GAAGhC,uBAAuB,CAACtC,MAAM;QACxD,IAAIsE,uBAAuB,GAAG,CAAC,EAAE;UAC7B1B,eAAe,GAAG,IAAI,CAACC,YAAY,CAACP,uBAAuB,EAAEwB,aAAa,CAAC;QAC/E,CAAC,MACI;UACD;UACA;UACA;UACAlB,eAAe,GAAGvC,IAAI,CAACC,yBAAyB,CAAC6B,SAAS,CAAC;QAC/D;MACJ;MACA,IAAIqC,UAAU,GAAG,GAAG;MACpB,IAAIpB,SAAS,GAAG,CAAC,WAAW;MAC5B,KAAK,IAAIrD,CAAC,GAAGgE,cAAc,CAACjD,CAAC,CAAC,CAACY,SAAS,GAAG,CAAC,EAAE3B,CAAC,IAAI,CAAC,GAAG;QACnD,MAAMqC,aAAa,GAAG4B,OAAO,CAAC7D,IAAI,CAACJ,CAAC,CAAC,CAACmE,EAAE,CAAC;QACzC,IAAI9B,aAAa,IAAI,IAAI,EAAE;UACvB,MAAMe,QAAQ,GAAGf,aAAa,CAAC/B,IAAI;UACnC,IAAI+B,aAAa,CAACT,OAAO,EAAE;YACvB;YACA;YACA;YACAyB,SAAS,GACLD,QAAQ,CAAC7C,yBAAyB,CAAC6B,SAAS,CAAC,GACzCgB,QAAQ,CAACE,KAAK,GAAG,GAAG,GACpB,IAAI,CAACpF,gBAAgB,GACrBuG,UAAU,GACVnE,IAAI,CAACgD,KAAK,GAAG,GAAG;YACxBtD,CAAC,GAAG,CAAC,CAAC;UACV,CAAC,MACI;YACDyE,UAAU,IAAIrB,QAAQ,CAACE,KAAK,GAAG,IAAI,CAACpF,gBAAgB;YACpD8B,CAAC,EAAE;UACP;QACJ;MACJ;MACA,IAAI0E,WAAW,GAAG,GAAG;MACrB,IAAIjB,UAAU,GAAG,WAAW;MAC5B,KAAK,IAAIzD,CAAC,GAAGgE,cAAc,CAACjD,CAAC,CAAC,CAACY,SAAS,GAAG,CAAC,EAAE3B,CAAC,GAAGgE,cAAc,CAAC/D,MAAM,GAAG;QACtE,MAAMoC,aAAa,GAAG4B,OAAO,CAAC7D,IAAI,CAACJ,CAAC,CAAC,CAACmE,EAAE,CAAC;QACzC,IAAI9B,aAAa,IAAI,IAAI,EAAE;UACvB,MAAMmB,SAAS,GAAGnB,aAAa,CAAC/B,IAAI;UACpC,IAAI+B,aAAa,CAACT,OAAO,EAAE;YACvB;YACA;YACA;YACA6B,UAAU,GACND,SAAS,CAACjD,yBAAyB,CAAC6B,SAAS,CAAC,GAC1CoB,SAAS,CAACF,KAAK,GAAG,GAAG,GACrB,IAAI,CAACpF,gBAAgB,GACrBwG,WAAW,GACXpE,IAAI,CAACgD,KAAK,GAAG,GAAG;YACxBtD,CAAC,GAAGgE,cAAc,CAAC/D,MAAM;UAC7B,CAAC,MACI;YACDyE,WAAW,IAAIlB,SAAS,CAACF,KAAK,GAAG,IAAI,CAACpF,gBAAgB;YACtD8B,CAAC,EAAE;UACP;QACJ;MACJ;MACA,IAAI6C,eAAe,IAAIQ,SAAS,IAAIR,eAAe,IAAIY,UAAU,EAAE;QAC/DnD,IAAI,CAACY,yBAAyB,CAACkB,SAAS,EAAES,eAAe,CAAC;MAC9D,CAAC,MACI,IAAIA,eAAe,GAAGQ,SAAS,EAAE;QAClC;QACA;QACA/C,IAAI,CAACY,yBAAyB,CAACkB,SAAS,EAAEiB,SAAS,CAAC;QACpD,IAAI,CAACtE,aAAa,GAAG,IAAI,CAACA,aAAa,GAAGsE,SAAS,GAAGR,eAAe;MACzE,CAAC,MACI,IAAIA,eAAe,GAAGY,UAAU,EAAE;QACnC;QACA;QACAnD,IAAI,CAACY,yBAAyB,CAACkB,SAAS,EAAEqB,UAAU,CAAC;QACrD,IAAI,CAAC1E,aAAa,GAAG,IAAI,CAACA,aAAa,GAAG8D,eAAe,GAAGY,UAAU;MAC1E;MACAO,cAAc,CAACjD,CAAC,CAAC,CAACa,OAAO,GAAG,IAAI;IACpC;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIwC,uBAAuBA,CAACF,WAAW,EAAES,UAAU,EAAE;IAC7C,IAAIC,WAAW,GAAG,CAAC;IACnB,KAAK,IAAI7D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4D,UAAU,CAAC1E,MAAM,EAAEc,CAAC,IAAI,CAAC,EAAE;MAC3C,MAAMT,IAAI,GAAGqE,UAAU,CAAC5D,CAAC,CAAC;MAC1B,IAAImD,WAAW,CAACW,QAAQ,CAAC,CAAC,IAAIvE,IAAI,CAACuE,QAAQ,CAAC,CAAC,EAAE;QAC3CD,WAAW,IAAI,CAAC;MACpB,CAAC,MACI,IAAIV,WAAW,CAACY,MAAM,CAAC,CAAC,IAAIxE,IAAI,CAACwE,MAAM,CAAC,CAAC,EAAE;QAC5CF,WAAW,IAAI,CAAC;MACpB,CAAC,MACI;QACDA,WAAW,IAAI,CAAC;MACpB;IACJ;IACA,OAAOA,WAAW;EACtB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI9B,YAAYA,CAACiC,cAAc,EAAE3C,SAAS,EAAE;IACpC,IAAI2C,cAAc,CAAC9E,MAAM,KAAK,CAAC,EAAE;MAC7B,OAAO,CAAC;IACZ;IACA,MAAM+E,YAAY,GAAG,EAAE;IACvB,KAAK,IAAIjE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgE,cAAc,CAAC9E,MAAM,EAAEc,CAAC,IAAI,CAAC,EAAE;MAC/CiE,YAAY,CAACjE,CAAC,CAAC,GAAGgE,cAAc,CAAChE,CAAC,CAAC,CAACR,yBAAyB,CAAC6B,SAAS,CAAC;IAC5E;IACA4C,YAAY,CAACX,IAAI,CAAC,CAACY,CAAC,EAAEC,CAAC,KAAKD,CAAC,GAAGC,CAAC,CAAC;IAClC,IAAIH,cAAc,CAAC9E,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;MACjC;MACA,OAAO+E,YAAY,CAACG,IAAI,CAACC,KAAK,CAACL,cAAc,CAAC9E,MAAM,GAAG,CAAC,CAAC,CAAC;IAC9D;IACA,MAAMoF,WAAW,GAAGN,cAAc,CAAC9E,MAAM,GAAG,CAAC;IAC7C,MAAMqF,UAAU,GAAGN,YAAY,CAACK,WAAW,GAAG,CAAC,CAAC;IAChD,MAAME,WAAW,GAAGP,YAAY,CAACK,WAAW,CAAC;IAC7C,OAAO,CAACC,UAAU,GAAGC,WAAW,IAAI,CAAC;EACzC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI5E,aAAaA,CAAC6E,MAAM,EAAE7F,KAAK,EAAE;IACzB,IAAI,CAAC8F,mBAAmB,CAACD,MAAM,EAAE7F,KAAK,CAAC;IACvC;IACA,KAAK,IAAIoB,CAAC,GAAG,IAAI,CAAC/B,UAAU,EAAE+B,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACvC,IAAIA,CAAC,GAAGpB,KAAK,CAAC6B,OAAO,EAAE;QACnB,IAAI,CAACkE,eAAe,CAAC3E,CAAC,EAAEyE,MAAM,EAAE7F,KAAK,CAAC;MAC1C;IACJ;IACA,KAAK,IAAIoB,CAAC,GAAG,IAAI,CAAC/B,UAAU,GAAG,CAAC,EAAE+B,CAAC,IAAIpB,KAAK,CAAC6B,OAAO,EAAET,CAAC,IAAI,CAAC,EAAE;MAC1D,IAAIA,CAAC,GAAG,CAAC,EAAE;QACP,IAAI,CAAC2E,eAAe,CAAC3E,CAAC,EAAEyE,MAAM,EAAE7F,KAAK,CAAC;MAC1C;IACJ;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI+F,eAAeA,CAACtD,SAAS,EAAEuD,KAAK,EAAEhG,KAAK,EAAE;IACrC,MAAME,KAAK,GAAGF,KAAK,CAACE,KAAK;IACzB,MAAMO,IAAI,GAAGP,KAAK,CAACuC,SAAS,CAAC;IAC7B,IAAIwD,IAAI,GAAG,GAAG;IACd,IAAIC,MAAM,GAAG,IAAI,CAACxH,QAAQ,GACtB,CAAC,IAAI,CAACc,eAAe,GAAG,IAAI,CAACC,UAAU,CAACgD,SAAS,CAAC,IAAI,CAAC;IAC3D;IACA;IACA,IAAI0D,aAAa,GAAG,KAAK;IACzB,KAAK,IAAI/E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,IAAI,CAACH,MAAM,EAAEc,CAAC,IAAI,CAAC,EAAE;MACrC,MAAMU,IAAI,GAAGrB,IAAI,CAACW,CAAC,CAAC;MACpB,IAAIU,IAAI,CAACoD,QAAQ,CAAC,CAAC,EAAE;QACjB,MAAMkB,MAAM,GAAG,IAAI,CAAC9H,MAAM,CAAC+H,eAAe,CAACvE,IAAI,CAACnB,IAAI,CAAC;QACrD,IAAIyF,MAAM,IAAI,IAAI,EAAE;UAChB,IAAI,IAAI,CAAC3H,WAAW,KAAKX,SAAS,CAACoB,KAAK,IACpC,IAAI,CAACT,WAAW,KAAKX,SAAS,CAACwI,KAAK,EAAE;YACtCxE,IAAI,CAAC6B,KAAK,GAAGyC,MAAM,CAACzC,KAAK;YACzB7B,IAAI,CAACyE,MAAM,GAAGH,MAAM,CAACG,MAAM;UAC/B,CAAC,MACI;YACDzE,IAAI,CAAC6B,KAAK,GAAGyC,MAAM,CAACG,MAAM;YAC1BzE,IAAI,CAACyE,MAAM,GAAGH,MAAM,CAACzC,KAAK;UAC9B;QACJ,CAAC,MACI;UACDwC,aAAa,GAAG,IAAI;QACxB;QACAF,IAAI,GAAGT,IAAI,CAACgB,GAAG,CAACP,IAAI,EAAEnE,IAAI,CAACyE,MAAM,CAAC;MACtC,CAAC,MACI,IAAIzE,IAAI,CAACqD,MAAM,CAAC,CAAC,EAAE;QACpB;QACA;QACA,IAAIsB,QAAQ,GAAG,CAAC;QAChB,IAAI3E,IAAI,CAAC4E,KAAK,IAAI,IAAI,EAAE;UACpBD,QAAQ,GAAG3E,IAAI,CAAC4E,KAAK,CAACpG,MAAM;QAChC,CAAC,MACI;UACDvC,MAAM,CAAC4I,IAAI,CAAC,oBAAoB,CAAC;QACrC;QACA7E,IAAI,CAAC6B,KAAK,GAAG,CAAC8C,QAAQ,GAAG,CAAC,IAAI,IAAI,CAAC9H,mBAAmB;MAC1D;MACA;MACAuH,MAAM,IAAIpE,IAAI,CAAC6B,KAAK,GAAG,GAAG;MAC1B7B,IAAI,CAACR,IAAI,CAACmB,SAAS,EAAEyD,MAAM,CAAC;MAC5BpE,IAAI,CAACP,yBAAyB,CAACkB,SAAS,EAAEyD,MAAM,CAAC;MACjDA,MAAM,IAAIpE,IAAI,CAAC6B,KAAK,GAAG,GAAG;MAC1BuC,MAAM,IAAI,IAAI,CAAC3H,gBAAgB;IACnC;IACA,IAAI4H,aAAa,IAAI,IAAI,EAAE;MACvBpI,MAAM,CAAC4I,IAAI,CAAC,iCAAiC,CAAC;IAClD;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIb,mBAAmBA,CAACE,KAAK,EAAEhG,KAAK,EAAE;IAC9B;IACA,IAAI4G,CAAC,GAAG,CAAC,IAAI,CAACpI,oBAAoB;IAClC;IACA;IACA,IAAIqI,qBAAqB,GAAG,GAAG;IAC/B,IAAI,CAACpH,UAAU,GAAG,EAAE;IACpB,IAAI,CAACC,KAAK,GAAG,EAAE;IACf,KAAK,IAAI+C,SAAS,GAAGzC,KAAK,CAAC6B,OAAO,EAAEY,SAAS,IAAI,CAAC,EAAEA,SAAS,IAAI,CAAC,EAAE;MAChE;MACA,IAAIqE,aAAa,GAAG,GAAG;MACvB,MAAM5G,KAAK,GAAGF,KAAK,CAACE,KAAK;MACzB,MAAMO,IAAI,GAAGP,KAAK,CAACuC,SAAS,CAAC;MAC7B,IAAIyD,MAAM,GAAG,IAAI,CAACxH,QAAQ;MAC1B;MACA;MACA,IAAIyH,aAAa,GAAG,KAAK;MACzB,KAAK,IAAI/E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,IAAI,CAACH,MAAM,EAAEc,CAAC,IAAI,CAAC,EAAE;QACrC,MAAMU,IAAI,GAAGrB,IAAI,CAACW,CAAC,CAAC;QACpB,IAAIU,IAAI,CAACoD,QAAQ,CAAC,CAAC,EAAE;UACjB,MAAMkB,MAAM,GAAG,IAAI,CAAC9H,MAAM,CAAC+H,eAAe,CAACvE,IAAI,CAACnB,IAAI,CAAC;UACrD,IAAIyF,MAAM,IAAI,IAAI,EAAE;YAChB,IAAI,IAAI,CAAC3H,WAAW,KAAKX,SAAS,CAACoB,KAAK,IACpC,IAAI,CAACT,WAAW,KAAKX,SAAS,CAACwI,KAAK,EAAE;cACtCxE,IAAI,CAAC6B,KAAK,GAAGyC,MAAM,CAACzC,KAAK;cACzB7B,IAAI,CAACyE,MAAM,GAAGH,MAAM,CAACG,MAAM;YAC/B,CAAC,MACI;cACDzE,IAAI,CAAC6B,KAAK,GAAGyC,MAAM,CAACG,MAAM;cAC1BzE,IAAI,CAACyE,MAAM,GAAGH,MAAM,CAACzC,KAAK;YAC9B;UACJ,CAAC,MACI;YACDwC,aAAa,GAAG,IAAI;UACxB;UACAW,aAAa,GAAGtB,IAAI,CAACgB,GAAG,CAACM,aAAa,EAAEhF,IAAI,CAACyE,MAAM,CAAC;QACxD,CAAC,MACI,IAAIzE,IAAI,CAACqD,MAAM,CAAC,CAAC,EAAE;UACpB;UACA;UACA,IAAIsB,QAAQ,GAAG,CAAC;UAChB,IAAI3E,IAAI,CAAC4E,KAAK,IAAI,IAAI,EAAE;YACpBD,QAAQ,GAAG3E,IAAI,CAAC4E,KAAK,CAACpG,MAAM;UAChC,CAAC,MACI;YACDvC,MAAM,CAAC4I,IAAI,CAAC,oBAAoB,CAAC;UACrC;UACA7E,IAAI,CAAC6B,KAAK,GAAG,CAAC8C,QAAQ,GAAG,CAAC,IAAI,IAAI,CAAC9H,mBAAmB;QAC1D;QACA;QACAuH,MAAM,IAAIpE,IAAI,CAAC6B,KAAK,GAAG,GAAG;QAC1B7B,IAAI,CAACR,IAAI,CAACmB,SAAS,EAAEyD,MAAM,CAAC;QAC5BpE,IAAI,CAACP,yBAAyB,CAACkB,SAAS,EAAEyD,MAAM,CAAC;QACjDA,MAAM,IAAIpE,IAAI,CAAC6B,KAAK,GAAG,GAAG;QAC1BuC,MAAM,IAAI,IAAI,CAAC3H,gBAAgB;QAC/B,IAAI2H,MAAM,GAAG,IAAI,CAAC1G,eAAe,EAAE;UAC/B,IAAI,CAACA,eAAe,GAAG0G,MAAM;UAC7B,IAAI,CAAC7G,UAAU,GAAGoD,SAAS;QAC/B;QACA,IAAI,CAAChD,UAAU,CAACgD,SAAS,CAAC,GAAGyD,MAAM;MACvC;MACA,IAAIC,aAAa,IAAI,IAAI,EAAE;QACvBpI,MAAM,CAAC4I,IAAI,CAAC,iCAAiC,CAAC;MAClD;MACA,IAAI,CAACjH,KAAK,CAAC+C,SAAS,CAAC,GAAGmE,CAAC;MACzB,MAAMG,kBAAkB,GAAGD,aAAa,GAAG,GAAG,GAAGD,qBAAqB,GAAG,GAAG,GAAG,IAAI,CAACrI,oBAAoB;MACxGqI,qBAAqB,GAAGC,aAAa;MACrC,IAAI,IAAI,CAACrI,WAAW,KAAKX,SAAS,CAACoB,KAAK,IAAI,IAAI,CAACT,WAAW,KAAKX,SAAS,CAACkJ,IAAI,EAAE;QAC7EJ,CAAC,IAAIG,kBAAkB;MAC3B,CAAC,MACI;QACDH,CAAC,IAAIG,kBAAkB;MAC3B;MACA,KAAK,IAAI3F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,IAAI,CAACH,MAAM,EAAEc,CAAC,IAAI,CAAC,EAAE;QACrC,MAAMT,IAAI,GAAGF,IAAI,CAACW,CAAC,CAAC;QACpBT,IAAI,CAACsG,IAAI,CAACxE,SAAS,EAAEmE,CAAC,CAAC;MAC3B;IACJ;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACInF,OAAOA,CAACuE,KAAK,EAAEhG,KAAK,EAAE;IAClB;IACA;IACA;IACA;IACA;IACA;IACA,MAAM0G,KAAK,GAAG1G,KAAK,CAACkH,UAAU,CAACC,SAAS,CAAC,CAAC;IAC1C,KAAK,IAAI9G,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqG,KAAK,CAACpG,MAAM,EAAED,CAAC,EAAE,EAAE;MACnC,MAAMM,IAAI,GAAG+F,KAAK,CAACrG,CAAC,CAAC;MACrB,IAAIM,IAAI,CAACkB,OAAO,GAAGlB,IAAI,CAACyG,OAAO,GAAG,CAAC,GAAG,CAAC,EAAE;QACrC;MACJ;MACA;MACA;MACA,IAAIC,UAAU,GAAG1G,IAAI,CAACC,yBAAyB,CAACD,IAAI,CAACyG,OAAO,GAAG,CAAC,CAAC;MACjE,IAAIE,YAAY,GAAG,IAAI;MACvB,IAAIC,WAAW,GAAG,CAAC;MACnB,KAAK,IAAInG,CAAC,GAAGT,IAAI,CAACyG,OAAO,GAAG,CAAC,EAAEhG,CAAC,GAAGT,IAAI,CAACkB,OAAO,EAAET,CAAC,IAAI,CAAC,EAAE;QACrD,MAAMoG,CAAC,GAAG7G,IAAI,CAACC,yBAAyB,CAACQ,CAAC,CAAC;QAC3C,IAAIiG,UAAU,KAAKG,CAAC,EAAE;UAClBF,YAAY,GAAG,KAAK;UACpBD,UAAU,GAAGG,CAAC;QAClB,CAAC,MACI;UACDD,WAAW,IAAI,CAAC;QACpB;MACJ;MACA,IAAI,CAACD,YAAY,EAAE;QACf,IAAIG,UAAU,GAAG,CAAC;QAClB,IAAIC,YAAY,GAAG,CAAC;QACpB,MAAMC,YAAY,GAAG,EAAE;QACvB,MAAMC,cAAc,GAAG,EAAE;QACzB,IAAIxG,CAAC,GAAG,CAAC;QACT,IAAIyG,QAAQ,GAAGlH,IAAI,CAACC,yBAAyB,CAACD,IAAI,CAACyG,OAAO,GAAG,CAAC,CAAC;QAC/D,KAAKhG,CAAC,GAAGT,IAAI,CAACyG,OAAO,GAAG,CAAC,EAAEhG,CAAC,GAAGT,IAAI,CAACkB,OAAO,GAAG,CAAC,EAAET,CAAC,IAAI,CAAC,EAAE;UACrD;UACA;UACA,MAAM0G,KAAK,GAAGnH,IAAI,CAACa,IAAI,CAACJ,CAAC,GAAG,CAAC,CAAC;UAC9B,IAAIyG,QAAQ,KAAKC,KAAK,EAAE;YACpBH,YAAY,CAACvG,CAAC,GAAGT,IAAI,CAACyG,OAAO,GAAG,CAAC,CAAC,GAAGS,QAAQ;YAC7CJ,UAAU,IAAI,CAAC;UACnB,CAAC,MACI,IAAI,IAAI,CAACM,eAAe,CAAC/H,KAAK,EAAEW,IAAI,EAAES,CAAC,GAAG,CAAC,EAAEyG,QAAQ,CAAC,EAAE;YACzDF,YAAY,CAACvG,CAAC,GAAGT,IAAI,CAACyG,OAAO,GAAG,CAAC,CAAC,GAAGS,QAAQ;YAC7CJ,UAAU,IAAI,CAAC;YACf;UACJ,CAAC,MACI;YACDE,YAAY,CAACvG,CAAC,GAAGT,IAAI,CAACyG,OAAO,GAAG,CAAC,CAAC,GAAGU,KAAK;YAC1CD,QAAQ,GAAGC,KAAK;UACpB;QACJ;QACAD,QAAQ,GAAGlH,IAAI,CAACa,IAAI,CAACJ,CAAC,CAAC;QACvB,KAAK,IAAIA,CAAC,GAAGT,IAAI,CAACkB,OAAO,GAAG,CAAC,EAAET,CAAC,GAAGT,IAAI,CAACyG,OAAO,GAAG,CAAC,EAAEhG,CAAC,EAAE,EAAE;UACtD;UACA;UACA,MAAM0G,KAAK,GAAGnH,IAAI,CAACa,IAAI,CAACJ,CAAC,GAAG,CAAC,CAAC;UAC9B,IAAIyG,QAAQ,KAAKC,KAAK,EAAE;YACpBF,cAAc,CAACxG,CAAC,GAAGT,IAAI,CAACyG,OAAO,GAAG,CAAC,CAAC,GAAGS,QAAQ;YAC/CH,YAAY,IAAI,CAAC;UACrB,CAAC,MACI,IAAI,IAAI,CAACK,eAAe,CAAC/H,KAAK,EAAEW,IAAI,EAAES,CAAC,GAAG,CAAC,EAAEyG,QAAQ,CAAC,EAAE;YACzDD,cAAc,CAACxG,CAAC,GAAGT,IAAI,CAACyG,OAAO,GAAG,CAAC,CAAC,GAAGS,QAAQ;YAC/CH,YAAY,IAAI,CAAC;YACjB;UACJ,CAAC,MACI;YACDE,cAAc,CAACxG,CAAC,GAAGT,IAAI,CAACyG,OAAO,GAAG,CAAC,CAAC,GAAGzG,IAAI,CAACa,IAAI,CAACJ,CAAC,GAAG,CAAC,CAAC;YACvDyG,QAAQ,GAAGC,KAAK;UACpB;QACJ;QACA,IAAIJ,YAAY,GAAGH,WAAW,IAAIE,UAAU,GAAGF,WAAW,EAAE;UACxD,IAAIG,YAAY,IAAID,UAAU,EAAE;YAC5B;YACA,KAAK,IAAIrG,CAAC,GAAGT,IAAI,CAACkB,OAAO,GAAG,CAAC,EAAET,CAAC,GAAGT,IAAI,CAACyG,OAAO,EAAEhG,CAAC,EAAE,EAAE;cAClDT,IAAI,CAACW,IAAI,CAACF,CAAC,EAAEwG,cAAc,CAACxG,CAAC,GAAGT,IAAI,CAACyG,OAAO,GAAG,CAAC,CAAC,CAAC;YACtD;UACJ,CAAC,MACI,IAAIK,UAAU,GAAGC,YAAY,EAAE;YAChC;YACA,KAAK,IAAItG,CAAC,GAAGT,IAAI,CAACyG,OAAO,GAAG,CAAC,EAAEhG,CAAC,GAAGT,IAAI,CAACkB,OAAO,EAAET,CAAC,IAAI,CAAC,EAAE;cACrDT,IAAI,CAACW,IAAI,CAACF,CAAC,EAAEuG,YAAY,CAACvG,CAAC,GAAGT,IAAI,CAACyG,OAAO,GAAG,CAAC,CAAC,CAAC;YACpD;UACJ,CAAC,MACI;YACD;YACA;YACA;YACA;UAAA;QAER;MACJ;IACJ;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIW,eAAeA,CAAC/H,KAAK,EAAEW,IAAI,EAAEF,IAAI,EAAEuH,QAAQ,EAAE;IACzC,MAAM9H,KAAK,GAAGF,KAAK,CAACE,KAAK;IACzB,MAAM+H,SAAS,GAAG/H,KAAK,CAACO,IAAI,CAAC;IAC7B,IAAIuB,SAAS,GAAG,CAAC,CAAC;IAClB,KAAK,IAAIZ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6G,SAAS,CAAC3H,MAAM,EAAEc,CAAC,IAAI,CAAC,EAAE;MAC1C,IAAIT,IAAI,KAAKsH,SAAS,CAAC7G,CAAC,CAAC,EAAE;QACvBY,SAAS,GAAGZ,CAAC;QACb;MACJ;IACJ;IACA,IAAIY,SAAS,GAAG,CAAC,EAAE;MACf,OAAO,KAAK;IAChB;IACA,MAAM6F,QAAQ,GAAGlH,IAAI,CAACC,yBAAyB,CAACH,IAAI,CAAC;IACrD,IAAIuH,QAAQ,GAAGH,QAAQ,EAAE;MACrB;MACA,IAAI7F,SAAS,KAAK,CAAC,EAAE;QACjB;QACA,OAAO,IAAI;MACf;MACA,MAAMyB,QAAQ,GAAGwE,SAAS,CAACjG,SAAS,GAAG,CAAC,CAAC;MACzC,IAAI0B,SAAS,GAAGD,QAAQ,CAAC7C,yBAAyB,CAACH,IAAI,CAAC;MACxDiD,SAAS,GAAGA,SAAS,GAAGD,QAAQ,CAACE,KAAK,GAAG,CAAC,GAAG,IAAI,CAACpF,gBAAgB,GAAGoC,IAAI,CAACgD,KAAK,GAAG,CAAC;MACnF,OAAOD,SAAS,IAAIsE,QAAQ;IAChC;IACA,IAAIA,QAAQ,GAAGH,QAAQ,EAAE;MACrB;MACA,IAAI7F,SAAS,KAAKiG,SAAS,CAAC3H,MAAM,GAAG,CAAC,EAAE;QACpC;QACA,OAAO,IAAI;MACf;MACA,MAAMuD,SAAS,GAAGoE,SAAS,CAACjG,SAAS,GAAG,CAAC,CAAC;MAC1C,IAAI8B,UAAU,GAAGD,SAAS,CAACjD,yBAAyB,CAACH,IAAI,CAAC;MAC1DqD,UAAU,GACNA,UAAU,GAAGD,SAAS,CAACF,KAAK,GAAG,CAAC,GAAG,IAAI,CAACpF,gBAAgB,GAAGoC,IAAI,CAACgD,KAAK,GAAG,CAAC;MAC7E,OAAOG,UAAU,IAAIkE,QAAQ;IACjC;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACItG,gBAAgBA,CAACsE,KAAK,EAAEhG,KAAK,EAAE;IAC3B,IAAI,CAACV,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACC,WAAW,GAAG,EAAE;IACrB,MAAMW,KAAK,GAAGF,KAAK,CAACE,KAAK;IACzB,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlB,KAAK,CAACI,MAAM,EAAEc,CAAC,IAAI,CAAC,EAAE;MACtC,IAAI,CAAC9B,QAAQ,CAAC8B,CAAC,CAAC,GAAG8G,MAAM,CAACC,SAAS;MACnC,IAAI,CAAC5I,WAAW,CAAC6B,CAAC,CAAC,GAAG,CAAC8G,MAAM,CAACC,SAAS;IAC3C;IACA,MAAMC,QAAQ,GAAGpI,KAAK,CAACqI,YAAY,CAAClB,SAAS,CAAC,CAAC;IAC/C;IACA;IACA;IACA,KAAK,IAAI/F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgH,QAAQ,CAAC9H,MAAM,EAAEc,CAAC,IAAI,CAAC,EAAE;MACzC,IAAI,CAACkH,iBAAiB,CAACF,QAAQ,CAAChH,CAAC,CAAC,CAAC;IACvC;IACA;IACA;IACA,IAAI,IAAI,CAAC9C,MAAM,CAACiK,SAAS,KAAKpK,qBAAqB,CAACqK,UAAU,IAC1D,IAAI,CAAClK,MAAM,CAACiK,SAAS,KAAKpK,qBAAqB,CAACsK,QAAQ,IACxD,IAAI,CAACnK,MAAM,CAACiK,SAAS,KAAKpK,qBAAqB,CAACuK,KAAK,EAAE;MACvD,IAAI,CAACC,mBAAmB,CAAC3I,KAAK,CAAC;IACnC;IACA,MAAM0G,KAAK,GAAG1G,KAAK,CAACkH,UAAU,CAACC,SAAS,CAAC,CAAC;IAC1C,KAAK,IAAI/F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsF,KAAK,CAACpG,MAAM,EAAEc,CAAC,IAAI,CAAC,EAAE;MACtC,IAAI,CAACwH,eAAe,CAAClC,KAAK,CAACtF,CAAC,CAAC,CAAC;IAClC;EACJ;EACA;AACJ;AACA;AACA;AACA;EACIuH,mBAAmBA,CAAC3I,KAAK,EAAE;IACvB;IACA;IACA,MAAME,KAAK,GAAGF,KAAK,CAACE,KAAK;IACzB,KAAK,IAAI8B,SAAS,GAAG,CAAC,EAAEA,SAAS,GAAG9B,KAAK,CAACI,MAAM,EAAE0B,SAAS,IAAI,CAAC,EAAE;MAC9D,MAAMvB,IAAI,GAAGP,KAAK,CAAC8B,SAAS,CAAC;MAC7B,KAAK,IAAI6G,SAAS,GAAG,CAAC,EAAEA,SAAS,GAAGpI,IAAI,CAACH,MAAM,EAAEuI,SAAS,IAAI,CAAC,EAAE;QAC7D,MAAMlI,IAAI,GAAGF,IAAI,CAACoI,SAAS,CAAC;QAC5B,IAAIlI,IAAI,CAACuE,QAAQ,CAAC,CAAC,EAAE;UACjB,IAAI4D,YAAY,GAAGnI,IAAI,CAACoC,8BAA8B,CAACf,SAAS,CAAC;UACjE,IAAI+G,WAAW,GAAG/G,SAAS,GAAG,CAAC;UAC/B;UACA,KAAK,IAAItB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;YAC3B,IAAIqI,WAAW,GAAG,CAAC,CAAC,IAChBA,WAAW,GAAG7I,KAAK,CAACI,MAAM,IAC1BwI,YAAY,IAAI,IAAI,IACpBA,YAAY,CAACxI,MAAM,GAAG,CAAC,EAAE;cACzB,MAAM0I,WAAW,GAAG,EAAE;cACtB,KAAK,IAAI3I,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyI,YAAY,CAACxI,MAAM,EAAED,CAAC,EAAE,EAAE;gBAC1C,MAAM4I,MAAM,GAAG,IAAIjL,kBAAkB,CAAC8K,YAAY,CAACzI,CAAC,CAAC,EAAEyI,YAAY,CAACzI,CAAC,CAAC,CAACmB,IAAI,CAACuH,WAAW,CAAC,CAAC;gBACzFC,WAAW,CAAC9G,IAAI,CAAC+G,MAAM,CAAC;cAC5B;cACAD,WAAW,CAACtE,IAAI,CAAC1G,kBAAkB,CAAC2G,OAAO,CAAC;cAC5C,IAAIjB,SAAS,GAAG/C,IAAI,CAAC6G,CAAC,CAAC,CAAC,CAAC,GAAG7G,IAAI,CAACgD,KAAK,GAAG,CAAC;cAC1C,IAAIG,UAAU,GAAGJ,SAAS,GAAG/C,IAAI,CAACgD,KAAK;cACvC;cACA;cACA,IAAIuF,kBAAkB,GAAG,CAAC;cAC1B,IAAIC,uBAAuB,GAAG,CAAC;cAC/B,MAAMC,cAAc,GAAG,EAAE;cACzB;cACA,KAAK,IAAI/I,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2I,WAAW,CAAC1I,MAAM,EAAED,CAAC,EAAE,EAAE;gBACzC,MAAMgJ,SAAS,GAAGL,WAAW,CAAC3I,CAAC,CAAC,CAACM,IAAI;gBACrC,IAAI2I,WAAW;gBACf,IAAID,SAAS,CAACnE,QAAQ,CAAC,CAAC,EAAE;kBACtB;kBACA,IAAIxE,CAAC,KAAK,CAAC,EAAE;oBACT4I,WAAW,GAAG3I,IAAI,CAAC4I,gBAAgB;kBACvC,CAAC,MACI;oBACDD,WAAW,GAAG3I,IAAI,CAAC6I,gBAAgB;kBACvC;kBACA,KAAK,IAAIC,SAAS,GAAG,CAAC,EAAEA,SAAS,GAAGH,WAAW,CAAChJ,MAAM,EAAEmJ,SAAS,IAAI,CAAC,EAAE;oBACpE,IAAIH,WAAW,CAACG,SAAS,CAAC,CAACC,MAAM,KAAKL,SAAS,IAC3CC,WAAW,CAACG,SAAS,CAAC,CAACE,MAAM,KAAKN,SAAS,EAAE;sBAC7CH,kBAAkB,IAAII,WAAW,CAACG,SAAS,CAAC,CAAC/C,KAAK,CAACpG,MAAM;sBACzD6I,uBAAuB,IAAI,CAAC;sBAC5BC,cAAc,CAAClH,IAAI,CAACoH,WAAW,CAACG,SAAS,CAAC,CAAC;oBAC/C;kBACJ;gBACJ,CAAC,MACI;kBACDP,kBAAkB,IAAIG,SAAS,CAAC3C,KAAK,CAACpG,MAAM;kBAC5C6I,uBAAuB,IAAI,CAAC;kBAC5BC,cAAc,CAAClH,IAAI,CAACmH,SAAS,CAAC;gBAClC;cACJ;cACA,MAAMO,aAAa,GAAG,CAACV,kBAAkB,GAAG,CAAC,IAAI,IAAI,CAACrK,cAAc;cACpE;cACA,IAAI8B,IAAI,CAACgD,KAAK,GAAGiG,aAAa,GAAG,CAAC,GAAG,IAAI,CAAC/K,cAAc,EAAE;gBACtD6E,SAAS,IAAI,IAAI,CAAC7E,cAAc;gBAChCiF,UAAU,IAAI,IAAI,CAACjF,cAAc;cACrC;cACA,MAAMgL,cAAc,GAAG/F,UAAU,GAAGJ,SAAS;cAC7C,MAAMoG,WAAW,GAAGD,cAAc,GAAGX,kBAAkB;cACvD,IAAIrB,QAAQ,GAAGnE,SAAS,GAAGoG,WAAW,GAAG,GAAG;cAC5C,IAAIC,cAAc,GAAG,IAAI,CAAChL,YAAY,GAAG,IAAI,CAACD,eAAe;cAC7D,IAAIkL,UAAU,GAAG,CAAC;cAClB,KAAK,IAAI3J,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+I,cAAc,CAAC9I,MAAM,EAAED,CAAC,EAAE,EAAE;gBAC5C,MAAM4J,cAAc,GAAGb,cAAc,CAAC/I,CAAC,CAAC,CAACqG,KAAK,CAACpG,MAAM;gBACrD,MAAMrB,cAAc,GAAG,IAAI,CAACA,cAAc;gBAC1C,IAAIiL,GAAG,GAAGjL,cAAc,CAACmK,cAAc,CAAC/I,CAAC,CAAC,CAAC8J,GAAG,CAAC,CAAC,CAAC,CAAC;gBAClD,IAAID,GAAG,IAAI,IAAI,EAAE;kBACbA,GAAG,GAAG,EAAE;kBACRjL,cAAc,CAACmK,cAAc,CAAC/I,CAAC,CAAC,CAAC8J,GAAG,CAAC,CAAC,CAAC,CAAC,GAAGD,GAAG;gBAClD;gBACA,IAAI7J,CAAC,GAAG6I,kBAAkB,GAAG,CAAC,EAAE;kBAC5Ba,cAAc,IAAI,IAAI,CAACjL,eAAe;gBAC1C,CAAC,MACI,IAAIuB,CAAC,GAAG6I,kBAAkB,GAAG,CAAC,EAAE;kBACjCa,cAAc,IAAI,IAAI,CAACjL,eAAe;gBAC1C;gBACA;gBACA;gBACA,KAAK,IAAIsL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,cAAc,EAAEG,CAAC,IAAI,CAAC,EAAE;kBACxCF,GAAG,CAACE,CAAC,GAAG,CAAC,GAAG1J,CAAC,GAAG,CAAC,CAAC,GAAGmH,QAAQ;kBAC7BA,QAAQ,IAAIiC,WAAW;kBACvBI,GAAG,CAACE,CAAC,GAAG,CAAC,GAAG1J,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGqJ,cAAc;gBAC3C;gBACAC,UAAU,GAAGxE,IAAI,CAACgB,GAAG,CAACwD,UAAU,EAAED,cAAc,CAAC;cACrD;YACJ;YACAjB,YAAY,GAAGnI,IAAI,CAACkC,0BAA0B,CAACb,SAAS,CAAC;YACzD+G,WAAW,GAAG/G,SAAS,GAAG,CAAC;UAC/B;QACJ;MACJ;IACJ;EACJ;EACA;AACJ;AACA;EACI4G,eAAeA,CAACjI,IAAI,EAAE;IAClB;IACA;IACA,IAAI0J,OAAO,GAAG,CAAC;IACf;IACA,IAAI1J,IAAI,CAAC2J,IAAI,CAAC,CAAC,CAAC,KAAK,MAAM,EAAE;MACzB,IAAI;QAAEzI;MAAQ,CAAC,GAAGlB,IAAI;MACtB,IAAI;QAAEyG;MAAQ,CAAC,GAAGzG,IAAI;MACtB,IAAIkB,OAAO,KAAKuF,OAAO,EAAE;QACrBvF,OAAO,GAAGlB,IAAI,CAAC+I,MAAM,CAAC7H,OAAO;QAC7BuF,OAAO,GAAGzG,IAAI,CAACgJ,MAAM,CAACvC,OAAO;MACjC;MACA,IAAImD,iBAAiB,GAAG,CAAC;MACzB,MAAMtL,cAAc,GAAG,IAAI,CAACA,cAAc;MAC1C,MAAMuL,MAAM,GAAGvL,cAAc,CAAC0B,IAAI,CAACwJ,GAAG,CAAC,CAAC,CAAC,CAAC;MAC1C,MAAMT,MAAM,GAAG/I,IAAI,CAAC8J,UAAU,GACxB9J,IAAI,CAACgJ,MAAM,CAAChJ,IAAI,GAChBA,IAAI,CAAC+I,MAAM,CAAC/I,IAAI;MACtB,MAAM;QAAEqF;MAAM,CAAC,GAAG,IAAI,CAAC1H,MAAM;MAC7B,MAAMoM,cAAc,GAAG,IAAI,CAACjM,WAAW,KAAKX,SAAS,CAAC6M,IAAI,IAAI,IAAI,CAAClM,WAAW,KAAKX,SAAS,CAACwI,KAAK;MAClG,KAAK,IAAIlF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,IAAI,CAAC+F,KAAK,CAACpG,MAAM,EAAEc,CAAC,IAAI,CAAC,EAAE;QAC3C,MAAMwJ,QAAQ,GAAGjK,IAAI,CAAC+F,KAAK,CAACtF,CAAC,CAAC;QAC9B,MAAMyJ,UAAU,GAAG,IAAI,CAACvM,MAAM,CAACwM,kBAAkB,CAACF,QAAQ,EAAE,IAAI,CAAC;QACjE;QACA,MAAMG,SAAS,GAAG,EAAE;QACpB;QACA;QACA;QACA,IAAIC,QAAQ,GAAGrK,IAAI,CAAC8J,UAAU;QAC9B,IAAII,UAAU,KAAKnB,MAAM,EAAE;UACvB;UACA;UACA;UACA;UACAsB,QAAQ,GAAG,CAACA,QAAQ;QACxB;QACA;QACA,IAAIR,MAAM,IAAI,IAAI,EAAE;UAChB,MAAMS,WAAW,GAAGD,QAAQ,GAAG,CAAC,GAAG,CAAC;UACpC,MAAMzL,WAAW,GAAG,IAAI,CAACA,WAAW;UACpC,MAAMD,QAAQ,GAAG,IAAI,CAACA,QAAQ;UAC9B,IAAIsH,CAAC,GAAGoE,QAAQ,GACVN,cAAc,GACVnL,WAAW,CAAC6H,OAAO,CAAC,GACpB9H,QAAQ,CAAC8H,OAAO,CAAC,GACrBsD,cAAc,GACVpL,QAAQ,CAACuC,OAAO,CAAC,GACjBtC,WAAW,CAACsC,OAAO,CAAC;UAC9B,IAAIqJ,KAAK,GAAGV,MAAM,CAACD,iBAAiB,GAAG,CAAC,GAAG,CAAC,GAAGU,WAAW,CAAC;UAC3D,IAAID,QAAQ,KAAKN,cAAc,EAAE;YAC7BQ,KAAK,GAAG,CAACA,KAAK;UAClB;UACAtE,CAAC,IAAIsE,KAAK;UACV,IAAI1D,CAAC,GAAGgD,MAAM,CAACD,iBAAiB,GAAG,CAAC,GAAGU,WAAW,CAAC;UACnD,MAAME,WAAW,GAAGP,QAAQ,CAACQ,WAAW,CAAC,IAAI,CAAC;UAC9C,IAAI,IAAI,CAAC9M,MAAM,CAAC+M,MAAM,CAACF,WAAW,CAAC,IAAIA,WAAW,CAACG,SAAS,CAAC,CAAC,KAAKT,UAAU,EAAE;YAC3E,MAAMU,KAAK,GAAGvF,KAAK,CAACwF,IAAI,CAACC,QAAQ,CAACN,WAAW,CAAC;YAC9C,IAAII,KAAK,IAAI,IAAI,EAAE;cACf/D,CAAC,GAAG+D,KAAK,CAAC/D,CAAC;YACf,CAAC,MACI;cACDA,CAAC,GACGqD,UAAU,CAACa,QAAQ,CAAClE,CAAC,GACjB7G,IAAI,CAAC+I,MAAM,CAAC/F,KAAK,GACbwH,WAAW,CAACO,QAAQ,CAAClE,CAAC;YACtC;UACJ;UACA,IAAI,IAAI,CAAC/I,WAAW,KAAKX,SAAS,CAACoB,KAAK,IACpC,IAAI,CAACT,WAAW,KAAKX,SAAS,CAACwI,KAAK,EAAE;YACtCyE,SAAS,CAAC7I,IAAI,CAAC,IAAIhE,KAAK,CAACsJ,CAAC,EAAEZ,CAAC,CAAC,CAAC;YAC/B,IAAI,IAAI,CAACtI,MAAM,CAACiK,SAAS,KAAKpK,qBAAqB,CAACuK,KAAK,EAAE;cACvDqC,SAAS,CAAC7I,IAAI,CAAC,IAAIhE,KAAK,CAACsJ,CAAC,EAAEZ,CAAC,GAAGsE,KAAK,CAAC,CAAC;YAC3C;UACJ,CAAC,MACI;YACDH,SAAS,CAAC7I,IAAI,CAAC,IAAIhE,KAAK,CAAC0I,CAAC,EAAEY,CAAC,CAAC,CAAC;YAC/B,IAAI,IAAI,CAAClJ,MAAM,CAACiK,SAAS,KAAKpK,qBAAqB,CAACuK,KAAK,EAAE;cACvDqC,SAAS,CAAC7I,IAAI,CAAC,IAAIhE,KAAK,CAAC0I,CAAC,GAAGsE,KAAK,EAAE1D,CAAC,CAAC,CAAC;YAC3C;UACJ;QACJ;QACA;QACA;QACA,IAAImE,SAAS,GAAGhL,IAAI,CAAC6G,CAAC,CAAClH,MAAM,GAAG,CAAC;QACjC,IAAIsL,SAAS,GAAG,CAAC,CAAC;QAClB,IAAIC,SAAS,GAAG,CAAC,CAAC;QAClB,IAAI9C,WAAW,GAAGpI,IAAI,CAACkB,OAAO,GAAG,CAAC;QAClC,IAAImJ,QAAQ,EAAE;UACVW,SAAS,GAAG,CAAC;UACbC,SAAS,GAAGjL,IAAI,CAAC6G,CAAC,CAAClH,MAAM;UACzBuL,SAAS,GAAG,CAAC;UACb9C,WAAW,GAAGpI,IAAI,CAACyG,OAAO,GAAG,CAAC;QAClC;QACA;QACA;QACA,KAAK,IAAI/G,CAAC,GAAGsL,SAAS,EAAEhL,IAAI,CAACkB,OAAO,KAAKlB,IAAI,CAACyG,OAAO,IAAI/G,CAAC,KAAKuL,SAAS,EAAEvL,CAAC,IAAIwL,SAAS,EAAE;UACtF;UACA,MAAMC,SAAS,GAAGnL,IAAI,CAAC6G,CAAC,CAACnH,CAAC,CAAC,GAAGgK,OAAO;UACrC;UACA;UACA,MAAM/K,QAAQ,GAAG,IAAI,CAACA,QAAQ;UAC9B,MAAMC,WAAW,GAAG,IAAI,CAACA,WAAW;UACpC,IAAIwM,WAAW,GAAG,CAACzM,QAAQ,CAACyJ,WAAW,CAAC,GAAGxJ,WAAW,CAACwJ,WAAW,GAAG,CAAC,CAAC,IAAI,GAAG;UAC9E,IAAIiD,cAAc,GAAG,CAAC1M,QAAQ,CAACyJ,WAAW,GAAG,CAAC,CAAC,GAAGxJ,WAAW,CAACwJ,WAAW,CAAC,IAAI,GAAG;UACjF,IAAIiC,QAAQ,EAAE;YACV,MAAMiB,GAAG,GAAGF,WAAW;YACvBA,WAAW,GAAGC,cAAc;YAC5BA,cAAc,GAAGC,GAAG;UACxB;UACA,IAAI,IAAI,CAACxN,WAAW,KAAKX,SAAS,CAACoB,KAAK,IACpC,IAAI,CAACT,WAAW,KAAKX,SAAS,CAACwI,KAAK,EAAE;YACtCyE,SAAS,CAAC7I,IAAI,CAAC,IAAIhE,KAAK,CAAC4N,SAAS,EAAEC,WAAW,CAAC,CAAC;YACjDhB,SAAS,CAAC7I,IAAI,CAAC,IAAIhE,KAAK,CAAC4N,SAAS,EAAEE,cAAc,CAAC,CAAC;UACxD,CAAC,MACI;YACDjB,SAAS,CAAC7I,IAAI,CAAC,IAAIhE,KAAK,CAAC6N,WAAW,EAAED,SAAS,CAAC,CAAC;YACjDf,SAAS,CAAC7I,IAAI,CAAC,IAAIhE,KAAK,CAAC8N,cAAc,EAAEF,SAAS,CAAC,CAAC;UACxD;UACA,IAAI,CAAC3M,MAAM,GAAGqG,IAAI,CAACgB,GAAG,CAAC,IAAI,CAACrH,MAAM,EAAE2M,SAAS,CAAC;UAC9C/C,WAAW,IAAI8C,SAAS;QAC5B;QACA;QACA,IAAIrB,MAAM,IAAI,IAAI,EAAE;UAChB,MAAMS,WAAW,GAAGD,QAAQ,GAAG,CAAC,GAAG,CAAC;UACpC,MAAM1L,QAAQ,GAAG,IAAI,CAACA,QAAQ;UAC9B,MAAMC,WAAW,GAAG,IAAI,CAACA,WAAW;UACpC,MAAMG,KAAK,GAAGsL,QAAQ,GAChBN,cAAc,GACVpL,QAAQ,CAACuC,OAAO,CAAC,GACjBtC,WAAW,CAACsC,OAAO,CAAC,GACxB6I,cAAc,GACVnL,WAAW,CAAC6H,OAAO,CAAC,GACpB9H,QAAQ,CAAC8H,OAAO,CAAC;UAC3B,IAAI8D,KAAK,GAAGV,MAAM,CAACD,iBAAiB,GAAG,CAAC,GAAG,CAAC,GAAGU,WAAW,CAAC;UAC3D,IAAID,QAAQ,KAAKN,cAAc,EAAE;YAC7BQ,KAAK,GAAG,CAACA,KAAK;UAClB;UACA,MAAMtE,CAAC,GAAGlH,KAAK,GAAGwL,KAAK;UACvB,IAAI1D,CAAC,GAAGgD,MAAM,CAACD,iBAAiB,GAAG,CAAC,GAAG,CAAC,GAAGU,WAAW,CAAC;UACvD,MAAMiB,WAAW,GAAGtB,QAAQ,CAACQ,WAAW,CAAC,KAAK,CAAC;UAC/C,MAAMe,UAAU,GAAG,IAAI,CAAC7N,MAAM,CAACwM,kBAAkB,CAACF,QAAQ,EAAE,KAAK,CAAC;UAClE,IAAI,IAAI,CAACtM,MAAM,CAAC+M,MAAM,CAACa,WAAW,CAAC,IAAIA,WAAW,CAACZ,SAAS,CAAC,CAAC,KAAKa,UAAU,EAAE;YAC3E,MAAMZ,KAAK,GAAGvF,KAAK,CAACwF,IAAI,CAACC,QAAQ,CAACS,WAAW,CAAC;YAC9C,IAAIX,KAAK,IAAI,IAAI,EAAE;cACf/D,CAAC,GAAG+D,KAAK,CAAC/D,CAAC;YACf,CAAC,MACI;cACDA,CAAC,GACG2E,UAAU,CAACT,QAAQ,CAAClE,CAAC,GACjB7G,IAAI,CAACgJ,MAAM,CAAChG,KAAK,GACbuI,WAAW,CAACR,QAAQ,CAAClE,CAAC;YACtC;UACJ;UACA,IAAI,IAAI,CAAC/I,WAAW,KAAKX,SAAS,CAACoB,KAAK,IACpC,IAAI,CAACT,WAAW,KAAKX,SAAS,CAACwI,KAAK,EAAE;YACtC,IAAI,IAAI,CAAChI,MAAM,CAACiK,SAAS,KAAKpK,qBAAqB,CAACuK,KAAK,EAAE;cACvDqC,SAAS,CAAC7I,IAAI,CAAC,IAAIhE,KAAK,CAACsJ,CAAC,EAAEZ,CAAC,GAAGsE,KAAK,CAAC,CAAC;YAC3C;YACAH,SAAS,CAAC7I,IAAI,CAAC,IAAIhE,KAAK,CAACsJ,CAAC,EAAEZ,CAAC,CAAC,CAAC;UACnC,CAAC,MACI;YACD,IAAI,IAAI,CAACtI,MAAM,CAACiK,SAAS,KAAKpK,qBAAqB,CAACuK,KAAK,EAAE;cACvDqC,SAAS,CAAC7I,IAAI,CAAC,IAAIhE,KAAK,CAAC0I,CAAC,GAAGsE,KAAK,EAAE1D,CAAC,CAAC,CAAC;YAC3C;YACAuD,SAAS,CAAC7I,IAAI,CAAC,IAAIhE,KAAK,CAAC0I,CAAC,EAAEY,CAAC,CAAC,CAAC;UACnC;QACJ;QACA,IAAI7G,IAAI,CAAC8J,UAAU,EAAE;UACjB,IAAI,CAAC2B,mBAAmB,CAACzL,IAAI,EAAEiK,QAAQ,CAAC;QAC5C;QACA,IAAI,CAACtM,MAAM,CAAC+N,aAAa,CAACzB,QAAQ,EAAEG,SAAS,CAAC;QAC9C;QACA;QACA,IAAIV,OAAO,KAAK,GAAG,EAAE;UACjBA,OAAO,GAAG,IAAI,CAAC1L,mBAAmB;QACtC,CAAC,MACI,IAAI0L,OAAO,GAAG,CAAC,EAAE;UAClBA,OAAO,GAAG,CAACA,OAAO;QACtB,CAAC,MACI;UACDA,OAAO,GAAG,CAACA,OAAO,GAAG,IAAI,CAAC1L,mBAAmB;QACjD;QACA4L,iBAAiB,EAAE;MACvB;MACA5J,IAAI,CAAC2J,IAAI,CAAC,CAAC,CAAC,GAAG,MAAM;IACzB;EACJ;EACA;AACJ;AACA;AACA;AACA;EACIhC,iBAAiBA,CAAC3H,IAAI,EAAE;IACpB,MAAM2L,QAAQ,GAAG3L,IAAI,CAACA,IAAI;IAC1B,MAAMmL,SAAS,GAAGnL,IAAI,CAAC6G,CAAC,CAAC,CAAC,CAAC,GAAG7G,IAAI,CAACgD,KAAK,GAAG,CAAC;IAC5C,MAAM4I,SAAS,GAAG5L,IAAI,CAACiG,CAAC,CAAC,CAAC,CAAC,GAAGjG,IAAI,CAAC4F,MAAM,GAAG,CAAC;IAC7C,MAAMjH,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC9B,MAAMC,WAAW,GAAG,IAAI,CAACA,WAAW;IACpCD,QAAQ,CAACqB,IAAI,CAACyG,OAAO,CAAC,GAAG5B,IAAI,CAACgH,GAAG,CAAClN,QAAQ,CAACqB,IAAI,CAACyG,OAAO,CAAC,EAAEmF,SAAS,CAAC;IACpEhN,WAAW,CAACoB,IAAI,CAACyG,OAAO,CAAC,GAAG5B,IAAI,CAACgB,GAAG,CAACjH,WAAW,CAACoB,IAAI,CAACyG,OAAO,CAAC,EAAEmF,SAAS,GAAG5L,IAAI,CAAC4F,MAAM,CAAC;IACxF,IAAI,IAAI,CAAC9H,WAAW,KAAKX,SAAS,CAACoB,KAAK,IAAI,IAAI,CAACT,WAAW,KAAKX,SAAS,CAACwI,KAAK,EAAE;MAC9E,IAAI,CAAChI,MAAM,CAACgK,iBAAiB,CAACgE,QAAQ,EAAER,SAAS,EAAES,SAAS,CAAC;IACjE,CAAC,MACI;MACD,IAAI,CAACjO,MAAM,CAACgK,iBAAiB,CAACgE,QAAQ,EAAEC,SAAS,EAAET,SAAS,CAAC;IACjE;IACA,IAAI,CAAC3M,MAAM,GAAGqG,IAAI,CAACgB,GAAG,CAAC,IAAI,CAACrH,MAAM,EAAE2M,SAAS,GAAGnL,IAAI,CAACgD,KAAK,CAAC;EAC/D;EACA;AACJ;AACA;AACA;AACA;AACA;EACIyI,mBAAmBA,CAACK,IAAI,EAAE7B,QAAQ,EAAE;IAChC;EAAA;AAER;AACA,eAAexM,oBAAoB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}