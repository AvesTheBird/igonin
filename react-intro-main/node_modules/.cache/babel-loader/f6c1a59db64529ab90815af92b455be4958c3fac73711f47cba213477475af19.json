{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * Implements a mechanism for temporary cell Ids.\n * @class CellPath\n */\nclass CellPath {\n  constructor() {\n    throw new Error(\"Static class can't be instantiated!\");\n  }\n  /**\n   * Creates the cell path for the given cell. The cell path is a\n   * concatenation of the indices of all ancestors on the (finite) path to\n   * the root, eg. \"0.0.0.1\".\n   *\n   * @param cell Cell whose path should be returned.\n   */\n  static create(cell) {\n    let result = '';\n    let parent = cell.getParent();\n    while (parent) {\n      const index = parent.getIndex(cell);\n      result = index + CellPath.PATH_SEPARATOR + result;\n      cell = parent;\n      parent = cell.getParent();\n    }\n    // Remove trailing separator\n    const n = result.length;\n    if (n > 1) {\n      result = result.substring(0, n - 1);\n    }\n    return result;\n  }\n  /**\n   * Returns the path for the parent of the cell represented by the given\n   * path. Returns null if the given path has no parent.\n   *\n   * @param path Path whose parent path should be returned.\n   */\n  static getParentPath(path) {\n    const index = path.lastIndexOf(CellPath.PATH_SEPARATOR);\n    if (index >= 0) {\n      return path.substring(0, index);\n    }\n    if (path.length > 0) {\n      return '';\n    }\n    return null;\n  }\n  /**\n   * Returns the cell for the specified cell path using the given root as the\n   * root of the path.\n   *\n   * @param root Root cell of the path to be resolved.\n   * @param path String that defines the path.\n   */\n  static resolve(root, path) {\n    let parent = root;\n    const tokens = path.split(CellPath.PATH_SEPARATOR);\n    for (let i = 0; i < tokens.length; i += 1) {\n      parent = parent.getChildAt(parseInt(tokens[i]));\n    }\n    return parent;\n  }\n  /**\n   * Compares the given cell paths and returns -1 if p1 is smaller, 0 if\n   * p1 is equal and 1 if p1 is greater than p2.\n   */\n  static compare(p1, p2) {\n    const min = Math.min(p1.length, p2.length);\n    let comp = 0;\n    for (let i = 0; i < min; i += 1) {\n      if (p1[i] !== p2[i]) {\n        if (p1[i].length === 0 || p2[i].length === 0) {\n          comp = p1[i] === p2[i] ? 0 : p1[i] > p2[i] ? 1 : -1;\n        } else {\n          const t1 = parseInt(p1[i]);\n          const t2 = parseInt(p2[i]);\n          comp = t1 === t2 ? 0 : t1 > t2 ? 1 : -1;\n        }\n        break;\n      }\n    }\n    // Compares path length if both paths are equal to this point\n    if (comp === 0) {\n      const t1 = p1.length;\n      const t2 = p2.length;\n      if (t1 !== t2) {\n        comp = t1 > t2 ? 1 : -1;\n      }\n    }\n    return comp;\n  }\n}\n/**\n * Defines the separator between the path components. Default is \".\".\n */\nCellPath.PATH_SEPARATOR = '.';\nexport default CellPath;","map":{"version":3,"names":["CellPath","constructor","Error","create","cell","result","parent","getParent","index","getIndex","PATH_SEPARATOR","n","length","substring","getParentPath","path","lastIndexOf","resolve","root","tokens","split","i","getChildAt","parseInt","compare","p1","p2","min","Math","comp","t1","t2"],"sources":["D:/OSPanel/domains/react/react-intro-main/node_modules/@maxgraph/core/dist/view/cell/CellPath.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * Implements a mechanism for temporary cell Ids.\n * @class CellPath\n */\nclass CellPath {\n    constructor() {\n        throw new Error(\"Static class can't be instantiated!\");\n    }\n    /**\n     * Creates the cell path for the given cell. The cell path is a\n     * concatenation of the indices of all ancestors on the (finite) path to\n     * the root, eg. \"0.0.0.1\".\n     *\n     * @param cell Cell whose path should be returned.\n     */\n    static create(cell) {\n        let result = '';\n        let parent = cell.getParent();\n        while (parent) {\n            const index = parent.getIndex(cell);\n            result = index + CellPath.PATH_SEPARATOR + result;\n            cell = parent;\n            parent = cell.getParent();\n        }\n        // Remove trailing separator\n        const n = result.length;\n        if (n > 1) {\n            result = result.substring(0, n - 1);\n        }\n        return result;\n    }\n    /**\n     * Returns the path for the parent of the cell represented by the given\n     * path. Returns null if the given path has no parent.\n     *\n     * @param path Path whose parent path should be returned.\n     */\n    static getParentPath(path) {\n        const index = path.lastIndexOf(CellPath.PATH_SEPARATOR);\n        if (index >= 0) {\n            return path.substring(0, index);\n        }\n        if (path.length > 0) {\n            return '';\n        }\n        return null;\n    }\n    /**\n     * Returns the cell for the specified cell path using the given root as the\n     * root of the path.\n     *\n     * @param root Root cell of the path to be resolved.\n     * @param path String that defines the path.\n     */\n    static resolve(root, path) {\n        let parent = root;\n        const tokens = path.split(CellPath.PATH_SEPARATOR);\n        for (let i = 0; i < tokens.length; i += 1) {\n            parent = parent.getChildAt(parseInt(tokens[i]));\n        }\n        return parent;\n    }\n    /**\n     * Compares the given cell paths and returns -1 if p1 is smaller, 0 if\n     * p1 is equal and 1 if p1 is greater than p2.\n     */\n    static compare(p1, p2) {\n        const min = Math.min(p1.length, p2.length);\n        let comp = 0;\n        for (let i = 0; i < min; i += 1) {\n            if (p1[i] !== p2[i]) {\n                if (p1[i].length === 0 || p2[i].length === 0) {\n                    comp = p1[i] === p2[i] ? 0 : p1[i] > p2[i] ? 1 : -1;\n                }\n                else {\n                    const t1 = parseInt(p1[i]);\n                    const t2 = parseInt(p2[i]);\n                    comp = t1 === t2 ? 0 : t1 > t2 ? 1 : -1;\n                }\n                break;\n            }\n        }\n        // Compares path length if both paths are equal to this point\n        if (comp === 0) {\n            const t1 = p1.length;\n            const t2 = p2.length;\n            if (t1 !== t2) {\n                comp = t1 > t2 ? 1 : -1;\n            }\n        }\n        return comp;\n    }\n}\n/**\n * Defines the separator between the path components. Default is \".\".\n */\nCellPath.PATH_SEPARATOR = '.';\nexport default CellPath;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}