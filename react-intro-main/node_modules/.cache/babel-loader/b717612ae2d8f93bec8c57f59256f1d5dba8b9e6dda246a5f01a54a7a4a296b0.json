{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport CellMarker from '../cell/CellMarker';\nimport Point from '../geometry/Point';\nimport { CONNECT_HANDLE_FILLCOLOR, CURSOR, DEFAULT_HOTSPOT, DEFAULT_INVALID_COLOR, DEFAULT_VALID_COLOR, DIALECT, EDGE_SELECTION_COLOR, EDGE_SELECTION_DASHED, EDGE_SELECTION_STROKEWIDTH, HANDLE_FILLCOLOR, HANDLE_SIZE, HANDLE_STROKECOLOR, HIGHLIGHT_STROKEWIDTH, LABEL_HANDLE_FILLCOLOR, LABEL_HANDLE_SIZE, LOCKED_HANDLE_FILLCOLOR, NONE, OUTLINE_HIGHLIGHT_COLOR, OUTLINE_HIGHLIGHT_STROKEWIDTH } from '../../util/Constants';\nimport { contains, findNearestSegment, intersects, ptSegDistSq } from '../../util/mathUtils';\nimport { convertPoint, getOffset, setOpacity } from '../../util/styleUtils';\nimport ImageShape from '../geometry/node/ImageShape';\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport ConnectionConstraint from '../other/ConnectionConstraint';\nimport InternalEvent from '../event/InternalEvent';\nimport ConstraintHandler from './ConstraintHandler';\nimport Rectangle from '../geometry/Rectangle';\nimport Client from '../../Client';\nimport EdgeStyle from '../style/EdgeStyle';\nimport { getClientX, getClientY, isAltDown, isMouseEvent, isShiftDown } from '../../util/EventUtils';\nimport { equalPoints } from '../../util/arrayUtils';\n/**\n * Graph event handler that reconnects edges and modifies control points and the edge\n * label location.\n * Uses {@link CellMarker} for finding and highlighting new source and target vertices.\n * This handler is automatically created in mxGraph.createHandler for each selected edge.\n * **To enable adding/removing control points, the following code can be used**\n * @example\n * ```\n * mxEdgeHandler.prototype.addEnabled = true;\n * mxEdgeHandler.prototype.removeEnabled = true;\n * ```\n * Note: This experimental feature is not recommended for production use.\n * @class EdgeHandler\n */\nclass EdgeHandler {\n  constructor(state) {\n    /**\n     * Holds the current validation error while a connection is being changed.\n     */\n    this.error = null;\n    /**\n     * Holds the {@link Shapes} that represent the points.\n     */\n    this.bends = [];\n    /**\n     * Specifies if cloning by control-drag is enabled. Default is true.\n     */\n    this.cloneEnabled = true;\n    /**\n     * Specifies if adding bends by shift-click is enabled. Default is false.\n     * Note: This experimental feature is not recommended for production use.\n     */\n    this.addEnabled = false;\n    /**\n     * Specifies if removing bends by shift-click is enabled. Default is false.\n     * Note: This experimental feature is not recommended for production use.\n     */\n    this.removeEnabled = false;\n    /**\n     * Specifies if removing bends by double click is enabled. Default is false.\n     */\n    this.dblClickRemoveEnabled = false;\n    /**\n     * Specifies if removing bends by dropping them on other bends is enabled.\n     * Default is false.\n     */\n    this.mergeRemoveEnabled = false;\n    /**\n     * Specifies if removing bends by creating straight segments should be enabled.\n     * If enabled, this can be overridden by holding down the alt key while moving.\n     * Default is false.\n     */\n    this.straightRemoveEnabled = false;\n    /**\n     * Specifies if virtual bends should be added in the center of each\n     * segments. These bends can then be used to add new waypoints.\n     * Default is false.\n     */\n    this.virtualBendsEnabled = false;\n    /**\n     * Opacity to be used for virtual bends (see <virtualBendsEnabled>).\n     * Default is 20.\n     */\n    this.virtualBendOpacity = 20;\n    /**\n     * Specifies if the parent should be highlighted if a child cell is selected.\n     * Default is false.\n     */\n    this.parentHighlightEnabled = false;\n    /**\n     * Specifies if bends should be added to the graph container. This is updated\n     * in <init> based on whether the edge or one of its terminals has an HTML\n     * label in the container.\n     */\n    this.preferHtml = false;\n    /**\n     * Specifies if the bounds of handles should be used for hit-detection in IE\n     * Default is true.\n     */\n    this.allowHandleBoundsCheck = true;\n    /**\n     * Specifies if waypoints should snap to the routing centers of terminals.\n     * Default is false.\n     */\n    this.snapToTerminals = false;\n    /**\n     * Optional {@link Image} to be used as handles. Default is null.\n     */\n    this.handleImage = null;\n    this.labelHandleImage = null;\n    /**\n     * Optional tolerance for hit-detection in <getHandleForEvent>. Default is 0.\n     */\n    // tolerance: number;\n    this.tolerance = 0;\n    /**\n     * Specifies if connections to the outline of a highlighted target should be\n     * enabled. This will allow to place the connection point along the outline of\n     * the highlighted target. Default is false.\n     */\n    // outlineConnect: boolean;\n    this.outlineConnect = false;\n    /**\n     * Specifies if the label handle should be moved if it intersects with another\n     * handle. Uses <checkLabelHandle> for checking and moving. Default is false.\n     */\n    // manageLabelHandle: boolean;\n    this.manageLabelHandle = false;\n    this.currentPoint = null;\n    this.parentHighlight = null;\n    this.index = null;\n    this.isSource = false;\n    this.isTarget = false;\n    this.isLabel = false;\n    this.points = [];\n    this.snapPoint = null;\n    this.abspoints = [];\n    this.startX = 0;\n    this.startY = 0;\n    this.outline = true;\n    this.active = true;\n    // `state.shape` must exists.\n    this.state = state;\n    this.graph = this.state.view.graph;\n    this.marker = this.createMarker();\n    this.constraintHandler = new ConstraintHandler(this.graph);\n    // Clones the original points from the cell\n    // and makes sure at least one point exists\n    this.points = [];\n    // Uses the absolute points of the state\n    // for the initial configuration and preview\n    this.abspoints = this.getSelectionPoints(this.state);\n    this.shape = this.createSelectionShape(this.abspoints);\n    this.shape.dialect = this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;\n    this.shape.init(this.graph.getView().getOverlayPane());\n    this.shape.pointerEvents = false;\n    this.shape.setCursor(CURSOR.MOVABLE_EDGE);\n    InternalEvent.redirectMouseEvents(this.shape.node, this.graph, this.state);\n    // Updates preferHtml\n    this.preferHtml = this.state.text != null && this.state.text.node.parentNode === this.graph.container;\n    if (!this.preferHtml) {\n      // Checks source terminal\n      const sourceState = this.state.getVisibleTerminalState(true);\n      if (sourceState != null) {\n        this.preferHtml = sourceState.text != null && sourceState.text.node.parentNode === this.graph.container;\n      }\n      if (!this.preferHtml) {\n        // Checks target terminal\n        const targetState = this.state.getVisibleTerminalState(false);\n        if (targetState != null) {\n          this.preferHtml = targetState.text != null && targetState.text.node.parentNode === this.graph.container;\n        }\n      }\n    }\n    const selectionHandler = this.graph.getPlugin('SelectionHandler');\n    // Creates bends for the non-routed absolute points\n    // or bends that don't correspond to points\n    if (selectionHandler && (this.graph.getSelectionCount() < selectionHandler.maxCells || selectionHandler.maxCells <= 0)) {\n      this.bends = this.createBends();\n      if (this.isVirtualBendsEnabled()) {\n        this.virtualBends = this.createVirtualBends();\n      }\n    }\n    // Adds a rectangular handle for the label position\n    this.label = new Point(this.state.absoluteOffset.x, this.state.absoluteOffset.y);\n    this.labelShape = this.createLabelHandleShape();\n    this.initBend(this.labelShape);\n    this.labelShape.setCursor(CURSOR.LABEL_HANDLE);\n    this.customHandles = this.createCustomHandles();\n    this.updateParentHighlight();\n    this.redraw();\n    // Handles escape keystrokes\n    this.escapeHandler = (sender, evt) => {\n      const dirty = this.index != null;\n      this.reset();\n      if (dirty) {\n        this.graph.cellRenderer.redraw(this.state, false, state.view.isRendering());\n      }\n    };\n    this.state.view.graph.addListener(InternalEvent.ESCAPE, this.escapeHandler);\n  }\n  /**\n   * Returns true if the parent highlight should be visible. This implementation\n   * always returns true.\n   */\n  isParentHighlightVisible() {\n    const parent = this.state.cell.getParent();\n    return parent ? !this.graph.isCellSelected(parent) : null;\n  }\n  /**\n   * Updates the highlight of the parent if <parentHighlightEnabled> is true.\n   */\n  updateParentHighlight() {\n    if (!this.isDestroyed()) {\n      const visible = this.isParentHighlightVisible();\n      const parent = this.state.cell.getParent();\n      const pstate = parent ? this.graph.view.getState(parent) : null;\n      if (this.parentHighlight) {\n        if (parent && parent.isVertex() && visible) {\n          const b = this.parentHighlight.bounds;\n          if (pstate && b && (b.x !== pstate.x || b.y !== pstate.y || b.width !== pstate.width || b.height !== pstate.height)) {\n            this.parentHighlight.bounds = Rectangle.fromRectangle(pstate);\n            this.parentHighlight.redraw();\n          }\n        } else {\n          if (pstate && pstate.parentHighlight === this.parentHighlight) {\n            pstate.parentHighlight = null;\n          }\n          this.parentHighlight.destroy();\n          this.parentHighlight = null;\n        }\n      } else if (this.parentHighlightEnabled && visible) {\n        if (parent && parent.isVertex() && pstate && !pstate.parentHighlight) {\n          this.parentHighlight = this.createParentHighlightShape(pstate);\n          // VML dialect required here for event transparency in IE\n          this.parentHighlight.dialect = DIALECT.SVG;\n          this.parentHighlight.pointerEvents = false;\n          if (pstate.style.rotation) {\n            this.parentHighlight.rotation = pstate.style.rotation;\n          }\n          this.parentHighlight.init(this.graph.getView().getOverlayPane());\n          this.parentHighlight.redraw();\n          // Shows highlight once per parent\n          pstate.parentHighlight = this.parentHighlight;\n        }\n      }\n    }\n  }\n  /**\n   * Returns an array of custom handles. This implementation returns an empty array.\n   */\n  createCustomHandles() {\n    return [];\n  }\n  /**\n   * Returns true if virtual bends should be added. This returns true if\n   * <virtualBendsEnabled> is true and the current style allows and\n   * renders custom waypoints.\n   */\n  isVirtualBendsEnabled(evt) {\n    return this.virtualBendsEnabled && (this.state.style.edgeStyle == null || this.state.style.edgeStyle === NONE || this.state.style.noEdgeStyle) && this.state.style.shape !== 'arrow';\n  }\n  /**\n   * Returns true if the given cell allows new connections to be created. This implementation\n   * always returns true.\n   */\n  isCellEnabled(cell) {\n    return true;\n  }\n  /**\n   * Returns true if the given event is a trigger to add a new Point. This\n   * implementation returns true if shift is pressed.\n   */\n  isAddPointEvent(evt) {\n    return isShiftDown(evt);\n  }\n  /**\n   * Returns true if the given event is a trigger to remove a point. This\n   * implementation returns true if shift is pressed.\n   */\n  isRemovePointEvent(evt) {\n    return isShiftDown(evt);\n  }\n  /**\n   * Returns the list of points that defines the selection stroke.\n   */\n  getSelectionPoints(state) {\n    return state.absolutePoints;\n  }\n  /**\n   * Creates the shape used to draw the selection border.\n   */\n  createParentHighlightShape(bounds) {\n    const shape = new RectangleShape(Rectangle.fromRectangle(bounds), NONE, this.getSelectionColor());\n    shape.strokeWidth = this.getSelectionStrokeWidth();\n    shape.isDashed = this.isSelectionDashed();\n    return shape;\n  }\n  /**\n   * Creates the shape used to draw the selection border.\n   */\n  createSelectionShape(points) {\n    const c = this.state.shape.constructor;\n    const shape = new c();\n    shape.outline = true;\n    shape.apply(this.state);\n    shape.isDashed = this.isSelectionDashed();\n    shape.stroke = this.getSelectionColor();\n    shape.isShadow = false;\n    return shape;\n  }\n  /**\n   * Returns {@link EDGE_SELECTION_COLOR}.\n   */\n  getSelectionColor() {\n    return EDGE_SELECTION_COLOR;\n  }\n  /**\n   * Returns {@link EDGE_SELECTION_STROKEWIDTH}.\n   */\n  getSelectionStrokeWidth() {\n    return EDGE_SELECTION_STROKEWIDTH;\n  }\n  /**\n   * Returns {@link EDGE_SELECTION_DASHED}.\n   */\n  isSelectionDashed() {\n    return EDGE_SELECTION_DASHED;\n  }\n  /**\n   * Returns true if the given cell is connectable. This is a hook to\n   * disable floating connections. This implementation returns true.\n   */\n  isConnectableCell(cell) {\n    return true;\n  }\n  /**\n   * Creates and returns the {@link CellMarker} used in {@link marker}.\n   */\n  getCellAt(x, y) {\n    return !this.outlineConnect ? this.graph.getCellAt(x, y) : null;\n  }\n  /**\n   * Creates and returns the {@link CellMarker} used in {@link marker}.\n   */\n  createMarker() {\n    return new EdgeHandlerCellMarker(this.graph, this);\n  }\n  /**\n   * Returns the error message or an empty string if the connection for the\n   * given source, target pair is not valid. Otherwise it returns null. This\n   * implementation uses {@link Graph#getEdgeValidationError}.\n   *\n   * @param source <Cell> that represents the source terminal.\n   * @param target <Cell> that represents the target terminal.\n   */\n  validateConnection(source, target) {\n    return this.graph.getEdgeValidationError(this.state.cell, source, target);\n  }\n  /**\n   * Creates and returns the bends used for modifying the edge. This is\n   * typically an array of {@link RectangleShape}.\n   */\n  createBends() {\n    const {\n      cell\n    } = this.state;\n    const bends = [];\n    for (let i = 0; i < this.abspoints.length; i += 1) {\n      if (this.isHandleVisible(i)) {\n        const source = i === 0;\n        const target = i === this.abspoints.length - 1;\n        const terminal = source || target;\n        if (terminal || this.graph.isCellBendable(cell)) {\n          (index => {\n            const bend = this.createHandleShape(index);\n            this.initBend(bend, () => {\n              if (this.dblClickRemoveEnabled) {\n                this.removePoint(this.state, index);\n              }\n            });\n            if (this.isHandleEnabled(i)) {\n              bend.setCursor(terminal ? CURSOR.TERMINAL_HANDLE : CURSOR.BEND_HANDLE);\n            }\n            bends.push(bend);\n            if (!terminal) {\n              this.points.push(new Point(0, 0));\n              bend.node.style.visibility = 'hidden';\n            }\n          })(i);\n        }\n      }\n    }\n    return bends;\n  }\n  /**\n   * Creates and returns the bends used for modifying the edge. This is\n   * typically an array of {@link RectangleShape}.\n   */\n  // createVirtualBends(): mxRectangleShape[];\n  createVirtualBends() {\n    const {\n      cell\n    } = this.state;\n    const last = this.abspoints[0];\n    const bends = [];\n    if (this.graph.isCellBendable(cell)) {\n      for (let i = 1; i < this.abspoints.length; i += 1) {\n        (bend => {\n          this.initBend(bend);\n          bend.setCursor(CURSOR.VIRTUAL_BEND_HANDLE);\n          bends.push(bend);\n        })(this.createHandleShape());\n      }\n    }\n    return bends;\n  }\n  /**\n   * Creates the shape used to display the given bend.\n   */\n  isHandleEnabled(index) {\n    return true;\n  }\n  /**\n   * Returns true if the handle at the given index is visible.\n   */\n  isHandleVisible(index) {\n    const source = this.state.getVisibleTerminalState(true);\n    const target = this.state.getVisibleTerminalState(false);\n    const geo = this.state.cell.getGeometry();\n    const edgeStyle = geo ? this.graph.view.getEdgeStyle(this.state, geo.points || undefined, source, target) : null;\n    return edgeStyle !== EdgeStyle.EntityRelation || index === 0 || index === this.abspoints.length - 1;\n  }\n  /**\n   * Creates the shape used to display the given bend. Note that the index may be\n   * null for special cases, such as when called from\n   * {@link ElbowEdgeHandler#createVirtualBend}. Only images and rectangles should be\n   * returned if support for HTML labels with not foreign objects is required.\n   * Index if null for virtual handles.\n   */\n  createHandleShape(index) {\n    if (this.handleImage) {\n      const shape = new ImageShape(new Rectangle(0, 0, this.handleImage.width, this.handleImage.height), this.handleImage.src);\n      // Allows HTML rendering of the images\n      shape.preserveImageAspect = false;\n      return shape;\n    }\n    let s = HANDLE_SIZE;\n    if (this.preferHtml) {\n      s -= 1;\n    }\n    return new RectangleShape(new Rectangle(0, 0, s, s), HANDLE_FILLCOLOR, HANDLE_STROKECOLOR);\n  }\n  /**\n   * Creates the shape used to display the the label handle.\n   */\n  createLabelHandleShape() {\n    if (this.labelHandleImage) {\n      const shape = new ImageShape(new Rectangle(0, 0, this.labelHandleImage.width, this.labelHandleImage.height), this.labelHandleImage.src);\n      // Allows HTML rendering of the images\n      shape.preserveImageAspect = false;\n      return shape;\n    }\n    const s = LABEL_HANDLE_SIZE;\n    return new RectangleShape(new Rectangle(0, 0, s, s), LABEL_HANDLE_FILLCOLOR, HANDLE_STROKECOLOR);\n  }\n  /**\n   * Helper method to initialize the given bend.\n   *\n   * @param bend {@link Shape} that represents the bend to be initialized.\n   */\n  initBend(bend, dblClick) {\n    if (this.preferHtml) {\n      bend.dialect = DIALECT.STRICTHTML;\n      bend.init(this.graph.container);\n    } else {\n      bend.dialect = this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;\n      bend.init(this.graph.getView().getOverlayPane());\n    }\n    InternalEvent.redirectMouseEvents(bend.node, this.graph, this.state, null, null, null, dblClick);\n    if (Client.IS_TOUCH) {\n      bend.node.setAttribute('pointer-events', 'none');\n    }\n  }\n  /**\n   * Returns the index of the handle for the given event.\n   */\n  getHandleForEvent(me) {\n    let result = null;\n    // Connection highlight may consume events before they reach sizer handle\n    const tol = !isMouseEvent(me.getEvent()) ? this.tolerance : 1;\n    const hit = this.allowHandleBoundsCheck && tol > 0 ? new Rectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;\n    let minDistSq = Number.POSITIVE_INFINITY;\n    function checkShape(shape) {\n      if (shape && shape.bounds && shape.node && shape.node.style.display !== 'none' && shape.node.style.visibility !== 'hidden' && (me.isSource(shape) || hit && intersects(shape.bounds, hit))) {\n        const dx = me.getGraphX() - shape.bounds.getCenterX();\n        const dy = me.getGraphY() - shape.bounds.getCenterY();\n        const tmp = dx * dx + dy * dy;\n        if (tmp <= minDistSq) {\n          minDistSq = tmp;\n          return true;\n        }\n      }\n      return false;\n    }\n    if (this.isCustomHandleEvent(me) && this.customHandles) {\n      // Inverse loop order to match display order\n      for (let i = this.customHandles.length - 1; i >= 0; i--) {\n        if (checkShape(this.customHandles[i].shape)) {\n          // LATER: Return reference to active shape\n          return InternalEvent.CUSTOM_HANDLE - i;\n        }\n      }\n    }\n    if (me.isSource(this.state.text) || checkShape(this.labelShape)) {\n      result = InternalEvent.LABEL_HANDLE;\n    }\n    for (let i = 0; i < this.bends.length; i += 1) {\n      if (checkShape(this.bends[i])) {\n        result = i;\n      }\n    }\n    if (this.virtualBends && this.isAddVirtualBendEvent(me)) {\n      for (let i = 0; i < this.virtualBends.length; i += 1) {\n        if (checkShape(this.virtualBends[i])) {\n          result = InternalEvent.VIRTUAL_HANDLE - i;\n        }\n      }\n    }\n    return result;\n  }\n  /**\n   * Returns true if the given event allows virtual bends to be added. This\n   * implementation returns true.\n   */\n  isAddVirtualBendEvent(me) {\n    return true;\n  }\n  /**\n   * Returns true if the given event allows custom handles to be changed. This\n   * implementation returns true.\n   */\n  isCustomHandleEvent(me) {\n    return true;\n  }\n  /**\n   * Handles the event by checking if a special element of the handler\n   * was clicked, in which case the index parameter is non-null. The\n   * indices may be one of <LABEL_HANDLE> or the number of the respective\n   * control point. The source and target points are used for reconnecting\n   * the edge.\n   */\n  mouseDown(sender, me) {\n    const handle = this.getHandleForEvent(me);\n    if (handle !== null && this.bends[handle]) {\n      const b = this.bends[handle].bounds;\n      if (b) this.snapPoint = new Point(b.getCenterX(), b.getCenterY());\n    }\n    if (this.addEnabled && handle === null && this.isAddPointEvent(me.getEvent())) {\n      this.addPoint(this.state, me.getEvent());\n      me.consume();\n    } else if (handle !== null && !me.isConsumed() && this.graph.isEnabled()) {\n      const cell = me.getCell();\n      if (this.removeEnabled && this.isRemovePointEvent(me.getEvent())) {\n        this.removePoint(this.state, handle);\n      } else if (handle !== InternalEvent.LABEL_HANDLE || cell && this.graph.isLabelMovable(cell)) {\n        if (this.virtualBends && handle <= InternalEvent.VIRTUAL_HANDLE) {\n          setOpacity(this.virtualBends[InternalEvent.VIRTUAL_HANDLE - handle].node, 100);\n        }\n        this.start(me.getX(), me.getY(), handle);\n      }\n      me.consume();\n    }\n  }\n  /**\n   * Starts the handling of the mouse gesture.\n   */\n  start(x, y, index) {\n    this.startX = x;\n    this.startY = y;\n    this.isSource = this.bends.length === 0 ? false : index === 0;\n    this.isTarget = this.bends.length === 0 ? false : index === this.bends.length - 1;\n    this.isLabel = index === InternalEvent.LABEL_HANDLE;\n    if (this.isSource || this.isTarget) {\n      const {\n        cell\n      } = this.state;\n      const terminal = cell.getTerminal(this.isSource);\n      if (terminal == null && this.graph.isTerminalPointMovable(cell, this.isSource) || terminal != null && this.graph.isCellDisconnectable(cell, terminal, this.isSource)) {\n        this.index = index;\n      }\n    } else {\n      this.index = index;\n    }\n    // Hides other custom handles\n    if (this.index !== null && this.index <= InternalEvent.CUSTOM_HANDLE && this.index > InternalEvent.VIRTUAL_HANDLE) {\n      if (this.customHandles != null) {\n        for (let i = 0; i < this.customHandles.length; i += 1) {\n          if (i !== InternalEvent.CUSTOM_HANDLE - this.index) {\n            this.customHandles[i].setVisible(false);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Returns a clone of the current preview state for the given point and terminal.\n   */\n  clonePreviewState(point, terminal) {\n    return this.state.clone();\n  }\n  /**\n   * Returns the tolerance for the guides. Default value is\n   * gridSize * scale / 2.\n   */\n  getSnapToTerminalTolerance() {\n    return this.graph.getGridSize() * this.graph.getView().scale / 2;\n  }\n  /**\n   * Hook for subclassers do show details while the handler is active.\n   */\n  updateHint(me, point) {\n    return;\n  }\n  /**\n   * Hooks for subclassers to hide details when the handler gets inactive.\n   */\n  removeHint() {\n    return;\n  }\n  /**\n   * Hook for rounding the unscaled width or height. This uses Math.round.\n   */\n  roundLength(length) {\n    return Math.round(length);\n  }\n  /**\n   * Returns true if <snapToTerminals> is true and if alt is not pressed.\n   */\n  isSnapToTerminalsEvent(me) {\n    return this.snapToTerminals && !isAltDown(me.getEvent());\n  }\n  /**\n   * Returns the point for the given event.\n   */\n  // getPointForEvent(me: mxMouseEvent): mxPoint;\n  getPointForEvent(me) {\n    const view = this.graph.getView();\n    const {\n      scale\n    } = view;\n    const point = new Point(this.roundLength(me.getGraphX() / scale) * scale, this.roundLength(me.getGraphY() / scale) * scale);\n    const tt = this.getSnapToTerminalTolerance();\n    let overrideX = false;\n    let overrideY = false;\n    if (tt > 0 && this.isSnapToTerminalsEvent(me)) {\n      const snapToPoint = pt => {\n        if (pt) {\n          const {\n            x\n          } = pt;\n          if (Math.abs(point.x - x) < tt) {\n            point.x = x;\n            overrideX = true;\n          }\n          const {\n            y\n          } = pt;\n          if (Math.abs(point.y - y) < tt) {\n            point.y = y;\n            overrideY = true;\n          }\n        }\n      };\n      // Temporary function\n      const snapToTerminal = terminal => {\n        if (terminal) {\n          snapToPoint(new Point(view.getRoutingCenterX(terminal), view.getRoutingCenterY(terminal)));\n        }\n      };\n      snapToTerminal(this.state.getVisibleTerminalState(true));\n      snapToTerminal(this.state.getVisibleTerminalState(false));\n      for (let i = 0; i < this.state.absolutePoints.length; i += 1) {\n        snapToPoint(this.state.absolutePoints[i]);\n      }\n    }\n    if (this.graph.isGridEnabledEvent(me.getEvent())) {\n      const tr = view.translate;\n      if (!overrideX) {\n        point.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;\n      }\n      if (!overrideY) {\n        point.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;\n      }\n    }\n    return point;\n  }\n  /**\n   * Updates the given preview state taking into account the state of the constraint handler.\n   */\n  getPreviewTerminalState(me) {\n    this.constraintHandler.update(me, this.isSource, true, me.isSource(this.marker.highlight.shape) ? null : this.currentPoint);\n    if (this.constraintHandler.currentFocus && this.constraintHandler.currentConstraint) {\n      // Handles special case where grid is large and connection point is at actual point in which\n      // case the outline is not followed as long as we're < gridSize / 2 away from that point\n      if (this.marker.highlight && this.marker.highlight.shape && this.marker.highlight.state && this.marker.highlight.state.cell === this.constraintHandler.currentFocus.cell) {\n        // Direct repaint needed if cell already highlighted\n        if (this.marker.highlight.shape.stroke !== 'transparent') {\n          this.marker.highlight.shape.stroke = 'transparent';\n          this.marker.highlight.repaint();\n        }\n      } else {\n        this.marker.markCell(this.constraintHandler.currentFocus.cell, 'transparent');\n      }\n      const other = this.graph.view.getTerminalPort(this.state, this.graph.view.getState(this.state.cell.getTerminal(!this.isSource)), !this.isSource);\n      const otherCell = other ? other.cell : null;\n      const source = this.isSource ? this.constraintHandler.currentFocus.cell : otherCell;\n      const target = this.isSource ? otherCell : this.constraintHandler.currentFocus.cell;\n      // Updates the error message of the handler\n      this.error = this.validateConnection(source, target);\n      let result = null;\n      if (this.error === null) {\n        result = this.constraintHandler.currentFocus;\n      }\n      if (this.error !== null || result && !this.isCellEnabled(result.cell)) {\n        this.constraintHandler.reset();\n      }\n      return result;\n    }\n    if (!this.graph.isIgnoreTerminalEvent(me.getEvent())) {\n      this.marker.process(me);\n      const state = this.marker.getValidState();\n      if (state && !this.isCellEnabled(state.cell)) {\n        this.constraintHandler.reset();\n        this.marker.reset();\n      }\n      return this.marker.getValidState();\n    }\n    this.marker.reset();\n    return null;\n  }\n  /**\n   * Updates the given preview state taking into account the state of the constraint handler.\n   *\n   * @param pt {@link Point} that contains the current pointer position.\n   * @param me Optional {@link MouseEvent} that contains the current event.\n   */\n  getPreviewPoints(pt, me) {\n    const geometry = this.state.cell.getGeometry();\n    if (!geometry) return null;\n    let points = (geometry.points || []).slice();\n    const point = new Point(pt.x, pt.y);\n    let result = null;\n    if (!this.isSource && !this.isTarget && this.index !== null) {\n      this.convertPoint(point, false);\n      // Adds point from virtual bend\n      if (this.index <= InternalEvent.VIRTUAL_HANDLE) {\n        points.splice(InternalEvent.VIRTUAL_HANDLE - this.index, 0, point);\n      }\n      // Removes point if dragged on terminal point\n      if (!this.isSource && !this.isTarget) {\n        for (let i = 0; i < this.bends.length; i += 1) {\n          if (i !== this.index) {\n            const bend = this.bends[i];\n            if (bend && contains(bend.bounds, pt.x, pt.y)) {\n              if (this.index <= InternalEvent.VIRTUAL_HANDLE) {\n                points.splice(InternalEvent.VIRTUAL_HANDLE - this.index, 1);\n              } else {\n                points.splice(this.index - 1, 1);\n              }\n              result = points;\n            }\n          }\n        }\n        // Removes point if user tries to straighten a segment\n        if (!result && this.straightRemoveEnabled && (!me || !isAltDown(me.getEvent()))) {\n          const tol = this.graph.getEventTolerance() * this.graph.getEventTolerance();\n          const abs = this.state.absolutePoints.slice();\n          abs[this.index] = pt;\n          // Handes special case where removing waypoint affects tolerance (flickering)\n          const src = this.state.getVisibleTerminalState(true);\n          if (src != null) {\n            const c = this.graph.getConnectionConstraint(this.state, src, true);\n            // Checks if point is not fixed\n            if (c == null || this.graph.getConnectionPoint(src, c) == null) {\n              abs[0] = new Point(src.view.getRoutingCenterX(src), src.view.getRoutingCenterY(src));\n            }\n          }\n          const trg = this.state.getVisibleTerminalState(false);\n          if (trg != null) {\n            const c = this.graph.getConnectionConstraint(this.state, trg, false);\n            // Checks if point is not fixed\n            if (c == null || this.graph.getConnectionPoint(trg, c) == null) {\n              abs[abs.length - 1] = new Point(trg.view.getRoutingCenterX(trg), trg.view.getRoutingCenterY(trg));\n            }\n          }\n          const checkRemove = (idx, tmp) => {\n            if (idx > 0 && idx < abs.length - 1 && ptSegDistSq(abs[idx - 1].x, abs[idx - 1].y, abs[idx + 1].x, abs[idx + 1].y, tmp.x, tmp.y) < tol) {\n              points.splice(idx - 1, 1);\n              result = points;\n            }\n          };\n          // LATER: Check if other points can be removed if a segment is made straight\n          checkRemove(this.index, pt);\n        }\n      }\n      // Updates existing point\n      if (result == null && this.index > InternalEvent.VIRTUAL_HANDLE) {\n        points[this.index - 1] = point;\n      }\n    } else if (this.graph.isResetEdgesOnConnect()) {\n      points = [];\n    }\n    return result != null ? result : points;\n  }\n  /**\n   * Returns true if <outlineConnect> is true and the source of the event is the outline shape\n   * or shift is pressed.\n   */\n  isOutlineConnectEvent(me) {\n    if (!this.currentPoint) return false;\n    const offset = getOffset(this.graph.container);\n    const evt = me.getEvent();\n    const clientX = getClientX(evt);\n    const clientY = getClientY(evt);\n    const doc = document.documentElement;\n    const left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n    const top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n    const gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;\n    const gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;\n    return this.outlineConnect && !isShiftDown(me.getEvent()) && (me.isSource(this.marker.highlight.shape) || isAltDown(me.getEvent()) && me.getState() != null || this.marker.highlight.isHighlightAt(clientX, clientY) || (gridX !== clientX || gridY !== clientY) && me.getState() == null && this.marker.highlight.isHighlightAt(gridX, gridY));\n  }\n  /**\n   * Updates the given preview state taking into account the state of the constraint handler.\n   */\n  updatePreviewState(edgeState, point, terminalState, me, outline = false) {\n    // Computes the points for the edge style and terminals\n    const sourceState = this.isSource ? terminalState : this.state.getVisibleTerminalState(true);\n    const targetState = this.isTarget ? terminalState : this.state.getVisibleTerminalState(false);\n    let sourceConstraint = this.graph.getConnectionConstraint(edgeState, sourceState, true);\n    let targetConstraint = this.graph.getConnectionConstraint(edgeState, targetState, false);\n    let constraint = this.constraintHandler.currentConstraint;\n    if (constraint == null && outline) {\n      if (terminalState != null) {\n        // Handles special case where mouse is on outline away from actual end point\n        // in which case the grid is ignored and mouse point is used instead\n        if (me.isSource(this.marker.highlight.shape)) {\n          point = new Point(me.getGraphX(), me.getGraphY());\n        }\n        constraint = this.graph.getOutlineConstraint(point, terminalState, me);\n        this.constraintHandler.setFocus(me, terminalState, this.isSource);\n        this.constraintHandler.currentConstraint = constraint;\n        this.constraintHandler.currentPoint = point;\n      } else {\n        constraint = new ConnectionConstraint(null);\n      }\n    }\n    if (this.outlineConnect && this.marker.highlight != null && this.marker.highlight.shape != null) {\n      const s = this.graph.view.scale;\n      if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {\n        this.marker.highlight.shape.stroke = outline ? OUTLINE_HIGHLIGHT_COLOR : 'transparent';\n        this.marker.highlight.shape.strokeWidth = OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;\n        this.marker.highlight.repaint();\n      } else if (this.marker.hasValidState()) {\n        const cell = me.getCell();\n        this.marker.highlight.shape.stroke = cell && cell.isConnectable() && this.marker.getValidState() !== me.getState() ? 'transparent' : DEFAULT_VALID_COLOR;\n        this.marker.highlight.shape.strokeWidth = HIGHLIGHT_STROKEWIDTH / s / s;\n        this.marker.highlight.repaint();\n      }\n    }\n    if (this.isSource) {\n      sourceConstraint = constraint;\n    } else if (this.isTarget) {\n      targetConstraint = constraint;\n    }\n    if (this.isSource || this.isTarget) {\n      if (constraint != null && constraint.point != null) {\n        edgeState.style[this.isSource ? 'exitX' : 'entryX'] = constraint.point.x;\n        edgeState.style[this.isSource ? 'exitY' : 'entryY'] = constraint.point.y;\n      } else {\n        delete edgeState.style[this.isSource ? 'exitX' : 'entryX'];\n        delete edgeState.style[this.isSource ? 'exitY' : 'entryY'];\n      }\n    }\n    edgeState.setVisibleTerminalState(sourceState, true);\n    edgeState.setVisibleTerminalState(targetState, false);\n    if (!this.isSource || sourceState != null) {\n      edgeState.view.updateFixedTerminalPoint(edgeState, sourceState, true, sourceConstraint);\n    }\n    if (!this.isTarget || targetState != null) {\n      edgeState.view.updateFixedTerminalPoint(edgeState, targetState, false, targetConstraint);\n    }\n    if ((this.isSource || this.isTarget) && terminalState == null) {\n      edgeState.setAbsoluteTerminalPoint(point, this.isSource);\n      if (this.marker.getMarkedState() == null) {\n        this.error = this.graph.isAllowDanglingEdges() ? null : '';\n      }\n    }\n    edgeState.view.updatePoints(edgeState, this.points, sourceState, targetState);\n    edgeState.view.updateFloatingTerminalPoints(edgeState, sourceState, targetState);\n  }\n  /**\n   * Handles the event by updating the preview.\n   */\n  mouseMove(sender, me) {\n    if (this.index != null && this.marker != null) {\n      this.currentPoint = this.getPointForEvent(me);\n      this.error = null;\n      // Uses the current point from the constraint handler if available\n      if (!this.graph.isIgnoreTerminalEvent(me.getEvent()) && isShiftDown(me.getEvent()) && this.snapPoint != null) {\n        if (Math.abs(this.snapPoint.x - this.currentPoint.x) < Math.abs(this.snapPoint.y - this.currentPoint.y)) {\n          this.currentPoint.x = this.snapPoint.x;\n        } else {\n          this.currentPoint.y = this.snapPoint.y;\n        }\n      }\n      if (this.index <= InternalEvent.CUSTOM_HANDLE && this.index > InternalEvent.VIRTUAL_HANDLE) {\n        if (this.customHandles != null) {\n          this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].processEvent(me);\n          this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].positionChanged();\n          if (this.shape != null && this.shape.node != null) {\n            this.shape.node.style.display = 'none';\n          }\n        }\n      } else if (this.isLabel && this.label) {\n        this.label.x = this.currentPoint.x;\n        this.label.y = this.currentPoint.y;\n      } else {\n        this.points = this.getPreviewPoints(this.currentPoint, me);\n        let terminalState = this.isSource || this.isTarget ? this.getPreviewTerminalState(me) : null;\n        if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null && this.constraintHandler.currentPoint != null) {\n          this.currentPoint = this.constraintHandler.currentPoint.clone();\n        } else if (this.outlineConnect) {\n          // Need to check outline before cloning terminal state\n          const outline = this.isSource || this.isTarget ? this.isOutlineConnectEvent(me) : false;\n          if (outline) {\n            terminalState = this.marker.highlight.state;\n          } else if (terminalState != null && terminalState !== me.getState() && me.getCell()?.isConnectable() && this.marker.highlight.shape != null) {\n            this.marker.highlight.shape.stroke = 'transparent';\n            this.marker.highlight.repaint();\n            terminalState = null;\n          }\n        }\n        if (terminalState != null && !this.isCellEnabled(terminalState.cell)) {\n          terminalState = null;\n          this.marker.reset();\n        }\n        if (this.currentPoint) {\n          const clone = this.clonePreviewState(this.currentPoint, terminalState != null ? terminalState.cell : null);\n          this.updatePreviewState(clone, this.currentPoint, terminalState, me, this.outline);\n          // Sets the color of the preview to valid or invalid, updates the\n          // points of the preview and redraws\n          const color = this.error == null ? this.marker.validColor : this.marker.invalidColor;\n          this.setPreviewColor(color);\n          this.abspoints = clone.absolutePoints;\n          this.active = true;\n          this.updateHint(me, this.currentPoint);\n        }\n      }\n      // This should go before calling isOutlineConnectEvent above. As a workaround\n      // we add an offset of gridSize to the hint to avoid problem with hit detection\n      // in highlight.isHighlightAt (which uses comonentFromPoint)\n      this.drawPreview();\n      InternalEvent.consume(me.getEvent());\n      me.consume();\n    }\n  }\n  /**\n   * Handles the event to applying the previewed changes on the edge by\n   * using {@link moveLabel}, <connect> or <changePoints>.\n   */\n  mouseUp(sender, me) {\n    // Workaround for wrong event source in Webkit\n    if (this.index != null && this.marker != null) {\n      if (this.shape != null && this.shape.node != null) {\n        this.shape.node.style.display = '';\n      }\n      let edge = this.state.cell;\n      const {\n        index\n      } = this;\n      this.index = null;\n      // Ignores event if mouse has not been moved\n      if (me.getX() !== this.startX || me.getY() !== this.startY) {\n        const clone = !this.graph.isIgnoreTerminalEvent(me.getEvent()) && this.graph.isCloneEvent(me.getEvent()) && this.cloneEnabled && this.graph.isCellsCloneable();\n        // Displays the reason for not carriying out the change\n        // if there is an error message with non-zero length\n        if (this.error != null) {\n          if (this.error.length > 0) {\n            this.graph.validationAlert(this.error);\n          }\n        } else if (index <= InternalEvent.CUSTOM_HANDLE && index > InternalEvent.VIRTUAL_HANDLE) {\n          if (this.customHandles != null) {\n            const model = this.graph.getDataModel();\n            model.beginUpdate();\n            try {\n              this.customHandles[InternalEvent.CUSTOM_HANDLE - index].execute(me);\n              if (this.shape != null && this.shape.node != null) {\n                this.shape.apply(this.state);\n                this.shape.redraw();\n              }\n            } finally {\n              model.endUpdate();\n            }\n          }\n        } else if (this.isLabel && this.label) {\n          this.moveLabel(this.state, this.label.x, this.label.y);\n        } else if (this.isSource || this.isTarget) {\n          let terminal = null;\n          if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {\n            terminal = this.constraintHandler.currentFocus.cell;\n          }\n          if (!terminal && this.marker.hasValidState() && this.marker.highlight != null && this.marker.highlight.shape != null && this.marker.highlight.shape.stroke !== 'transparent' && this.marker.highlight.shape.stroke !== 'white') {\n            terminal = this.marker.validState.cell;\n          }\n          if (terminal) {\n            const model = this.graph.getDataModel();\n            const parent = edge.getParent();\n            model.beginUpdate();\n            try {\n              // Clones and adds the cell\n              if (clone) {\n                let geo = edge.getGeometry();\n                const cloned = this.graph.cloneCell(edge);\n                model.add(parent, cloned, parent.getChildCount());\n                if (geo != null) {\n                  geo = geo.clone();\n                  model.setGeometry(cloned, geo);\n                }\n                const other = edge.getTerminal(!this.isSource);\n                this.graph.connectCell(cloned, other, !this.isSource);\n                edge = cloned;\n              }\n              edge = this.connect(edge, terminal, this.isSource, clone, me);\n            } finally {\n              model.endUpdate();\n            }\n          } else if (this.graph.isAllowDanglingEdges()) {\n            const pt = this.abspoints[this.isSource ? 0 : this.abspoints.length - 1];\n            pt.x = this.roundLength(pt.x / this.graph.view.scale - this.graph.view.translate.x);\n            pt.y = this.roundLength(pt.y / this.graph.view.scale - this.graph.view.translate.y);\n            const parent = edge.getParent();\n            const pstate = parent ? this.graph.getView().getState(parent) : null;\n            if (pstate != null) {\n              pt.x -= pstate.origin.x;\n              pt.y -= pstate.origin.y;\n            }\n            pt.x -= this.graph.getPanDx() / this.graph.view.scale;\n            pt.y -= this.graph.getPanDy() / this.graph.view.scale;\n            // Destroys and recreates this handler\n            edge = this.changeTerminalPoint(edge, pt, this.isSource, clone);\n          }\n        } else if (this.active) {\n          edge = this.changePoints(edge, this.points, clone);\n        } else {\n          this.graph.getView().invalidate(this.state.cell);\n          this.graph.getView().validate(this.state.cell);\n        }\n      } else if (this.graph.isToggleEvent(me.getEvent())) {\n        this.graph.selectCellForEvent(this.state.cell, me.getEvent());\n      }\n      // Resets the preview color the state of the handler if this\n      // handler has not been recreated\n      if (this.marker != null) {\n        this.reset();\n        // Updates the selection if the edge has been cloned\n        if (edge !== this.state.cell) {\n          this.graph.setSelectionCell(edge);\n        }\n      }\n      me.consume();\n    }\n  }\n  /**\n   * Resets the state of this handler.\n   */\n  reset() {\n    if (this.active) {\n      this.refresh();\n    }\n    this.error = null;\n    this.index = null;\n    this.points = [];\n    this.snapPoint = null;\n    this.isLabel = false;\n    this.isSource = false;\n    this.isTarget = false;\n    this.active = false;\n    if (this.marker) {\n      this.marker.reset();\n    }\n    this.constraintHandler.reset();\n    if (this.customHandles) {\n      for (let i = 0; i < this.customHandles.length; i += 1) {\n        this.customHandles[i].reset();\n      }\n    }\n    this.setPreviewColor(EDGE_SELECTION_COLOR);\n    this.removeHint();\n    this.redraw();\n  }\n  /**\n   * Sets the color of the preview to the given value.\n   */\n  setPreviewColor(color) {\n    this.shape.stroke = color;\n  }\n  /**\n   * Converts the given point in-place from screen to unscaled, untranslated\n   * graph coordinates and applies the grid. Returns the given, modified\n   * point instance.\n   *\n   * @param point {@link Point} to be converted.\n   * @param gridEnabled Boolean that specifies if the grid should be applied.\n   */\n  convertPoint(point, gridEnabled) {\n    const scale = this.graph.getView().getScale();\n    const tr = this.graph.getView().getTranslate();\n    if (gridEnabled) {\n      point.x = this.graph.snap(point.x);\n      point.y = this.graph.snap(point.y);\n    }\n    point.x = Math.round(point.x / scale - tr.x);\n    point.y = Math.round(point.y / scale - tr.y);\n    const parent = this.state.cell.getParent();\n    const pstate = parent ? this.graph.getView().getState(parent) : parent;\n    if (pstate) {\n      point.x -= pstate.origin.x;\n      point.y -= pstate.origin.y;\n    }\n    return point;\n  }\n  /**\n   * Changes the coordinates for the label of the given edge.\n   *\n   * @param edge <Cell> that represents the edge.\n   * @param x Integer that specifies the x-coordinate of the new location.\n   * @param y Integer that specifies the y-coordinate of the new location.\n   */\n  moveLabel(edgeState, x, y) {\n    const model = this.graph.getDataModel();\n    let geometry = edgeState.cell.getGeometry();\n    if (geometry != null) {\n      const {\n        scale\n      } = this.graph.getView();\n      geometry = geometry.clone();\n      if (geometry.relative) {\n        // Resets the relative location stored inside the geometry\n        let pt = this.graph.getView().getRelativePoint(edgeState, x, y);\n        geometry.x = Math.round(pt.x * 10000) / 10000;\n        geometry.y = Math.round(pt.y);\n        // Resets the offset inside the geometry to find the offset\n        // from the resulting point\n        geometry.offset = new Point(0, 0);\n        pt = this.graph.view.getPoint(edgeState, geometry);\n        geometry.offset = new Point(Math.round((x - pt.x) / scale), Math.round((y - pt.y) / scale));\n      } else {\n        const points = edgeState.absolutePoints;\n        const p0 = points[0];\n        const pe = points[points.length - 1];\n        if (p0 != null && pe != null) {\n          const cx = p0.x + (pe.x - p0.x) / 2;\n          const cy = p0.y + (pe.y - p0.y) / 2;\n          geometry.offset = new Point(Math.round((x - cx) / scale), Math.round((y - cy) / scale));\n          geometry.x = 0;\n          geometry.y = 0;\n        }\n      }\n      model.setGeometry(edgeState.cell, geometry);\n    }\n  }\n  /**\n   * Changes the terminal or terminal point of the given edge in the graph\n   * model.\n   *\n   * @param edge <Cell> that represents the edge to be reconnected.\n   * @param terminal <Cell> that represents the new terminal.\n   * @param isSource Boolean indicating if the new terminal is the source or\n   * target terminal.\n   * @param isClone Boolean indicating if the new connection should be a clone of\n   * the old edge.\n   * @param me {@link MouseEvent} that contains the mouse up event.\n   */\n  connect(edge, terminal, isSource, isClone, me) {\n    const parent = edge.getParent();\n    this.graph.batchUpdate(() => {\n      let constraint = this.constraintHandler.currentConstraint;\n      if (constraint == null) {\n        constraint = new ConnectionConstraint(null);\n      }\n      this.graph.connectCell(edge, terminal, isSource, constraint);\n    });\n    return edge;\n  }\n  /**\n   * Changes the terminal point of the given edge.\n   */\n  changeTerminalPoint(edge, point, isSource, clone) {\n    const model = this.graph.getDataModel();\n    model.batchUpdate(() => {\n      if (clone) {\n        const parent = edge.getParent();\n        const terminal = edge.getTerminal(!isSource);\n        edge = this.graph.cloneCell(edge);\n        model.add(parent, edge, parent.getChildCount());\n        model.setTerminal(edge, terminal, !isSource);\n      }\n      let geo = edge.getGeometry();\n      if (geo != null) {\n        geo = geo.clone();\n        geo.setTerminalPoint(point, isSource);\n        model.setGeometry(edge, geo);\n        this.graph.connectCell(edge, null, isSource, new ConnectionConstraint(null));\n      }\n    });\n    return edge;\n  }\n  /**\n   * Changes the control points of the given edge in the graph model.\n   */\n  changePoints(edge, points, clone) {\n    const model = this.graph.getDataModel();\n    model.batchUpdate(() => {\n      if (clone) {\n        const parent = edge.getParent();\n        const source = edge.getTerminal(true);\n        const target = edge.getTerminal(false);\n        edge = this.graph.cloneCell(edge);\n        model.add(parent, edge, parent.getChildCount());\n        model.setTerminal(edge, source, true);\n        model.setTerminal(edge, target, false);\n      }\n      let geo = edge.getGeometry();\n      if (geo != null) {\n        geo = geo.clone();\n        geo.points = points;\n        model.setGeometry(edge, geo);\n      }\n    });\n    return edge;\n  }\n  /**\n   * Adds a control point for the given state and event.\n   */\n  addPoint(state, evt) {\n    const pt = convertPoint(this.graph.container, getClientX(evt), getClientY(evt));\n    const gridEnabled = this.graph.isGridEnabledEvent(evt);\n    this.convertPoint(pt, gridEnabled);\n    this.addPointAt(state, pt.x, pt.y);\n    InternalEvent.consume(evt);\n  }\n  /**\n   * Adds a control point at the given point.\n   */\n  addPointAt(state, x, y) {\n    let geo = state.cell.getGeometry();\n    const pt = new Point(x, y);\n    if (geo != null) {\n      geo = geo.clone();\n      const t = this.graph.view.translate;\n      const s = this.graph.view.scale;\n      let offset = new Point(t.x * s, t.y * s);\n      const parent = this.state.cell.getParent();\n      if (parent && parent.isVertex()) {\n        const pState = this.graph.view.getState(parent);\n        if (pState) offset = new Point(pState.x, pState.y);\n      }\n      const index = findNearestSegment(state, pt.x * s + offset.x, pt.y * s + offset.y);\n      if (geo.points == null) {\n        geo.points = [pt];\n      } else {\n        geo.points.splice(index, 0, pt);\n      }\n      this.graph.getDataModel().setGeometry(state.cell, geo);\n      this.refresh();\n      this.redraw();\n    }\n  }\n  /**\n   * Removes the control point at the given index from the given state.\n   */\n  removePoint(state, index) {\n    if (index > 0 && index < this.abspoints.length - 1) {\n      let geo = this.state.cell.getGeometry();\n      if (geo != null && geo.points != null) {\n        geo = geo.clone();\n        (geo.points || []).splice(index - 1, 1);\n        this.graph.getDataModel().setGeometry(state.cell, geo);\n        this.refresh();\n        this.redraw();\n      }\n    }\n  }\n  /**\n   * Returns the fillcolor for the handle at the given index.\n   */\n  getHandleFillColor(index) {\n    const isSource = index === 0;\n    const {\n      cell\n    } = this.state;\n    const terminal = cell.getTerminal(isSource);\n    let color = HANDLE_FILLCOLOR;\n    if (terminal != null && !this.graph.isCellDisconnectable(cell, terminal, isSource) || terminal == null && !this.graph.isTerminalPointMovable(cell, isSource)) {\n      color = LOCKED_HANDLE_FILLCOLOR;\n    } else if (terminal != null && this.graph.isCellDisconnectable(cell, terminal, isSource)) {\n      color = CONNECT_HANDLE_FILLCOLOR;\n    }\n    return color;\n  }\n  /**\n   * Redraws the preview, and the bends- and label control points.\n   */\n  redraw(ignoreHandles) {\n    this.abspoints = this.state.absolutePoints.slice();\n    const g = this.state.cell.getGeometry();\n    if (g) {\n      const pts = g.points;\n      if (this.bends != null && this.bends.length > 0) {\n        if (pts != null) {\n          if (this.points == null) {\n            this.points = [];\n          }\n          for (let i = 1; i < this.bends.length - 1; i += 1) {\n            if (this.bends[i] != null && this.abspoints[i] != null) {\n              this.points[i - 1] = pts[i - 1];\n            }\n          }\n        }\n      }\n    }\n    this.drawPreview();\n    if (!ignoreHandles) {\n      this.redrawHandles();\n    }\n  }\n  /**\n   * Redraws the handles.\n   */\n  redrawHandles() {\n    const {\n      cell\n    } = this.state;\n    // Updates the handle for the label position\n    let b = this.labelShape.bounds;\n    this.label = new Point(this.state.absoluteOffset.x, this.state.absoluteOffset.y);\n    this.labelShape.bounds = new Rectangle(Math.round(this.label.x - b.width / 2), Math.round(this.label.y - b.height / 2), b.width, b.height);\n    // Shows or hides the label handle depending on the label\n    const lab = this.graph.getLabel(cell);\n    this.labelShape.visible = lab != null && lab.length > 0 && this.graph.isLabelMovable(cell);\n    if (this.bends != null && this.bends.length > 0) {\n      const n = this.abspoints.length - 1;\n      const p0 = this.abspoints[0];\n      const x0 = p0.x;\n      const y0 = p0.y;\n      b = this.bends[0].bounds;\n      this.bends[0].bounds = new Rectangle(Math.floor(x0 - b.width / 2), Math.floor(y0 - b.height / 2), b.width, b.height);\n      this.bends[0].fill = this.getHandleFillColor(0);\n      this.bends[0].redraw();\n      if (this.manageLabelHandle) {\n        this.checkLabelHandle(this.bends[0].bounds);\n      }\n      const pe = this.abspoints[n];\n      const xn = pe.x;\n      const yn = pe.y;\n      const bn = this.bends.length - 1;\n      b = this.bends[bn].bounds;\n      this.bends[bn].bounds = new Rectangle(Math.floor(xn - b.width / 2), Math.floor(yn - b.height / 2), b.width, b.height);\n      this.bends[bn].fill = this.getHandleFillColor(bn);\n      this.bends[bn].redraw();\n      if (this.manageLabelHandle) {\n        this.checkLabelHandle(this.bends[bn].bounds);\n      }\n      this.redrawInnerBends(p0, pe);\n    }\n    if (this.virtualBends && this.virtualBends.length > 0) {\n      let last = this.abspoints[0];\n      for (let i = 0; i < this.virtualBends.length; i += 1) {\n        if (this.virtualBends[i] != null && this.abspoints[i + 1] != null) {\n          const pt = this.abspoints[i + 1];\n          const b = this.virtualBends[i];\n          const x = last.x + (pt.x - last.x) / 2;\n          const y = last.y + (pt.y - last.y) / 2;\n          if (b.bounds) {\n            b.bounds = new Rectangle(Math.floor(x - b.bounds.width / 2), Math.floor(y - b.bounds.height / 2), b.bounds.width, b.bounds.height);\n            b.redraw();\n          }\n          setOpacity(b.node, this.virtualBendOpacity);\n          last = pt;\n          if (this.manageLabelHandle) {\n            this.checkLabelHandle(b.bounds);\n          }\n        }\n      }\n    }\n    this.labelShape.redraw();\n    if (this.customHandles) {\n      for (let i = 0; i < this.customHandles.length; i += 1) {\n        const shape = this.customHandles[i].shape;\n        if (shape) {\n          const temp = shape.node.style.display;\n          this.customHandles[i].redraw();\n          shape.node.style.display = temp;\n          // Hides custom handles during text editing\n          shape.node.style.visibility = this.isCustomHandleVisible(this.customHandles[i]) ? '' : 'hidden';\n        }\n      }\n    }\n  }\n  /**\n   * Returns true if the given custom handle is visible.\n   */\n  isCustomHandleVisible(handle) {\n    return !this.graph.isEditing() && this.state.view.graph.getSelectionCount() === 1;\n  }\n  /**\n   * Shortcut to <hideSizers>.\n   */\n  setHandlesVisible(visible) {\n    for (let i = 0; i < this.bends.length; i += 1) {\n      this.bends[i].node.style.display = visible ? '' : 'none';\n    }\n    if (this.virtualBends) {\n      for (let i = 0; i < this.virtualBends.length; i += 1) {\n        this.virtualBends[i].node.style.display = visible ? '' : 'none';\n      }\n    }\n    this.labelShape.node.style.display = visible ? '' : 'none';\n    if (this.customHandles) {\n      for (let i = 0; i < this.customHandles.length; i += 1) {\n        this.customHandles[i].setVisible(visible);\n      }\n    }\n  }\n  /**\n   * Updates and redraws the inner bends.\n   *\n   * @param p0 {@link Point} that represents the location of the first point.\n   * @param pe {@link Point} that represents the location of the last point.\n   */\n  redrawInnerBends(p0, pe) {\n    for (let i = 1; i < this.bends.length - 1; i += 1) {\n      if (this.bends[i] != null) {\n        if (this.abspoints[i] != null) {\n          const {\n            x\n          } = this.abspoints[i];\n          const {\n            y\n          } = this.abspoints[i];\n          const b = this.bends[i].bounds;\n          this.bends[i].node.style.visibility = 'visible';\n          this.bends[i].bounds = new Rectangle(Math.round(x - b.width / 2), Math.round(y - b.height / 2), b.width, b.height);\n          if (this.manageLabelHandle) {\n            this.checkLabelHandle(this.bends[i].bounds);\n          } else if (this.handleImage == null && this.labelShape.visible && intersects(this.bends[i].bounds, this.labelShape.bounds)) {\n            const w = HANDLE_SIZE + 3;\n            const h = HANDLE_SIZE + 3;\n            this.bends[i].bounds = new Rectangle(Math.round(x - w / 2), Math.round(y - h / 2), w, h);\n          }\n          this.bends[i].redraw();\n        } else {\n          this.bends[i].destroy();\n        }\n      }\n    }\n  }\n  /**\n   * Checks if the label handle intersects the given bounds and moves it if it\n   * intersects.\n   */\n  checkLabelHandle(b) {\n    const b2 = this.labelShape.bounds;\n    if (intersects(b, b2)) {\n      if (b.getCenterY() < b2.getCenterY()) {\n        b2.y = b.y + b.height;\n      } else {\n        b2.y = b.y - b2.height;\n      }\n    }\n  }\n  /**\n   * Redraws the preview.\n   */\n  drawPreview() {\n    try {\n      if (this.isLabel) {\n        const b = this.labelShape.bounds;\n        const bounds = new Rectangle(Math.round(this.label.x - b.width / 2), Math.round(this.label.y - b.height / 2), b.width, b.height);\n        if (!b.equals(bounds)) {\n          this.labelShape.bounds = bounds;\n          this.labelShape.redraw();\n        }\n      }\n      if (this.shape != null && !equalPoints(this.shape.points, this.abspoints)) {\n        this.shape.apply(this.state);\n        this.shape.points = this.abspoints.slice();\n        this.shape.scale = this.state.view.scale;\n        this.shape.isDashed = this.isSelectionDashed();\n        this.shape.stroke = this.getSelectionColor();\n        this.shape.strokeWidth = this.getSelectionStrokeWidth() / this.shape.scale / this.shape.scale;\n        this.shape.isShadow = false;\n        this.shape.redraw();\n      }\n      this.updateParentHighlight();\n    } catch (e) {\n      // ignore\n    }\n  }\n  /**\n   * Refreshes the bends of this handler.\n   */\n  refresh() {\n    if (this.state != null) {\n      this.abspoints = this.getSelectionPoints(this.state);\n      this.points = [];\n      this.destroyBends(this.bends);\n      this.bends = this.createBends();\n      if (this.virtualBends) {\n        this.destroyBends(this.virtualBends);\n        this.virtualBends = this.createVirtualBends();\n      }\n      if (this.customHandles) {\n        this.destroyBends(this.customHandles);\n        this.customHandles = this.createCustomHandles();\n      }\n      // Puts label node on top of bends\n      if (this.labelShape != null && this.labelShape.node != null && this.labelShape.node.parentNode != null) {\n        this.labelShape.node.parentNode.appendChild(this.labelShape.node);\n      }\n    }\n  }\n  /**\n   * Returns true if <destroy> was called.\n   */\n  isDestroyed() {\n    return this.shape == null;\n  }\n  /**\n   * Destroys all elements in <bends>.\n   */\n  destroyBends(bends) {\n    if (bends != null) {\n      for (let i = 0; i < bends.length; i += 1) {\n        if (bends[i] != null) {\n          bends[i].destroy();\n        }\n      }\n    }\n  }\n  /**\n   * Destroys the handler and all its resources and DOM nodes. This does\n   * normally not need to be called as handlers are destroyed automatically\n   * when the corresponding cell is deselected.\n   */\n  onDestroy() {\n    this.state.view.graph.removeListener(this.escapeHandler);\n    this.marker.destroy();\n    // @ts-expect-error Can be null when destroyed.\n    this.marker = null;\n    this.shape.destroy();\n    // @ts-expect-error Can be null when destroyed.\n    this.shape = null;\n    if (this.parentHighlight) {\n      const parent = this.state.cell.getParent();\n      const pstate = parent ? this.graph.view.getState(parent) : null;\n      if (pstate && pstate.parentHighlight === this.parentHighlight) {\n        pstate.parentHighlight = null;\n      }\n      this.parentHighlight.destroy();\n      this.parentHighlight = null;\n    }\n    this.labelShape.destroy();\n    // @ts-expect-error Can be null when destroyed.\n    this.labelShape = null;\n    this.constraintHandler.onDestroy();\n    // @ts-expect-error Can be null when destroyed.\n    this.constraintHandler = null;\n    if (this.virtualBends) {\n      this.destroyBends(this.virtualBends);\n      this.virtualBends = [];\n    }\n    if (this.customHandles) {\n      this.destroyBends(this.customHandles);\n      this.customHandles = [];\n    }\n    this.destroyBends(this.bends);\n    this.bends = [];\n    this.removeHint();\n  }\n}\nclass EdgeHandlerCellMarker extends CellMarker {\n  constructor(graph, edgeHandler, validColor = DEFAULT_VALID_COLOR, invalidColor = DEFAULT_INVALID_COLOR, hotspot = DEFAULT_HOTSPOT) {\n    super(graph, validColor, invalidColor, hotspot);\n    // Only returns edges if they are connectable and never returns\n    // the edge that is currently being modified\n    this.getCell = me => {\n      let cell = super.getCell(me);\n      // Checks for cell at preview point (with grid)\n      if ((cell === this.edgeHandler.state.cell || !cell) && this.edgeHandler.currentPoint) {\n        cell = this.edgeHandler.graph.getCellAt(this.edgeHandler.currentPoint.x, this.edgeHandler.currentPoint.y);\n      }\n      // Uses connectable parent vertex if one exists\n      if (cell && !cell.isConnectable()) {\n        const parent = cell.getParent();\n        if (parent && parent.isVertex() && parent.isConnectable()) {\n          cell = parent;\n        }\n      }\n      if (cell) {\n        if (this.graph.isSwimlane(cell) && this.edgeHandler.currentPoint && this.graph.hitsSwimlaneContent(cell, this.edgeHandler.currentPoint.x, this.edgeHandler.currentPoint.y) || !this.edgeHandler.isConnectableCell(cell) || cell === this.edgeHandler.state.cell || cell && !this.edgeHandler.graph.connectableEdges && cell.isEdge() || this.edgeHandler.state.cell.isAncestor(cell)) {\n          cell = null;\n        }\n      }\n      if (cell && !cell.isConnectable()) {\n        cell = null;\n      }\n      return cell;\n    };\n    // Sets the highlight color according to validateConnection\n    this.isValidState = state => {\n      const cell = this.edgeHandler.state.cell.getTerminal(!this.edgeHandler.isSource);\n      const cellState = this.edgeHandler.graph.view.getState(cell);\n      const other = this.edgeHandler.graph.view.getTerminalPort(state, cellState, !this.edgeHandler.isSource);\n      const otherCell = other ? other.cell : null;\n      const source = this.edgeHandler.isSource ? state.cell : otherCell;\n      const target = this.edgeHandler.isSource ? otherCell : state.cell;\n      // Updates the error message of the handler\n      this.edgeHandler.error = this.edgeHandler.validateConnection(source, target);\n      return !this.edgeHandler.error;\n    };\n    this.edgeHandler = edgeHandler;\n  }\n}\nexport default EdgeHandler;","map":{"version":3,"names":["CellMarker","Point","CONNECT_HANDLE_FILLCOLOR","CURSOR","DEFAULT_HOTSPOT","DEFAULT_INVALID_COLOR","DEFAULT_VALID_COLOR","DIALECT","EDGE_SELECTION_COLOR","EDGE_SELECTION_DASHED","EDGE_SELECTION_STROKEWIDTH","HANDLE_FILLCOLOR","HANDLE_SIZE","HANDLE_STROKECOLOR","HIGHLIGHT_STROKEWIDTH","LABEL_HANDLE_FILLCOLOR","LABEL_HANDLE_SIZE","LOCKED_HANDLE_FILLCOLOR","NONE","OUTLINE_HIGHLIGHT_COLOR","OUTLINE_HIGHLIGHT_STROKEWIDTH","contains","findNearestSegment","intersects","ptSegDistSq","convertPoint","getOffset","setOpacity","ImageShape","RectangleShape","ConnectionConstraint","InternalEvent","ConstraintHandler","Rectangle","Client","EdgeStyle","getClientX","getClientY","isAltDown","isMouseEvent","isShiftDown","equalPoints","EdgeHandler","constructor","state","error","bends","cloneEnabled","addEnabled","removeEnabled","dblClickRemoveEnabled","mergeRemoveEnabled","straightRemoveEnabled","virtualBendsEnabled","virtualBendOpacity","parentHighlightEnabled","preferHtml","allowHandleBoundsCheck","snapToTerminals","handleImage","labelHandleImage","tolerance","outlineConnect","manageLabelHandle","currentPoint","parentHighlight","index","isSource","isTarget","isLabel","points","snapPoint","abspoints","startX","startY","outline","active","graph","view","marker","createMarker","constraintHandler","getSelectionPoints","shape","createSelectionShape","dialect","SVG","MIXEDHTML","init","getView","getOverlayPane","pointerEvents","setCursor","MOVABLE_EDGE","redirectMouseEvents","node","text","parentNode","container","sourceState","getVisibleTerminalState","targetState","selectionHandler","getPlugin","getSelectionCount","maxCells","createBends","isVirtualBendsEnabled","virtualBends","createVirtualBends","label","absoluteOffset","x","y","labelShape","createLabelHandleShape","initBend","LABEL_HANDLE","customHandles","createCustomHandles","updateParentHighlight","redraw","escapeHandler","sender","evt","dirty","reset","cellRenderer","isRendering","addListener","ESCAPE","isParentHighlightVisible","parent","cell","getParent","isCellSelected","isDestroyed","visible","pstate","getState","isVertex","b","bounds","width","height","fromRectangle","destroy","createParentHighlightShape","style","rotation","edgeStyle","noEdgeStyle","isCellEnabled","isAddPointEvent","isRemovePointEvent","absolutePoints","getSelectionColor","strokeWidth","getSelectionStrokeWidth","isDashed","isSelectionDashed","c","apply","stroke","isShadow","isConnectableCell","getCellAt","EdgeHandlerCellMarker","validateConnection","source","target","getEdgeValidationError","i","length","isHandleVisible","terminal","isCellBendable","bend","createHandleShape","removePoint","isHandleEnabled","TERMINAL_HANDLE","BEND_HANDLE","push","visibility","last","VIRTUAL_BEND_HANDLE","geo","getGeometry","getEdgeStyle","undefined","EntityRelation","src","preserveImageAspect","s","dblClick","STRICTHTML","IS_TOUCH","setAttribute","getHandleForEvent","me","result","tol","getEvent","hit","getGraphX","getGraphY","minDistSq","Number","POSITIVE_INFINITY","checkShape","display","dx","getCenterX","dy","getCenterY","tmp","isCustomHandleEvent","CUSTOM_HANDLE","isAddVirtualBendEvent","VIRTUAL_HANDLE","mouseDown","handle","addPoint","consume","isConsumed","isEnabled","getCell","isLabelMovable","start","getX","getY","getTerminal","isTerminalPointMovable","isCellDisconnectable","setVisible","clonePreviewState","point","clone","getSnapToTerminalTolerance","getGridSize","scale","updateHint","removeHint","roundLength","Math","round","isSnapToTerminalsEvent","getPointForEvent","tt","overrideX","overrideY","snapToPoint","pt","abs","snapToTerminal","getRoutingCenterX","getRoutingCenterY","isGridEnabledEvent","tr","translate","snap","getPreviewTerminalState","update","highlight","currentFocus","currentConstraint","repaint","markCell","other","getTerminalPort","otherCell","isIgnoreTerminalEvent","process","getValidState","getPreviewPoints","geometry","slice","splice","getEventTolerance","getConnectionConstraint","getConnectionPoint","trg","checkRemove","idx","isResetEdgesOnConnect","isOutlineConnectEvent","offset","clientX","clientY","doc","document","documentElement","left","window","pageXOffset","scrollLeft","clientLeft","top","pageYOffset","scrollTop","clientTop","gridX","gridY","isHighlightAt","updatePreviewState","edgeState","terminalState","sourceConstraint","targetConstraint","constraint","getOutlineConstraint","setFocus","hasValidState","isConnectable","setVisibleTerminalState","updateFixedTerminalPoint","setAbsoluteTerminalPoint","getMarkedState","isAllowDanglingEdges","updatePoints","updateFloatingTerminalPoints","mouseMove","processEvent","positionChanged","color","validColor","invalidColor","setPreviewColor","drawPreview","mouseUp","edge","isCloneEvent","isCellsCloneable","validationAlert","model","getDataModel","beginUpdate","execute","endUpdate","moveLabel","validState","cloned","cloneCell","add","getChildCount","setGeometry","connectCell","connect","origin","getPanDx","getPanDy","changeTerminalPoint","changePoints","invalidate","validate","isToggleEvent","selectCellForEvent","setSelectionCell","refresh","gridEnabled","getScale","getTranslate","relative","getRelativePoint","getPoint","p0","pe","cx","cy","isClone","batchUpdate","setTerminal","setTerminalPoint","addPointAt","t","pState","getHandleFillColor","ignoreHandles","g","pts","redrawHandles","lab","getLabel","n","x0","y0","floor","fill","checkLabelHandle","xn","yn","bn","redrawInnerBends","temp","isCustomHandleVisible","isEditing","setHandlesVisible","w","h","b2","equals","e","destroyBends","appendChild","onDestroy","removeListener","edgeHandler","hotspot","isSwimlane","hitsSwimlaneContent","connectableEdges","isEdge","isAncestor","isValidState","cellState"],"sources":["D:/ospanel/domains/old/react/react-intro-main/node_modules/@maxgraph/core/dist/view/handler/EdgeHandler.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport CellMarker from '../cell/CellMarker';\nimport Point from '../geometry/Point';\nimport { CONNECT_HANDLE_FILLCOLOR, CURSOR, DEFAULT_HOTSPOT, DEFAULT_INVALID_COLOR, DEFAULT_VALID_COLOR, DIALECT, EDGE_SELECTION_COLOR, EDGE_SELECTION_DASHED, EDGE_SELECTION_STROKEWIDTH, HANDLE_FILLCOLOR, HANDLE_SIZE, HANDLE_STROKECOLOR, HIGHLIGHT_STROKEWIDTH, LABEL_HANDLE_FILLCOLOR, LABEL_HANDLE_SIZE, LOCKED_HANDLE_FILLCOLOR, NONE, OUTLINE_HIGHLIGHT_COLOR, OUTLINE_HIGHLIGHT_STROKEWIDTH, } from '../../util/Constants';\nimport { contains, findNearestSegment, intersects, ptSegDistSq, } from '../../util/mathUtils';\nimport { convertPoint, getOffset, setOpacity } from '../../util/styleUtils';\nimport ImageShape from '../geometry/node/ImageShape';\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport ConnectionConstraint from '../other/ConnectionConstraint';\nimport InternalEvent from '../event/InternalEvent';\nimport ConstraintHandler from './ConstraintHandler';\nimport Rectangle from '../geometry/Rectangle';\nimport Client from '../../Client';\nimport EdgeStyle from '../style/EdgeStyle';\nimport { getClientX, getClientY, isAltDown, isMouseEvent, isShiftDown, } from '../../util/EventUtils';\nimport { equalPoints } from '../../util/arrayUtils';\n/**\n * Graph event handler that reconnects edges and modifies control points and the edge\n * label location.\n * Uses {@link CellMarker} for finding and highlighting new source and target vertices.\n * This handler is automatically created in mxGraph.createHandler for each selected edge.\n * **To enable adding/removing control points, the following code can be used**\n * @example\n * ```\n * mxEdgeHandler.prototype.addEnabled = true;\n * mxEdgeHandler.prototype.removeEnabled = true;\n * ```\n * Note: This experimental feature is not recommended for production use.\n * @class EdgeHandler\n */\nclass EdgeHandler {\n    constructor(state) {\n        /**\n         * Holds the current validation error while a connection is being changed.\n         */\n        this.error = null;\n        /**\n         * Holds the {@link Shapes} that represent the points.\n         */\n        this.bends = [];\n        /**\n         * Specifies if cloning by control-drag is enabled. Default is true.\n         */\n        this.cloneEnabled = true;\n        /**\n         * Specifies if adding bends by shift-click is enabled. Default is false.\n         * Note: This experimental feature is not recommended for production use.\n         */\n        this.addEnabled = false;\n        /**\n         * Specifies if removing bends by shift-click is enabled. Default is false.\n         * Note: This experimental feature is not recommended for production use.\n         */\n        this.removeEnabled = false;\n        /**\n         * Specifies if removing bends by double click is enabled. Default is false.\n         */\n        this.dblClickRemoveEnabled = false;\n        /**\n         * Specifies if removing bends by dropping them on other bends is enabled.\n         * Default is false.\n         */\n        this.mergeRemoveEnabled = false;\n        /**\n         * Specifies if removing bends by creating straight segments should be enabled.\n         * If enabled, this can be overridden by holding down the alt key while moving.\n         * Default is false.\n         */\n        this.straightRemoveEnabled = false;\n        /**\n         * Specifies if virtual bends should be added in the center of each\n         * segments. These bends can then be used to add new waypoints.\n         * Default is false.\n         */\n        this.virtualBendsEnabled = false;\n        /**\n         * Opacity to be used for virtual bends (see <virtualBendsEnabled>).\n         * Default is 20.\n         */\n        this.virtualBendOpacity = 20;\n        /**\n         * Specifies if the parent should be highlighted if a child cell is selected.\n         * Default is false.\n         */\n        this.parentHighlightEnabled = false;\n        /**\n         * Specifies if bends should be added to the graph container. This is updated\n         * in <init> based on whether the edge or one of its terminals has an HTML\n         * label in the container.\n         */\n        this.preferHtml = false;\n        /**\n         * Specifies if the bounds of handles should be used for hit-detection in IE\n         * Default is true.\n         */\n        this.allowHandleBoundsCheck = true;\n        /**\n         * Specifies if waypoints should snap to the routing centers of terminals.\n         * Default is false.\n         */\n        this.snapToTerminals = false;\n        /**\n         * Optional {@link Image} to be used as handles. Default is null.\n         */\n        this.handleImage = null;\n        this.labelHandleImage = null;\n        /**\n         * Optional tolerance for hit-detection in <getHandleForEvent>. Default is 0.\n         */\n        // tolerance: number;\n        this.tolerance = 0;\n        /**\n         * Specifies if connections to the outline of a highlighted target should be\n         * enabled. This will allow to place the connection point along the outline of\n         * the highlighted target. Default is false.\n         */\n        // outlineConnect: boolean;\n        this.outlineConnect = false;\n        /**\n         * Specifies if the label handle should be moved if it intersects with another\n         * handle. Uses <checkLabelHandle> for checking and moving. Default is false.\n         */\n        // manageLabelHandle: boolean;\n        this.manageLabelHandle = false;\n        this.currentPoint = null;\n        this.parentHighlight = null;\n        this.index = null;\n        this.isSource = false;\n        this.isTarget = false;\n        this.isLabel = false;\n        this.points = [];\n        this.snapPoint = null;\n        this.abspoints = [];\n        this.startX = 0;\n        this.startY = 0;\n        this.outline = true;\n        this.active = true;\n        // `state.shape` must exists.\n        this.state = state;\n        this.graph = this.state.view.graph;\n        this.marker = this.createMarker();\n        this.constraintHandler = new ConstraintHandler(this.graph);\n        // Clones the original points from the cell\n        // and makes sure at least one point exists\n        this.points = [];\n        // Uses the absolute points of the state\n        // for the initial configuration and preview\n        this.abspoints = this.getSelectionPoints(this.state);\n        this.shape = this.createSelectionShape(this.abspoints);\n        this.shape.dialect =\n            this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;\n        this.shape.init(this.graph.getView().getOverlayPane());\n        this.shape.pointerEvents = false;\n        this.shape.setCursor(CURSOR.MOVABLE_EDGE);\n        InternalEvent.redirectMouseEvents(this.shape.node, this.graph, this.state);\n        // Updates preferHtml\n        this.preferHtml =\n            this.state.text != null && this.state.text.node.parentNode === this.graph.container;\n        if (!this.preferHtml) {\n            // Checks source terminal\n            const sourceState = this.state.getVisibleTerminalState(true);\n            if (sourceState != null) {\n                this.preferHtml =\n                    sourceState.text != null &&\n                        sourceState.text.node.parentNode === this.graph.container;\n            }\n            if (!this.preferHtml) {\n                // Checks target terminal\n                const targetState = this.state.getVisibleTerminalState(false);\n                if (targetState != null) {\n                    this.preferHtml =\n                        targetState.text != null &&\n                            targetState.text.node.parentNode === this.graph.container;\n                }\n            }\n        }\n        const selectionHandler = this.graph.getPlugin('SelectionHandler');\n        // Creates bends for the non-routed absolute points\n        // or bends that don't correspond to points\n        if (selectionHandler &&\n            (this.graph.getSelectionCount() < selectionHandler.maxCells ||\n                selectionHandler.maxCells <= 0)) {\n            this.bends = this.createBends();\n            if (this.isVirtualBendsEnabled()) {\n                this.virtualBends = this.createVirtualBends();\n            }\n        }\n        // Adds a rectangular handle for the label position\n        this.label = new Point(this.state.absoluteOffset.x, this.state.absoluteOffset.y);\n        this.labelShape = this.createLabelHandleShape();\n        this.initBend(this.labelShape);\n        this.labelShape.setCursor(CURSOR.LABEL_HANDLE);\n        this.customHandles = this.createCustomHandles();\n        this.updateParentHighlight();\n        this.redraw();\n        // Handles escape keystrokes\n        this.escapeHandler = (sender, evt) => {\n            const dirty = this.index != null;\n            this.reset();\n            if (dirty) {\n                this.graph.cellRenderer.redraw(this.state, false, state.view.isRendering());\n            }\n        };\n        this.state.view.graph.addListener(InternalEvent.ESCAPE, this.escapeHandler);\n    }\n    /**\n     * Returns true if the parent highlight should be visible. This implementation\n     * always returns true.\n     */\n    isParentHighlightVisible() {\n        const parent = this.state.cell.getParent();\n        return parent ? !this.graph.isCellSelected(parent) : null;\n    }\n    /**\n     * Updates the highlight of the parent if <parentHighlightEnabled> is true.\n     */\n    updateParentHighlight() {\n        if (!this.isDestroyed()) {\n            const visible = this.isParentHighlightVisible();\n            const parent = this.state.cell.getParent();\n            const pstate = parent ? this.graph.view.getState(parent) : null;\n            if (this.parentHighlight) {\n                if (parent && parent.isVertex() && visible) {\n                    const b = this.parentHighlight.bounds;\n                    if (pstate &&\n                        b &&\n                        (b.x !== pstate.x ||\n                            b.y !== pstate.y ||\n                            b.width !== pstate.width ||\n                            b.height !== pstate.height)) {\n                        this.parentHighlight.bounds = Rectangle.fromRectangle(pstate);\n                        this.parentHighlight.redraw();\n                    }\n                }\n                else {\n                    if (pstate && pstate.parentHighlight === this.parentHighlight) {\n                        pstate.parentHighlight = null;\n                    }\n                    this.parentHighlight.destroy();\n                    this.parentHighlight = null;\n                }\n            }\n            else if (this.parentHighlightEnabled && visible) {\n                if (parent && parent.isVertex() && pstate && !pstate.parentHighlight) {\n                    this.parentHighlight = this.createParentHighlightShape(pstate);\n                    // VML dialect required here for event transparency in IE\n                    this.parentHighlight.dialect = DIALECT.SVG;\n                    this.parentHighlight.pointerEvents = false;\n                    if (pstate.style.rotation) {\n                        this.parentHighlight.rotation = pstate.style.rotation;\n                    }\n                    this.parentHighlight.init(this.graph.getView().getOverlayPane());\n                    this.parentHighlight.redraw();\n                    // Shows highlight once per parent\n                    pstate.parentHighlight = this.parentHighlight;\n                }\n            }\n        }\n    }\n    /**\n     * Returns an array of custom handles. This implementation returns an empty array.\n     */\n    createCustomHandles() {\n        return [];\n    }\n    /**\n     * Returns true if virtual bends should be added. This returns true if\n     * <virtualBendsEnabled> is true and the current style allows and\n     * renders custom waypoints.\n     */\n    isVirtualBendsEnabled(evt) {\n        return (this.virtualBendsEnabled &&\n            (this.state.style.edgeStyle == null ||\n                this.state.style.edgeStyle === NONE ||\n                this.state.style.noEdgeStyle) &&\n            this.state.style.shape !== 'arrow');\n    }\n    /**\n     * Returns true if the given cell allows new connections to be created. This implementation\n     * always returns true.\n     */\n    isCellEnabled(cell) {\n        return true;\n    }\n    /**\n     * Returns true if the given event is a trigger to add a new Point. This\n     * implementation returns true if shift is pressed.\n     */\n    isAddPointEvent(evt) {\n        return isShiftDown(evt);\n    }\n    /**\n     * Returns true if the given event is a trigger to remove a point. This\n     * implementation returns true if shift is pressed.\n     */\n    isRemovePointEvent(evt) {\n        return isShiftDown(evt);\n    }\n    /**\n     * Returns the list of points that defines the selection stroke.\n     */\n    getSelectionPoints(state) {\n        return state.absolutePoints;\n    }\n    /**\n     * Creates the shape used to draw the selection border.\n     */\n    createParentHighlightShape(bounds) {\n        const shape = new RectangleShape(Rectangle.fromRectangle(bounds), NONE, this.getSelectionColor());\n        shape.strokeWidth = this.getSelectionStrokeWidth();\n        shape.isDashed = this.isSelectionDashed();\n        return shape;\n    }\n    /**\n     * Creates the shape used to draw the selection border.\n     */\n    createSelectionShape(points) {\n        const c = this.state.shape.constructor;\n        const shape = new c();\n        shape.outline = true;\n        shape.apply(this.state);\n        shape.isDashed = this.isSelectionDashed();\n        shape.stroke = this.getSelectionColor();\n        shape.isShadow = false;\n        return shape;\n    }\n    /**\n     * Returns {@link EDGE_SELECTION_COLOR}.\n     */\n    getSelectionColor() {\n        return EDGE_SELECTION_COLOR;\n    }\n    /**\n     * Returns {@link EDGE_SELECTION_STROKEWIDTH}.\n     */\n    getSelectionStrokeWidth() {\n        return EDGE_SELECTION_STROKEWIDTH;\n    }\n    /**\n     * Returns {@link EDGE_SELECTION_DASHED}.\n     */\n    isSelectionDashed() {\n        return EDGE_SELECTION_DASHED;\n    }\n    /**\n     * Returns true if the given cell is connectable. This is a hook to\n     * disable floating connections. This implementation returns true.\n     */\n    isConnectableCell(cell) {\n        return true;\n    }\n    /**\n     * Creates and returns the {@link CellMarker} used in {@link marker}.\n     */\n    getCellAt(x, y) {\n        return !this.outlineConnect ? this.graph.getCellAt(x, y) : null;\n    }\n    /**\n     * Creates and returns the {@link CellMarker} used in {@link marker}.\n     */\n    createMarker() {\n        return new EdgeHandlerCellMarker(this.graph, this);\n    }\n    /**\n     * Returns the error message or an empty string if the connection for the\n     * given source, target pair is not valid. Otherwise it returns null. This\n     * implementation uses {@link Graph#getEdgeValidationError}.\n     *\n     * @param source <Cell> that represents the source terminal.\n     * @param target <Cell> that represents the target terminal.\n     */\n    validateConnection(source, target) {\n        return this.graph.getEdgeValidationError(this.state.cell, source, target);\n    }\n    /**\n     * Creates and returns the bends used for modifying the edge. This is\n     * typically an array of {@link RectangleShape}.\n     */\n    createBends() {\n        const { cell } = this.state;\n        const bends = [];\n        for (let i = 0; i < this.abspoints.length; i += 1) {\n            if (this.isHandleVisible(i)) {\n                const source = i === 0;\n                const target = i === this.abspoints.length - 1;\n                const terminal = source || target;\n                if (terminal || this.graph.isCellBendable(cell)) {\n                    ((index) => {\n                        const bend = this.createHandleShape(index);\n                        this.initBend(bend, () => {\n                            if (this.dblClickRemoveEnabled) {\n                                this.removePoint(this.state, index);\n                            }\n                        });\n                        if (this.isHandleEnabled(i)) {\n                            bend.setCursor(terminal ? CURSOR.TERMINAL_HANDLE : CURSOR.BEND_HANDLE);\n                        }\n                        bends.push(bend);\n                        if (!terminal) {\n                            this.points.push(new Point(0, 0));\n                            bend.node.style.visibility = 'hidden';\n                        }\n                    })(i);\n                }\n            }\n        }\n        return bends;\n    }\n    /**\n     * Creates and returns the bends used for modifying the edge. This is\n     * typically an array of {@link RectangleShape}.\n     */\n    // createVirtualBends(): mxRectangleShape[];\n    createVirtualBends() {\n        const { cell } = this.state;\n        const last = this.abspoints[0];\n        const bends = [];\n        if (this.graph.isCellBendable(cell)) {\n            for (let i = 1; i < this.abspoints.length; i += 1) {\n                ((bend) => {\n                    this.initBend(bend);\n                    bend.setCursor(CURSOR.VIRTUAL_BEND_HANDLE);\n                    bends.push(bend);\n                })(this.createHandleShape());\n            }\n        }\n        return bends;\n    }\n    /**\n     * Creates the shape used to display the given bend.\n     */\n    isHandleEnabled(index) {\n        return true;\n    }\n    /**\n     * Returns true if the handle at the given index is visible.\n     */\n    isHandleVisible(index) {\n        const source = this.state.getVisibleTerminalState(true);\n        const target = this.state.getVisibleTerminalState(false);\n        const geo = this.state.cell.getGeometry();\n        const edgeStyle = geo\n            ? this.graph.view.getEdgeStyle(this.state, geo.points || undefined, source, target)\n            : null;\n        return (edgeStyle !== EdgeStyle.EntityRelation ||\n            index === 0 ||\n            index === this.abspoints.length - 1);\n    }\n    /**\n     * Creates the shape used to display the given bend. Note that the index may be\n     * null for special cases, such as when called from\n     * {@link ElbowEdgeHandler#createVirtualBend}. Only images and rectangles should be\n     * returned if support for HTML labels with not foreign objects is required.\n     * Index if null for virtual handles.\n     */\n    createHandleShape(index) {\n        if (this.handleImage) {\n            const shape = new ImageShape(new Rectangle(0, 0, this.handleImage.width, this.handleImage.height), this.handleImage.src);\n            // Allows HTML rendering of the images\n            shape.preserveImageAspect = false;\n            return shape;\n        }\n        let s = HANDLE_SIZE;\n        if (this.preferHtml) {\n            s -= 1;\n        }\n        return new RectangleShape(new Rectangle(0, 0, s, s), HANDLE_FILLCOLOR, HANDLE_STROKECOLOR);\n    }\n    /**\n     * Creates the shape used to display the the label handle.\n     */\n    createLabelHandleShape() {\n        if (this.labelHandleImage) {\n            const shape = new ImageShape(new Rectangle(0, 0, this.labelHandleImage.width, this.labelHandleImage.height), this.labelHandleImage.src);\n            // Allows HTML rendering of the images\n            shape.preserveImageAspect = false;\n            return shape;\n        }\n        const s = LABEL_HANDLE_SIZE;\n        return new RectangleShape(new Rectangle(0, 0, s, s), LABEL_HANDLE_FILLCOLOR, HANDLE_STROKECOLOR);\n    }\n    /**\n     * Helper method to initialize the given bend.\n     *\n     * @param bend {@link Shape} that represents the bend to be initialized.\n     */\n    initBend(bend, dblClick) {\n        if (this.preferHtml) {\n            bend.dialect = DIALECT.STRICTHTML;\n            bend.init(this.graph.container);\n        }\n        else {\n            bend.dialect = this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;\n            bend.init(this.graph.getView().getOverlayPane());\n        }\n        InternalEvent.redirectMouseEvents(bend.node, this.graph, this.state, null, null, null, dblClick);\n        if (Client.IS_TOUCH) {\n            bend.node.setAttribute('pointer-events', 'none');\n        }\n    }\n    /**\n     * Returns the index of the handle for the given event.\n     */\n    getHandleForEvent(me) {\n        let result = null;\n        // Connection highlight may consume events before they reach sizer handle\n        const tol = !isMouseEvent(me.getEvent()) ? this.tolerance : 1;\n        const hit = this.allowHandleBoundsCheck && tol > 0\n            ? new Rectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol)\n            : null;\n        let minDistSq = Number.POSITIVE_INFINITY;\n        function checkShape(shape) {\n            if (shape &&\n                shape.bounds &&\n                shape.node &&\n                shape.node.style.display !== 'none' &&\n                shape.node.style.visibility !== 'hidden' &&\n                (me.isSource(shape) || (hit && intersects(shape.bounds, hit)))) {\n                const dx = me.getGraphX() - shape.bounds.getCenterX();\n                const dy = me.getGraphY() - shape.bounds.getCenterY();\n                const tmp = dx * dx + dy * dy;\n                if (tmp <= minDistSq) {\n                    minDistSq = tmp;\n                    return true;\n                }\n            }\n            return false;\n        }\n        if (this.isCustomHandleEvent(me) && this.customHandles) {\n            // Inverse loop order to match display order\n            for (let i = this.customHandles.length - 1; i >= 0; i--) {\n                if (checkShape(this.customHandles[i].shape)) {\n                    // LATER: Return reference to active shape\n                    return InternalEvent.CUSTOM_HANDLE - i;\n                }\n            }\n        }\n        if (me.isSource(this.state.text) || checkShape(this.labelShape)) {\n            result = InternalEvent.LABEL_HANDLE;\n        }\n        for (let i = 0; i < this.bends.length; i += 1) {\n            if (checkShape(this.bends[i])) {\n                result = i;\n            }\n        }\n        if (this.virtualBends && this.isAddVirtualBendEvent(me)) {\n            for (let i = 0; i < this.virtualBends.length; i += 1) {\n                if (checkShape(this.virtualBends[i])) {\n                    result = InternalEvent.VIRTUAL_HANDLE - i;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Returns true if the given event allows virtual bends to be added. This\n     * implementation returns true.\n     */\n    isAddVirtualBendEvent(me) {\n        return true;\n    }\n    /**\n     * Returns true if the given event allows custom handles to be changed. This\n     * implementation returns true.\n     */\n    isCustomHandleEvent(me) {\n        return true;\n    }\n    /**\n     * Handles the event by checking if a special element of the handler\n     * was clicked, in which case the index parameter is non-null. The\n     * indices may be one of <LABEL_HANDLE> or the number of the respective\n     * control point. The source and target points are used for reconnecting\n     * the edge.\n     */\n    mouseDown(sender, me) {\n        const handle = this.getHandleForEvent(me);\n        if (handle !== null && this.bends[handle]) {\n            const b = this.bends[handle].bounds;\n            if (b)\n                this.snapPoint = new Point(b.getCenterX(), b.getCenterY());\n        }\n        if (this.addEnabled && handle === null && this.isAddPointEvent(me.getEvent())) {\n            this.addPoint(this.state, me.getEvent());\n            me.consume();\n        }\n        else if (handle !== null && !me.isConsumed() && this.graph.isEnabled()) {\n            const cell = me.getCell();\n            if (this.removeEnabled && this.isRemovePointEvent(me.getEvent())) {\n                this.removePoint(this.state, handle);\n            }\n            else if (handle !== InternalEvent.LABEL_HANDLE ||\n                (cell && this.graph.isLabelMovable(cell))) {\n                if (this.virtualBends && handle <= InternalEvent.VIRTUAL_HANDLE) {\n                    setOpacity(this.virtualBends[InternalEvent.VIRTUAL_HANDLE - handle].node, 100);\n                }\n                this.start(me.getX(), me.getY(), handle);\n            }\n            me.consume();\n        }\n    }\n    /**\n     * Starts the handling of the mouse gesture.\n     */\n    start(x, y, index) {\n        this.startX = x;\n        this.startY = y;\n        this.isSource = this.bends.length === 0 ? false : index === 0;\n        this.isTarget = this.bends.length === 0 ? false : index === this.bends.length - 1;\n        this.isLabel = index === InternalEvent.LABEL_HANDLE;\n        if (this.isSource || this.isTarget) {\n            const { cell } = this.state;\n            const terminal = cell.getTerminal(this.isSource);\n            if ((terminal == null && this.graph.isTerminalPointMovable(cell, this.isSource)) ||\n                (terminal != null &&\n                    this.graph.isCellDisconnectable(cell, terminal, this.isSource))) {\n                this.index = index;\n            }\n        }\n        else {\n            this.index = index;\n        }\n        // Hides other custom handles\n        if (this.index !== null &&\n            this.index <= InternalEvent.CUSTOM_HANDLE &&\n            this.index > InternalEvent.VIRTUAL_HANDLE) {\n            if (this.customHandles != null) {\n                for (let i = 0; i < this.customHandles.length; i += 1) {\n                    if (i !== InternalEvent.CUSTOM_HANDLE - this.index) {\n                        this.customHandles[i].setVisible(false);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Returns a clone of the current preview state for the given point and terminal.\n     */\n    clonePreviewState(point, terminal) {\n        return this.state.clone();\n    }\n    /**\n     * Returns the tolerance for the guides. Default value is\n     * gridSize * scale / 2.\n     */\n    getSnapToTerminalTolerance() {\n        return (this.graph.getGridSize() * this.graph.getView().scale) / 2;\n    }\n    /**\n     * Hook for subclassers do show details while the handler is active.\n     */\n    updateHint(me, point) {\n        return;\n    }\n    /**\n     * Hooks for subclassers to hide details when the handler gets inactive.\n     */\n    removeHint() {\n        return;\n    }\n    /**\n     * Hook for rounding the unscaled width or height. This uses Math.round.\n     */\n    roundLength(length) {\n        return Math.round(length);\n    }\n    /**\n     * Returns true if <snapToTerminals> is true and if alt is not pressed.\n     */\n    isSnapToTerminalsEvent(me) {\n        return this.snapToTerminals && !isAltDown(me.getEvent());\n    }\n    /**\n     * Returns the point for the given event.\n     */\n    // getPointForEvent(me: mxMouseEvent): mxPoint;\n    getPointForEvent(me) {\n        const view = this.graph.getView();\n        const { scale } = view;\n        const point = new Point(this.roundLength(me.getGraphX() / scale) * scale, this.roundLength(me.getGraphY() / scale) * scale);\n        const tt = this.getSnapToTerminalTolerance();\n        let overrideX = false;\n        let overrideY = false;\n        if (tt > 0 && this.isSnapToTerminalsEvent(me)) {\n            const snapToPoint = (pt) => {\n                if (pt) {\n                    const { x } = pt;\n                    if (Math.abs(point.x - x) < tt) {\n                        point.x = x;\n                        overrideX = true;\n                    }\n                    const { y } = pt;\n                    if (Math.abs(point.y - y) < tt) {\n                        point.y = y;\n                        overrideY = true;\n                    }\n                }\n            };\n            // Temporary function\n            const snapToTerminal = (terminal) => {\n                if (terminal) {\n                    snapToPoint(new Point(view.getRoutingCenterX(terminal), view.getRoutingCenterY(terminal)));\n                }\n            };\n            snapToTerminal(this.state.getVisibleTerminalState(true));\n            snapToTerminal(this.state.getVisibleTerminalState(false));\n            for (let i = 0; i < this.state.absolutePoints.length; i += 1) {\n                snapToPoint(this.state.absolutePoints[i]);\n            }\n        }\n        if (this.graph.isGridEnabledEvent(me.getEvent())) {\n            const tr = view.translate;\n            if (!overrideX) {\n                point.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;\n            }\n            if (!overrideY) {\n                point.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;\n            }\n        }\n        return point;\n    }\n    /**\n     * Updates the given preview state taking into account the state of the constraint handler.\n     */\n    getPreviewTerminalState(me) {\n        this.constraintHandler.update(me, this.isSource, true, me.isSource(this.marker.highlight.shape) ? null : this.currentPoint);\n        if (this.constraintHandler.currentFocus && this.constraintHandler.currentConstraint) {\n            // Handles special case where grid is large and connection point is at actual point in which\n            // case the outline is not followed as long as we're < gridSize / 2 away from that point\n            if (this.marker.highlight &&\n                this.marker.highlight.shape &&\n                this.marker.highlight.state &&\n                this.marker.highlight.state.cell === this.constraintHandler.currentFocus.cell) {\n                // Direct repaint needed if cell already highlighted\n                if (this.marker.highlight.shape.stroke !== 'transparent') {\n                    this.marker.highlight.shape.stroke = 'transparent';\n                    this.marker.highlight.repaint();\n                }\n            }\n            else {\n                this.marker.markCell(this.constraintHandler.currentFocus.cell, 'transparent');\n            }\n            const other = this.graph.view.getTerminalPort(this.state, this.graph.view.getState(this.state.cell.getTerminal(!this.isSource)), !this.isSource);\n            const otherCell = other ? other.cell : null;\n            const source = this.isSource ? this.constraintHandler.currentFocus.cell : otherCell;\n            const target = this.isSource ? otherCell : this.constraintHandler.currentFocus.cell;\n            // Updates the error message of the handler\n            this.error = this.validateConnection(source, target);\n            let result = null;\n            if (this.error === null) {\n                result = this.constraintHandler.currentFocus;\n            }\n            if (this.error !== null || (result && !this.isCellEnabled(result.cell))) {\n                this.constraintHandler.reset();\n            }\n            return result;\n        }\n        if (!this.graph.isIgnoreTerminalEvent(me.getEvent())) {\n            this.marker.process(me);\n            const state = this.marker.getValidState();\n            if (state && !this.isCellEnabled(state.cell)) {\n                this.constraintHandler.reset();\n                this.marker.reset();\n            }\n            return this.marker.getValidState();\n        }\n        this.marker.reset();\n        return null;\n    }\n    /**\n     * Updates the given preview state taking into account the state of the constraint handler.\n     *\n     * @param pt {@link Point} that contains the current pointer position.\n     * @param me Optional {@link MouseEvent} that contains the current event.\n     */\n    getPreviewPoints(pt, me) {\n        const geometry = this.state.cell.getGeometry();\n        if (!geometry)\n            return null;\n        let points = (geometry.points || []).slice();\n        const point = new Point(pt.x, pt.y);\n        let result = null;\n        if (!this.isSource && !this.isTarget && this.index !== null) {\n            this.convertPoint(point, false);\n            // Adds point from virtual bend\n            if (this.index <= InternalEvent.VIRTUAL_HANDLE) {\n                points.splice(InternalEvent.VIRTUAL_HANDLE - this.index, 0, point);\n            }\n            // Removes point if dragged on terminal point\n            if (!this.isSource && !this.isTarget) {\n                for (let i = 0; i < this.bends.length; i += 1) {\n                    if (i !== this.index) {\n                        const bend = this.bends[i];\n                        if (bend && contains(bend.bounds, pt.x, pt.y)) {\n                            if (this.index <= InternalEvent.VIRTUAL_HANDLE) {\n                                points.splice(InternalEvent.VIRTUAL_HANDLE - this.index, 1);\n                            }\n                            else {\n                                points.splice(this.index - 1, 1);\n                            }\n                            result = points;\n                        }\n                    }\n                }\n                // Removes point if user tries to straighten a segment\n                if (!result && this.straightRemoveEnabled && (!me || !isAltDown(me.getEvent()))) {\n                    const tol = this.graph.getEventTolerance() * this.graph.getEventTolerance();\n                    const abs = this.state.absolutePoints.slice();\n                    abs[this.index] = pt;\n                    // Handes special case where removing waypoint affects tolerance (flickering)\n                    const src = this.state.getVisibleTerminalState(true);\n                    if (src != null) {\n                        const c = this.graph.getConnectionConstraint(this.state, src, true);\n                        // Checks if point is not fixed\n                        if (c == null || this.graph.getConnectionPoint(src, c) == null) {\n                            abs[0] = new Point(src.view.getRoutingCenterX(src), src.view.getRoutingCenterY(src));\n                        }\n                    }\n                    const trg = this.state.getVisibleTerminalState(false);\n                    if (trg != null) {\n                        const c = this.graph.getConnectionConstraint(this.state, trg, false);\n                        // Checks if point is not fixed\n                        if (c == null || this.graph.getConnectionPoint(trg, c) == null) {\n                            abs[abs.length - 1] = new Point(trg.view.getRoutingCenterX(trg), trg.view.getRoutingCenterY(trg));\n                        }\n                    }\n                    const checkRemove = (idx, tmp) => {\n                        if (idx > 0 &&\n                            idx < abs.length - 1 &&\n                            ptSegDistSq(abs[idx - 1].x, abs[idx - 1].y, abs[idx + 1].x, abs[idx + 1].y, tmp.x, tmp.y) < tol) {\n                            points.splice(idx - 1, 1);\n                            result = points;\n                        }\n                    };\n                    // LATER: Check if other points can be removed if a segment is made straight\n                    checkRemove(this.index, pt);\n                }\n            }\n            // Updates existing point\n            if (result == null && this.index > InternalEvent.VIRTUAL_HANDLE) {\n                points[this.index - 1] = point;\n            }\n        }\n        else if (this.graph.isResetEdgesOnConnect()) {\n            points = [];\n        }\n        return result != null ? result : points;\n    }\n    /**\n     * Returns true if <outlineConnect> is true and the source of the event is the outline shape\n     * or shift is pressed.\n     */\n    isOutlineConnectEvent(me) {\n        if (!this.currentPoint)\n            return false;\n        const offset = getOffset(this.graph.container);\n        const evt = me.getEvent();\n        const clientX = getClientX(evt);\n        const clientY = getClientY(evt);\n        const doc = document.documentElement;\n        const left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n        const top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n        const gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;\n        const gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;\n        return (this.outlineConnect &&\n            !isShiftDown(me.getEvent()) &&\n            (me.isSource(this.marker.highlight.shape) ||\n                (isAltDown(me.getEvent()) && me.getState() != null) ||\n                this.marker.highlight.isHighlightAt(clientX, clientY) ||\n                ((gridX !== clientX || gridY !== clientY) &&\n                    me.getState() == null &&\n                    this.marker.highlight.isHighlightAt(gridX, gridY))));\n    }\n    /**\n     * Updates the given preview state taking into account the state of the constraint handler.\n     */\n    updatePreviewState(edgeState, point, terminalState, me, outline = false) {\n        // Computes the points for the edge style and terminals\n        const sourceState = this.isSource\n            ? terminalState\n            : this.state.getVisibleTerminalState(true);\n        const targetState = this.isTarget\n            ? terminalState\n            : this.state.getVisibleTerminalState(false);\n        let sourceConstraint = this.graph.getConnectionConstraint(edgeState, sourceState, true);\n        let targetConstraint = this.graph.getConnectionConstraint(edgeState, targetState, false);\n        let constraint = this.constraintHandler.currentConstraint;\n        if (constraint == null && outline) {\n            if (terminalState != null) {\n                // Handles special case where mouse is on outline away from actual end point\n                // in which case the grid is ignored and mouse point is used instead\n                if (me.isSource(this.marker.highlight.shape)) {\n                    point = new Point(me.getGraphX(), me.getGraphY());\n                }\n                constraint = this.graph.getOutlineConstraint(point, terminalState, me);\n                this.constraintHandler.setFocus(me, terminalState, this.isSource);\n                this.constraintHandler.currentConstraint = constraint;\n                this.constraintHandler.currentPoint = point;\n            }\n            else {\n                constraint = new ConnectionConstraint(null);\n            }\n        }\n        if (this.outlineConnect &&\n            this.marker.highlight != null &&\n            this.marker.highlight.shape != null) {\n            const s = this.graph.view.scale;\n            if (this.constraintHandler.currentConstraint != null &&\n                this.constraintHandler.currentFocus != null) {\n                this.marker.highlight.shape.stroke = outline\n                    ? OUTLINE_HIGHLIGHT_COLOR\n                    : 'transparent';\n                this.marker.highlight.shape.strokeWidth = OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;\n                this.marker.highlight.repaint();\n            }\n            else if (this.marker.hasValidState()) {\n                const cell = me.getCell();\n                this.marker.highlight.shape.stroke =\n                    cell && cell.isConnectable() && this.marker.getValidState() !== me.getState()\n                        ? 'transparent'\n                        : DEFAULT_VALID_COLOR;\n                this.marker.highlight.shape.strokeWidth = HIGHLIGHT_STROKEWIDTH / s / s;\n                this.marker.highlight.repaint();\n            }\n        }\n        if (this.isSource) {\n            sourceConstraint = constraint;\n        }\n        else if (this.isTarget) {\n            targetConstraint = constraint;\n        }\n        if (this.isSource || this.isTarget) {\n            if (constraint != null && constraint.point != null) {\n                edgeState.style[this.isSource ? 'exitX' : 'entryX'] = constraint.point.x;\n                edgeState.style[this.isSource ? 'exitY' : 'entryY'] = constraint.point.y;\n            }\n            else {\n                delete edgeState.style[this.isSource ? 'exitX' : 'entryX'];\n                delete edgeState.style[this.isSource ? 'exitY' : 'entryY'];\n            }\n        }\n        edgeState.setVisibleTerminalState(sourceState, true);\n        edgeState.setVisibleTerminalState(targetState, false);\n        if (!this.isSource || sourceState != null) {\n            edgeState.view.updateFixedTerminalPoint(edgeState, sourceState, true, sourceConstraint);\n        }\n        if (!this.isTarget || targetState != null) {\n            edgeState.view.updateFixedTerminalPoint(edgeState, targetState, false, targetConstraint);\n        }\n        if ((this.isSource || this.isTarget) && terminalState == null) {\n            edgeState.setAbsoluteTerminalPoint(point, this.isSource);\n            if (this.marker.getMarkedState() == null) {\n                this.error = this.graph.isAllowDanglingEdges() ? null : '';\n            }\n        }\n        edgeState.view.updatePoints(edgeState, this.points, sourceState, targetState);\n        edgeState.view.updateFloatingTerminalPoints(edgeState, sourceState, targetState);\n    }\n    /**\n     * Handles the event by updating the preview.\n     */\n    mouseMove(sender, me) {\n        if (this.index != null && this.marker != null) {\n            this.currentPoint = this.getPointForEvent(me);\n            this.error = null;\n            // Uses the current point from the constraint handler if available\n            if (!this.graph.isIgnoreTerminalEvent(me.getEvent()) &&\n                isShiftDown(me.getEvent()) &&\n                this.snapPoint != null) {\n                if (Math.abs(this.snapPoint.x - this.currentPoint.x) <\n                    Math.abs(this.snapPoint.y - this.currentPoint.y)) {\n                    this.currentPoint.x = this.snapPoint.x;\n                }\n                else {\n                    this.currentPoint.y = this.snapPoint.y;\n                }\n            }\n            if (this.index <= InternalEvent.CUSTOM_HANDLE &&\n                this.index > InternalEvent.VIRTUAL_HANDLE) {\n                if (this.customHandles != null) {\n                    this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].processEvent(me);\n                    this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].positionChanged();\n                    if (this.shape != null && this.shape.node != null) {\n                        this.shape.node.style.display = 'none';\n                    }\n                }\n            }\n            else if (this.isLabel && this.label) {\n                this.label.x = this.currentPoint.x;\n                this.label.y = this.currentPoint.y;\n            }\n            else {\n                this.points = this.getPreviewPoints(this.currentPoint, me);\n                let terminalState = this.isSource || this.isTarget ? this.getPreviewTerminalState(me) : null;\n                if (this.constraintHandler.currentConstraint != null &&\n                    this.constraintHandler.currentFocus != null &&\n                    this.constraintHandler.currentPoint != null) {\n                    this.currentPoint = this.constraintHandler.currentPoint.clone();\n                }\n                else if (this.outlineConnect) {\n                    // Need to check outline before cloning terminal state\n                    const outline = this.isSource || this.isTarget ? this.isOutlineConnectEvent(me) : false;\n                    if (outline) {\n                        terminalState = this.marker.highlight.state;\n                    }\n                    else if (terminalState != null &&\n                        terminalState !== me.getState() &&\n                        me.getCell()?.isConnectable() &&\n                        this.marker.highlight.shape != null) {\n                        this.marker.highlight.shape.stroke = 'transparent';\n                        this.marker.highlight.repaint();\n                        terminalState = null;\n                    }\n                }\n                if (terminalState != null && !this.isCellEnabled(terminalState.cell)) {\n                    terminalState = null;\n                    this.marker.reset();\n                }\n                if (this.currentPoint) {\n                    const clone = this.clonePreviewState(this.currentPoint, terminalState != null ? terminalState.cell : null);\n                    this.updatePreviewState(clone, this.currentPoint, terminalState, me, this.outline);\n                    // Sets the color of the preview to valid or invalid, updates the\n                    // points of the preview and redraws\n                    const color = this.error == null ? this.marker.validColor : this.marker.invalidColor;\n                    this.setPreviewColor(color);\n                    this.abspoints = clone.absolutePoints;\n                    this.active = true;\n                    this.updateHint(me, this.currentPoint);\n                }\n            }\n            // This should go before calling isOutlineConnectEvent above. As a workaround\n            // we add an offset of gridSize to the hint to avoid problem with hit detection\n            // in highlight.isHighlightAt (which uses comonentFromPoint)\n            this.drawPreview();\n            InternalEvent.consume(me.getEvent());\n            me.consume();\n        }\n    }\n    /**\n     * Handles the event to applying the previewed changes on the edge by\n     * using {@link moveLabel}, <connect> or <changePoints>.\n     */\n    mouseUp(sender, me) {\n        // Workaround for wrong event source in Webkit\n        if (this.index != null && this.marker != null) {\n            if (this.shape != null && this.shape.node != null) {\n                this.shape.node.style.display = '';\n            }\n            let edge = this.state.cell;\n            const { index } = this;\n            this.index = null;\n            // Ignores event if mouse has not been moved\n            if (me.getX() !== this.startX || me.getY() !== this.startY) {\n                const clone = !this.graph.isIgnoreTerminalEvent(me.getEvent()) &&\n                    this.graph.isCloneEvent(me.getEvent()) &&\n                    this.cloneEnabled &&\n                    this.graph.isCellsCloneable();\n                // Displays the reason for not carriying out the change\n                // if there is an error message with non-zero length\n                if (this.error != null) {\n                    if (this.error.length > 0) {\n                        this.graph.validationAlert(this.error);\n                    }\n                }\n                else if (index <= InternalEvent.CUSTOM_HANDLE &&\n                    index > InternalEvent.VIRTUAL_HANDLE) {\n                    if (this.customHandles != null) {\n                        const model = this.graph.getDataModel();\n                        model.beginUpdate();\n                        try {\n                            this.customHandles[InternalEvent.CUSTOM_HANDLE - index].execute(me);\n                            if (this.shape != null && this.shape.node != null) {\n                                this.shape.apply(this.state);\n                                this.shape.redraw();\n                            }\n                        }\n                        finally {\n                            model.endUpdate();\n                        }\n                    }\n                }\n                else if (this.isLabel && this.label) {\n                    this.moveLabel(this.state, this.label.x, this.label.y);\n                }\n                else if (this.isSource || this.isTarget) {\n                    let terminal = null;\n                    if (this.constraintHandler.currentConstraint != null &&\n                        this.constraintHandler.currentFocus != null) {\n                        terminal = this.constraintHandler.currentFocus.cell;\n                    }\n                    if (!terminal &&\n                        this.marker.hasValidState() &&\n                        this.marker.highlight != null &&\n                        this.marker.highlight.shape != null &&\n                        this.marker.highlight.shape.stroke !== 'transparent' &&\n                        this.marker.highlight.shape.stroke !== 'white') {\n                        terminal = this.marker.validState.cell;\n                    }\n                    if (terminal) {\n                        const model = this.graph.getDataModel();\n                        const parent = edge.getParent();\n                        model.beginUpdate();\n                        try {\n                            // Clones and adds the cell\n                            if (clone) {\n                                let geo = edge.getGeometry();\n                                const cloned = this.graph.cloneCell(edge);\n                                model.add(parent, cloned, parent.getChildCount());\n                                if (geo != null) {\n                                    geo = geo.clone();\n                                    model.setGeometry(cloned, geo);\n                                }\n                                const other = edge.getTerminal(!this.isSource);\n                                this.graph.connectCell(cloned, other, !this.isSource);\n                                edge = cloned;\n                            }\n                            edge = this.connect(edge, terminal, this.isSource, clone, me);\n                        }\n                        finally {\n                            model.endUpdate();\n                        }\n                    }\n                    else if (this.graph.isAllowDanglingEdges()) {\n                        const pt = this.abspoints[this.isSource ? 0 : this.abspoints.length - 1];\n                        pt.x = this.roundLength(pt.x / this.graph.view.scale - this.graph.view.translate.x);\n                        pt.y = this.roundLength(pt.y / this.graph.view.scale - this.graph.view.translate.y);\n                        const parent = edge.getParent();\n                        const pstate = parent ? this.graph.getView().getState(parent) : null;\n                        if (pstate != null) {\n                            pt.x -= pstate.origin.x;\n                            pt.y -= pstate.origin.y;\n                        }\n                        pt.x -= this.graph.getPanDx() / this.graph.view.scale;\n                        pt.y -= this.graph.getPanDy() / this.graph.view.scale;\n                        // Destroys and recreates this handler\n                        edge = this.changeTerminalPoint(edge, pt, this.isSource, clone);\n                    }\n                }\n                else if (this.active) {\n                    edge = this.changePoints(edge, this.points, clone);\n                }\n                else {\n                    this.graph.getView().invalidate(this.state.cell);\n                    this.graph.getView().validate(this.state.cell);\n                }\n            }\n            else if (this.graph.isToggleEvent(me.getEvent())) {\n                this.graph.selectCellForEvent(this.state.cell, me.getEvent());\n            }\n            // Resets the preview color the state of the handler if this\n            // handler has not been recreated\n            if (this.marker != null) {\n                this.reset();\n                // Updates the selection if the edge has been cloned\n                if (edge !== this.state.cell) {\n                    this.graph.setSelectionCell(edge);\n                }\n            }\n            me.consume();\n        }\n    }\n    /**\n     * Resets the state of this handler.\n     */\n    reset() {\n        if (this.active) {\n            this.refresh();\n        }\n        this.error = null;\n        this.index = null;\n        this.points = [];\n        this.snapPoint = null;\n        this.isLabel = false;\n        this.isSource = false;\n        this.isTarget = false;\n        this.active = false;\n        if (this.marker) {\n            this.marker.reset();\n        }\n        this.constraintHandler.reset();\n        if (this.customHandles) {\n            for (let i = 0; i < this.customHandles.length; i += 1) {\n                this.customHandles[i].reset();\n            }\n        }\n        this.setPreviewColor(EDGE_SELECTION_COLOR);\n        this.removeHint();\n        this.redraw();\n    }\n    /**\n     * Sets the color of the preview to the given value.\n     */\n    setPreviewColor(color) {\n        this.shape.stroke = color;\n    }\n    /**\n     * Converts the given point in-place from screen to unscaled, untranslated\n     * graph coordinates and applies the grid. Returns the given, modified\n     * point instance.\n     *\n     * @param point {@link Point} to be converted.\n     * @param gridEnabled Boolean that specifies if the grid should be applied.\n     */\n    convertPoint(point, gridEnabled) {\n        const scale = this.graph.getView().getScale();\n        const tr = this.graph.getView().getTranslate();\n        if (gridEnabled) {\n            point.x = this.graph.snap(point.x);\n            point.y = this.graph.snap(point.y);\n        }\n        point.x = Math.round(point.x / scale - tr.x);\n        point.y = Math.round(point.y / scale - tr.y);\n        const parent = this.state.cell.getParent();\n        const pstate = parent ? this.graph.getView().getState(parent) : parent;\n        if (pstate) {\n            point.x -= pstate.origin.x;\n            point.y -= pstate.origin.y;\n        }\n        return point;\n    }\n    /**\n     * Changes the coordinates for the label of the given edge.\n     *\n     * @param edge <Cell> that represents the edge.\n     * @param x Integer that specifies the x-coordinate of the new location.\n     * @param y Integer that specifies the y-coordinate of the new location.\n     */\n    moveLabel(edgeState, x, y) {\n        const model = this.graph.getDataModel();\n        let geometry = edgeState.cell.getGeometry();\n        if (geometry != null) {\n            const { scale } = this.graph.getView();\n            geometry = geometry.clone();\n            if (geometry.relative) {\n                // Resets the relative location stored inside the geometry\n                let pt = this.graph.getView().getRelativePoint(edgeState, x, y);\n                geometry.x = Math.round(pt.x * 10000) / 10000;\n                geometry.y = Math.round(pt.y);\n                // Resets the offset inside the geometry to find the offset\n                // from the resulting point\n                geometry.offset = new Point(0, 0);\n                pt = this.graph.view.getPoint(edgeState, geometry);\n                geometry.offset = new Point(Math.round((x - pt.x) / scale), Math.round((y - pt.y) / scale));\n            }\n            else {\n                const points = edgeState.absolutePoints;\n                const p0 = points[0];\n                const pe = points[points.length - 1];\n                if (p0 != null && pe != null) {\n                    const cx = p0.x + (pe.x - p0.x) / 2;\n                    const cy = p0.y + (pe.y - p0.y) / 2;\n                    geometry.offset = new Point(Math.round((x - cx) / scale), Math.round((y - cy) / scale));\n                    geometry.x = 0;\n                    geometry.y = 0;\n                }\n            }\n            model.setGeometry(edgeState.cell, geometry);\n        }\n    }\n    /**\n     * Changes the terminal or terminal point of the given edge in the graph\n     * model.\n     *\n     * @param edge <Cell> that represents the edge to be reconnected.\n     * @param terminal <Cell> that represents the new terminal.\n     * @param isSource Boolean indicating if the new terminal is the source or\n     * target terminal.\n     * @param isClone Boolean indicating if the new connection should be a clone of\n     * the old edge.\n     * @param me {@link MouseEvent} that contains the mouse up event.\n     */\n    connect(edge, terminal, isSource, isClone, me) {\n        const parent = edge.getParent();\n        this.graph.batchUpdate(() => {\n            let constraint = this.constraintHandler.currentConstraint;\n            if (constraint == null) {\n                constraint = new ConnectionConstraint(null);\n            }\n            this.graph.connectCell(edge, terminal, isSource, constraint);\n        });\n        return edge;\n    }\n    /**\n     * Changes the terminal point of the given edge.\n     */\n    changeTerminalPoint(edge, point, isSource, clone) {\n        const model = this.graph.getDataModel();\n        model.batchUpdate(() => {\n            if (clone) {\n                const parent = edge.getParent();\n                const terminal = edge.getTerminal(!isSource);\n                edge = this.graph.cloneCell(edge);\n                model.add(parent, edge, parent.getChildCount());\n                model.setTerminal(edge, terminal, !isSource);\n            }\n            let geo = edge.getGeometry();\n            if (geo != null) {\n                geo = geo.clone();\n                geo.setTerminalPoint(point, isSource);\n                model.setGeometry(edge, geo);\n                this.graph.connectCell(edge, null, isSource, new ConnectionConstraint(null));\n            }\n        });\n        return edge;\n    }\n    /**\n     * Changes the control points of the given edge in the graph model.\n     */\n    changePoints(edge, points, clone) {\n        const model = this.graph.getDataModel();\n        model.batchUpdate(() => {\n            if (clone) {\n                const parent = edge.getParent();\n                const source = edge.getTerminal(true);\n                const target = edge.getTerminal(false);\n                edge = this.graph.cloneCell(edge);\n                model.add(parent, edge, parent.getChildCount());\n                model.setTerminal(edge, source, true);\n                model.setTerminal(edge, target, false);\n            }\n            let geo = edge.getGeometry();\n            if (geo != null) {\n                geo = geo.clone();\n                geo.points = points;\n                model.setGeometry(edge, geo);\n            }\n        });\n        return edge;\n    }\n    /**\n     * Adds a control point for the given state and event.\n     */\n    addPoint(state, evt) {\n        const pt = convertPoint(this.graph.container, getClientX(evt), getClientY(evt));\n        const gridEnabled = this.graph.isGridEnabledEvent(evt);\n        this.convertPoint(pt, gridEnabled);\n        this.addPointAt(state, pt.x, pt.y);\n        InternalEvent.consume(evt);\n    }\n    /**\n     * Adds a control point at the given point.\n     */\n    addPointAt(state, x, y) {\n        let geo = state.cell.getGeometry();\n        const pt = new Point(x, y);\n        if (geo != null) {\n            geo = geo.clone();\n            const t = this.graph.view.translate;\n            const s = this.graph.view.scale;\n            let offset = new Point(t.x * s, t.y * s);\n            const parent = this.state.cell.getParent();\n            if (parent && parent.isVertex()) {\n                const pState = this.graph.view.getState(parent);\n                if (pState)\n                    offset = new Point(pState.x, pState.y);\n            }\n            const index = findNearestSegment(state, pt.x * s + offset.x, pt.y * s + offset.y);\n            if (geo.points == null) {\n                geo.points = [pt];\n            }\n            else {\n                geo.points.splice(index, 0, pt);\n            }\n            this.graph.getDataModel().setGeometry(state.cell, geo);\n            this.refresh();\n            this.redraw();\n        }\n    }\n    /**\n     * Removes the control point at the given index from the given state.\n     */\n    removePoint(state, index) {\n        if (index > 0 && index < this.abspoints.length - 1) {\n            let geo = this.state.cell.getGeometry();\n            if (geo != null && geo.points != null) {\n                geo = geo.clone();\n                (geo.points || []).splice(index - 1, 1);\n                this.graph.getDataModel().setGeometry(state.cell, geo);\n                this.refresh();\n                this.redraw();\n            }\n        }\n    }\n    /**\n     * Returns the fillcolor for the handle at the given index.\n     */\n    getHandleFillColor(index) {\n        const isSource = index === 0;\n        const { cell } = this.state;\n        const terminal = cell.getTerminal(isSource);\n        let color = HANDLE_FILLCOLOR;\n        if ((terminal != null && !this.graph.isCellDisconnectable(cell, terminal, isSource)) ||\n            (terminal == null && !this.graph.isTerminalPointMovable(cell, isSource))) {\n            color = LOCKED_HANDLE_FILLCOLOR;\n        }\n        else if (terminal != null &&\n            this.graph.isCellDisconnectable(cell, terminal, isSource)) {\n            color = CONNECT_HANDLE_FILLCOLOR;\n        }\n        return color;\n    }\n    /**\n     * Redraws the preview, and the bends- and label control points.\n     */\n    redraw(ignoreHandles) {\n        this.abspoints = this.state.absolutePoints.slice();\n        const g = this.state.cell.getGeometry();\n        if (g) {\n            const pts = g.points;\n            if (this.bends != null && this.bends.length > 0) {\n                if (pts != null) {\n                    if (this.points == null) {\n                        this.points = [];\n                    }\n                    for (let i = 1; i < this.bends.length - 1; i += 1) {\n                        if (this.bends[i] != null && this.abspoints[i] != null) {\n                            this.points[i - 1] = pts[i - 1];\n                        }\n                    }\n                }\n            }\n        }\n        this.drawPreview();\n        if (!ignoreHandles) {\n            this.redrawHandles();\n        }\n    }\n    /**\n     * Redraws the handles.\n     */\n    redrawHandles() {\n        const { cell } = this.state;\n        // Updates the handle for the label position\n        let b = this.labelShape.bounds;\n        this.label = new Point(this.state.absoluteOffset.x, this.state.absoluteOffset.y);\n        this.labelShape.bounds = new Rectangle(Math.round(this.label.x - b.width / 2), Math.round(this.label.y - b.height / 2), b.width, b.height);\n        // Shows or hides the label handle depending on the label\n        const lab = this.graph.getLabel(cell);\n        this.labelShape.visible =\n            lab != null && lab.length > 0 && this.graph.isLabelMovable(cell);\n        if (this.bends != null && this.bends.length > 0) {\n            const n = this.abspoints.length - 1;\n            const p0 = this.abspoints[0];\n            const x0 = p0.x;\n            const y0 = p0.y;\n            b = this.bends[0].bounds;\n            this.bends[0].bounds = new Rectangle(Math.floor(x0 - b.width / 2), Math.floor(y0 - b.height / 2), b.width, b.height);\n            this.bends[0].fill = this.getHandleFillColor(0);\n            this.bends[0].redraw();\n            if (this.manageLabelHandle) {\n                this.checkLabelHandle(this.bends[0].bounds);\n            }\n            const pe = this.abspoints[n];\n            const xn = pe.x;\n            const yn = pe.y;\n            const bn = this.bends.length - 1;\n            b = this.bends[bn].bounds;\n            this.bends[bn].bounds = new Rectangle(Math.floor(xn - b.width / 2), Math.floor(yn - b.height / 2), b.width, b.height);\n            this.bends[bn].fill = this.getHandleFillColor(bn);\n            this.bends[bn].redraw();\n            if (this.manageLabelHandle) {\n                this.checkLabelHandle(this.bends[bn].bounds);\n            }\n            this.redrawInnerBends(p0, pe);\n        }\n        if (this.virtualBends && this.virtualBends.length > 0) {\n            let last = this.abspoints[0];\n            for (let i = 0; i < this.virtualBends.length; i += 1) {\n                if (this.virtualBends[i] != null && this.abspoints[i + 1] != null) {\n                    const pt = this.abspoints[i + 1];\n                    const b = this.virtualBends[i];\n                    const x = last.x + (pt.x - last.x) / 2;\n                    const y = last.y + (pt.y - last.y) / 2;\n                    if (b.bounds) {\n                        b.bounds = new Rectangle(Math.floor(x - b.bounds.width / 2), Math.floor(y - b.bounds.height / 2), b.bounds.width, b.bounds.height);\n                        b.redraw();\n                    }\n                    setOpacity(b.node, this.virtualBendOpacity);\n                    last = pt;\n                    if (this.manageLabelHandle) {\n                        this.checkLabelHandle(b.bounds);\n                    }\n                }\n            }\n        }\n        this.labelShape.redraw();\n        if (this.customHandles) {\n            for (let i = 0; i < this.customHandles.length; i += 1) {\n                const shape = this.customHandles[i].shape;\n                if (shape) {\n                    const temp = shape.node.style.display;\n                    this.customHandles[i].redraw();\n                    shape.node.style.display = temp;\n                    // Hides custom handles during text editing\n                    shape.node.style.visibility = this.isCustomHandleVisible(this.customHandles[i])\n                        ? ''\n                        : 'hidden';\n                }\n            }\n        }\n    }\n    /**\n     * Returns true if the given custom handle is visible.\n     */\n    isCustomHandleVisible(handle) {\n        return (!this.graph.isEditing() && this.state.view.graph.getSelectionCount() === 1);\n    }\n    /**\n     * Shortcut to <hideSizers>.\n     */\n    setHandlesVisible(visible) {\n        for (let i = 0; i < this.bends.length; i += 1) {\n            this.bends[i].node.style.display = visible ? '' : 'none';\n        }\n        if (this.virtualBends) {\n            for (let i = 0; i < this.virtualBends.length; i += 1) {\n                this.virtualBends[i].node.style.display = visible ? '' : 'none';\n            }\n        }\n        this.labelShape.node.style.display = visible ? '' : 'none';\n        if (this.customHandles) {\n            for (let i = 0; i < this.customHandles.length; i += 1) {\n                this.customHandles[i].setVisible(visible);\n            }\n        }\n    }\n    /**\n     * Updates and redraws the inner bends.\n     *\n     * @param p0 {@link Point} that represents the location of the first point.\n     * @param pe {@link Point} that represents the location of the last point.\n     */\n    redrawInnerBends(p0, pe) {\n        for (let i = 1; i < this.bends.length - 1; i += 1) {\n            if (this.bends[i] != null) {\n                if (this.abspoints[i] != null) {\n                    const { x } = this.abspoints[i];\n                    const { y } = this.abspoints[i];\n                    const b = this.bends[i].bounds;\n                    this.bends[i].node.style.visibility = 'visible';\n                    this.bends[i].bounds = new Rectangle(Math.round(x - b.width / 2), Math.round(y - b.height / 2), b.width, b.height);\n                    if (this.manageLabelHandle) {\n                        this.checkLabelHandle(this.bends[i].bounds);\n                    }\n                    else if (this.handleImage == null &&\n                        this.labelShape.visible &&\n                        intersects(this.bends[i].bounds, this.labelShape.bounds)) {\n                        const w = HANDLE_SIZE + 3;\n                        const h = HANDLE_SIZE + 3;\n                        this.bends[i].bounds = new Rectangle(Math.round(x - w / 2), Math.round(y - h / 2), w, h);\n                    }\n                    this.bends[i].redraw();\n                }\n                else {\n                    this.bends[i].destroy();\n                }\n            }\n        }\n    }\n    /**\n     * Checks if the label handle intersects the given bounds and moves it if it\n     * intersects.\n     */\n    checkLabelHandle(b) {\n        const b2 = this.labelShape.bounds;\n        if (intersects(b, b2)) {\n            if (b.getCenterY() < b2.getCenterY()) {\n                b2.y = b.y + b.height;\n            }\n            else {\n                b2.y = b.y - b2.height;\n            }\n        }\n    }\n    /**\n     * Redraws the preview.\n     */\n    drawPreview() {\n        try {\n            if (this.isLabel) {\n                const b = this.labelShape.bounds;\n                const bounds = new Rectangle(Math.round(this.label.x - b.width / 2), Math.round(this.label.y - b.height / 2), b.width, b.height);\n                if (!b.equals(bounds)) {\n                    this.labelShape.bounds = bounds;\n                    this.labelShape.redraw();\n                }\n            }\n            if (this.shape != null && !equalPoints(this.shape.points, this.abspoints)) {\n                this.shape.apply(this.state);\n                this.shape.points = this.abspoints.slice();\n                this.shape.scale = this.state.view.scale;\n                this.shape.isDashed = this.isSelectionDashed();\n                this.shape.stroke = this.getSelectionColor();\n                this.shape.strokeWidth =\n                    this.getSelectionStrokeWidth() / this.shape.scale / this.shape.scale;\n                this.shape.isShadow = false;\n                this.shape.redraw();\n            }\n            this.updateParentHighlight();\n        }\n        catch (e) {\n            // ignore\n        }\n    }\n    /**\n     * Refreshes the bends of this handler.\n     */\n    refresh() {\n        if (this.state != null) {\n            this.abspoints = this.getSelectionPoints(this.state);\n            this.points = [];\n            this.destroyBends(this.bends);\n            this.bends = this.createBends();\n            if (this.virtualBends) {\n                this.destroyBends(this.virtualBends);\n                this.virtualBends = this.createVirtualBends();\n            }\n            if (this.customHandles) {\n                this.destroyBends(this.customHandles);\n                this.customHandles = this.createCustomHandles();\n            }\n            // Puts label node on top of bends\n            if (this.labelShape != null &&\n                this.labelShape.node != null &&\n                this.labelShape.node.parentNode != null) {\n                this.labelShape.node.parentNode.appendChild(this.labelShape.node);\n            }\n        }\n    }\n    /**\n     * Returns true if <destroy> was called.\n     */\n    isDestroyed() {\n        return this.shape == null;\n    }\n    /**\n     * Destroys all elements in <bends>.\n     */\n    destroyBends(bends) {\n        if (bends != null) {\n            for (let i = 0; i < bends.length; i += 1) {\n                if (bends[i] != null) {\n                    bends[i].destroy();\n                }\n            }\n        }\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes. This does\n     * normally not need to be called as handlers are destroyed automatically\n     * when the corresponding cell is deselected.\n     */\n    onDestroy() {\n        this.state.view.graph.removeListener(this.escapeHandler);\n        this.marker.destroy();\n        // @ts-expect-error Can be null when destroyed.\n        this.marker = null;\n        this.shape.destroy();\n        // @ts-expect-error Can be null when destroyed.\n        this.shape = null;\n        if (this.parentHighlight) {\n            const parent = this.state.cell.getParent();\n            const pstate = parent ? this.graph.view.getState(parent) : null;\n            if (pstate && pstate.parentHighlight === this.parentHighlight) {\n                pstate.parentHighlight = null;\n            }\n            this.parentHighlight.destroy();\n            this.parentHighlight = null;\n        }\n        this.labelShape.destroy();\n        // @ts-expect-error Can be null when destroyed.\n        this.labelShape = null;\n        this.constraintHandler.onDestroy();\n        // @ts-expect-error Can be null when destroyed.\n        this.constraintHandler = null;\n        if (this.virtualBends) {\n            this.destroyBends(this.virtualBends);\n            this.virtualBends = [];\n        }\n        if (this.customHandles) {\n            this.destroyBends(this.customHandles);\n            this.customHandles = [];\n        }\n        this.destroyBends(this.bends);\n        this.bends = [];\n        this.removeHint();\n    }\n}\nclass EdgeHandlerCellMarker extends CellMarker {\n    constructor(graph, edgeHandler, validColor = DEFAULT_VALID_COLOR, invalidColor = DEFAULT_INVALID_COLOR, hotspot = DEFAULT_HOTSPOT) {\n        super(graph, validColor, invalidColor, hotspot);\n        // Only returns edges if they are connectable and never returns\n        // the edge that is currently being modified\n        this.getCell = (me) => {\n            let cell = super.getCell(me);\n            // Checks for cell at preview point (with grid)\n            if ((cell === this.edgeHandler.state.cell || !cell) &&\n                this.edgeHandler.currentPoint) {\n                cell = this.edgeHandler.graph.getCellAt(this.edgeHandler.currentPoint.x, this.edgeHandler.currentPoint.y);\n            }\n            // Uses connectable parent vertex if one exists\n            if (cell && !cell.isConnectable()) {\n                const parent = cell.getParent();\n                if (parent && parent.isVertex() && parent.isConnectable()) {\n                    cell = parent;\n                }\n            }\n            if (cell) {\n                if ((this.graph.isSwimlane(cell) &&\n                    this.edgeHandler.currentPoint &&\n                    this.graph.hitsSwimlaneContent(cell, this.edgeHandler.currentPoint.x, this.edgeHandler.currentPoint.y)) ||\n                    !this.edgeHandler.isConnectableCell(cell) ||\n                    cell === this.edgeHandler.state.cell ||\n                    (cell && !this.edgeHandler.graph.connectableEdges && cell.isEdge()) ||\n                    this.edgeHandler.state.cell.isAncestor(cell)) {\n                    cell = null;\n                }\n            }\n            if (cell && !cell.isConnectable()) {\n                cell = null;\n            }\n            return cell;\n        };\n        // Sets the highlight color according to validateConnection\n        this.isValidState = (state) => {\n            const cell = this.edgeHandler.state.cell.getTerminal(!this.edgeHandler.isSource);\n            const cellState = this.edgeHandler.graph.view.getState(cell);\n            const other = this.edgeHandler.graph.view.getTerminalPort(state, cellState, !this.edgeHandler.isSource);\n            const otherCell = other ? other.cell : null;\n            const source = this.edgeHandler.isSource ? state.cell : otherCell;\n            const target = this.edgeHandler.isSource ? otherCell : state.cell;\n            // Updates the error message of the handler\n            this.edgeHandler.error = this.edgeHandler.validateConnection(source, target);\n            return !this.edgeHandler.error;\n        };\n        this.edgeHandler = edgeHandler;\n    }\n}\nexport default EdgeHandler;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}