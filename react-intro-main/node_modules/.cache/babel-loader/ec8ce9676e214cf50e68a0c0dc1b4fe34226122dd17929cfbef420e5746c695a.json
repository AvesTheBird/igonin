{"ast":null,"code":"var _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nconst LogicElementManager = ({\n  onGenerateCode\n}) => {\n  _s();\n  const [elements, setElements] = useState([]);\n  useEffect(() => {\n    const handleElementAdded = event => {\n      const newElement = event.detail;\n      setElements(prevElements => [...prevElements, newElement]);\n    };\n    window.addEventListener('elementAdded', handleElementAdded);\n    return () => window.removeEventListener('elementAdded', handleElementAdded);\n  }, []);\n  useEffect(() => {\n    let vhdlCode = `library ieee;\\nuse ieee.std_logic_1164.all;\\nuse ieee.numeric_std.all;\\n\\n`;\n    vhdlCode += `entity adder is\\n`;\n    vhdlCode += `  port (\\n`;\n    vhdlCode += `    clk   : in std_logic; --  тактовый сигнал\\n`;\n    vhdlCode += `    rst_n : in std_logic -- сигнал сброса\\n`;\n\n    // Добавляем входы\n    const inputs = elements.filter(element => element.type === 'INPUT').map(element => element.inputs[0]);\n    const outputs = elements.filter(element => element.type === 'OUTPUT').map(element => element.output);\n    inputs.forEach((input, index) => {\n      vhdlCode += `    ${input} : in std_logic${index < inputs.length - 1 || outputs.length > 0 ? ';' : ''}\\n`;\n    });\n\n    // Добавляем выходы\n    outputs.forEach((output, index) => {\n      vhdlCode += `    ${output} : out std_logic${index < outputs.length - 1 ? ';' : ''}\\n`;\n    });\n    vhdlCode += `  );\\nend adder;\\n\\n`;\n    vhdlCode += `architecture rtl of adder is\\n`;\n    let uniqueSignalIndex = 0; // Индекс для генерации уникальных имен сигналов\n\n    // Генерация сигналов для логических элементов\n    elements.forEach(element => {\n      if (['AND', 'OR', 'NOT'].includes(element.type)) {\n        const uniqueSignalName = 'sig_' + uniqueSignalIndex++; // Генерация уникального имени сигнала\n        vhdlCode += `  signal ${uniqueSignalName} : std_logic;\\n`; // Генерация сигнала с уникальным именем\n      }\n    });\n    vhdlCode += `begin\\n`;\n\n    // Генерация логических элементов\n    elements.forEach((element, index) => {\n      switch (element.type) {\n        case 'AND':\n          vhdlCode += `  AND_GATE_${index}: entity work.and_gate\\n`;\n          vhdlCode += `    port map (A => ${element.inputs[0]}, B => ${element.inputs[1]}, Y => ${element.output});\\n`;\n          break;\n        case 'OR':\n          vhdlCode += `  OR_GATE_${index}: entity work.or_gate\\n`;\n          vhdlCode += `    port map (A => ${element.inputs[0]}, B => ${element.inputs[1]}, Y => ${element.output});\\n`;\n          break;\n        case 'NOT':\n          const uniqueSignalName = 'sig_' + index; // Уникальное имя для промежуточного сигнала\n\n          vhdlCode += `  NOT_GATE_${index}: entity work.not_gate\\n`;\n          vhdlCode += `    port map (A => ${element.inputs[0]}, Y => ${uniqueSignalName});\\n`; // Используем уникальное имя для порта\n\n          // Выход для этого элемента\n          if (element.output) {\n            vhdlCode += `  ${element.output} <= ${uniqueSignalName};\\n`; // Присваиваем промежуточный сигнал на выход\n          } else {\n            vhdlCode += `  -- Нет выходного сигнала для NOT_GATE_${index}\\n`;\n          }\n          break;\n        case 'INPUT':\n          break;\n        case 'OUTPUT':\n          break;\n        default:\n          vhdlCode += `  -- Неизвестный элемент: ${element.type}\\n`;\n      }\n    });\n    vhdlCode += `end rtl;\\n`;\n    onGenerateCode(vhdlCode); // Передача кода в редактор\n  }, [elements]);\n  return null;\n};\n_s(LogicElementManager, \"tZwa6oWmA+aeqKemK9M90QcIDxc=\");\n_c = LogicElementManager;\nexport default LogicElementManager;\nvar _c;\n$RefreshReg$(_c, \"LogicElementManager\");","map":{"version":3,"names":["React","useState","useEffect","LogicElementManager","onGenerateCode","_s","elements","setElements","handleElementAdded","event","newElement","detail","prevElements","window","addEventListener","removeEventListener","vhdlCode","inputs","filter","element","type","map","outputs","output","forEach","input","index","length","uniqueSignalIndex","includes","uniqueSignalName","_c","$RefreshReg$"],"sources":["D:/OSPanel/domains/react/react-intro-main/src/components/LogicElementManager.jsx"],"sourcesContent":["import React, { useState, useEffect } from 'react';\r\n\r\nconst LogicElementManager = ({ onGenerateCode }) => {\r\n  const [elements, setElements] = useState([]);\r\n\r\n  useEffect(() => {\r\n    const handleElementAdded = (event) => {\r\n      const newElement = event.detail;\r\n      setElements((prevElements) => [...prevElements, newElement]);\r\n    };\r\n\r\n    window.addEventListener('elementAdded', handleElementAdded);\r\n    return () => window.removeEventListener('elementAdded', handleElementAdded);\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    let vhdlCode = `library ieee;\\nuse ieee.std_logic_1164.all;\\nuse ieee.numeric_std.all;\\n\\n`;\r\n\r\n    vhdlCode += `entity adder is\\n`;\r\n    vhdlCode += `  port (\\n`;\r\n    vhdlCode += `    clk   : in std_logic; --  тактовый сигнал\\n`;\r\n    vhdlCode += `    rst_n : in std_logic -- сигнал сброса\\n`;\r\n\r\n    // Добавляем входы\r\n    const inputs = elements\r\n      .filter(element => element.type === 'INPUT')\r\n      .map(element => element.inputs[0]);\r\n    \r\n    const outputs = elements\r\n      .filter(element => element.type === 'OUTPUT')\r\n      .map(element => element.output);\r\n    \r\n    inputs.forEach((input, index) => {\r\n        vhdlCode += `    ${input} : in std_logic${(index < inputs.length - 1) || outputs.length > 0 ? ';' : ''}\\n`;\r\n    });\r\n\r\n    // Добавляем выходы\r\n    outputs.forEach((output, index) => {\r\n        vhdlCode += `    ${output} : out std_logic${index < outputs.length - 1 ? ';' : ''}\\n`;\r\n    });\r\n    \r\n    vhdlCode += `  );\\nend adder;\\n\\n`;\r\n\r\n    vhdlCode += `architecture rtl of adder is\\n`;\r\n\r\n    let uniqueSignalIndex = 0;  // Индекс для генерации уникальных имен сигналов\r\n\r\n    // Генерация сигналов для логических элементов\r\n    elements.forEach((element) => {\r\n        if (['AND', 'OR', 'NOT'].includes(element.type)) {\r\n            const uniqueSignalName = 'sig_' + uniqueSignalIndex++; // Генерация уникального имени сигнала\r\n            vhdlCode += `  signal ${uniqueSignalName} : std_logic;\\n`; // Генерация сигнала с уникальным именем\r\n        }\r\n    });\r\n    \r\n    vhdlCode += `begin\\n`;\r\n\r\n    // Генерация логических элементов\r\n    elements.forEach((element, index) => {\r\n        switch (element.type) {\r\n            case 'AND':\r\n                vhdlCode += `  AND_GATE_${index}: entity work.and_gate\\n`;\r\n                vhdlCode += `    port map (A => ${element.inputs[0]}, B => ${element.inputs[1]}, Y => ${element.output});\\n`;\r\n                break;\r\n\r\n            case 'OR':\r\n                vhdlCode += `  OR_GATE_${index}: entity work.or_gate\\n`;\r\n                vhdlCode += `    port map (A => ${element.inputs[0]}, B => ${element.inputs[1]}, Y => ${element.output});\\n`;\r\n                break;\r\n\r\n            case 'NOT':\r\n                const uniqueSignalName = 'sig_' + index; // Уникальное имя для промежуточного сигнала\r\n\r\n                vhdlCode += `  NOT_GATE_${index}: entity work.not_gate\\n`;\r\n                vhdlCode += `    port map (A => ${element.inputs[0]}, Y => ${uniqueSignalName});\\n`; // Используем уникальное имя для порта\r\n\r\n                // Выход для этого элемента\r\n                if (element.output) {\r\n                  vhdlCode += `  ${element.output} <= ${uniqueSignalName};\\n`; // Присваиваем промежуточный сигнал на выход\r\n                } else {\r\n                  vhdlCode += `  -- Нет выходного сигнала для NOT_GATE_${index}\\n`;\r\n                }\r\n                break;\r\n\r\n            case 'INPUT':\r\n              break;\r\n\r\n            case 'OUTPUT':\r\n              break;\r\n\r\n            default:\r\n                vhdlCode += `  -- Неизвестный элемент: ${element.type}\\n`;\r\n        }\r\n    });\r\n\r\n    vhdlCode += `end rtl;\\n`;\r\n\r\n    onGenerateCode(vhdlCode); // Передача кода в редактор\r\n  }, [elements]);\r\n\r\n  return null;\r\n};\r\n\r\nexport default LogicElementManager;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}