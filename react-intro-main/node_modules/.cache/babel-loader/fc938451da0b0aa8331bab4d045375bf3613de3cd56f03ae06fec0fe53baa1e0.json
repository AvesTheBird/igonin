{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { strictEquals } from '../equals.js';\nimport { DebugNameData, getFunctionName } from './debugName.js';\nimport { getLogger } from './logging.js';\nlet _recomputeInitiallyAndOnChange;\nexport function _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange) {\n  _recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;\n}\nlet _keepObserved;\nexport function _setKeepObserved(keepObserved) {\n  _keepObserved = keepObserved;\n}\nlet _derived;\n/**\n * @internal\n * This is to allow splitting files.\n*/\nexport function _setDerivedOpts(derived) {\n  _derived = derived;\n}\nexport class ConvenientObservable {\n  get TChange() {\n    return null;\n  }\n  reportChanges() {\n    this.get();\n  }\n  /** @sealed */\n  read(reader) {\n    if (reader) {\n      return reader.readObservable(this);\n    } else {\n      return this.get();\n    }\n  }\n  map(fnOrOwner, fnOrUndefined) {\n    const owner = fnOrUndefined === undefined ? undefined : fnOrOwner;\n    const fn = fnOrUndefined === undefined ? fnOrOwner : fnOrUndefined;\n    return _derived({\n      owner,\n      debugName: () => {\n        const name = getFunctionName(fn);\n        if (name !== undefined) {\n          return name;\n        }\n        // regexp to match `x => x.y` or `x => x?.y` where x and y can be arbitrary identifiers (uses backref):\n        const regexp = /^\\s*\\(?\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*\\)?\\s*=>\\s*\\1(?:\\??)\\.([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*$/;\n        const match = regexp.exec(fn.toString());\n        if (match) {\n          return \"\".concat(this.debugName, \".\").concat(match[2]);\n        }\n        if (!owner) {\n          return \"\".concat(this.debugName, \" (mapped)\");\n        }\n        return undefined;\n      },\n      debugReferenceFn: fn\n    }, reader => fn(this.read(reader), reader));\n  }\n  /**\n   * @sealed\n   * Converts an observable of an observable value into a direct observable of the value.\n  */\n  flatten() {\n    return _derived({\n      owner: undefined,\n      debugName: () => \"\".concat(this.debugName, \" (flattened)\")\n    }, reader => this.read(reader).read(reader));\n  }\n  recomputeInitiallyAndOnChange(store, handleValue) {\n    store.add(_recomputeInitiallyAndOnChange(this, handleValue));\n    return this;\n  }\n  /**\n   * Ensures that this observable is observed. This keeps the cache alive.\n   * However, in case of deriveds, it does not force eager evaluation (only when the value is read/get).\n   * Use `recomputeInitiallyAndOnChange` for eager evaluation.\n   */\n  keepObserved(store) {\n    store.add(_keepObserved(this));\n    return this;\n  }\n}\nexport class BaseObservable extends ConvenientObservable {\n  constructor() {\n    super(...arguments);\n    this.observers = new Set();\n  }\n  addObserver(observer) {\n    const len = this.observers.size;\n    this.observers.add(observer);\n    if (len === 0) {\n      this.onFirstObserverAdded();\n    }\n  }\n  removeObserver(observer) {\n    const deleted = this.observers.delete(observer);\n    if (deleted && this.observers.size === 0) {\n      this.onLastObserverRemoved();\n    }\n  }\n  onFirstObserverAdded() {}\n  onLastObserverRemoved() {}\n}\n/**\n * Starts a transaction in which many observables can be changed at once.\n * {@link fn} should start with a JS Doc using `@description` to give the transaction a debug name.\n * Reaction run on demand or when the transaction ends.\n */\nexport function transaction(fn, getDebugName) {\n  const tx = new TransactionImpl(fn, getDebugName);\n  try {\n    fn(tx);\n  } finally {\n    tx.finish();\n  }\n}\nlet _globalTransaction = undefined;\nexport function globalTransaction(fn) {\n  if (_globalTransaction) {\n    fn(_globalTransaction);\n  } else {\n    const tx = new TransactionImpl(fn, undefined);\n    _globalTransaction = tx;\n    try {\n      fn(tx);\n    } finally {\n      tx.finish(); // During finish, more actions might be added to the transaction.\n      // Which is why we only clear the global transaction after finish.\n      _globalTransaction = undefined;\n    }\n  }\n}\nexport async function asyncTransaction(fn, getDebugName) {\n  const tx = new TransactionImpl(fn, getDebugName);\n  try {\n    await fn(tx);\n  } finally {\n    tx.finish();\n  }\n}\n/**\n * Allows to chain transactions.\n */\nexport function subtransaction(tx, fn, getDebugName) {\n  if (!tx) {\n    transaction(fn, getDebugName);\n  } else {\n    fn(tx);\n  }\n}\nexport class TransactionImpl {\n  constructor(_fn, _getDebugName) {\n    var _getLogger;\n    this._fn = _fn;\n    this._getDebugName = _getDebugName;\n    this.updatingObservers = [];\n    (_getLogger = getLogger()) === null || _getLogger === void 0 || _getLogger.handleBeginTransaction(this);\n  }\n  getDebugName() {\n    if (this._getDebugName) {\n      return this._getDebugName();\n    }\n    return getFunctionName(this._fn);\n  }\n  updateObserver(observer, observable) {\n    // When this gets called while finish is active, they will still get considered\n    this.updatingObservers.push({\n      observer,\n      observable\n    });\n    observer.beginUpdate(observable);\n  }\n  finish() {\n    var _getLogger2;\n    const updatingObservers = this.updatingObservers;\n    for (let i = 0; i < updatingObservers.length; i++) {\n      const {\n        observer,\n        observable\n      } = updatingObservers[i];\n      observer.endUpdate(observable);\n    }\n    // Prevent anyone from updating observers from now on.\n    this.updatingObservers = null;\n    (_getLogger2 = getLogger()) === null || _getLogger2 === void 0 || _getLogger2.handleEndTransaction();\n  }\n}\nexport function observableValue(nameOrOwner, initialValue) {\n  let debugNameData;\n  if (typeof nameOrOwner === 'string') {\n    debugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n  } else {\n    debugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n  }\n  return new ObservableValue(debugNameData, initialValue, strictEquals);\n}\nexport class ObservableValue extends BaseObservable {\n  get debugName() {\n    var _this$_debugNameData$;\n    return (_this$_debugNameData$ = this._debugNameData.getDebugName(this)) !== null && _this$_debugNameData$ !== void 0 ? _this$_debugNameData$ : 'ObservableValue';\n  }\n  constructor(_debugNameData, initialValue, _equalityComparator) {\n    super();\n    this._debugNameData = _debugNameData;\n    this._equalityComparator = _equalityComparator;\n    this._value = initialValue;\n  }\n  get() {\n    return this._value;\n  }\n  set(value, tx, change) {\n    if (change === undefined && this._equalityComparator(this._value, value)) {\n      return;\n    }\n    let _tx;\n    if (!tx) {\n      tx = _tx = new TransactionImpl(() => {}, () => \"Setting \".concat(this.debugName));\n    }\n    try {\n      var _getLogger3;\n      const oldValue = this._value;\n      this._setValue(value);\n      (_getLogger3 = getLogger()) === null || _getLogger3 === void 0 || _getLogger3.handleObservableChanged(this, {\n        oldValue,\n        newValue: value,\n        change,\n        didChange: true,\n        hadValue: true\n      });\n      for (const observer of this.observers) {\n        tx.updateObserver(observer, this);\n        observer.handleChange(this, change);\n      }\n    } finally {\n      if (_tx) {\n        _tx.finish();\n      }\n    }\n  }\n  toString() {\n    return \"\".concat(this.debugName, \": \").concat(this._value);\n  }\n  _setValue(newValue) {\n    this._value = newValue;\n  }\n}\n/**\n * A disposable observable. When disposed, its value is also disposed.\n * When a new value is set, the previous value is disposed.\n */\nexport function disposableObservableValue(nameOrOwner, initialValue) {\n  let debugNameData;\n  if (typeof nameOrOwner === 'string') {\n    debugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n  } else {\n    debugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n  }\n  return new DisposableObservableValue(debugNameData, initialValue, strictEquals);\n}\nexport class DisposableObservableValue extends ObservableValue {\n  _setValue(newValue) {\n    if (this._value === newValue) {\n      return;\n    }\n    if (this._value) {\n      this._value.dispose();\n    }\n    this._value = newValue;\n  }\n  dispose() {\n    var _this$_value;\n    (_this$_value = this._value) === null || _this$_value === void 0 || _this$_value.dispose();\n  }\n}","map":{"version":3,"names":["strictEquals","DebugNameData","getFunctionName","getLogger","_recomputeInitiallyAndOnChange","_setRecomputeInitiallyAndOnChange","recomputeInitiallyAndOnChange","_keepObserved","_setKeepObserved","keepObserved","_derived","_setDerivedOpts","derived","ConvenientObservable","TChange","reportChanges","get","read","reader","readObservable","map","fnOrOwner","fnOrUndefined","owner","undefined","fn","debugName","name","regexp","match","exec","toString","concat","debugReferenceFn","flatten","store","handleValue","add","BaseObservable","constructor","arguments","observers","Set","addObserver","observer","len","size","onFirstObserverAdded","removeObserver","deleted","delete","onLastObserverRemoved","transaction","getDebugName","tx","TransactionImpl","finish","_globalTransaction","globalTransaction","asyncTransaction","subtransaction","_fn","_getDebugName","_getLogger","updatingObservers","handleBeginTransaction","updateObserver","observable","push","beginUpdate","_getLogger2","i","length","endUpdate","handleEndTransaction","observableValue","nameOrOwner","initialValue","debugNameData","ObservableValue","_this$_debugNameData$","_debugNameData","_equalityComparator","_value","set","value","change","_tx","_getLogger3","oldValue","_setValue","handleObservableChanged","newValue","didChange","hadValue","handleChange","disposableObservableValue","DisposableObservableValue","dispose","_this$_value"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { strictEquals } from '../equals.js';\nimport { DebugNameData, getFunctionName } from './debugName.js';\nimport { getLogger } from './logging.js';\nlet _recomputeInitiallyAndOnChange;\nexport function _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange) {\n    _recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;\n}\nlet _keepObserved;\nexport function _setKeepObserved(keepObserved) {\n    _keepObserved = keepObserved;\n}\nlet _derived;\n/**\n * @internal\n * This is to allow splitting files.\n*/\nexport function _setDerivedOpts(derived) {\n    _derived = derived;\n}\nexport class ConvenientObservable {\n    get TChange() { return null; }\n    reportChanges() {\n        this.get();\n    }\n    /** @sealed */\n    read(reader) {\n        if (reader) {\n            return reader.readObservable(this);\n        }\n        else {\n            return this.get();\n        }\n    }\n    map(fnOrOwner, fnOrUndefined) {\n        const owner = fnOrUndefined === undefined ? undefined : fnOrOwner;\n        const fn = fnOrUndefined === undefined ? fnOrOwner : fnOrUndefined;\n        return _derived({\n            owner,\n            debugName: () => {\n                const name = getFunctionName(fn);\n                if (name !== undefined) {\n                    return name;\n                }\n                // regexp to match `x => x.y` or `x => x?.y` where x and y can be arbitrary identifiers (uses backref):\n                const regexp = /^\\s*\\(?\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*\\)?\\s*=>\\s*\\1(?:\\??)\\.([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*$/;\n                const match = regexp.exec(fn.toString());\n                if (match) {\n                    return `${this.debugName}.${match[2]}`;\n                }\n                if (!owner) {\n                    return `${this.debugName} (mapped)`;\n                }\n                return undefined;\n            },\n            debugReferenceFn: fn,\n        }, (reader) => fn(this.read(reader), reader));\n    }\n    /**\n     * @sealed\n     * Converts an observable of an observable value into a direct observable of the value.\n    */\n    flatten() {\n        return _derived({\n            owner: undefined,\n            debugName: () => `${this.debugName} (flattened)`,\n        }, (reader) => this.read(reader).read(reader));\n    }\n    recomputeInitiallyAndOnChange(store, handleValue) {\n        store.add(_recomputeInitiallyAndOnChange(this, handleValue));\n        return this;\n    }\n    /**\n     * Ensures that this observable is observed. This keeps the cache alive.\n     * However, in case of deriveds, it does not force eager evaluation (only when the value is read/get).\n     * Use `recomputeInitiallyAndOnChange` for eager evaluation.\n     */\n    keepObserved(store) {\n        store.add(_keepObserved(this));\n        return this;\n    }\n}\nexport class BaseObservable extends ConvenientObservable {\n    constructor() {\n        super(...arguments);\n        this.observers = new Set();\n    }\n    addObserver(observer) {\n        const len = this.observers.size;\n        this.observers.add(observer);\n        if (len === 0) {\n            this.onFirstObserverAdded();\n        }\n    }\n    removeObserver(observer) {\n        const deleted = this.observers.delete(observer);\n        if (deleted && this.observers.size === 0) {\n            this.onLastObserverRemoved();\n        }\n    }\n    onFirstObserverAdded() { }\n    onLastObserverRemoved() { }\n}\n/**\n * Starts a transaction in which many observables can be changed at once.\n * {@link fn} should start with a JS Doc using `@description` to give the transaction a debug name.\n * Reaction run on demand or when the transaction ends.\n */\nexport function transaction(fn, getDebugName) {\n    const tx = new TransactionImpl(fn, getDebugName);\n    try {\n        fn(tx);\n    }\n    finally {\n        tx.finish();\n    }\n}\nlet _globalTransaction = undefined;\nexport function globalTransaction(fn) {\n    if (_globalTransaction) {\n        fn(_globalTransaction);\n    }\n    else {\n        const tx = new TransactionImpl(fn, undefined);\n        _globalTransaction = tx;\n        try {\n            fn(tx);\n        }\n        finally {\n            tx.finish(); // During finish, more actions might be added to the transaction.\n            // Which is why we only clear the global transaction after finish.\n            _globalTransaction = undefined;\n        }\n    }\n}\nexport async function asyncTransaction(fn, getDebugName) {\n    const tx = new TransactionImpl(fn, getDebugName);\n    try {\n        await fn(tx);\n    }\n    finally {\n        tx.finish();\n    }\n}\n/**\n * Allows to chain transactions.\n */\nexport function subtransaction(tx, fn, getDebugName) {\n    if (!tx) {\n        transaction(fn, getDebugName);\n    }\n    else {\n        fn(tx);\n    }\n}\nexport class TransactionImpl {\n    constructor(_fn, _getDebugName) {\n        this._fn = _fn;\n        this._getDebugName = _getDebugName;\n        this.updatingObservers = [];\n        getLogger()?.handleBeginTransaction(this);\n    }\n    getDebugName() {\n        if (this._getDebugName) {\n            return this._getDebugName();\n        }\n        return getFunctionName(this._fn);\n    }\n    updateObserver(observer, observable) {\n        // When this gets called while finish is active, they will still get considered\n        this.updatingObservers.push({ observer, observable });\n        observer.beginUpdate(observable);\n    }\n    finish() {\n        const updatingObservers = this.updatingObservers;\n        for (let i = 0; i < updatingObservers.length; i++) {\n            const { observer, observable } = updatingObservers[i];\n            observer.endUpdate(observable);\n        }\n        // Prevent anyone from updating observers from now on.\n        this.updatingObservers = null;\n        getLogger()?.handleEndTransaction();\n    }\n}\nexport function observableValue(nameOrOwner, initialValue) {\n    let debugNameData;\n    if (typeof nameOrOwner === 'string') {\n        debugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n    }\n    else {\n        debugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n    }\n    return new ObservableValue(debugNameData, initialValue, strictEquals);\n}\nexport class ObservableValue extends BaseObservable {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? 'ObservableValue';\n    }\n    constructor(_debugNameData, initialValue, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this._equalityComparator = _equalityComparator;\n        this._value = initialValue;\n    }\n    get() {\n        return this._value;\n    }\n    set(value, tx, change) {\n        if (change === undefined && this._equalityComparator(this._value, value)) {\n            return;\n        }\n        let _tx;\n        if (!tx) {\n            tx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n        }\n        try {\n            const oldValue = this._value;\n            this._setValue(value);\n            getLogger()?.handleObservableChanged(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });\n            for (const observer of this.observers) {\n                tx.updateObserver(observer, this);\n                observer.handleChange(this, change);\n            }\n        }\n        finally {\n            if (_tx) {\n                _tx.finish();\n            }\n        }\n    }\n    toString() {\n        return `${this.debugName}: ${this._value}`;\n    }\n    _setValue(newValue) {\n        this._value = newValue;\n    }\n}\n/**\n * A disposable observable. When disposed, its value is also disposed.\n * When a new value is set, the previous value is disposed.\n */\nexport function disposableObservableValue(nameOrOwner, initialValue) {\n    let debugNameData;\n    if (typeof nameOrOwner === 'string') {\n        debugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n    }\n    else {\n        debugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n    }\n    return new DisposableObservableValue(debugNameData, initialValue, strictEquals);\n}\nexport class DisposableObservableValue extends ObservableValue {\n    _setValue(newValue) {\n        if (this._value === newValue) {\n            return;\n        }\n        if (this._value) {\n            this._value.dispose();\n        }\n        this._value = newValue;\n    }\n    dispose() {\n        this._value?.dispose();\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}