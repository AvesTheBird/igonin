{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2017, JGraph Ltd\nCopyright (c) 2006-2017, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport ConnectorShape from '../geometry/edge/ConnectorShape';\nimport ImageShape from '../geometry/node/ImageShape';\nimport TextShape from '../geometry/node/TextShape';\nimport { ALIGN, DEFAULT_FONTFAMILY, DEFAULT_FONTSIZE, DEFAULT_FONTSTYLE, DEFAULT_TEXT_DIRECTION, DIALECT, NONE } from '../../util/Constants';\nimport { getRotatedPoint, mod, toRadians } from '../../util/mathUtils';\nimport { convertPoint } from '../../util/styleUtils';\nimport { equalEntries, equalPoints } from '../../util/arrayUtils';\nimport Rectangle from '../geometry/Rectangle';\nimport StencilShapeRegistry from '../geometry/node/StencilShapeRegistry';\nimport InternalEvent from '../event/InternalEvent';\nimport Client from '../../Client';\nimport InternalMouseEvent from '../event/InternalMouseEvent';\nimport Dictionary from '../../util/Dictionary';\nimport EventObject from '../event/EventObject';\nimport Point from '../geometry/Point';\nimport Shape from '../geometry/Shape';\nimport { getClientX, getClientY, getSource } from '../../util/EventUtils';\nimport { isNode } from '../../util/domUtils';\n/**\n * Renders cells into a document object model. The <defaultShapes> is a global\n * map of shapename, constructor pairs that is used in all instances. You can\n * get a list of all available shape names using the following code.\n *\n * In general the cell renderer is in charge of creating, redrawing and\n * destroying the shape and label associated with a cell state, as well as\n * some other graphical objects, namely controls and overlays. The shape\n * hieararchy in the display (ie. the hierarchy in which the DOM nodes\n * appear in the document) does not reflect the cell hierarchy. The shapes\n * are a (flat) sequence of shapes and labels inside the draw pane of the\n * graph view, with some exceptions, namely the HTML labels being placed\n * directly inside the graph container for certain browsers.\n *\n * ```javascript\n * MaxLog.show();\n * for (var i in mxCellRenderer.defaultShapes)\n * {\n *   MaxLog.debug(i);\n * }\n * ```\n *\n * Constructor: mxCellRenderer\n *\n * Constructs a new cell renderer with the following built-in shapes:\n * arrow, rectangle, ellipse, rhombus, image, line, label, cylinder,\n * swimlane, connector, actor and cloud.\n */\nclass CellRenderer {\n  constructor() {\n    /**\n     * Defines the default shape for edges. Default is {@link Connector}.\n     */\n    // @ts-expect-error The constructors for Shape and Connector are different.\n    this.defaultEdgeShape = ConnectorShape;\n    /**\n     * Defines the default shape for vertices. Default is {@link RectangleShape}.\n     */\n    this.defaultVertexShape = RectangleShape;\n    /**\n     * Defines the default shape for labels. Default is {@link Text}.\n     */\n    this.defaultTextShape = TextShape;\n    /**\n     * Specifies if the folding icon should ignore the horizontal\n     * orientation of a swimlane. Default is true.\n     */\n    this.legacyControlPosition = true;\n    /**\n     * Specifies if spacing and label position should be ignored if overflow is\n     * fill or width. Default is true for backwards compatiblity.\n     */\n    this.legacySpacing = true;\n    /**\n     * Anti-aliasing option for new shapes. Default is true.\n     */\n    this.antiAlias = true;\n    /**\n     * Minimum stroke width for SVG output.\n     */\n    this.minSvgStrokeWidth = 1;\n    /**\n     * Specifies if the enabled state of the graph should be ignored in the control\n     * click handler (to allow folding in disabled graphs). Default is false.\n     */\n    this.forceControlClickHandler = false;\n  }\n  /**\n   * Registers the given constructor under the specified key in this instance of the renderer.\n   * @example\n   * ```\n   * mxCellRenderer.registerShape(mxConstants.SHAPE_RECTANGLE, mxRectangleShape);\n   * ```\n   *\n   * @param key the shape name.\n   * @param shape constructor of the {@link Shape} subclass.\n   */\n  static registerShape(key, shape) {\n    CellRenderer.defaultShapes[key] = shape;\n  }\n  /**\n   * Initializes the shape in the given state by calling its init method with\n   * the correct container after configuring it using <configureShape>.\n   *\n   * @param state <CellState> for which the shape should be initialized.\n   */\n  initializeShape(state) {\n    if (state.shape) {\n      state.shape.dialect = state.view.graph.dialect;\n      this.configureShape(state);\n      state.shape.init(state.view.getDrawPane());\n    }\n  }\n  /**\n   * Creates and returns the shape for the given cell state.\n   *\n   * @param state <CellState> for which the shape should be created.\n   */\n  createShape(state) {\n    let shape = null;\n    // Checks if there is a stencil for the name and creates\n    // a shape instance for the stencil if one exists\n    const stencil = StencilShapeRegistry.getStencil(state.style.shape);\n    if (stencil) {\n      shape = new Shape(stencil);\n    } else {\n      const ctor = this.getShapeConstructor(state);\n      shape = new ctor();\n    }\n    return shape;\n  }\n  /**\n   * Creates the indicator shape for the given cell state.\n   *\n   * @param state <CellState> for which the indicator shape should be created.\n   */\n  createIndicatorShape(state) {\n    if (state.shape) {\n      state.shape.indicatorShape = this.getShape(state.getIndicatorShape() || null);\n    }\n  }\n  /**\n   * Returns the shape for the given name from <defaultShapes>.\n   */\n  getShape(name) {\n    return name ? CellRenderer.defaultShapes[name] : null;\n  }\n  /**\n   * Returns the constructor to be used for creating the shape.\n   */\n  getShapeConstructor(state) {\n    let ctor = this.getShape(state.style.shape || null);\n    if (!ctor) {\n      // @ts-expect-error The various Shape constructors are not compatible.\n      ctor = state.cell.isEdge() ? this.defaultEdgeShape : this.defaultVertexShape;\n    }\n    return ctor;\n  }\n  /**\n   * Configures the shape for the given cell state.\n   *\n   * @param state <CellState> for which the shape should be configured.\n   */\n  configureShape(state) {\n    const shape = state.shape;\n    if (shape) {\n      shape.apply(state);\n      shape.imageSrc = state.getImageSrc() || null;\n      shape.indicatorColor = state.getIndicatorColor() || NONE;\n      shape.indicatorStrokeColor = state.style.indicatorStrokeColor || NONE;\n      shape.indicatorGradientColor = state.getIndicatorGradientColor() || NONE;\n      if (state.style.indicatorDirection) {\n        shape.indicatorDirection = state.style.indicatorDirection;\n      }\n      shape.indicatorImageSrc = state.getIndicatorImageSrc() || null;\n      this.postConfigureShape(state);\n    }\n  }\n  /**\n   * Replaces any reserved words used for attributes, eg. inherit,\n   * indicated or swimlane for colors in the shape for the given state.\n   * This implementation resolves these keywords on the fill, stroke\n   * and gradient color keys.\n   */\n  postConfigureShape(state) {\n    if (state.shape) {\n      this.resolveColor(state, 'indicatorGradientColor', 'gradientColor');\n      this.resolveColor(state, 'indicatorColor', 'fillColor');\n      this.resolveColor(state, 'gradient', 'gradientColor');\n      this.resolveColor(state, 'stroke', 'strokeColor');\n      this.resolveColor(state, 'fill', 'fillColor');\n    }\n  }\n  /**\n   * Resolves special keywords 'inherit', 'indicated' and 'swimlane' and sets\n   * the respective color on the shape.\n   */\n  checkPlaceholderStyles(state) {\n    // LATER: Check if the color has actually changed\n    if (state.style) {\n      const values = ['inherit', 'swimlane', 'indicated'];\n      const styles = ['fillColor', 'strokeColor', 'gradientColor', 'fontColor'];\n      for (let i = 0; i < styles.length; i += 1) {\n        if (values.indexOf(state.style[styles[i]]) >= 0) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Resolves special keywords 'inherit', 'indicated' and 'swimlane' and sets\n   * the respective color on the shape.\n   */\n  resolveColor(state, field, key) {\n    const shape = key === 'fontColor' ? state.text : state.shape;\n    if (shape) {\n      const graph = state.view.graph;\n      // @ts-ignore\n      const value = shape[field];\n      let referenced = null;\n      if (value === 'inherit') {\n        referenced = state.cell.getParent();\n      } else if (value === 'swimlane') {\n        // @ts-ignore\n        shape[field] = key === 'strokeColor' || key === 'fontColor' ? '#000000' : '#ffffff';\n        if (state.cell.getTerminal(false)) {\n          referenced = state.cell.getTerminal(false);\n        } else {\n          referenced = state.cell;\n        }\n        referenced = graph.getSwimlane(referenced);\n        key = graph.swimlaneIndicatorColorAttribute;\n      } else if (value === 'indicated' && state.shape) {\n        // @ts-ignore\n        shape[field] = state.shape.indicatorColor;\n      } else if (key !== 'fillColor' && value === 'fillColor' && state.shape) {\n        // @ts-ignore\n        shape[field] = state.style.fillColor;\n      } else if (key !== 'strokeColor' && value === 'strokeColor' && state.shape) {\n        // @ts-ignore\n        shape[field] = state.style.strokeColor;\n      }\n      if (referenced) {\n        const rstate = graph.getView().getState(referenced);\n        // @ts-ignore\n        shape[field] = null;\n        if (rstate) {\n          const rshape = key === 'fontColor' ? rstate.text : rstate.shape;\n          if (rshape && field !== 'indicatorColor') {\n            // @ts-ignore\n            shape[field] = rshape[field];\n          } else {\n            // @ts-ignore\n            shape[field] = rstate.style[key];\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Returns the value to be used for the label.\n   *\n   * @param state <CellState> for which the label should be created.\n   */\n  getLabelValue(state) {\n    const graph = state.view.graph;\n    return graph.getLabel(state.cell);\n  }\n  /**\n   * Creates the label for the given cell state.\n   *\n   * @param state <CellState> for which the label should be created.\n   */\n  createLabel(state, value) {\n    const graph = state.view.graph;\n    if ((state.style.fontSize || 0) > 0 || state.style.fontSize == null) {\n      // Avoids using DOM node for empty labels\n      const isForceHtml = graph.isHtmlLabel(state.cell) || isNode(value);\n      state.text = new this.defaultTextShape(value, new Rectangle(), state.style.align ?? ALIGN.CENTER, state.getVerticalAlign(), state.style.fontColor, state.style.fontFamily, state.style.fontSize, state.style.fontStyle, state.style.spacing, state.style.spacingTop, state.style.spacingRight, state.style.spacingBottom, state.style.spacingLeft, state.style.horizontal, state.style.labelBackgroundColor, state.style.labelBorderColor, graph.isWrapping(state.cell) && graph.isHtmlLabel(state.cell), graph.isLabelClipped(state.cell), state.style.overflow, state.style.labelPadding, state.style.textDirection ?? DEFAULT_TEXT_DIRECTION);\n      state.text.opacity = state.style.textOpacity ?? 100;\n      state.text.dialect = isForceHtml ? DIALECT.STRICTHTML : graph.dialect;\n      state.text.style = state.style;\n      state.text.state = state;\n      this.initializeLabel(state, state.text);\n      // Workaround for touch devices routing all events for a mouse gesture\n      // (down, move, up) via the initial DOM node. IE additionally redirects\n      // the event via the initial DOM node but the event source is the node\n      // under the mouse, so we need to check if this is the case and force\n      // getCellAt for the subsequent mouseMoves and the final mouseUp.\n      let forceGetCell = false;\n      const getState = evt => {\n        let result = state;\n        if (Client.IS_TOUCH || forceGetCell) {\n          const x = getClientX(evt);\n          const y = getClientY(evt);\n          // Dispatches the drop event to the graph which\n          // consumes and executes the source function\n          const pt = convertPoint(graph.container, x, y);\n          result = graph.view.getState(graph.getCellAt(pt.x, pt.y));\n        }\n        return result;\n      };\n      // TODO: Add handling for special touch device gestures\n      InternalEvent.addGestureListeners(state.text.node, evt => {\n        if (this.isLabelEvent(state, evt)) {\n          graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt, state));\n          const source = getSource(evt);\n          forceGetCell =\n          // @ts-ignore nodeName should exist.\n          graph.dialect !== DIALECT.SVG && source.nodeName === 'IMG';\n        }\n      }, evt => {\n        if (this.isLabelEvent(state, evt)) {\n          graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, getState(evt)));\n        }\n      }, evt => {\n        if (this.isLabelEvent(state, evt)) {\n          graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt, getState(evt)));\n          forceGetCell = false;\n        }\n      });\n      // Uses double click timeout in mxGraph for quirks mode\n      if (graph.isNativeDblClickEnabled()) {\n        InternalEvent.addListener(state.text.node, 'dblclick', evt => {\n          if (this.isLabelEvent(state, evt)) {\n            graph.dblClick(evt, state.cell);\n            InternalEvent.consume(evt);\n          }\n        });\n      }\n    }\n  }\n  /**\n   * Initiailzes the label with a suitable container.\n   *\n   * @param state <CellState> whose label should be initialized.\n   */\n  initializeLabel(state, shape) {\n    if (Client.IS_SVG && Client.NO_FO && shape.dialect !== DIALECT.SVG) {\n      const graph = state.view.graph;\n      shape.init(graph.container);\n    } else {\n      shape.init(state.view.getDrawPane());\n    }\n  }\n  /**\n   * Creates the actual shape for showing the overlay for the given cell state.\n   *\n   * @param state <CellState> for which the overlay should be created.\n   */\n  createCellOverlays(state) {\n    const graph = state.view.graph;\n    const overlays = graph.getCellOverlays(state.cell);\n    const dict = new Dictionary();\n    for (let i = 0; i < overlays.length; i += 1) {\n      const shape = state.overlays.remove(overlays[i]);\n      if (!shape) {\n        const tmp = new ImageShape(new Rectangle(), overlays[i].image.src);\n        tmp.dialect = graph.dialect;\n        tmp.preserveImageAspect = false;\n        tmp.overlay = overlays[i];\n        this.initializeOverlay(state, tmp);\n        this.installCellOverlayListeners(state, overlays[i], tmp);\n        if (overlays[i].cursor) {\n          tmp.node.style.cursor = overlays[i].cursor;\n        }\n        dict.put(overlays[i], tmp);\n      } else {\n        dict.put(overlays[i], shape);\n      }\n    }\n    // Removes unused\n    state.overlays.visit((id, shape) => {\n      shape.destroy();\n    });\n    state.overlays = dict;\n  }\n  /**\n   * Initializes the given overlay.\n   *\n   * @param state <CellState> for which the overlay should be created.\n   * @param overlay {@link ImageShape} that represents the overlay.\n   */\n  initializeOverlay(state, overlay) {\n    overlay.init(state.view.getOverlayPane());\n  }\n  /**\n   * Installs the listeners for the given <CellState>, <CellOverlay> and\n   * {@link Shape} that represents the overlay.\n   */\n  installCellOverlayListeners(state, overlay, shape) {\n    const graph = state.view.graph;\n    InternalEvent.addListener(shape.node, 'click', evt => {\n      if (graph.isEditing()) {\n        graph.stopEditing(!graph.isInvokesStopCellEditing());\n      }\n      overlay.fireEvent(new EventObject(InternalEvent.CLICK, {\n        event: evt,\n        cell: state.cell\n      }));\n    });\n    InternalEvent.addGestureListeners(shape.node, evt => {\n      InternalEvent.consume(evt);\n    }, evt => {\n      graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, state));\n    });\n    if (Client.IS_TOUCH) {\n      InternalEvent.addListener(shape.node, 'touchend', evt => {\n        overlay.fireEvent(new EventObject(InternalEvent.CLICK, {\n          event: evt,\n          cell: state.cell\n        }));\n      });\n    }\n  }\n  /**\n   * Creates the control for the given cell state.\n   *\n   * @param state <CellState> for which the control should be created.\n   */\n  createControl(state) {\n    const graph = state.view.graph;\n    const image = graph.getFoldingImage(state);\n    if (graph.isFoldingEnabled() && image) {\n      if (!state.control) {\n        const b = new Rectangle(0, 0, image.width, image.height);\n        state.control = new ImageShape(b, image.src);\n        state.control.preserveImageAspect = false;\n        state.control.dialect = graph.dialect;\n        this.initControl(state, state.control, true, this.createControlClickHandler(state));\n      }\n    } else if (state.control) {\n      state.control.destroy();\n      state.control = null;\n    }\n  }\n  /**\n   * Hook for creating the click handler for the folding icon.\n   *\n   * @param state <CellState> whose control click handler should be returned.\n   */\n  createControlClickHandler(state) {\n    const graph = state.view.graph;\n    return evt => {\n      if (this.forceControlClickHandler || graph.isEnabled()) {\n        const collapse = !state.cell.isCollapsed();\n        graph.foldCells(collapse, false, [state.cell], false, evt);\n        InternalEvent.consume(evt);\n      }\n    };\n  }\n  /**\n   * Initializes the given control and returns the corresponding DOM node.\n   *\n   * @param state <CellState> for which the control should be initialized.\n   * @param control {@link Shape} to be initialized.\n   * @param handleEvents Boolean indicating if mousedown and mousemove should fire events via the graph.\n   * @param clickHandler Optional function to implement clicks on the control.\n   */\n  initControl(state, control, handleEvents, clickHandler) {\n    const graph = state.view.graph;\n    // In the special case where the label is in HTML and the display is SVG the image\n    // should go into the graph container directly in order to be clickable. Otherwise\n    // it is obscured by the HTML label that overlaps the cell.\n    const isForceHtml = graph.isHtmlLabel(state.cell) && Client.NO_FO && graph.dialect === DIALECT.SVG;\n    if (isForceHtml) {\n      control.dialect = DIALECT.PREFERHTML;\n      control.init(graph.container);\n      control.node.style.zIndex = String(1);\n    } else {\n      control.init(state.view.getOverlayPane());\n    }\n    const node = control.node;\n    // Workaround for missing click event on iOS is to check tolerance below\n    if (clickHandler && !Client.IS_IOS) {\n      if (graph.isEnabled()) {\n        node.style.cursor = 'pointer';\n      }\n      InternalEvent.addListener(node, 'click', clickHandler);\n    }\n    if (handleEvents) {\n      let first = null;\n      InternalEvent.addGestureListeners(node, evt => {\n        first = new Point(getClientX(evt), getClientY(evt));\n        graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt, state));\n        InternalEvent.consume(evt);\n      }, evt => {\n        graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, state));\n      }, evt => {\n        graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt, state));\n        InternalEvent.consume(evt);\n      });\n      // Uses capture phase for event interception to stop bubble phase\n      if (clickHandler && Client.IS_IOS) {\n        node.addEventListener('touchend', evt => {\n          if (first) {\n            const tol = graph.getEventTolerance();\n            if (Math.abs(first.x - getClientX(evt)) < tol && Math.abs(first.y - getClientY(evt)) < tol) {\n              clickHandler.call(clickHandler, evt);\n              InternalEvent.consume(evt);\n            }\n          }\n        }, true);\n      }\n    }\n    return node;\n  }\n  /**\n   * Returns true if the event is for the shape of the given state. This\n   * implementation always returns true.\n   *\n   * @param state <CellState> whose shape fired the event.\n   * @param evt Mouse event which was fired.\n   */\n  isShapeEvent(state, evt) {\n    return true;\n  }\n  /**\n   * Returns true if the event is for the label of the given state. This\n   * implementation always returns true.\n   *\n   * @param state <CellState> whose label fired the event.\n   * @param evt Mouse event which was fired.\n   */\n  isLabelEvent(state, evt) {\n    return true;\n  }\n  /**\n   * Installs the event listeners for the given cell state.\n   *\n   * @param state <CellState> for which the event listeners should be isntalled.\n   */\n  installListeners(state) {\n    const graph = state.view.graph;\n    // Workaround for touch devices routing all events for a mouse\n    // gesture (down, move, up) via the initial DOM node. Same for\n    // HTML images in all IE versions (VML images are working).\n    const getState = evt => {\n      let result = state;\n      const source = getSource(evt);\n      if (source && graph.dialect !== DIALECT.SVG &&\n      // @ts-ignore nodeName should exist\n      source.nodeName === 'IMG' || Client.IS_TOUCH) {\n        const x = getClientX(evt);\n        const y = getClientY(evt);\n        // Dispatches the drop event to the graph which\n        // consumes and executes the source function\n        const pt = convertPoint(graph.container, x, y);\n        const cell = graph.getCellAt(pt.x, pt.y);\n        result = cell ? graph.view.getState(cell) : null;\n      }\n      return result;\n    };\n    if (state.shape) {\n      InternalEvent.addGestureListeners(state.shape.node, evt => {\n        if (this.isShapeEvent(state, evt)) {\n          graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt, state));\n        }\n      }, evt => {\n        if (this.isShapeEvent(state, evt)) {\n          graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, getState(evt)));\n        }\n      }, evt => {\n        if (this.isShapeEvent(state, evt)) {\n          graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt, getState(evt)));\n        }\n      });\n      // Uses double click timeout in mxGraph for quirks mode\n      if (graph.isNativeDblClickEnabled()) {\n        InternalEvent.addListener(state.shape.node, 'dblclick', evt => {\n          if (this.isShapeEvent(state, evt)) {\n            graph.dblClick(evt, state.cell);\n            InternalEvent.consume(evt);\n          }\n        });\n      }\n    }\n  }\n  /**\n   * Redraws the label for the given cell state.\n   *\n   * @param state <CellState> whose label should be redrawn.\n   */\n  redrawLabel(state, forced) {\n    const graph = state.view.graph;\n    const value = this.getLabelValue(state);\n    const wrapping = graph.isWrapping(state.cell);\n    const clipping = graph.isLabelClipped(state.cell);\n    const isForceHtml = graph.isHtmlLabel(state.cell) || value && isNode(value);\n    const dialect = isForceHtml ? DIALECT.STRICTHTML : graph.dialect;\n    const overflow = state.style.overflow ?? 'visible';\n    if (state.text && (state.text.wrap !== wrapping || state.text.clipped !== clipping || state.text.overflow !== overflow || state.text.dialect !== dialect)) {\n      state.text.destroy();\n      state.text = null;\n    }\n    if (state.text == null && value != null && (isNode(value) || value.length > 0)) {\n      this.createLabel(state, value);\n    } else if (state.text != null && (value == null || value.length == 0)) {\n      state.text.destroy();\n      state.text = null;\n    }\n    if (state.text != null) {\n      // Forced is true if the style has changed, so to get the updated\n      // result in getLabelBounds we apply the new style to the shape\n      if (forced) {\n        // Checks if a full repaint is needed\n        if (state.text.lastValue != null && this.isTextShapeInvalid(state, state.text)) {\n          // Forces a full repaint\n          state.text.lastValue = null;\n        }\n        state.text.resetStyles();\n        state.text.apply(state);\n        // Special case where value is obtained via hook in graph\n        state.text.valign = state.getVerticalAlign();\n      }\n      const bounds = this.getLabelBounds(state);\n      const nextScale = this.getTextScale(state);\n      this.resolveColor(state, 'color', 'fontColor');\n      if (forced || state.text.value !== value || state.text.wrap !== wrapping || state.text.overflow !== overflow || state.text.clipped !== clipping || state.text.scale !== nextScale || state.text.dialect !== dialect || state.text.bounds == null || !state.text.bounds.equals(bounds)) {\n        state.text.dialect = dialect;\n        state.text.value = value;\n        state.text.bounds = bounds;\n        state.text.scale = nextScale;\n        state.text.wrap = wrapping;\n        state.text.clipped = clipping;\n        state.text.overflow = overflow;\n        // Preserves visible state\n        // @ts-ignore\n        const vis = state.text.node.style.visibility;\n        this.redrawLabelShape(state.text);\n        // @ts-ignore\n        state.text.node.style.visibility = vis;\n      }\n    }\n  }\n  /**\n   * Returns true if the style for the text shape has changed.\n   *\n   * @param state <CellState> whose label should be checked.\n   * @param shape {@link Text} shape to be checked.\n   */\n  isTextShapeInvalid(state, shape) {\n    function check(property, stylename, defaultValue) {\n      let result = false;\n      // Workaround for spacing added to directional spacing\n      if (stylename === 'spacingTop' || stylename === 'spacingRight' || stylename === 'spacingBottom' || stylename === 'spacingLeft') {\n        result =\n        // @ts-ignore\n        parseFloat(String(shape[property])) - parseFloat(String(shape.spacing)) !== (state.style[stylename] || defaultValue);\n      } else {\n        // @ts-ignore\n        result = shape[property] !== (state.style[stylename] || defaultValue);\n      }\n      return result;\n    }\n    return check('fontStyle', 'fontStyle', DEFAULT_FONTSTYLE) || check('family', 'fontFamily', DEFAULT_FONTFAMILY) || check('size', 'fontSize', DEFAULT_FONTSIZE) || check('color', 'fontColor', 'black') || check('align', 'align', '') || check('valign', 'verticalAlign', '') || check('spacing', 'spacing', 2) || check('spacingTop', 'spacingTop', 0) || check('spacingRight', 'spacingRight', 0) || check('spacingBottom', 'spacingBottom', 0) || check('spacingLeft', 'spacingLeft', 0) || check('horizontal', 'horizontal', true) || check('background', 'labelBackgroundColor', null) || check('border', 'labelBorderColor', null) || check('opacity', 'textOpacity', 100) || check('textDirection', 'textDirection', DEFAULT_TEXT_DIRECTION);\n  }\n  /**\n   * Called to invoked redraw on the given text shape.\n   *\n   * @param shape {@link Text} shape to be redrawn.\n   */\n  redrawLabelShape(shape) {\n    shape.redraw();\n  }\n  /**\n   * Returns the scaling used for the label of the given state\n   *\n   * @param state <CellState> whose label scale should be returned.\n   */\n  getTextScale(state) {\n    return state.view.scale;\n  }\n  /**\n   * Returns the bounds to be used to draw the label of the given state.\n   *\n   * @param state <CellState> whose label bounds should be returned.\n   */\n  getLabelBounds(state) {\n    const {\n      scale\n    } = state.view;\n    const isEdge = state.cell.isEdge();\n    let bounds = new Rectangle(state.absoluteOffset.x, state.absoluteOffset.y);\n    if (isEdge) {\n      // @ts-ignore\n      const spacing = state.text.getSpacing();\n      bounds.x += spacing.x * scale;\n      bounds.y += spacing.y * scale;\n      const geo = state.cell.getGeometry();\n      if (geo != null) {\n        bounds.width = Math.max(0, geo.width * scale);\n        bounds.height = Math.max(0, geo.height * scale);\n      }\n    } else {\n      // Inverts label position\n      // @ts-ignore\n      if (state.text.isPaintBoundsInverted()) {\n        const tmp = bounds.x;\n        bounds.x = bounds.y;\n        bounds.y = tmp;\n      }\n      bounds.x += state.x;\n      bounds.y += state.y;\n      // Minimum of 1 fixes alignment bug in HTML labels\n      bounds.width = Math.max(1, state.width);\n      bounds.height = Math.max(1, state.height);\n    }\n    // @ts-ignore\n    if (state.text.isPaintBoundsInverted()) {\n      // Rotates around center of state\n      const t = (state.width - state.height) / 2;\n      bounds.x += t;\n      bounds.y -= t;\n      const tmp = bounds.width;\n      bounds.width = bounds.height;\n      bounds.height = tmp;\n    }\n    // Shape can modify its label bounds\n    if (state.shape != null) {\n      const hpos = state.style.labelPosition ?? ALIGN.CENTER;\n      const vpos = state.style.verticalLabelPosition ?? ALIGN.MIDDLE;\n      if (hpos === ALIGN.CENTER && vpos === ALIGN.MIDDLE) {\n        bounds = state.shape.getLabelBounds(bounds);\n      }\n    }\n    // Label width style overrides actual label width\n    const lw = state.style.labelWidth ?? null;\n    if (lw != null) {\n      bounds.width = lw * scale;\n    }\n    if (!isEdge) {\n      this.rotateLabelBounds(state, bounds);\n    }\n    return bounds;\n  }\n  /**\n   * Adds the shape rotation to the given label bounds and\n   * applies the alignment and offsets.\n   *\n   * @param state <CellState> whose label bounds should be rotated.\n   * @param bounds {@link Rectangle} the rectangle to be rotated.\n   */\n  rotateLabelBounds(state, bounds) {\n    bounds.y -= state.text.margin.y * bounds.height;\n    bounds.x -= state.text.margin.x * bounds.width;\n    if (!this.legacySpacing || state.style.overflow !== 'fill' && state.style.overflow !== 'width') {\n      const s = state.view.scale;\n      const spacing = state.text.getSpacing();\n      bounds.x += spacing.x * s;\n      bounds.y += spacing.y * s;\n      const hpos = state.style.labelPosition ?? ALIGN.CENTER;\n      const vpos = state.style.verticalLabelPosition ?? ALIGN.MIDDLE;\n      const lw = state.style.labelWidth ?? null;\n      bounds.width = Math.max(0, bounds.width - (hpos === ALIGN.CENTER && lw == null ?\n      // @ts-ignore\n      state.text.spacingLeft * s + state.text.spacingRight * s : 0));\n      bounds.height = Math.max(0, bounds.height - (vpos === ALIGN.MIDDLE ?\n      // @ts-ignore\n      state.text.spacingTop * s + state.text.spacingBottom * s : 0));\n    }\n    // @ts-ignore\n    const theta = state.text.getTextRotation();\n    // Only needed if rotated around another center\n    if (theta !== 0 && state != null &&\n    // @ts-ignore\n    state.cell.isVertex()) {\n      const cx = state.getCenterX();\n      const cy = state.getCenterY();\n      if (bounds.x !== cx || bounds.y !== cy) {\n        const rad = theta * (Math.PI / 180);\n        const pt = getRotatedPoint(new Point(bounds.x, bounds.y), Math.cos(rad), Math.sin(rad), new Point(cx, cy));\n        bounds.x = pt.x;\n        bounds.y = pt.y;\n      }\n    }\n  }\n  /**\n   * Redraws the overlays for the given cell state.\n   *\n   * @param state <CellState> whose overlays should be redrawn.\n   */\n  redrawCellOverlays(state, forced = false) {\n    this.createCellOverlays(state);\n    if (state.overlays != null) {\n      const rot = mod(state.style.rotation ?? 0, 90);\n      const rad = toRadians(rot);\n      const cos = Math.cos(rad);\n      const sin = Math.sin(rad);\n      state.overlays.visit((id, shape) => {\n        // @ts-ignore\n        const bounds = shape.overlay.getBounds(state);\n        if (!state.cell.isEdge()) {\n          if (state.shape != null && rot !== 0) {\n            let cx = bounds.getCenterX();\n            let cy = bounds.getCenterY();\n            const point = getRotatedPoint(new Point(cx, cy), cos, sin, new Point(state.getCenterX(), state.getCenterY()));\n            cx = point.x;\n            cy = point.y;\n            bounds.x = Math.round(cx - bounds.width / 2);\n            bounds.y = Math.round(cy - bounds.height / 2);\n          }\n        }\n        if (forced || shape.bounds == null || shape.scale !== state.view.scale || !shape.bounds.equals(bounds)) {\n          shape.bounds = bounds;\n          shape.scale = state.view.scale;\n          shape.redraw();\n        }\n      });\n    }\n  }\n  /**\n   * Redraws the control for the given cell state.\n   *\n   * @param state <CellState> whose control should be redrawn.\n   */\n  redrawControl(state, forced = false) {\n    const image = state.view.graph.getFoldingImage(state);\n    if (state.control != null && image != null) {\n      const bounds = this.getControlBounds(state, image.width, image.height);\n      const r = this.legacyControlPosition ? state.style.rotation ?? 0 : state.shape.getTextRotation();\n      const s = state.view.scale;\n      if (forced || state.control.scale !== s || !state.control.bounds.equals(bounds) || state.control.rotation !== r) {\n        state.control.rotation = r;\n        state.control.bounds = bounds;\n        state.control.scale = s;\n        state.control.redraw();\n      }\n    }\n  }\n  /**\n   * Returns the bounds to be used to draw the control (folding icon) of the\n   * given state.\n   */\n  getControlBounds(state, w, h) {\n    if (state.control != null) {\n      const s = state.view.scale;\n      let cx = state.getCenterX();\n      let cy = state.getCenterY();\n      if (!state.cell.isEdge()) {\n        cx = state.x + w * s;\n        cy = state.y + h * s;\n        if (state.shape != null) {\n          // TODO: Factor out common code\n          let rot = state.shape.getShapeRotation();\n          if (this.legacyControlPosition) {\n            rot = state.style.rotation ?? 0;\n          } else if (state.shape.isPaintBoundsInverted()) {\n            const t = (state.width - state.height) / 2;\n            cx += t;\n            cy -= t;\n          }\n          if (rot !== 0) {\n            const rad = toRadians(rot);\n            const cos = Math.cos(rad);\n            const sin = Math.sin(rad);\n            const point = getRotatedPoint(new Point(cx, cy), cos, sin, new Point(state.getCenterX(), state.getCenterY()));\n            cx = point.x;\n            cy = point.y;\n          }\n        }\n      }\n      return state.cell.isEdge() ? new Rectangle(Math.round(cx - w / 2 * s), Math.round(cy - h / 2 * s), Math.round(w * s), Math.round(h * s)) : new Rectangle(Math.round(cx - w / 2 * s), Math.round(cy - h / 2 * s), Math.round(w * s), Math.round(h * s));\n    }\n    return null;\n  }\n  /**\n   * Inserts the given array of {@link Shapes} after the given nodes in the DOM.\n   *\n   * @param shapes Array of {@link Shapes} to be inserted.\n   * @param node Node in <drawPane> after which the shapes should be inserted.\n   * @param htmlNode Node in the graph container after which the shapes should be inserted that\n   * will not go into the <drawPane> (eg. HTML labels without foreignObjects).\n   */\n  insertStateAfter(state, node, htmlNode) {\n    const graph = state.view.graph;\n    const shapes = this.getShapesForState(state);\n    for (let i = 0; i < shapes.length; i += 1) {\n      // @ts-ignore\n      if (shapes[i] != null && shapes[i].node != null) {\n        const html =\n        // @ts-ignore\n        shapes[i].node.parentNode !== state.view.getDrawPane() &&\n        // @ts-ignore\n        shapes[i].node.parentNode !== state.view.getOverlayPane();\n        const temp = html ? htmlNode : node;\n        // @ts-ignore\n        if (temp != null && temp.nextSibling !== shapes[i].node) {\n          if (temp.nextSibling == null) {\n            // @ts-ignore\n            temp.parentNode.appendChild(shapes[i].node);\n          } else {\n            // @ts-ignore\n            temp.parentNode.insertBefore(shapes[i].node, temp.nextSibling);\n          }\n        } else if (temp == null) {\n          // Special case: First HTML node should be first sibling after canvas\n          // @ts-ignore\n          const shapeNode = shapes[i].node;\n          if (shapeNode.parentNode === graph.container) {\n            let {\n              canvas\n            } = state.view;\n            while (canvas != null && canvas.parentNode !== graph.container) {\n              // @ts-ignore\n              canvas = canvas.parentNode;\n            }\n            if (canvas != null && canvas.nextSibling != null) {\n              if (canvas.nextSibling !== shapeNode) {\n                // @ts-ignore\n                shapeNode.parentNode.insertBefore(shapeNode, canvas.nextSibling);\n              }\n            } else {\n              // @ts-ignore\n              shapeNode.parentNode.appendChild(shapeNode);\n            }\n          } else if (shapeNode.parentNode != null && shapeNode.parentNode.firstChild != null && shapeNode.parentNode.firstChild != shapeNode) {\n            // Inserts the node as the first child of the parent to implement the order\n            shapeNode.parentNode.insertBefore(shapeNode, shapeNode.parentNode.firstChild);\n          }\n        }\n        if (html) {\n          // @ts-ignore\n          htmlNode = shapes[i].node;\n        } else {\n          // @ts-ignore\n          node = shapes[i].node;\n        }\n      }\n    }\n    return [node, htmlNode];\n  }\n  /**\n   * Returns the {@link Shapes} for the given cell state in the order in which they should\n   * appear in the DOM.\n   *\n   * @param state <CellState> whose shapes should be returned.\n   */\n  getShapesForState(state) {\n    return [state.shape, state.text, state.control];\n  }\n  /**\n   * Updates the bounds or points and scale of the shapes for the given cell\n   * state. This is called in mxGraphView.validatePoints as the last step of\n   * updating all cells.\n   *\n   * @param state <CellState> for which the shapes should be updated.\n   * @param force Optional boolean that specifies if the cell should be reconfiured\n   * and redrawn without any additional checks.\n   * @param rendering Optional boolean that specifies if the cell should actually\n   * be drawn into the DOM. If this is false then redraw and/or reconfigure\n   * will not be called on the shape.\n   */\n  redraw(state, force = false, rendering = true) {\n    const shapeChanged = this.redrawShape(state, force, rendering);\n    if (state.shape != null && rendering) {\n      this.redrawLabel(state, shapeChanged);\n      this.redrawCellOverlays(state, shapeChanged);\n      this.redrawControl(state, shapeChanged);\n    }\n  }\n  /**\n   * Redraws the shape for the given cell state.\n   *\n   * @param state <CellState> whose label should be redrawn.\n   */\n  redrawShape(state, force = false, rendering = true) {\n    let shapeChanged = false;\n    const graph = state.view.graph;\n    // Forces creation of new shape if shape style has changed\n    if (state.shape != null && state.shape.style != null && state.style != null && state.shape.style.shape !== state.style.shape) {\n      state.shape.destroy();\n      state.shape = null;\n    }\n    if (state.shape == null && graph.container != null && state.cell !== state.view.currentRoot && (state.cell.isVertex() || state.cell.isEdge())) {\n      state.shape = this.createShape(state);\n      if (state.shape != null) {\n        state.shape.minSvgStrokeWidth = this.minSvgStrokeWidth;\n        state.shape.antiAlias = this.antiAlias;\n        this.createIndicatorShape(state);\n        this.initializeShape(state);\n        this.createCellOverlays(state);\n        this.installListeners(state);\n        // Forces a refresh of the handler if one exists\n        const selectionCellsHandler = graph.getPlugin('SelectionCellsHandler');\n        selectionCellsHandler?.updateHandler(state);\n      }\n    } else if (!force && state.shape != null && (!equalEntries(state.shape.style, state.style) || this.checkPlaceholderStyles(state))) {\n      state.shape.resetStyles();\n      this.configureShape(state);\n      // LATER: Ignore update for realtime to fix reset of current gesture\n      const selectionCellsHandler = graph.getPlugin('SelectionCellsHandler');\n      selectionCellsHandler?.updateHandler(state);\n      force = true;\n    }\n    // Updates indicator shape\n    if (state.shape != null && state.shape.indicatorShape != this.getShape(state.getIndicatorShape())) {\n      if (state.shape.indicator != null) {\n        state.shape.indicator.destroy();\n        state.shape.indicator = null;\n      }\n      this.createIndicatorShape(state);\n      if (state.shape.indicatorShape != null) {\n        state.shape.indicator = new state.shape.indicatorShape();\n        state.shape.indicator.dialect = state.shape.dialect;\n        state.shape.indicator.init(state.node);\n        force = true;\n      }\n    }\n    if (state.shape) {\n      // Handles changes of the collapse icon\n      this.createControl(state);\n      // Redraws the cell if required, ignores changes to bounds if points are\n      // defined as the bounds are updated for the given points inside the shape\n      if (force || this.isShapeInvalid(state, state.shape)) {\n        if (state.absolutePoints.length > 0) {\n          state.shape.points = state.absolutePoints.slice();\n          state.shape.bounds = null;\n        } else {\n          state.shape.points = [];\n          state.shape.bounds = new Rectangle(state.x, state.y, state.width, state.height);\n        }\n        state.shape.scale = state.view.scale;\n        if (rendering == null || rendering) {\n          this.doRedrawShape(state);\n        } else {\n          state.shape.updateBoundingBox();\n        }\n        shapeChanged = true;\n      }\n    }\n    return shapeChanged;\n  }\n  /**\n   * Invokes redraw on the shape of the given state.\n   */\n  doRedrawShape(state) {\n    state.shape?.redraw();\n  }\n  /**\n   * Returns true if the given shape must be repainted.\n   */\n  isShapeInvalid(state, shape) {\n    return shape.bounds == null || shape.scale !== state.view.scale || state.absolutePoints.length === 0 && !shape.bounds.equals(state) || state.absolutePoints.length > 0 && !equalPoints(shape.points, state.absolutePoints);\n  }\n  /**\n   * Destroys the shapes associated with the given cell state.\n   *\n   * @param state <CellState> for which the shapes should be destroyed.\n   */\n  destroy(state) {\n    if (state.shape) {\n      if (state.text) {\n        state.text.destroy();\n        state.text = null;\n      }\n      state.overlays.visit((id, shape) => {\n        shape.destroy();\n      });\n      state.overlays = new Dictionary();\n      if (state.control) {\n        state.control.destroy();\n        state.control = null;\n      }\n      state.shape.destroy();\n      state.shape = null;\n    }\n  }\n}\n/**\n * Static array that contains the globally registered shapes which are\n * known to all instances of this class. For adding new shapes you should\n * use the static {@link CellRenderer#registerShape} function.\n */\nCellRenderer.defaultShapes = {};\nexport default CellRenderer;","map":{"version":3,"names":["RectangleShape","ConnectorShape","ImageShape","TextShape","ALIGN","DEFAULT_FONTFAMILY","DEFAULT_FONTSIZE","DEFAULT_FONTSTYLE","DEFAULT_TEXT_DIRECTION","DIALECT","NONE","getRotatedPoint","mod","toRadians","convertPoint","equalEntries","equalPoints","Rectangle","StencilShapeRegistry","InternalEvent","Client","InternalMouseEvent","Dictionary","EventObject","Point","Shape","getClientX","getClientY","getSource","isNode","CellRenderer","constructor","defaultEdgeShape","defaultVertexShape","defaultTextShape","legacyControlPosition","legacySpacing","antiAlias","minSvgStrokeWidth","forceControlClickHandler","registerShape","key","shape","defaultShapes","initializeShape","state","dialect","view","graph","configureShape","init","getDrawPane","createShape","stencil","getStencil","style","ctor","getShapeConstructor","createIndicatorShape","indicatorShape","getShape","getIndicatorShape","name","cell","isEdge","apply","imageSrc","getImageSrc","indicatorColor","getIndicatorColor","indicatorStrokeColor","indicatorGradientColor","getIndicatorGradientColor","indicatorDirection","indicatorImageSrc","getIndicatorImageSrc","postConfigureShape","resolveColor","checkPlaceholderStyles","values","styles","i","length","indexOf","field","text","value","referenced","getParent","getTerminal","getSwimlane","swimlaneIndicatorColorAttribute","fillColor","strokeColor","rstate","getView","getState","rshape","getLabelValue","getLabel","createLabel","fontSize","isForceHtml","isHtmlLabel","align","CENTER","getVerticalAlign","fontColor","fontFamily","fontStyle","spacing","spacingTop","spacingRight","spacingBottom","spacingLeft","horizontal","labelBackgroundColor","labelBorderColor","isWrapping","isLabelClipped","overflow","labelPadding","textDirection","opacity","textOpacity","STRICTHTML","initializeLabel","forceGetCell","evt","result","IS_TOUCH","x","y","pt","container","getCellAt","addGestureListeners","node","isLabelEvent","fireMouseEvent","MOUSE_DOWN","source","SVG","nodeName","MOUSE_MOVE","MOUSE_UP","isNativeDblClickEnabled","addListener","dblClick","consume","IS_SVG","NO_FO","createCellOverlays","overlays","getCellOverlays","dict","remove","tmp","image","src","preserveImageAspect","overlay","initializeOverlay","installCellOverlayListeners","cursor","put","visit","id","destroy","getOverlayPane","isEditing","stopEditing","isInvokesStopCellEditing","fireEvent","CLICK","event","createControl","getFoldingImage","isFoldingEnabled","control","b","width","height","initControl","createControlClickHandler","isEnabled","collapse","isCollapsed","foldCells","handleEvents","clickHandler","PREFERHTML","zIndex","String","IS_IOS","first","addEventListener","tol","getEventTolerance","Math","abs","call","isShapeEvent","installListeners","redrawLabel","forced","wrapping","clipping","wrap","clipped","lastValue","isTextShapeInvalid","resetStyles","valign","bounds","getLabelBounds","nextScale","getTextScale","scale","equals","vis","visibility","redrawLabelShape","check","property","stylename","defaultValue","parseFloat","redraw","absoluteOffset","getSpacing","geo","getGeometry","max","isPaintBoundsInverted","t","hpos","labelPosition","vpos","verticalLabelPosition","MIDDLE","lw","labelWidth","rotateLabelBounds","margin","s","theta","getTextRotation","isVertex","cx","getCenterX","cy","getCenterY","rad","PI","cos","sin","redrawCellOverlays","rot","rotation","getBounds","point","round","redrawControl","getControlBounds","r","w","h","getShapeRotation","insertStateAfter","htmlNode","shapes","getShapesForState","html","parentNode","temp","nextSibling","appendChild","insertBefore","shapeNode","canvas","firstChild","force","rendering","shapeChanged","redrawShape","currentRoot","selectionCellsHandler","getPlugin","updateHandler","indicator","isShapeInvalid","absolutePoints","points","slice","doRedrawShape","updateBoundingBox"],"sources":["D:/OSPanel/domains/проекты open server/old/react/react-intro-main/node_modules/@maxgraph/core/dist/view/cell/CellRenderer.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2017, JGraph Ltd\nCopyright (c) 2006-2017, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport ConnectorShape from '../geometry/edge/ConnectorShape';\nimport ImageShape from '../geometry/node/ImageShape';\nimport TextShape from '../geometry/node/TextShape';\nimport { ALIGN, DEFAULT_FONTFAMILY, DEFAULT_FONTSIZE, DEFAULT_FONTSTYLE, DEFAULT_TEXT_DIRECTION, DIALECT, NONE, } from '../../util/Constants';\nimport { getRotatedPoint, mod, toRadians } from '../../util/mathUtils';\nimport { convertPoint } from '../../util/styleUtils';\nimport { equalEntries, equalPoints } from '../../util/arrayUtils';\nimport Rectangle from '../geometry/Rectangle';\nimport StencilShapeRegistry from '../geometry/node/StencilShapeRegistry';\nimport InternalEvent from '../event/InternalEvent';\nimport Client from '../../Client';\nimport InternalMouseEvent from '../event/InternalMouseEvent';\nimport Dictionary from '../../util/Dictionary';\nimport EventObject from '../event/EventObject';\nimport Point from '../geometry/Point';\nimport Shape from '../geometry/Shape';\nimport { getClientX, getClientY, getSource } from '../../util/EventUtils';\nimport { isNode } from '../../util/domUtils';\n/**\n * Renders cells into a document object model. The <defaultShapes> is a global\n * map of shapename, constructor pairs that is used in all instances. You can\n * get a list of all available shape names using the following code.\n *\n * In general the cell renderer is in charge of creating, redrawing and\n * destroying the shape and label associated with a cell state, as well as\n * some other graphical objects, namely controls and overlays. The shape\n * hieararchy in the display (ie. the hierarchy in which the DOM nodes\n * appear in the document) does not reflect the cell hierarchy. The shapes\n * are a (flat) sequence of shapes and labels inside the draw pane of the\n * graph view, with some exceptions, namely the HTML labels being placed\n * directly inside the graph container for certain browsers.\n *\n * ```javascript\n * MaxLog.show();\n * for (var i in mxCellRenderer.defaultShapes)\n * {\n *   MaxLog.debug(i);\n * }\n * ```\n *\n * Constructor: mxCellRenderer\n *\n * Constructs a new cell renderer with the following built-in shapes:\n * arrow, rectangle, ellipse, rhombus, image, line, label, cylinder,\n * swimlane, connector, actor and cloud.\n */\nclass CellRenderer {\n    constructor() {\n        /**\n         * Defines the default shape for edges. Default is {@link Connector}.\n         */\n        // @ts-expect-error The constructors for Shape and Connector are different.\n        this.defaultEdgeShape = ConnectorShape;\n        /**\n         * Defines the default shape for vertices. Default is {@link RectangleShape}.\n         */\n        this.defaultVertexShape = RectangleShape;\n        /**\n         * Defines the default shape for labels. Default is {@link Text}.\n         */\n        this.defaultTextShape = TextShape;\n        /**\n         * Specifies if the folding icon should ignore the horizontal\n         * orientation of a swimlane. Default is true.\n         */\n        this.legacyControlPosition = true;\n        /**\n         * Specifies if spacing and label position should be ignored if overflow is\n         * fill or width. Default is true for backwards compatiblity.\n         */\n        this.legacySpacing = true;\n        /**\n         * Anti-aliasing option for new shapes. Default is true.\n         */\n        this.antiAlias = true;\n        /**\n         * Minimum stroke width for SVG output.\n         */\n        this.minSvgStrokeWidth = 1;\n        /**\n         * Specifies if the enabled state of the graph should be ignored in the control\n         * click handler (to allow folding in disabled graphs). Default is false.\n         */\n        this.forceControlClickHandler = false;\n    }\n    /**\n     * Registers the given constructor under the specified key in this instance of the renderer.\n     * @example\n     * ```\n     * mxCellRenderer.registerShape(mxConstants.SHAPE_RECTANGLE, mxRectangleShape);\n     * ```\n     *\n     * @param key the shape name.\n     * @param shape constructor of the {@link Shape} subclass.\n     */\n    static registerShape(key, shape) {\n        CellRenderer.defaultShapes[key] = shape;\n    }\n    /**\n     * Initializes the shape in the given state by calling its init method with\n     * the correct container after configuring it using <configureShape>.\n     *\n     * @param state <CellState> for which the shape should be initialized.\n     */\n    initializeShape(state) {\n        if (state.shape) {\n            state.shape.dialect = state.view.graph.dialect;\n            this.configureShape(state);\n            state.shape.init(state.view.getDrawPane());\n        }\n    }\n    /**\n     * Creates and returns the shape for the given cell state.\n     *\n     * @param state <CellState> for which the shape should be created.\n     */\n    createShape(state) {\n        let shape = null;\n        // Checks if there is a stencil for the name and creates\n        // a shape instance for the stencil if one exists\n        const stencil = StencilShapeRegistry.getStencil(state.style.shape);\n        if (stencil) {\n            shape = new Shape(stencil);\n        }\n        else {\n            const ctor = this.getShapeConstructor(state);\n            shape = new ctor();\n        }\n        return shape;\n    }\n    /**\n     * Creates the indicator shape for the given cell state.\n     *\n     * @param state <CellState> for which the indicator shape should be created.\n     */\n    createIndicatorShape(state) {\n        if (state.shape) {\n            state.shape.indicatorShape = this.getShape(state.getIndicatorShape() || null);\n        }\n    }\n    /**\n     * Returns the shape for the given name from <defaultShapes>.\n     */\n    getShape(name) {\n        return name ? CellRenderer.defaultShapes[name] : null;\n    }\n    /**\n     * Returns the constructor to be used for creating the shape.\n     */\n    getShapeConstructor(state) {\n        let ctor = this.getShape(state.style.shape || null);\n        if (!ctor) {\n            // @ts-expect-error The various Shape constructors are not compatible.\n            ctor = state.cell.isEdge() ? this.defaultEdgeShape : this.defaultVertexShape;\n        }\n        return ctor;\n    }\n    /**\n     * Configures the shape for the given cell state.\n     *\n     * @param state <CellState> for which the shape should be configured.\n     */\n    configureShape(state) {\n        const shape = state.shape;\n        if (shape) {\n            shape.apply(state);\n            shape.imageSrc = state.getImageSrc() || null;\n            shape.indicatorColor = state.getIndicatorColor() || NONE;\n            shape.indicatorStrokeColor = state.style.indicatorStrokeColor || NONE;\n            shape.indicatorGradientColor = state.getIndicatorGradientColor() || NONE;\n            if (state.style.indicatorDirection) {\n                shape.indicatorDirection = state.style.indicatorDirection;\n            }\n            shape.indicatorImageSrc = state.getIndicatorImageSrc() || null;\n            this.postConfigureShape(state);\n        }\n    }\n    /**\n     * Replaces any reserved words used for attributes, eg. inherit,\n     * indicated or swimlane for colors in the shape for the given state.\n     * This implementation resolves these keywords on the fill, stroke\n     * and gradient color keys.\n     */\n    postConfigureShape(state) {\n        if (state.shape) {\n            this.resolveColor(state, 'indicatorGradientColor', 'gradientColor');\n            this.resolveColor(state, 'indicatorColor', 'fillColor');\n            this.resolveColor(state, 'gradient', 'gradientColor');\n            this.resolveColor(state, 'stroke', 'strokeColor');\n            this.resolveColor(state, 'fill', 'fillColor');\n        }\n    }\n    /**\n     * Resolves special keywords 'inherit', 'indicated' and 'swimlane' and sets\n     * the respective color on the shape.\n     */\n    checkPlaceholderStyles(state) {\n        // LATER: Check if the color has actually changed\n        if (state.style) {\n            const values = ['inherit', 'swimlane', 'indicated'];\n            const styles = [\n                'fillColor',\n                'strokeColor',\n                'gradientColor',\n                'fontColor',\n            ];\n            for (let i = 0; i < styles.length; i += 1) {\n                if (values.indexOf(state.style[styles[i]]) >= 0) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Resolves special keywords 'inherit', 'indicated' and 'swimlane' and sets\n     * the respective color on the shape.\n     */\n    resolveColor(state, field, key) {\n        const shape = key === 'fontColor' ? state.text : state.shape;\n        if (shape) {\n            const graph = state.view.graph;\n            // @ts-ignore\n            const value = shape[field];\n            let referenced = null;\n            if (value === 'inherit') {\n                referenced = state.cell.getParent();\n            }\n            else if (value === 'swimlane') {\n                // @ts-ignore\n                shape[field] =\n                    key === 'strokeColor' || key === 'fontColor' ? '#000000' : '#ffffff';\n                if (state.cell.getTerminal(false)) {\n                    referenced = state.cell.getTerminal(false);\n                }\n                else {\n                    referenced = state.cell;\n                }\n                referenced = graph.getSwimlane(referenced);\n                key = graph.swimlaneIndicatorColorAttribute;\n            }\n            else if (value === 'indicated' && state.shape) {\n                // @ts-ignore\n                shape[field] = state.shape.indicatorColor;\n            }\n            else if (key !== 'fillColor' && value === 'fillColor' && state.shape) {\n                // @ts-ignore\n                shape[field] = state.style.fillColor;\n            }\n            else if (key !== 'strokeColor' && value === 'strokeColor' && state.shape) {\n                // @ts-ignore\n                shape[field] = state.style.strokeColor;\n            }\n            if (referenced) {\n                const rstate = graph.getView().getState(referenced);\n                // @ts-ignore\n                shape[field] = null;\n                if (rstate) {\n                    const rshape = key === 'fontColor' ? rstate.text : rstate.shape;\n                    if (rshape && field !== 'indicatorColor') {\n                        // @ts-ignore\n                        shape[field] = rshape[field];\n                    }\n                    else {\n                        // @ts-ignore\n                        shape[field] = rstate.style[key];\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Returns the value to be used for the label.\n     *\n     * @param state <CellState> for which the label should be created.\n     */\n    getLabelValue(state) {\n        const graph = state.view.graph;\n        return graph.getLabel(state.cell);\n    }\n    /**\n     * Creates the label for the given cell state.\n     *\n     * @param state <CellState> for which the label should be created.\n     */\n    createLabel(state, value) {\n        const graph = state.view.graph;\n        if ((state.style.fontSize || 0) > 0 || state.style.fontSize == null) {\n            // Avoids using DOM node for empty labels\n            const isForceHtml = graph.isHtmlLabel(state.cell) || isNode(value);\n            state.text = new this.defaultTextShape(value, new Rectangle(), state.style.align ?? ALIGN.CENTER, state.getVerticalAlign(), state.style.fontColor, state.style.fontFamily, state.style.fontSize, state.style.fontStyle, state.style.spacing, state.style.spacingTop, state.style.spacingRight, state.style.spacingBottom, state.style.spacingLeft, state.style.horizontal, state.style.labelBackgroundColor, state.style.labelBorderColor, graph.isWrapping(state.cell) && graph.isHtmlLabel(state.cell), graph.isLabelClipped(state.cell), state.style.overflow, state.style.labelPadding, state.style.textDirection ?? DEFAULT_TEXT_DIRECTION);\n            state.text.opacity = state.style.textOpacity ?? 100;\n            state.text.dialect = isForceHtml ? DIALECT.STRICTHTML : graph.dialect;\n            state.text.style = state.style;\n            state.text.state = state;\n            this.initializeLabel(state, state.text);\n            // Workaround for touch devices routing all events for a mouse gesture\n            // (down, move, up) via the initial DOM node. IE additionally redirects\n            // the event via the initial DOM node but the event source is the node\n            // under the mouse, so we need to check if this is the case and force\n            // getCellAt for the subsequent mouseMoves and the final mouseUp.\n            let forceGetCell = false;\n            const getState = (evt) => {\n                let result = state;\n                if (Client.IS_TOUCH || forceGetCell) {\n                    const x = getClientX(evt);\n                    const y = getClientY(evt);\n                    // Dispatches the drop event to the graph which\n                    // consumes and executes the source function\n                    const pt = convertPoint(graph.container, x, y);\n                    result = graph.view.getState(graph.getCellAt(pt.x, pt.y));\n                }\n                return result;\n            };\n            // TODO: Add handling for special touch device gestures\n            InternalEvent.addGestureListeners(state.text.node, (evt) => {\n                if (this.isLabelEvent(state, evt)) {\n                    graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt, state));\n                    const source = getSource(evt);\n                    forceGetCell =\n                        // @ts-ignore nodeName should exist.\n                        graph.dialect !== DIALECT.SVG && source.nodeName === 'IMG';\n                }\n            }, (evt) => {\n                if (this.isLabelEvent(state, evt)) {\n                    graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, getState(evt)));\n                }\n            }, (evt) => {\n                if (this.isLabelEvent(state, evt)) {\n                    graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt, getState(evt)));\n                    forceGetCell = false;\n                }\n            });\n            // Uses double click timeout in mxGraph for quirks mode\n            if (graph.isNativeDblClickEnabled()) {\n                InternalEvent.addListener(state.text.node, 'dblclick', (evt) => {\n                    if (this.isLabelEvent(state, evt)) {\n                        graph.dblClick(evt, state.cell);\n                        InternalEvent.consume(evt);\n                    }\n                });\n            }\n        }\n    }\n    /**\n     * Initiailzes the label with a suitable container.\n     *\n     * @param state <CellState> whose label should be initialized.\n     */\n    initializeLabel(state, shape) {\n        if (Client.IS_SVG && Client.NO_FO && shape.dialect !== DIALECT.SVG) {\n            const graph = state.view.graph;\n            shape.init(graph.container);\n        }\n        else {\n            shape.init(state.view.getDrawPane());\n        }\n    }\n    /**\n     * Creates the actual shape for showing the overlay for the given cell state.\n     *\n     * @param state <CellState> for which the overlay should be created.\n     */\n    createCellOverlays(state) {\n        const graph = state.view.graph;\n        const overlays = graph.getCellOverlays(state.cell);\n        const dict = new Dictionary();\n        for (let i = 0; i < overlays.length; i += 1) {\n            const shape = state.overlays.remove(overlays[i]);\n            if (!shape) {\n                const tmp = new ImageShape(new Rectangle(), overlays[i].image.src);\n                tmp.dialect = graph.dialect;\n                tmp.preserveImageAspect = false;\n                tmp.overlay = overlays[i];\n                this.initializeOverlay(state, tmp);\n                this.installCellOverlayListeners(state, overlays[i], tmp);\n                if (overlays[i].cursor) {\n                    tmp.node.style.cursor = overlays[i].cursor;\n                }\n                dict.put(overlays[i], tmp);\n            }\n            else {\n                dict.put(overlays[i], shape);\n            }\n        }\n        // Removes unused\n        state.overlays.visit((id, shape) => {\n            shape.destroy();\n        });\n        state.overlays = dict;\n    }\n    /**\n     * Initializes the given overlay.\n     *\n     * @param state <CellState> for which the overlay should be created.\n     * @param overlay {@link ImageShape} that represents the overlay.\n     */\n    initializeOverlay(state, overlay) {\n        overlay.init(state.view.getOverlayPane());\n    }\n    /**\n     * Installs the listeners for the given <CellState>, <CellOverlay> and\n     * {@link Shape} that represents the overlay.\n     */\n    installCellOverlayListeners(state, overlay, shape) {\n        const graph = state.view.graph;\n        InternalEvent.addListener(shape.node, 'click', (evt) => {\n            if (graph.isEditing()) {\n                graph.stopEditing(!graph.isInvokesStopCellEditing());\n            }\n            overlay.fireEvent(new EventObject(InternalEvent.CLICK, { event: evt, cell: state.cell }));\n        });\n        InternalEvent.addGestureListeners(shape.node, (evt) => {\n            InternalEvent.consume(evt);\n        }, (evt) => {\n            graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, state));\n        });\n        if (Client.IS_TOUCH) {\n            InternalEvent.addListener(shape.node, 'touchend', (evt) => {\n                overlay.fireEvent(new EventObject(InternalEvent.CLICK, { event: evt, cell: state.cell }));\n            });\n        }\n    }\n    /**\n     * Creates the control for the given cell state.\n     *\n     * @param state <CellState> for which the control should be created.\n     */\n    createControl(state) {\n        const graph = state.view.graph;\n        const image = graph.getFoldingImage(state);\n        if (graph.isFoldingEnabled() && image) {\n            if (!state.control) {\n                const b = new Rectangle(0, 0, image.width, image.height);\n                state.control = new ImageShape(b, image.src);\n                state.control.preserveImageAspect = false;\n                state.control.dialect = graph.dialect;\n                this.initControl(state, state.control, true, this.createControlClickHandler(state));\n            }\n        }\n        else if (state.control) {\n            state.control.destroy();\n            state.control = null;\n        }\n    }\n    /**\n     * Hook for creating the click handler for the folding icon.\n     *\n     * @param state <CellState> whose control click handler should be returned.\n     */\n    createControlClickHandler(state) {\n        const graph = state.view.graph;\n        return (evt) => {\n            if (this.forceControlClickHandler || graph.isEnabled()) {\n                const collapse = !state.cell.isCollapsed();\n                graph.foldCells(collapse, false, [state.cell], false, evt);\n                InternalEvent.consume(evt);\n            }\n        };\n    }\n    /**\n     * Initializes the given control and returns the corresponding DOM node.\n     *\n     * @param state <CellState> for which the control should be initialized.\n     * @param control {@link Shape} to be initialized.\n     * @param handleEvents Boolean indicating if mousedown and mousemove should fire events via the graph.\n     * @param clickHandler Optional function to implement clicks on the control.\n     */\n    initControl(state, control, handleEvents, clickHandler) {\n        const graph = state.view.graph;\n        // In the special case where the label is in HTML and the display is SVG the image\n        // should go into the graph container directly in order to be clickable. Otherwise\n        // it is obscured by the HTML label that overlaps the cell.\n        const isForceHtml = graph.isHtmlLabel(state.cell) && Client.NO_FO && graph.dialect === DIALECT.SVG;\n        if (isForceHtml) {\n            control.dialect = DIALECT.PREFERHTML;\n            control.init(graph.container);\n            control.node.style.zIndex = String(1);\n        }\n        else {\n            control.init(state.view.getOverlayPane());\n        }\n        const node = control.node;\n        // Workaround for missing click event on iOS is to check tolerance below\n        if (clickHandler && !Client.IS_IOS) {\n            if (graph.isEnabled()) {\n                node.style.cursor = 'pointer';\n            }\n            InternalEvent.addListener(node, 'click', clickHandler);\n        }\n        if (handleEvents) {\n            let first = null;\n            InternalEvent.addGestureListeners(node, (evt) => {\n                first = new Point(getClientX(evt), getClientY(evt));\n                graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt, state));\n                InternalEvent.consume(evt);\n            }, (evt) => {\n                graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, state));\n            }, (evt) => {\n                graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt, state));\n                InternalEvent.consume(evt);\n            });\n            // Uses capture phase for event interception to stop bubble phase\n            if (clickHandler && Client.IS_IOS) {\n                node.addEventListener('touchend', (evt) => {\n                    if (first) {\n                        const tol = graph.getEventTolerance();\n                        if (Math.abs(first.x - getClientX(evt)) < tol &&\n                            Math.abs(first.y - getClientY(evt)) < tol) {\n                            clickHandler.call(clickHandler, evt);\n                            InternalEvent.consume(evt);\n                        }\n                    }\n                }, true);\n            }\n        }\n        return node;\n    }\n    /**\n     * Returns true if the event is for the shape of the given state. This\n     * implementation always returns true.\n     *\n     * @param state <CellState> whose shape fired the event.\n     * @param evt Mouse event which was fired.\n     */\n    isShapeEvent(state, evt) {\n        return true;\n    }\n    /**\n     * Returns true if the event is for the label of the given state. This\n     * implementation always returns true.\n     *\n     * @param state <CellState> whose label fired the event.\n     * @param evt Mouse event which was fired.\n     */\n    isLabelEvent(state, evt) {\n        return true;\n    }\n    /**\n     * Installs the event listeners for the given cell state.\n     *\n     * @param state <CellState> for which the event listeners should be isntalled.\n     */\n    installListeners(state) {\n        const graph = state.view.graph;\n        // Workaround for touch devices routing all events for a mouse\n        // gesture (down, move, up) via the initial DOM node. Same for\n        // HTML images in all IE versions (VML images are working).\n        const getState = (evt) => {\n            let result = state;\n            const source = getSource(evt);\n            if ((source &&\n                graph.dialect !== DIALECT.SVG &&\n                // @ts-ignore nodeName should exist\n                source.nodeName === 'IMG') ||\n                Client.IS_TOUCH) {\n                const x = getClientX(evt);\n                const y = getClientY(evt);\n                // Dispatches the drop event to the graph which\n                // consumes and executes the source function\n                const pt = convertPoint(graph.container, x, y);\n                const cell = graph.getCellAt(pt.x, pt.y);\n                result = cell ? graph.view.getState(cell) : null;\n            }\n            return result;\n        };\n        if (state.shape) {\n            InternalEvent.addGestureListeners(state.shape.node, (evt) => {\n                if (this.isShapeEvent(state, evt)) {\n                    graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt, state));\n                }\n            }, (evt) => {\n                if (this.isShapeEvent(state, evt)) {\n                    graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, getState(evt)));\n                }\n            }, (evt) => {\n                if (this.isShapeEvent(state, evt)) {\n                    graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt, getState(evt)));\n                }\n            });\n            // Uses double click timeout in mxGraph for quirks mode\n            if (graph.isNativeDblClickEnabled()) {\n                InternalEvent.addListener(state.shape.node, 'dblclick', (evt) => {\n                    if (this.isShapeEvent(state, evt)) {\n                        graph.dblClick(evt, state.cell);\n                        InternalEvent.consume(evt);\n                    }\n                });\n            }\n        }\n    }\n    /**\n     * Redraws the label for the given cell state.\n     *\n     * @param state <CellState> whose label should be redrawn.\n     */\n    redrawLabel(state, forced) {\n        const graph = state.view.graph;\n        const value = this.getLabelValue(state);\n        const wrapping = graph.isWrapping(state.cell);\n        const clipping = graph.isLabelClipped(state.cell);\n        const isForceHtml = graph.isHtmlLabel(state.cell) || (value && isNode(value));\n        const dialect = isForceHtml ? DIALECT.STRICTHTML : graph.dialect;\n        const overflow = state.style.overflow ?? 'visible';\n        if (state.text &&\n            (state.text.wrap !== wrapping ||\n                state.text.clipped !== clipping ||\n                state.text.overflow !== overflow ||\n                state.text.dialect !== dialect)) {\n            state.text.destroy();\n            state.text = null;\n        }\n        if (state.text == null && value != null && (isNode(value) || value.length > 0)) {\n            this.createLabel(state, value);\n        }\n        else if (state.text != null && (value == null || value.length == 0)) {\n            state.text.destroy();\n            state.text = null;\n        }\n        if (state.text != null) {\n            // Forced is true if the style has changed, so to get the updated\n            // result in getLabelBounds we apply the new style to the shape\n            if (forced) {\n                // Checks if a full repaint is needed\n                if (state.text.lastValue != null && this.isTextShapeInvalid(state, state.text)) {\n                    // Forces a full repaint\n                    state.text.lastValue = null;\n                }\n                state.text.resetStyles();\n                state.text.apply(state);\n                // Special case where value is obtained via hook in graph\n                state.text.valign = state.getVerticalAlign();\n            }\n            const bounds = this.getLabelBounds(state);\n            const nextScale = this.getTextScale(state);\n            this.resolveColor(state, 'color', 'fontColor');\n            if (forced ||\n                state.text.value !== value ||\n                state.text.wrap !== wrapping ||\n                state.text.overflow !== overflow ||\n                state.text.clipped !== clipping ||\n                state.text.scale !== nextScale ||\n                state.text.dialect !== dialect ||\n                state.text.bounds == null ||\n                !state.text.bounds.equals(bounds)) {\n                state.text.dialect = dialect;\n                state.text.value = value;\n                state.text.bounds = bounds;\n                state.text.scale = nextScale;\n                state.text.wrap = wrapping;\n                state.text.clipped = clipping;\n                state.text.overflow = overflow;\n                // Preserves visible state\n                // @ts-ignore\n                const vis = state.text.node.style.visibility;\n                this.redrawLabelShape(state.text);\n                // @ts-ignore\n                state.text.node.style.visibility = vis;\n            }\n        }\n    }\n    /**\n     * Returns true if the style for the text shape has changed.\n     *\n     * @param state <CellState> whose label should be checked.\n     * @param shape {@link Text} shape to be checked.\n     */\n    isTextShapeInvalid(state, shape) {\n        function check(property, stylename, defaultValue) {\n            let result = false;\n            // Workaround for spacing added to directional spacing\n            if (stylename === 'spacingTop' ||\n                stylename === 'spacingRight' ||\n                stylename === 'spacingBottom' ||\n                stylename === 'spacingLeft') {\n                result =\n                    // @ts-ignore\n                    parseFloat(String(shape[property])) - parseFloat(String(shape.spacing)) !==\n                        (state.style[stylename] || defaultValue);\n            }\n            else {\n                // @ts-ignore\n                result = shape[property] !== (state.style[stylename] || defaultValue);\n            }\n            return result;\n        }\n        return (check('fontStyle', 'fontStyle', DEFAULT_FONTSTYLE) ||\n            check('family', 'fontFamily', DEFAULT_FONTFAMILY) ||\n            check('size', 'fontSize', DEFAULT_FONTSIZE) ||\n            check('color', 'fontColor', 'black') ||\n            check('align', 'align', '') ||\n            check('valign', 'verticalAlign', '') ||\n            check('spacing', 'spacing', 2) ||\n            check('spacingTop', 'spacingTop', 0) ||\n            check('spacingRight', 'spacingRight', 0) ||\n            check('spacingBottom', 'spacingBottom', 0) ||\n            check('spacingLeft', 'spacingLeft', 0) ||\n            check('horizontal', 'horizontal', true) ||\n            check('background', 'labelBackgroundColor', null) ||\n            check('border', 'labelBorderColor', null) ||\n            check('opacity', 'textOpacity', 100) ||\n            check('textDirection', 'textDirection', DEFAULT_TEXT_DIRECTION));\n    }\n    /**\n     * Called to invoked redraw on the given text shape.\n     *\n     * @param shape {@link Text} shape to be redrawn.\n     */\n    redrawLabelShape(shape) {\n        shape.redraw();\n    }\n    /**\n     * Returns the scaling used for the label of the given state\n     *\n     * @param state <CellState> whose label scale should be returned.\n     */\n    getTextScale(state) {\n        return state.view.scale;\n    }\n    /**\n     * Returns the bounds to be used to draw the label of the given state.\n     *\n     * @param state <CellState> whose label bounds should be returned.\n     */\n    getLabelBounds(state) {\n        const { scale } = state.view;\n        const isEdge = state.cell.isEdge();\n        let bounds = new Rectangle(state.absoluteOffset.x, state.absoluteOffset.y);\n        if (isEdge) {\n            // @ts-ignore\n            const spacing = state.text.getSpacing();\n            bounds.x += spacing.x * scale;\n            bounds.y += spacing.y * scale;\n            const geo = state.cell.getGeometry();\n            if (geo != null) {\n                bounds.width = Math.max(0, geo.width * scale);\n                bounds.height = Math.max(0, geo.height * scale);\n            }\n        }\n        else {\n            // Inverts label position\n            // @ts-ignore\n            if (state.text.isPaintBoundsInverted()) {\n                const tmp = bounds.x;\n                bounds.x = bounds.y;\n                bounds.y = tmp;\n            }\n            bounds.x += state.x;\n            bounds.y += state.y;\n            // Minimum of 1 fixes alignment bug in HTML labels\n            bounds.width = Math.max(1, state.width);\n            bounds.height = Math.max(1, state.height);\n        }\n        // @ts-ignore\n        if (state.text.isPaintBoundsInverted()) {\n            // Rotates around center of state\n            const t = (state.width - state.height) / 2;\n            bounds.x += t;\n            bounds.y -= t;\n            const tmp = bounds.width;\n            bounds.width = bounds.height;\n            bounds.height = tmp;\n        }\n        // Shape can modify its label bounds\n        if (state.shape != null) {\n            const hpos = state.style.labelPosition ?? ALIGN.CENTER;\n            const vpos = state.style.verticalLabelPosition ?? ALIGN.MIDDLE;\n            if (hpos === ALIGN.CENTER && vpos === ALIGN.MIDDLE) {\n                bounds = state.shape.getLabelBounds(bounds);\n            }\n        }\n        // Label width style overrides actual label width\n        const lw = state.style.labelWidth ?? null;\n        if (lw != null) {\n            bounds.width = lw * scale;\n        }\n        if (!isEdge) {\n            this.rotateLabelBounds(state, bounds);\n        }\n        return bounds;\n    }\n    /**\n     * Adds the shape rotation to the given label bounds and\n     * applies the alignment and offsets.\n     *\n     * @param state <CellState> whose label bounds should be rotated.\n     * @param bounds {@link Rectangle} the rectangle to be rotated.\n     */\n    rotateLabelBounds(state, bounds) {\n        bounds.y -= state.text.margin.y * bounds.height;\n        bounds.x -= state.text.margin.x * bounds.width;\n        if (!this.legacySpacing ||\n            (state.style.overflow !== 'fill' && state.style.overflow !== 'width')) {\n            const s = state.view.scale;\n            const spacing = state.text.getSpacing();\n            bounds.x += spacing.x * s;\n            bounds.y += spacing.y * s;\n            const hpos = state.style.labelPosition ?? ALIGN.CENTER;\n            const vpos = state.style.verticalLabelPosition ?? ALIGN.MIDDLE;\n            const lw = state.style.labelWidth ?? null;\n            bounds.width = Math.max(0, bounds.width -\n                (hpos === ALIGN.CENTER && lw == null\n                    ? // @ts-ignore\n                        state.text.spacingLeft * s + state.text.spacingRight * s\n                    : 0));\n            bounds.height = Math.max(0, bounds.height -\n                (vpos === ALIGN.MIDDLE\n                    ? // @ts-ignore\n                        state.text.spacingTop * s + state.text.spacingBottom * s\n                    : 0));\n        }\n        // @ts-ignore\n        const theta = state.text.getTextRotation();\n        // Only needed if rotated around another center\n        if (theta !== 0 &&\n            state != null &&\n            // @ts-ignore\n            state.cell.isVertex()) {\n            const cx = state.getCenterX();\n            const cy = state.getCenterY();\n            if (bounds.x !== cx || bounds.y !== cy) {\n                const rad = theta * (Math.PI / 180);\n                const pt = getRotatedPoint(new Point(bounds.x, bounds.y), Math.cos(rad), Math.sin(rad), new Point(cx, cy));\n                bounds.x = pt.x;\n                bounds.y = pt.y;\n            }\n        }\n    }\n    /**\n     * Redraws the overlays for the given cell state.\n     *\n     * @param state <CellState> whose overlays should be redrawn.\n     */\n    redrawCellOverlays(state, forced = false) {\n        this.createCellOverlays(state);\n        if (state.overlays != null) {\n            const rot = mod(state.style.rotation ?? 0, 90);\n            const rad = toRadians(rot);\n            const cos = Math.cos(rad);\n            const sin = Math.sin(rad);\n            state.overlays.visit((id, shape) => {\n                // @ts-ignore\n                const bounds = shape.overlay.getBounds(state);\n                if (!state.cell.isEdge()) {\n                    if (state.shape != null && rot !== 0) {\n                        let cx = bounds.getCenterX();\n                        let cy = bounds.getCenterY();\n                        const point = getRotatedPoint(new Point(cx, cy), cos, sin, new Point(state.getCenterX(), state.getCenterY()));\n                        cx = point.x;\n                        cy = point.y;\n                        bounds.x = Math.round(cx - bounds.width / 2);\n                        bounds.y = Math.round(cy - bounds.height / 2);\n                    }\n                }\n                if (forced ||\n                    shape.bounds == null ||\n                    shape.scale !== state.view.scale ||\n                    !shape.bounds.equals(bounds)) {\n                    shape.bounds = bounds;\n                    shape.scale = state.view.scale;\n                    shape.redraw();\n                }\n            });\n        }\n    }\n    /**\n     * Redraws the control for the given cell state.\n     *\n     * @param state <CellState> whose control should be redrawn.\n     */\n    redrawControl(state, forced = false) {\n        const image = state.view.graph.getFoldingImage(state);\n        if (state.control != null && image != null) {\n            const bounds = this.getControlBounds(state, image.width, image.height);\n            const r = this.legacyControlPosition\n                ? state.style.rotation ?? 0\n                : state.shape.getTextRotation();\n            const s = state.view.scale;\n            if (forced ||\n                state.control.scale !== s ||\n                !state.control.bounds.equals(bounds) ||\n                state.control.rotation !== r) {\n                state.control.rotation = r;\n                state.control.bounds = bounds;\n                state.control.scale = s;\n                state.control.redraw();\n            }\n        }\n    }\n    /**\n     * Returns the bounds to be used to draw the control (folding icon) of the\n     * given state.\n     */\n    getControlBounds(state, w, h) {\n        if (state.control != null) {\n            const s = state.view.scale;\n            let cx = state.getCenterX();\n            let cy = state.getCenterY();\n            if (!state.cell.isEdge()) {\n                cx = state.x + w * s;\n                cy = state.y + h * s;\n                if (state.shape != null) {\n                    // TODO: Factor out common code\n                    let rot = state.shape.getShapeRotation();\n                    if (this.legacyControlPosition) {\n                        rot = state.style.rotation ?? 0;\n                    }\n                    else if (state.shape.isPaintBoundsInverted()) {\n                        const t = (state.width - state.height) / 2;\n                        cx += t;\n                        cy -= t;\n                    }\n                    if (rot !== 0) {\n                        const rad = toRadians(rot);\n                        const cos = Math.cos(rad);\n                        const sin = Math.sin(rad);\n                        const point = getRotatedPoint(new Point(cx, cy), cos, sin, new Point(state.getCenterX(), state.getCenterY()));\n                        cx = point.x;\n                        cy = point.y;\n                    }\n                }\n            }\n            return state.cell.isEdge()\n                ? new Rectangle(Math.round(cx - (w / 2) * s), Math.round(cy - (h / 2) * s), Math.round(w * s), Math.round(h * s))\n                : new Rectangle(Math.round(cx - (w / 2) * s), Math.round(cy - (h / 2) * s), Math.round(w * s), Math.round(h * s));\n        }\n        return null;\n    }\n    /**\n     * Inserts the given array of {@link Shapes} after the given nodes in the DOM.\n     *\n     * @param shapes Array of {@link Shapes} to be inserted.\n     * @param node Node in <drawPane> after which the shapes should be inserted.\n     * @param htmlNode Node in the graph container after which the shapes should be inserted that\n     * will not go into the <drawPane> (eg. HTML labels without foreignObjects).\n     */\n    insertStateAfter(state, node, htmlNode) {\n        const graph = state.view.graph;\n        const shapes = this.getShapesForState(state);\n        for (let i = 0; i < shapes.length; i += 1) {\n            // @ts-ignore\n            if (shapes[i] != null && shapes[i].node != null) {\n                const html = \n                // @ts-ignore\n                shapes[i].node.parentNode !== state.view.getDrawPane() &&\n                    // @ts-ignore\n                    shapes[i].node.parentNode !== state.view.getOverlayPane();\n                const temp = html ? htmlNode : node;\n                // @ts-ignore\n                if (temp != null && temp.nextSibling !== shapes[i].node) {\n                    if (temp.nextSibling == null) {\n                        // @ts-ignore\n                        temp.parentNode.appendChild(shapes[i].node);\n                    }\n                    else {\n                        // @ts-ignore\n                        temp.parentNode.insertBefore(shapes[i].node, temp.nextSibling);\n                    }\n                }\n                else if (temp == null) {\n                    // Special case: First HTML node should be first sibling after canvas\n                    // @ts-ignore\n                    const shapeNode = shapes[i].node;\n                    if (shapeNode.parentNode === graph.container) {\n                        let { canvas } = state.view;\n                        while (canvas != null && canvas.parentNode !== graph.container) {\n                            // @ts-ignore\n                            canvas = canvas.parentNode;\n                        }\n                        if (canvas != null && canvas.nextSibling != null) {\n                            if (canvas.nextSibling !== shapeNode) {\n                                // @ts-ignore\n                                shapeNode.parentNode.insertBefore(shapeNode, canvas.nextSibling);\n                            }\n                        }\n                        else {\n                            // @ts-ignore\n                            shapeNode.parentNode.appendChild(shapeNode);\n                        }\n                    }\n                    else if (shapeNode.parentNode != null &&\n                        shapeNode.parentNode.firstChild != null &&\n                        shapeNode.parentNode.firstChild != shapeNode) {\n                        // Inserts the node as the first child of the parent to implement the order\n                        shapeNode.parentNode.insertBefore(shapeNode, shapeNode.parentNode.firstChild);\n                    }\n                }\n                if (html) {\n                    // @ts-ignore\n                    htmlNode = shapes[i].node;\n                }\n                else {\n                    // @ts-ignore\n                    node = shapes[i].node;\n                }\n            }\n        }\n        return [node, htmlNode];\n    }\n    /**\n     * Returns the {@link Shapes} for the given cell state in the order in which they should\n     * appear in the DOM.\n     *\n     * @param state <CellState> whose shapes should be returned.\n     */\n    getShapesForState(state) {\n        return [state.shape, state.text, state.control];\n    }\n    /**\n     * Updates the bounds or points and scale of the shapes for the given cell\n     * state. This is called in mxGraphView.validatePoints as the last step of\n     * updating all cells.\n     *\n     * @param state <CellState> for which the shapes should be updated.\n     * @param force Optional boolean that specifies if the cell should be reconfiured\n     * and redrawn without any additional checks.\n     * @param rendering Optional boolean that specifies if the cell should actually\n     * be drawn into the DOM. If this is false then redraw and/or reconfigure\n     * will not be called on the shape.\n     */\n    redraw(state, force = false, rendering = true) {\n        const shapeChanged = this.redrawShape(state, force, rendering);\n        if (state.shape != null && rendering) {\n            this.redrawLabel(state, shapeChanged);\n            this.redrawCellOverlays(state, shapeChanged);\n            this.redrawControl(state, shapeChanged);\n        }\n    }\n    /**\n     * Redraws the shape for the given cell state.\n     *\n     * @param state <CellState> whose label should be redrawn.\n     */\n    redrawShape(state, force = false, rendering = true) {\n        let shapeChanged = false;\n        const graph = state.view.graph;\n        // Forces creation of new shape if shape style has changed\n        if (state.shape != null &&\n            state.shape.style != null &&\n            state.style != null &&\n            state.shape.style.shape !== state.style.shape) {\n            state.shape.destroy();\n            state.shape = null;\n        }\n        if (state.shape == null &&\n            graph.container != null &&\n            state.cell !== state.view.currentRoot &&\n            (state.cell.isVertex() || state.cell.isEdge())) {\n            state.shape = this.createShape(state);\n            if (state.shape != null) {\n                state.shape.minSvgStrokeWidth = this.minSvgStrokeWidth;\n                state.shape.antiAlias = this.antiAlias;\n                this.createIndicatorShape(state);\n                this.initializeShape(state);\n                this.createCellOverlays(state);\n                this.installListeners(state);\n                // Forces a refresh of the handler if one exists\n                const selectionCellsHandler = graph.getPlugin('SelectionCellsHandler');\n                selectionCellsHandler?.updateHandler(state);\n            }\n        }\n        else if (!force &&\n            state.shape != null &&\n            (!equalEntries(state.shape.style, state.style) ||\n                this.checkPlaceholderStyles(state))) {\n            state.shape.resetStyles();\n            this.configureShape(state);\n            // LATER: Ignore update for realtime to fix reset of current gesture\n            const selectionCellsHandler = graph.getPlugin('SelectionCellsHandler');\n            selectionCellsHandler?.updateHandler(state);\n            force = true;\n        }\n        // Updates indicator shape\n        if (state.shape != null &&\n            state.shape.indicatorShape != this.getShape(state.getIndicatorShape())) {\n            if (state.shape.indicator != null) {\n                state.shape.indicator.destroy();\n                state.shape.indicator = null;\n            }\n            this.createIndicatorShape(state);\n            if (state.shape.indicatorShape != null) {\n                state.shape.indicator = new state.shape.indicatorShape();\n                state.shape.indicator.dialect = state.shape.dialect;\n                state.shape.indicator.init(state.node);\n                force = true;\n            }\n        }\n        if (state.shape) {\n            // Handles changes of the collapse icon\n            this.createControl(state);\n            // Redraws the cell if required, ignores changes to bounds if points are\n            // defined as the bounds are updated for the given points inside the shape\n            if (force || this.isShapeInvalid(state, state.shape)) {\n                if (state.absolutePoints.length > 0) {\n                    state.shape.points = state.absolutePoints.slice();\n                    state.shape.bounds = null;\n                }\n                else {\n                    state.shape.points = [];\n                    state.shape.bounds = new Rectangle(state.x, state.y, state.width, state.height);\n                }\n                state.shape.scale = state.view.scale;\n                if (rendering == null || rendering) {\n                    this.doRedrawShape(state);\n                }\n                else {\n                    state.shape.updateBoundingBox();\n                }\n                shapeChanged = true;\n            }\n        }\n        return shapeChanged;\n    }\n    /**\n     * Invokes redraw on the shape of the given state.\n     */\n    doRedrawShape(state) {\n        state.shape?.redraw();\n    }\n    /**\n     * Returns true if the given shape must be repainted.\n     */\n    isShapeInvalid(state, shape) {\n        return (shape.bounds == null ||\n            shape.scale !== state.view.scale ||\n            (state.absolutePoints.length === 0 && !shape.bounds.equals(state)) ||\n            (state.absolutePoints.length > 0 &&\n                !equalPoints(shape.points, state.absolutePoints)));\n    }\n    /**\n     * Destroys the shapes associated with the given cell state.\n     *\n     * @param state <CellState> for which the shapes should be destroyed.\n     */\n    destroy(state) {\n        if (state.shape) {\n            if (state.text) {\n                state.text.destroy();\n                state.text = null;\n            }\n            state.overlays.visit((id, shape) => {\n                shape.destroy();\n            });\n            state.overlays = new Dictionary();\n            if (state.control) {\n                state.control.destroy();\n                state.control = null;\n            }\n            state.shape.destroy();\n            state.shape = null;\n        }\n    }\n}\n/**\n * Static array that contains the globally registered shapes which are\n * known to all instances of this class. For adding new shapes you should\n * use the static {@link CellRenderer#registerShape} function.\n */\nCellRenderer.defaultShapes = {};\nexport default CellRenderer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}