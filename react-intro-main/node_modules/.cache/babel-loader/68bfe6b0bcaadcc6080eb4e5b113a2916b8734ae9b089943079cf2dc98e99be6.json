{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { DIALECT, GUIDE_COLOR, GUIDE_STROKEWIDTH } from '../../util/Constants';\nimport Point from '../geometry/Point';\nimport PolylineShape from '../geometry/edge/PolylineShape';\n/**\n * Implements the alignment of selection cells to other cells in the graph.\n *\n * Constructor: mxGuide\n *\n * Constructs a new guide object.\n */\nclass Guide {\n  constructor(graph, states) {\n    /**\n     * Contains the {@link CellStates} that are used for alignment.\n     */\n    this.states = [];\n    /**\n     * Specifies if horizontal guides are enabled. Default is true.\n     */\n    this.horizontal = true;\n    /**\n     * Specifies if vertical guides are enabled. Default is true.\n     */\n    this.vertical = true;\n    /**\n     * Holds the {@link Shape} for the horizontal guide.\n     */\n    this.guideX = null;\n    /**\n     * Holds the {@link Shape} for the vertical guide.\n     */\n    this.guideY = null;\n    /**\n     * Specifies if rounded coordinates should be used. Default is false.\n     */\n    this.rounded = false;\n    /**\n     * Default tolerance in px if grid is disabled. Default is 2.\n     */\n    this.tolerance = 2;\n    this.graph = graph;\n    this.setStates(states);\n  }\n  /**\n   * Sets the {@link CellState}s that should be used for alignment.\n   */\n  setStates(states) {\n    this.states = states;\n  }\n  /**\n   * Returns true if the guide should be enabled for the given native event. This\n   * implementation always returns true.\n   */\n  isEnabledForEvent(evt) {\n    return true;\n  }\n  /**\n   * Returns the tolerance for the guides. Default value is gridSize / 2.\n   */\n  getGuideTolerance(gridEnabled = false) {\n    return gridEnabled && this.graph.isGridEnabled() ? this.graph.getGridSize() / 2 : this.tolerance;\n  }\n  /**\n   * Returns the mxShape to be used for painting the respective guide. This\n   * implementation returns a new, dashed and crisp {@link PolylineShape} using\n   * {@link GUIDE_COLOR} and {@link GUIDE_STROKEWIDTH} as the format.\n   *\n   * @param horizontal Boolean that specifies which guide should be created.\n   */\n  createGuideShape(horizontal = false) {\n    // TODO: Should vertical guides be supported here?? ============================\n    const guide = new PolylineShape([], GUIDE_COLOR, GUIDE_STROKEWIDTH);\n    guide.isDashed = true;\n    return guide;\n  }\n  /**\n   * Returns true if the given state should be ignored.\n   * @param state\n   */\n  isStateIgnored(state) {\n    return false;\n  }\n  /**\n   * Moves the <bounds> by the given {@link Point} and returnt the snapped point.\n   */\n  move(bounds = null, delta, gridEnabled = false, clone = false) {\n    if ((this.horizontal || this.vertical) && bounds) {\n      const {\n        scale\n      } = this.graph.getView();\n      const tt = this.getGuideTolerance(gridEnabled) * scale;\n      const b = bounds.clone();\n      b.x += delta.x;\n      b.y += delta.y;\n      let overrideX = false;\n      let stateX = null;\n      let valueX = null;\n      let overrideY = false;\n      let stateY = null;\n      let valueY = null;\n      let ttX = tt;\n      let ttY = tt;\n      const left = b.x;\n      const right = b.x + b.width;\n      const center = b.getCenterX();\n      const top = b.y;\n      const bottom = b.y + b.height;\n      const middle = b.getCenterY();\n      // Snaps the left, center and right to the given x-coordinate\n      const snapX = (x, state, centerAlign) => {\n        let override = false;\n        if (centerAlign && Math.abs(x - center) < ttX) {\n          delta.x = x - bounds.getCenterX();\n          ttX = Math.abs(x - center);\n          override = true;\n        } else if (!centerAlign) {\n          if (Math.abs(x - left) < ttX) {\n            delta.x = x - bounds.x;\n            ttX = Math.abs(x - left);\n            override = true;\n          } else if (Math.abs(x - right) < ttX) {\n            delta.x = x - bounds.x - bounds.width;\n            ttX = Math.abs(x - right);\n            override = true;\n          }\n        }\n        if (override) {\n          stateX = state;\n          valueX = x;\n          if (!this.guideX) {\n            this.guideX = this.createGuideShape(true);\n            // Makes sure to use SVG shapes in order to implement\n            // event-transparency on the background area of the rectangle since\n            // HTML shapes do not let mouseevents through even when transparent\n            this.guideX.dialect = DIALECT.SVG;\n            this.guideX.pointerEvents = false;\n            this.guideX.init(this.graph.getView().getOverlayPane());\n          }\n        }\n        overrideX = overrideX || override;\n      };\n      // Snaps the top, middle or bottom to the given y-coordinate\n      const snapY = (y, state, centerAlign) => {\n        let override = false;\n        if (centerAlign && Math.abs(y - middle) < ttY) {\n          delta.y = y - bounds.getCenterY();\n          ttY = Math.abs(y - middle);\n          override = true;\n        } else if (!centerAlign) {\n          if (Math.abs(y - top) < ttY) {\n            delta.y = y - bounds.y;\n            ttY = Math.abs(y - top);\n            override = true;\n          } else if (Math.abs(y - bottom) < ttY) {\n            delta.y = y - bounds.y - bounds.height;\n            ttY = Math.abs(y - bottom);\n            override = true;\n          }\n        }\n        if (override) {\n          stateY = state;\n          valueY = y;\n          if (!this.guideY) {\n            this.guideY = this.createGuideShape(false);\n            // Makes sure to use SVG shapes in order to implement\n            // event-transparency on the background area of the rectangle since\n            // HTML shapes do not let mouseevents through even when transparent\n            this.guideY.dialect = DIALECT.SVG;\n            this.guideY.pointerEvents = false;\n            this.guideY.init(this.graph.getView().getOverlayPane());\n          }\n        }\n        overrideY = overrideY || override;\n      };\n      for (let i = 0; i < this.states.length; i += 1) {\n        const state = this.states[i];\n        if (state && !this.isStateIgnored(state)) {\n          // Align x\n          if (this.horizontal) {\n            snapX(state.getCenterX(), state, true);\n            snapX(state.x, state, false);\n            snapX(state.x + state.width, state, false);\n            // Aligns left and right of shape to center of page\n            if (!state.cell) {\n              snapX(state.getCenterX(), state, false);\n            }\n          }\n          // Align y\n          if (this.vertical) {\n            snapY(state.getCenterY(), state, true);\n            snapY(state.y, state, false);\n            snapY(state.y + state.height, state, false);\n            // Aligns left and right of shape to center of page\n            if (!state.cell) {\n              snapY(state.getCenterY(), state, false);\n            }\n          }\n        }\n      }\n      // Moves cells to the raster if not aligned\n      this.graph.snapDelta(delta, bounds, !gridEnabled, overrideX, overrideY);\n      delta = this.getDelta(bounds, stateX, delta.x, stateY, delta.y);\n      // Redraws the guides\n      const c = this.graph.container;\n      if (!overrideX && this.guideX) {\n        this.guideX.node.style.visibility = 'hidden';\n      } else if (this.guideX) {\n        let minY = null;\n        let maxY = null;\n        if (stateX) {\n          minY = Math.min(bounds.y + delta.y - this.graph.getPanDy(), stateX.y);\n          maxY = Math.max(bounds.y + bounds.height + delta.y - this.graph.getPanDy(),\n          // @ts-ignore stateX! doesn't work for some reason...\n          stateX.y + stateX.height);\n        }\n        if (minY !== null && maxY !== null) {\n          this.guideX.points = [new Point(valueX, minY), new Point(valueX, maxY)];\n        } else {\n          this.guideX.points = [new Point(valueX, -this.graph.getPanDy()), new Point(valueX, c.scrollHeight - 3 - this.graph.getPanDy())];\n        }\n        this.guideX.stroke = this.getGuideColor(stateX, true);\n        this.guideX.node.style.visibility = 'visible';\n        this.guideX.redraw();\n      }\n      if (!overrideY && this.guideY != null) {\n        this.guideY.node.style.visibility = 'hidden';\n      } else if (this.guideY != null) {\n        let minX = null;\n        let maxX = null;\n        if (stateY != null && bounds != null) {\n          minX = Math.min(bounds.x + delta.x - this.graph.getPanDx(), stateY.x);\n          maxX = Math.max(bounds.x + bounds.width + delta.x - this.graph.getPanDx(),\n          // @ts-ignore\n          stateY.x + stateY.width);\n        }\n        if (minX != null && maxX != null && valueY !== null) {\n          this.guideY.points = [new Point(minX, valueY), new Point(maxX, valueY)];\n        } else if (valueY !== null) {\n          this.guideY.points = [new Point(-this.graph.getPanDx(), valueY), new Point(c.scrollWidth - 3 - this.graph.getPanDx(), valueY)];\n        }\n        this.guideY.stroke = this.getGuideColor(stateY, false);\n        this.guideY.node.style.visibility = 'visible';\n        this.guideY.redraw();\n      }\n    }\n    return delta;\n  }\n  /**\n   * Rounds to pixels for virtual states (eg. page guides)\n   */\n  getDelta(bounds, stateX = null, dx, stateY = null, dy) {\n    const s = this.graph.view.scale;\n    if (this.rounded || stateX != null && stateX.cell == null) {\n      dx = Math.round((bounds.x + dx) / s) * s - bounds.x;\n    }\n    if (this.rounded || stateY != null && stateY.cell == null) {\n      dy = Math.round((bounds.y + dy) / s) * s - bounds.y;\n    }\n    return new Point(dx, dy);\n  }\n  /**\n   * Hides all current guides.\n   */\n  getGuideColor(state, horizontal) {\n    return GUIDE_COLOR;\n  }\n  /**\n   * Hides all current guides.\n   */\n  hide() {\n    this.setVisible(false);\n  }\n  /**\n   * Shows or hides the current guides.\n   */\n  setVisible(visible) {\n    if (this.guideX) {\n      this.guideX.node.style.visibility = visible ? 'visible' : 'hidden';\n    }\n    if (this.guideY) {\n      this.guideY.node.style.visibility = visible ? 'visible' : 'hidden';\n    }\n  }\n  /**\n   * Destroys all resources that this object uses.\n   */\n  destroy() {\n    if (this.guideX) {\n      this.guideX.destroy();\n      this.guideX = null;\n    }\n    if (this.guideY) {\n      this.guideY.destroy();\n      this.guideY = null;\n    }\n  }\n}\nexport default Guide;","map":{"version":3,"names":["DIALECT","GUIDE_COLOR","GUIDE_STROKEWIDTH","Point","PolylineShape","Guide","constructor","graph","states","horizontal","vertical","guideX","guideY","rounded","tolerance","setStates","isEnabledForEvent","evt","getGuideTolerance","gridEnabled","isGridEnabled","getGridSize","createGuideShape","guide","isDashed","isStateIgnored","state","move","bounds","delta","clone","scale","getView","tt","b","x","y","overrideX","stateX","valueX","overrideY","stateY","valueY","ttX","ttY","left","right","width","center","getCenterX","top","bottom","height","middle","getCenterY","snapX","centerAlign","override","Math","abs","dialect","SVG","pointerEvents","init","getOverlayPane","snapY","i","length","cell","snapDelta","getDelta","c","container","node","style","visibility","minY","maxY","min","getPanDy","max","points","scrollHeight","stroke","getGuideColor","redraw","minX","maxX","getPanDx","scrollWidth","dx","dy","s","view","round","hide","setVisible","visible","destroy"],"sources":["D:/OSPanel/domains/проекты open server/old/react/react-intro-main/node_modules/@maxgraph/core/dist/view/other/Guide.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { DIALECT, GUIDE_COLOR, GUIDE_STROKEWIDTH } from '../../util/Constants';\nimport Point from '../geometry/Point';\nimport PolylineShape from '../geometry/edge/PolylineShape';\n/**\n * Implements the alignment of selection cells to other cells in the graph.\n *\n * Constructor: mxGuide\n *\n * Constructs a new guide object.\n */\nclass Guide {\n    constructor(graph, states) {\n        /**\n         * Contains the {@link CellStates} that are used for alignment.\n         */\n        this.states = [];\n        /**\n         * Specifies if horizontal guides are enabled. Default is true.\n         */\n        this.horizontal = true;\n        /**\n         * Specifies if vertical guides are enabled. Default is true.\n         */\n        this.vertical = true;\n        /**\n         * Holds the {@link Shape} for the horizontal guide.\n         */\n        this.guideX = null;\n        /**\n         * Holds the {@link Shape} for the vertical guide.\n         */\n        this.guideY = null;\n        /**\n         * Specifies if rounded coordinates should be used. Default is false.\n         */\n        this.rounded = false;\n        /**\n         * Default tolerance in px if grid is disabled. Default is 2.\n         */\n        this.tolerance = 2;\n        this.graph = graph;\n        this.setStates(states);\n    }\n    /**\n     * Sets the {@link CellState}s that should be used for alignment.\n     */\n    setStates(states) {\n        this.states = states;\n    }\n    /**\n     * Returns true if the guide should be enabled for the given native event. This\n     * implementation always returns true.\n     */\n    isEnabledForEvent(evt) {\n        return true;\n    }\n    /**\n     * Returns the tolerance for the guides. Default value is gridSize / 2.\n     */\n    getGuideTolerance(gridEnabled = false) {\n        return gridEnabled && this.graph.isGridEnabled()\n            ? this.graph.getGridSize() / 2\n            : this.tolerance;\n    }\n    /**\n     * Returns the mxShape to be used for painting the respective guide. This\n     * implementation returns a new, dashed and crisp {@link PolylineShape} using\n     * {@link GUIDE_COLOR} and {@link GUIDE_STROKEWIDTH} as the format.\n     *\n     * @param horizontal Boolean that specifies which guide should be created.\n     */\n    createGuideShape(horizontal = false) {\n        // TODO: Should vertical guides be supported here?? ============================\n        const guide = new PolylineShape([], GUIDE_COLOR, GUIDE_STROKEWIDTH);\n        guide.isDashed = true;\n        return guide;\n    }\n    /**\n     * Returns true if the given state should be ignored.\n     * @param state\n     */\n    isStateIgnored(state) {\n        return false;\n    }\n    /**\n     * Moves the <bounds> by the given {@link Point} and returnt the snapped point.\n     */\n    move(bounds = null, delta, gridEnabled = false, clone = false) {\n        if ((this.horizontal || this.vertical) && bounds) {\n            const { scale } = this.graph.getView();\n            const tt = this.getGuideTolerance(gridEnabled) * scale;\n            const b = bounds.clone();\n            b.x += delta.x;\n            b.y += delta.y;\n            let overrideX = false;\n            let stateX = null;\n            let valueX = null;\n            let overrideY = false;\n            let stateY = null;\n            let valueY = null;\n            let ttX = tt;\n            let ttY = tt;\n            const left = b.x;\n            const right = b.x + b.width;\n            const center = b.getCenterX();\n            const top = b.y;\n            const bottom = b.y + b.height;\n            const middle = b.getCenterY();\n            // Snaps the left, center and right to the given x-coordinate\n            const snapX = (x, state, centerAlign) => {\n                let override = false;\n                if (centerAlign && Math.abs(x - center) < ttX) {\n                    delta.x = x - bounds.getCenterX();\n                    ttX = Math.abs(x - center);\n                    override = true;\n                }\n                else if (!centerAlign) {\n                    if (Math.abs(x - left) < ttX) {\n                        delta.x = x - bounds.x;\n                        ttX = Math.abs(x - left);\n                        override = true;\n                    }\n                    else if (Math.abs(x - right) < ttX) {\n                        delta.x = x - bounds.x - bounds.width;\n                        ttX = Math.abs(x - right);\n                        override = true;\n                    }\n                }\n                if (override) {\n                    stateX = state;\n                    valueX = x;\n                    if (!this.guideX) {\n                        this.guideX = this.createGuideShape(true);\n                        // Makes sure to use SVG shapes in order to implement\n                        // event-transparency on the background area of the rectangle since\n                        // HTML shapes do not let mouseevents through even when transparent\n                        this.guideX.dialect = DIALECT.SVG;\n                        this.guideX.pointerEvents = false;\n                        this.guideX.init(this.graph.getView().getOverlayPane());\n                    }\n                }\n                overrideX = overrideX || override;\n            };\n            // Snaps the top, middle or bottom to the given y-coordinate\n            const snapY = (y, state, centerAlign) => {\n                let override = false;\n                if (centerAlign && Math.abs(y - middle) < ttY) {\n                    delta.y = y - bounds.getCenterY();\n                    ttY = Math.abs(y - middle);\n                    override = true;\n                }\n                else if (!centerAlign) {\n                    if (Math.abs(y - top) < ttY) {\n                        delta.y = y - bounds.y;\n                        ttY = Math.abs(y - top);\n                        override = true;\n                    }\n                    else if (Math.abs(y - bottom) < ttY) {\n                        delta.y = y - bounds.y - bounds.height;\n                        ttY = Math.abs(y - bottom);\n                        override = true;\n                    }\n                }\n                if (override) {\n                    stateY = state;\n                    valueY = y;\n                    if (!this.guideY) {\n                        this.guideY = this.createGuideShape(false);\n                        // Makes sure to use SVG shapes in order to implement\n                        // event-transparency on the background area of the rectangle since\n                        // HTML shapes do not let mouseevents through even when transparent\n                        this.guideY.dialect = DIALECT.SVG;\n                        this.guideY.pointerEvents = false;\n                        this.guideY.init(this.graph.getView().getOverlayPane());\n                    }\n                }\n                overrideY = overrideY || override;\n            };\n            for (let i = 0; i < this.states.length; i += 1) {\n                const state = this.states[i];\n                if (state && !this.isStateIgnored(state)) {\n                    // Align x\n                    if (this.horizontal) {\n                        snapX(state.getCenterX(), state, true);\n                        snapX(state.x, state, false);\n                        snapX(state.x + state.width, state, false);\n                        // Aligns left and right of shape to center of page\n                        if (!state.cell) {\n                            snapX(state.getCenterX(), state, false);\n                        }\n                    }\n                    // Align y\n                    if (this.vertical) {\n                        snapY(state.getCenterY(), state, true);\n                        snapY(state.y, state, false);\n                        snapY(state.y + state.height, state, false);\n                        // Aligns left and right of shape to center of page\n                        if (!state.cell) {\n                            snapY(state.getCenterY(), state, false);\n                        }\n                    }\n                }\n            }\n            // Moves cells to the raster if not aligned\n            this.graph.snapDelta(delta, bounds, !gridEnabled, overrideX, overrideY);\n            delta = this.getDelta(bounds, stateX, delta.x, stateY, delta.y);\n            // Redraws the guides\n            const c = this.graph.container;\n            if (!overrideX && this.guideX) {\n                this.guideX.node.style.visibility = 'hidden';\n            }\n            else if (this.guideX) {\n                let minY = null;\n                let maxY = null;\n                if (stateX) {\n                    minY = Math.min(bounds.y + delta.y - this.graph.getPanDy(), stateX.y);\n                    maxY = Math.max(bounds.y + bounds.height + delta.y - this.graph.getPanDy(), \n                    // @ts-ignore stateX! doesn't work for some reason...\n                    stateX.y + stateX.height);\n                }\n                if (minY !== null && maxY !== null) {\n                    this.guideX.points = [new Point(valueX, minY), new Point(valueX, maxY)];\n                }\n                else {\n                    this.guideX.points = [\n                        new Point(valueX, -this.graph.getPanDy()),\n                        new Point(valueX, c.scrollHeight - 3 - this.graph.getPanDy()),\n                    ];\n                }\n                this.guideX.stroke = this.getGuideColor(stateX, true);\n                this.guideX.node.style.visibility = 'visible';\n                this.guideX.redraw();\n            }\n            if (!overrideY && this.guideY != null) {\n                this.guideY.node.style.visibility = 'hidden';\n            }\n            else if (this.guideY != null) {\n                let minX = null;\n                let maxX = null;\n                if (stateY != null && bounds != null) {\n                    minX = Math.min(bounds.x + delta.x - this.graph.getPanDx(), stateY.x);\n                    maxX = Math.max(bounds.x + bounds.width + delta.x - this.graph.getPanDx(), \n                    // @ts-ignore\n                    stateY.x + stateY.width);\n                }\n                if (minX != null && maxX != null && valueY !== null) {\n                    this.guideY.points = [new Point(minX, valueY), new Point(maxX, valueY)];\n                }\n                else if (valueY !== null) {\n                    this.guideY.points = [\n                        new Point(-this.graph.getPanDx(), valueY),\n                        new Point(c.scrollWidth - 3 - this.graph.getPanDx(), valueY),\n                    ];\n                }\n                this.guideY.stroke = this.getGuideColor(stateY, false);\n                this.guideY.node.style.visibility = 'visible';\n                this.guideY.redraw();\n            }\n        }\n        return delta;\n    }\n    /**\n     * Rounds to pixels for virtual states (eg. page guides)\n     */\n    getDelta(bounds, stateX = null, dx, stateY = null, dy) {\n        const s = this.graph.view.scale;\n        if (this.rounded || (stateX != null && stateX.cell == null)) {\n            dx = Math.round((bounds.x + dx) / s) * s - bounds.x;\n        }\n        if (this.rounded || (stateY != null && stateY.cell == null)) {\n            dy = Math.round((bounds.y + dy) / s) * s - bounds.y;\n        }\n        return new Point(dx, dy);\n    }\n    /**\n     * Hides all current guides.\n     */\n    getGuideColor(state, horizontal) {\n        return GUIDE_COLOR;\n    }\n    /**\n     * Hides all current guides.\n     */\n    hide() {\n        this.setVisible(false);\n    }\n    /**\n     * Shows or hides the current guides.\n     */\n    setVisible(visible) {\n        if (this.guideX) {\n            this.guideX.node.style.visibility = visible ? 'visible' : 'hidden';\n        }\n        if (this.guideY) {\n            this.guideY.node.style.visibility = visible ? 'visible' : 'hidden';\n        }\n    }\n    /**\n     * Destroys all resources that this object uses.\n     */\n    destroy() {\n        if (this.guideX) {\n            this.guideX.destroy();\n            this.guideX = null;\n        }\n        if (this.guideY) {\n            this.guideY.destroy();\n            this.guideY = null;\n        }\n    }\n}\nexport default Guide;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}