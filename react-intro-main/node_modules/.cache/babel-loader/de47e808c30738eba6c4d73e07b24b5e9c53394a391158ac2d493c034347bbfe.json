{"ast":null,"code":"var _PersistedMenuHideState;\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar PersistedMenuHideState_1, MenuInfo_1;\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { DebounceEmitter, Emitter } from '../../../base/common/event.js';\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nimport { isIMenuItem, isISubmenuItem, MenuItemAction, MenuRegistry, SubmenuItemAction } from './actions.js';\nimport { ICommandService } from '../../commands/common/commands.js';\nimport { IContextKeyService } from '../../contextkey/common/contextkey.js';\nimport { Separator, toAction } from '../../../base/common/actions.js';\nimport { IStorageService } from '../../storage/common/storage.js';\nimport { removeFastWithoutKeepingOrder } from '../../../base/common/arrays.js';\nimport { localize } from '../../../nls.js';\nimport { IKeybindingService } from '../../keybinding/common/keybinding.js';\nlet MenuService = class MenuService {\n  constructor(_commandService, _keybindingService, storageService) {\n    this._commandService = _commandService;\n    this._keybindingService = _keybindingService;\n    this._hiddenStates = new PersistedMenuHideState(storageService);\n  }\n  createMenu(id, contextKeyService, options) {\n    return new MenuImpl(id, this._hiddenStates, {\n      emitEventsForSubmenuChanges: false,\n      eventDebounceDelay: 50,\n      ...options\n    }, this._commandService, this._keybindingService, contextKeyService);\n  }\n  getMenuActions(id, contextKeyService, options) {\n    const menu = new MenuImpl(id, this._hiddenStates, {\n      emitEventsForSubmenuChanges: false,\n      eventDebounceDelay: 50,\n      ...options\n    }, this._commandService, this._keybindingService, contextKeyService);\n    const actions = menu.getActions(options);\n    menu.dispose();\n    return actions;\n  }\n  resetHiddenStates(ids) {\n    this._hiddenStates.reset(ids);\n  }\n};\nMenuService = __decorate([__param(0, ICommandService), __param(1, IKeybindingService), __param(2, IStorageService)], MenuService);\nexport { MenuService };\nlet PersistedMenuHideState = (_PersistedMenuHideState = class PersistedMenuHideState {\n  constructor(_storageService) {\n    this._storageService = _storageService;\n    this._disposables = new DisposableStore();\n    this._onDidChange = new Emitter();\n    this.onDidChange = this._onDidChange.event;\n    this._ignoreChangeEvent = false;\n    this._hiddenByDefaultCache = new Map();\n    try {\n      const raw = _storageService.get(PersistedMenuHideState_1._key, 0 /* StorageScope.PROFILE */, '{}');\n      this._data = JSON.parse(raw);\n    } catch (err) {\n      this._data = Object.create(null);\n    }\n    this._disposables.add(_storageService.onDidChangeValue(0 /* StorageScope.PROFILE */, PersistedMenuHideState_1._key, this._disposables)(() => {\n      if (!this._ignoreChangeEvent) {\n        try {\n          const raw = _storageService.get(PersistedMenuHideState_1._key, 0 /* StorageScope.PROFILE */, '{}');\n          this._data = JSON.parse(raw);\n        } catch (err) {\n          console.log('FAILED to read storage after UPDATE', err);\n        }\n      }\n      this._onDidChange.fire();\n    }));\n  }\n  dispose() {\n    this._onDidChange.dispose();\n    this._disposables.dispose();\n  }\n  _isHiddenByDefault(menu, commandId) {\n    var _this$_hiddenByDefaul;\n    return (_this$_hiddenByDefaul = this._hiddenByDefaultCache.get(\"\".concat(menu.id, \"/\").concat(commandId))) !== null && _this$_hiddenByDefaul !== void 0 ? _this$_hiddenByDefaul : false;\n  }\n  setDefaultState(menu, commandId, hidden) {\n    this._hiddenByDefaultCache.set(\"\".concat(menu.id, \"/\").concat(commandId), hidden);\n  }\n  isHidden(menu, commandId) {\n    var _this$_data$menu$id$i, _this$_data$menu$id;\n    const hiddenByDefault = this._isHiddenByDefault(menu, commandId);\n    const state = (_this$_data$menu$id$i = (_this$_data$menu$id = this._data[menu.id]) === null || _this$_data$menu$id === void 0 ? void 0 : _this$_data$menu$id.includes(commandId)) !== null && _this$_data$menu$id$i !== void 0 ? _this$_data$menu$id$i : false;\n    return hiddenByDefault ? !state : state;\n  }\n  updateHidden(menu, commandId, hidden) {\n    const hiddenByDefault = this._isHiddenByDefault(menu, commandId);\n    if (hiddenByDefault) {\n      hidden = !hidden;\n    }\n    const entries = this._data[menu.id];\n    if (!hidden) {\n      // remove and cleanup\n      if (entries) {\n        const idx = entries.indexOf(commandId);\n        if (idx >= 0) {\n          removeFastWithoutKeepingOrder(entries, idx);\n        }\n        if (entries.length === 0) {\n          delete this._data[menu.id];\n        }\n      }\n    } else {\n      // add unless already added\n      if (!entries) {\n        this._data[menu.id] = [commandId];\n      } else {\n        const idx = entries.indexOf(commandId);\n        if (idx < 0) {\n          entries.push(commandId);\n        }\n      }\n    }\n    this._persist();\n  }\n  reset(menus) {\n    if (menus === undefined) {\n      // reset all\n      this._data = Object.create(null);\n      this._persist();\n    } else {\n      // reset only for a specific menu\n      for (const {\n        id\n      } of menus) {\n        if (this._data[id]) {\n          delete this._data[id];\n        }\n      }\n      this._persist();\n    }\n  }\n  _persist() {\n    try {\n      this._ignoreChangeEvent = true;\n      const raw = JSON.stringify(this._data);\n      this._storageService.store(PersistedMenuHideState_1._key, raw, 0 /* StorageScope.PROFILE */, 0 /* StorageTarget.USER */);\n    } finally {\n      this._ignoreChangeEvent = false;\n    }\n  }\n}, PersistedMenuHideState_1 = _PersistedMenuHideState, _PersistedMenuHideState._key = 'menu.hiddenCommands', _PersistedMenuHideState);\nPersistedMenuHideState = PersistedMenuHideState_1 = __decorate([__param(0, IStorageService)], PersistedMenuHideState);\nclass MenuInfoSnapshot {\n  constructor(_id, _collectContextKeysForSubmenus) {\n    this._id = _id;\n    this._collectContextKeysForSubmenus = _collectContextKeysForSubmenus;\n    this._menuGroups = [];\n    this._allMenuIds = new Set();\n    this._structureContextKeys = new Set();\n    this._preconditionContextKeys = new Set();\n    this._toggledContextKeys = new Set();\n    this.refresh();\n  }\n  get allMenuIds() {\n    return this._allMenuIds;\n  }\n  get structureContextKeys() {\n    return this._structureContextKeys;\n  }\n  get preconditionContextKeys() {\n    return this._preconditionContextKeys;\n  }\n  get toggledContextKeys() {\n    return this._toggledContextKeys;\n  }\n  refresh() {\n    // reset\n    this._menuGroups.length = 0;\n    this._allMenuIds.clear();\n    this._structureContextKeys.clear();\n    this._preconditionContextKeys.clear();\n    this._toggledContextKeys.clear();\n    const menuItems = this._sort(MenuRegistry.getMenuItems(this._id));\n    let group;\n    for (const item of menuItems) {\n      // group by groupId\n      const groupName = item.group || '';\n      if (!group || group[0] !== groupName) {\n        group = [groupName, []];\n        this._menuGroups.push(group);\n      }\n      group[1].push(item);\n      // keep keys and submenu ids for eventing\n      this._collectContextKeysAndSubmenuIds(item);\n    }\n    this._allMenuIds.add(this._id);\n  }\n  _sort(menuItems) {\n    // no sorting needed in snapshot\n    return menuItems;\n  }\n  _collectContextKeysAndSubmenuIds(item) {\n    MenuInfoSnapshot._fillInKbExprKeys(item.when, this._structureContextKeys);\n    if (isIMenuItem(item)) {\n      // keep precondition keys for event if applicable\n      if (item.command.precondition) {\n        MenuInfoSnapshot._fillInKbExprKeys(item.command.precondition, this._preconditionContextKeys);\n      }\n      // keep toggled keys for event if applicable\n      if (item.command.toggled) {\n        const toggledExpression = item.command.toggled.condition || item.command.toggled;\n        MenuInfoSnapshot._fillInKbExprKeys(toggledExpression, this._toggledContextKeys);\n      }\n    } else if (this._collectContextKeysForSubmenus) {\n      // recursively collect context keys from submenus so that this\n      // menu fires events when context key changes affect submenus\n      MenuRegistry.getMenuItems(item.submenu).forEach(this._collectContextKeysAndSubmenuIds, this);\n      this._allMenuIds.add(item.submenu);\n    }\n  }\n  static _fillInKbExprKeys(exp, set) {\n    if (exp) {\n      for (const key of exp.keys()) {\n        set.add(key);\n      }\n    }\n  }\n}\nlet MenuInfo = MenuInfo_1 = class MenuInfo extends MenuInfoSnapshot {\n  constructor(_id, _hiddenStates, _collectContextKeysForSubmenus, _commandService, _keybindingService, _contextKeyService) {\n    super(_id, _collectContextKeysForSubmenus);\n    this._hiddenStates = _hiddenStates;\n    this._commandService = _commandService;\n    this._keybindingService = _keybindingService;\n    this._contextKeyService = _contextKeyService;\n    this.refresh();\n  }\n  createActionGroups(options) {\n    const result = [];\n    for (const group of this._menuGroups) {\n      const [id, items] = group;\n      let activeActions;\n      for (const item of items) {\n        if (this._contextKeyService.contextMatchesRules(item.when)) {\n          const isMenuItem = isIMenuItem(item);\n          if (isMenuItem) {\n            this._hiddenStates.setDefaultState(this._id, item.command.id, !!item.isHiddenByDefault);\n          }\n          const menuHide = createMenuHide(this._id, isMenuItem ? item.command : item, this._hiddenStates);\n          if (isMenuItem) {\n            var _activeActions;\n            // MenuItemAction\n            const menuKeybinding = createConfigureKeybindingAction(this._commandService, this._keybindingService, item.command.id, item.when);\n            ((_activeActions = activeActions) !== null && _activeActions !== void 0 ? _activeActions : activeActions = []).push(new MenuItemAction(item.command, item.alt, options, menuHide, menuKeybinding, this._contextKeyService, this._commandService));\n          } else {\n            // SubmenuItemAction\n            const groups = new MenuInfo_1(item.submenu, this._hiddenStates, this._collectContextKeysForSubmenus, this._commandService, this._keybindingService, this._contextKeyService).createActionGroups(options);\n            const submenuActions = Separator.join(...groups.map(g => g[1]));\n            if (submenuActions.length > 0) {\n              var _activeActions2;\n              ((_activeActions2 = activeActions) !== null && _activeActions2 !== void 0 ? _activeActions2 : activeActions = []).push(new SubmenuItemAction(item, menuHide, submenuActions));\n            }\n          }\n        }\n      }\n      if (activeActions && activeActions.length > 0) {\n        result.push([id, activeActions]);\n      }\n    }\n    return result;\n  }\n  _sort(menuItems) {\n    return menuItems.sort(MenuInfo_1._compareMenuItems);\n  }\n  static _compareMenuItems(a, b) {\n    const aGroup = a.group;\n    const bGroup = b.group;\n    if (aGroup !== bGroup) {\n      // Falsy groups come last\n      if (!aGroup) {\n        return 1;\n      } else if (!bGroup) {\n        return -1;\n      }\n      // 'navigation' group comes first\n      if (aGroup === 'navigation') {\n        return -1;\n      } else if (bGroup === 'navigation') {\n        return 1;\n      }\n      // lexical sort for groups\n      const value = aGroup.localeCompare(bGroup);\n      if (value !== 0) {\n        return value;\n      }\n    }\n    // sort on priority - default is 0\n    const aPrio = a.order || 0;\n    const bPrio = b.order || 0;\n    if (aPrio < bPrio) {\n      return -1;\n    } else if (aPrio > bPrio) {\n      return 1;\n    }\n    // sort on titles\n    return MenuInfo_1._compareTitles(isIMenuItem(a) ? a.command.title : a.title, isIMenuItem(b) ? b.command.title : b.title);\n  }\n  static _compareTitles(a, b) {\n    const aStr = typeof a === 'string' ? a : a.original;\n    const bStr = typeof b === 'string' ? b : b.original;\n    return aStr.localeCompare(bStr);\n  }\n};\nMenuInfo = MenuInfo_1 = __decorate([__param(3, ICommandService), __param(4, IKeybindingService), __param(5, IContextKeyService)], MenuInfo);\nlet MenuImpl = class MenuImpl {\n  constructor(id, hiddenStates, options, commandService, keybindingService, contextKeyService) {\n    this._disposables = new DisposableStore();\n    this._menuInfo = new MenuInfo(id, hiddenStates, options.emitEventsForSubmenuChanges, commandService, keybindingService, contextKeyService);\n    // Rebuild this menu whenever the menu registry reports an event for this MenuId.\n    // This usually happen while code and extensions are loaded and affects the over\n    // structure of the menu\n    const rebuildMenuSoon = new RunOnceScheduler(() => {\n      this._menuInfo.refresh();\n      this._onDidChange.fire({\n        menu: this,\n        isStructuralChange: true,\n        isEnablementChange: true,\n        isToggleChange: true\n      });\n    }, options.eventDebounceDelay);\n    this._disposables.add(rebuildMenuSoon);\n    this._disposables.add(MenuRegistry.onDidChangeMenu(e => {\n      for (const id of this._menuInfo.allMenuIds) {\n        if (e.has(id)) {\n          rebuildMenuSoon.schedule();\n          break;\n        }\n      }\n    }));\n    // When context keys or storage state changes we need to check if the menu also has changed. However,\n    // we only do that when someone listens on this menu because (1) these events are\n    // firing often and (2) menu are often leaked\n    const lazyListener = this._disposables.add(new DisposableStore());\n    const merge = events => {\n      let isStructuralChange = false;\n      let isEnablementChange = false;\n      let isToggleChange = false;\n      for (const item of events) {\n        isStructuralChange = isStructuralChange || item.isStructuralChange;\n        isEnablementChange = isEnablementChange || item.isEnablementChange;\n        isToggleChange = isToggleChange || item.isToggleChange;\n        if (isStructuralChange && isEnablementChange && isToggleChange) {\n          // everything is TRUE, no need to continue iterating\n          break;\n        }\n      }\n      return {\n        menu: this,\n        isStructuralChange,\n        isEnablementChange,\n        isToggleChange\n      };\n    };\n    const startLazyListener = () => {\n      lazyListener.add(contextKeyService.onDidChangeContext(e => {\n        const isStructuralChange = e.affectsSome(this._menuInfo.structureContextKeys);\n        const isEnablementChange = e.affectsSome(this._menuInfo.preconditionContextKeys);\n        const isToggleChange = e.affectsSome(this._menuInfo.toggledContextKeys);\n        if (isStructuralChange || isEnablementChange || isToggleChange) {\n          this._onDidChange.fire({\n            menu: this,\n            isStructuralChange,\n            isEnablementChange,\n            isToggleChange\n          });\n        }\n      }));\n      lazyListener.add(hiddenStates.onDidChange(e => {\n        this._onDidChange.fire({\n          menu: this,\n          isStructuralChange: true,\n          isEnablementChange: false,\n          isToggleChange: false\n        });\n      }));\n    };\n    this._onDidChange = new DebounceEmitter({\n      // start/stop context key listener\n      onWillAddFirstListener: startLazyListener,\n      onDidRemoveLastListener: lazyListener.clear.bind(lazyListener),\n      delay: options.eventDebounceDelay,\n      merge\n    });\n    this.onDidChange = this._onDidChange.event;\n  }\n  getActions(options) {\n    return this._menuInfo.createActionGroups(options);\n  }\n  dispose() {\n    this._disposables.dispose();\n    this._onDidChange.dispose();\n  }\n};\nMenuImpl = __decorate([__param(3, ICommandService), __param(4, IKeybindingService), __param(5, IContextKeyService)], MenuImpl);\nfunction createMenuHide(menu, command, states) {\n  const id = isISubmenuItem(command) ? command.submenu.id : command.id;\n  const title = typeof command.title === 'string' ? command.title : command.title.value;\n  const hide = toAction({\n    id: \"hide/\".concat(menu.id, \"/\").concat(id),\n    label: localize('hide.label', 'Hide \\'{0}\\'', title),\n    run() {\n      states.updateHidden(menu, id, true);\n    }\n  });\n  const toggle = toAction({\n    id: \"toggle/\".concat(menu.id, \"/\").concat(id),\n    label: title,\n    get checked() {\n      return !states.isHidden(menu, id);\n    },\n    run() {\n      states.updateHidden(menu, id, !!this.checked);\n    }\n  });\n  return {\n    hide,\n    toggle,\n    get isHidden() {\n      return !toggle.checked;\n    }\n  };\n}\nexport function createConfigureKeybindingAction(commandService, keybindingService, commandId) {\n  let when = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n  let enabled = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  return toAction({\n    id: \"configureKeybinding/\".concat(commandId),\n    label: localize('configure keybinding', \"Configure Keybinding\"),\n    enabled,\n    run() {\n      // Only set the when clause when there is no keybinding\n      // It is possible that the action and the keybinding have different when clauses\n      const hasKeybinding = !!keybindingService.lookupKeybinding(commandId); // This may only be called inside the `run()` method as it can be expensive on startup. #210529\n      const whenValue = !hasKeybinding && when ? when.serialize() : undefined;\n      commandService.executeCommand('workbench.action.openGlobalKeybindings', \"@command:\".concat(commandId) + (whenValue ? \" +when:\".concat(whenValue) : ''));\n    }\n  });\n}","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","PersistedMenuHideState_1","MenuInfo_1","RunOnceScheduler","DebounceEmitter","Emitter","DisposableStore","isIMenuItem","isISubmenuItem","MenuItemAction","MenuRegistry","SubmenuItemAction","ICommandService","IContextKeyService","Separator","toAction","IStorageService","removeFastWithoutKeepingOrder","localize","IKeybindingService","MenuService","constructor","_commandService","_keybindingService","storageService","_hiddenStates","PersistedMenuHideState","createMenu","id","contextKeyService","options","MenuImpl","emitEventsForSubmenuChanges","eventDebounceDelay","getMenuActions","menu","actions","getActions","dispose","resetHiddenStates","ids","reset","_PersistedMenuHideState","_storageService","_disposables","_onDidChange","onDidChange","event","_ignoreChangeEvent","_hiddenByDefaultCache","Map","raw","get","_key","_data","JSON","parse","err","create","add","onDidChangeValue","console","log","fire","_isHiddenByDefault","commandId","_this$_hiddenByDefaul","concat","setDefaultState","hidden","set","isHidden","_this$_data$menu$id$i","_this$_data$menu$id","hiddenByDefault","state","includes","updateHidden","entries","idx","indexOf","push","_persist","menus","undefined","stringify","store","MenuInfoSnapshot","_id","_collectContextKeysForSubmenus","_menuGroups","_allMenuIds","Set","_structureContextKeys","_preconditionContextKeys","_toggledContextKeys","refresh","allMenuIds","structureContextKeys","preconditionContextKeys","toggledContextKeys","clear","menuItems","_sort","getMenuItems","group","item","groupName","_collectContextKeysAndSubmenuIds","_fillInKbExprKeys","when","command","precondition","toggled","toggledExpression","condition","submenu","forEach","exp","keys","MenuInfo","_contextKeyService","createActionGroups","result","items","activeActions","contextMatchesRules","isMenuItem","isHiddenByDefault","menuHide","createMenuHide","_activeActions","menuKeybinding","createConfigureKeybindingAction","alt","groups","submenuActions","join","map","g","_activeActions2","sort","_compareMenuItems","a","b","aGroup","bGroup","value","localeCompare","aPrio","order","bPrio","_compareTitles","title","aStr","original","bStr","hiddenStates","commandService","keybindingService","_menuInfo","rebuildMenuSoon","isStructuralChange","isEnablementChange","isToggleChange","onDidChangeMenu","e","has","schedule","lazyListener","merge","events","startLazyListener","onDidChangeContext","affectsSome","onWillAddFirstListener","onDidRemoveLastListener","bind","delay","states","hide","label","run","toggle","checked","enabled","hasKeybinding","lookupKeybinding","whenValue","serialize","executeCommand"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/platform/actions/common/menuService.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar PersistedMenuHideState_1, MenuInfo_1;\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { DebounceEmitter, Emitter } from '../../../base/common/event.js';\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nimport { isIMenuItem, isISubmenuItem, MenuItemAction, MenuRegistry, SubmenuItemAction } from './actions.js';\nimport { ICommandService } from '../../commands/common/commands.js';\nimport { IContextKeyService } from '../../contextkey/common/contextkey.js';\nimport { Separator, toAction } from '../../../base/common/actions.js';\nimport { IStorageService } from '../../storage/common/storage.js';\nimport { removeFastWithoutKeepingOrder } from '../../../base/common/arrays.js';\nimport { localize } from '../../../nls.js';\nimport { IKeybindingService } from '../../keybinding/common/keybinding.js';\nlet MenuService = class MenuService {\n    constructor(_commandService, _keybindingService, storageService) {\n        this._commandService = _commandService;\n        this._keybindingService = _keybindingService;\n        this._hiddenStates = new PersistedMenuHideState(storageService);\n    }\n    createMenu(id, contextKeyService, options) {\n        return new MenuImpl(id, this._hiddenStates, { emitEventsForSubmenuChanges: false, eventDebounceDelay: 50, ...options }, this._commandService, this._keybindingService, contextKeyService);\n    }\n    getMenuActions(id, contextKeyService, options) {\n        const menu = new MenuImpl(id, this._hiddenStates, { emitEventsForSubmenuChanges: false, eventDebounceDelay: 50, ...options }, this._commandService, this._keybindingService, contextKeyService);\n        const actions = menu.getActions(options);\n        menu.dispose();\n        return actions;\n    }\n    resetHiddenStates(ids) {\n        this._hiddenStates.reset(ids);\n    }\n};\nMenuService = __decorate([\n    __param(0, ICommandService),\n    __param(1, IKeybindingService),\n    __param(2, IStorageService)\n], MenuService);\nexport { MenuService };\nlet PersistedMenuHideState = class PersistedMenuHideState {\n    static { PersistedMenuHideState_1 = this; }\n    static { this._key = 'menu.hiddenCommands'; }\n    constructor(_storageService) {\n        this._storageService = _storageService;\n        this._disposables = new DisposableStore();\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n        this._ignoreChangeEvent = false;\n        this._hiddenByDefaultCache = new Map();\n        try {\n            const raw = _storageService.get(PersistedMenuHideState_1._key, 0 /* StorageScope.PROFILE */, '{}');\n            this._data = JSON.parse(raw);\n        }\n        catch (err) {\n            this._data = Object.create(null);\n        }\n        this._disposables.add(_storageService.onDidChangeValue(0 /* StorageScope.PROFILE */, PersistedMenuHideState_1._key, this._disposables)(() => {\n            if (!this._ignoreChangeEvent) {\n                try {\n                    const raw = _storageService.get(PersistedMenuHideState_1._key, 0 /* StorageScope.PROFILE */, '{}');\n                    this._data = JSON.parse(raw);\n                }\n                catch (err) {\n                    console.log('FAILED to read storage after UPDATE', err);\n                }\n            }\n            this._onDidChange.fire();\n        }));\n    }\n    dispose() {\n        this._onDidChange.dispose();\n        this._disposables.dispose();\n    }\n    _isHiddenByDefault(menu, commandId) {\n        return this._hiddenByDefaultCache.get(`${menu.id}/${commandId}`) ?? false;\n    }\n    setDefaultState(menu, commandId, hidden) {\n        this._hiddenByDefaultCache.set(`${menu.id}/${commandId}`, hidden);\n    }\n    isHidden(menu, commandId) {\n        const hiddenByDefault = this._isHiddenByDefault(menu, commandId);\n        const state = this._data[menu.id]?.includes(commandId) ?? false;\n        return hiddenByDefault ? !state : state;\n    }\n    updateHidden(menu, commandId, hidden) {\n        const hiddenByDefault = this._isHiddenByDefault(menu, commandId);\n        if (hiddenByDefault) {\n            hidden = !hidden;\n        }\n        const entries = this._data[menu.id];\n        if (!hidden) {\n            // remove and cleanup\n            if (entries) {\n                const idx = entries.indexOf(commandId);\n                if (idx >= 0) {\n                    removeFastWithoutKeepingOrder(entries, idx);\n                }\n                if (entries.length === 0) {\n                    delete this._data[menu.id];\n                }\n            }\n        }\n        else {\n            // add unless already added\n            if (!entries) {\n                this._data[menu.id] = [commandId];\n            }\n            else {\n                const idx = entries.indexOf(commandId);\n                if (idx < 0) {\n                    entries.push(commandId);\n                }\n            }\n        }\n        this._persist();\n    }\n    reset(menus) {\n        if (menus === undefined) {\n            // reset all\n            this._data = Object.create(null);\n            this._persist();\n        }\n        else {\n            // reset only for a specific menu\n            for (const { id } of menus) {\n                if (this._data[id]) {\n                    delete this._data[id];\n                }\n            }\n            this._persist();\n        }\n    }\n    _persist() {\n        try {\n            this._ignoreChangeEvent = true;\n            const raw = JSON.stringify(this._data);\n            this._storageService.store(PersistedMenuHideState_1._key, raw, 0 /* StorageScope.PROFILE */, 0 /* StorageTarget.USER */);\n        }\n        finally {\n            this._ignoreChangeEvent = false;\n        }\n    }\n};\nPersistedMenuHideState = PersistedMenuHideState_1 = __decorate([\n    __param(0, IStorageService)\n], PersistedMenuHideState);\nclass MenuInfoSnapshot {\n    constructor(_id, _collectContextKeysForSubmenus) {\n        this._id = _id;\n        this._collectContextKeysForSubmenus = _collectContextKeysForSubmenus;\n        this._menuGroups = [];\n        this._allMenuIds = new Set();\n        this._structureContextKeys = new Set();\n        this._preconditionContextKeys = new Set();\n        this._toggledContextKeys = new Set();\n        this.refresh();\n    }\n    get allMenuIds() {\n        return this._allMenuIds;\n    }\n    get structureContextKeys() {\n        return this._structureContextKeys;\n    }\n    get preconditionContextKeys() {\n        return this._preconditionContextKeys;\n    }\n    get toggledContextKeys() {\n        return this._toggledContextKeys;\n    }\n    refresh() {\n        // reset\n        this._menuGroups.length = 0;\n        this._allMenuIds.clear();\n        this._structureContextKeys.clear();\n        this._preconditionContextKeys.clear();\n        this._toggledContextKeys.clear();\n        const menuItems = this._sort(MenuRegistry.getMenuItems(this._id));\n        let group;\n        for (const item of menuItems) {\n            // group by groupId\n            const groupName = item.group || '';\n            if (!group || group[0] !== groupName) {\n                group = [groupName, []];\n                this._menuGroups.push(group);\n            }\n            group[1].push(item);\n            // keep keys and submenu ids for eventing\n            this._collectContextKeysAndSubmenuIds(item);\n        }\n        this._allMenuIds.add(this._id);\n    }\n    _sort(menuItems) {\n        // no sorting needed in snapshot\n        return menuItems;\n    }\n    _collectContextKeysAndSubmenuIds(item) {\n        MenuInfoSnapshot._fillInKbExprKeys(item.when, this._structureContextKeys);\n        if (isIMenuItem(item)) {\n            // keep precondition keys for event if applicable\n            if (item.command.precondition) {\n                MenuInfoSnapshot._fillInKbExprKeys(item.command.precondition, this._preconditionContextKeys);\n            }\n            // keep toggled keys for event if applicable\n            if (item.command.toggled) {\n                const toggledExpression = item.command.toggled.condition || item.command.toggled;\n                MenuInfoSnapshot._fillInKbExprKeys(toggledExpression, this._toggledContextKeys);\n            }\n        }\n        else if (this._collectContextKeysForSubmenus) {\n            // recursively collect context keys from submenus so that this\n            // menu fires events when context key changes affect submenus\n            MenuRegistry.getMenuItems(item.submenu).forEach(this._collectContextKeysAndSubmenuIds, this);\n            this._allMenuIds.add(item.submenu);\n        }\n    }\n    static _fillInKbExprKeys(exp, set) {\n        if (exp) {\n            for (const key of exp.keys()) {\n                set.add(key);\n            }\n        }\n    }\n}\nlet MenuInfo = MenuInfo_1 = class MenuInfo extends MenuInfoSnapshot {\n    constructor(_id, _hiddenStates, _collectContextKeysForSubmenus, _commandService, _keybindingService, _contextKeyService) {\n        super(_id, _collectContextKeysForSubmenus);\n        this._hiddenStates = _hiddenStates;\n        this._commandService = _commandService;\n        this._keybindingService = _keybindingService;\n        this._contextKeyService = _contextKeyService;\n        this.refresh();\n    }\n    createActionGroups(options) {\n        const result = [];\n        for (const group of this._menuGroups) {\n            const [id, items] = group;\n            let activeActions;\n            for (const item of items) {\n                if (this._contextKeyService.contextMatchesRules(item.when)) {\n                    const isMenuItem = isIMenuItem(item);\n                    if (isMenuItem) {\n                        this._hiddenStates.setDefaultState(this._id, item.command.id, !!item.isHiddenByDefault);\n                    }\n                    const menuHide = createMenuHide(this._id, isMenuItem ? item.command : item, this._hiddenStates);\n                    if (isMenuItem) {\n                        // MenuItemAction\n                        const menuKeybinding = createConfigureKeybindingAction(this._commandService, this._keybindingService, item.command.id, item.when);\n                        (activeActions ??= []).push(new MenuItemAction(item.command, item.alt, options, menuHide, menuKeybinding, this._contextKeyService, this._commandService));\n                    }\n                    else {\n                        // SubmenuItemAction\n                        const groups = new MenuInfo_1(item.submenu, this._hiddenStates, this._collectContextKeysForSubmenus, this._commandService, this._keybindingService, this._contextKeyService).createActionGroups(options);\n                        const submenuActions = Separator.join(...groups.map(g => g[1]));\n                        if (submenuActions.length > 0) {\n                            (activeActions ??= []).push(new SubmenuItemAction(item, menuHide, submenuActions));\n                        }\n                    }\n                }\n            }\n            if (activeActions && activeActions.length > 0) {\n                result.push([id, activeActions]);\n            }\n        }\n        return result;\n    }\n    _sort(menuItems) {\n        return menuItems.sort(MenuInfo_1._compareMenuItems);\n    }\n    static _compareMenuItems(a, b) {\n        const aGroup = a.group;\n        const bGroup = b.group;\n        if (aGroup !== bGroup) {\n            // Falsy groups come last\n            if (!aGroup) {\n                return 1;\n            }\n            else if (!bGroup) {\n                return -1;\n            }\n            // 'navigation' group comes first\n            if (aGroup === 'navigation') {\n                return -1;\n            }\n            else if (bGroup === 'navigation') {\n                return 1;\n            }\n            // lexical sort for groups\n            const value = aGroup.localeCompare(bGroup);\n            if (value !== 0) {\n                return value;\n            }\n        }\n        // sort on priority - default is 0\n        const aPrio = a.order || 0;\n        const bPrio = b.order || 0;\n        if (aPrio < bPrio) {\n            return -1;\n        }\n        else if (aPrio > bPrio) {\n            return 1;\n        }\n        // sort on titles\n        return MenuInfo_1._compareTitles(isIMenuItem(a) ? a.command.title : a.title, isIMenuItem(b) ? b.command.title : b.title);\n    }\n    static _compareTitles(a, b) {\n        const aStr = typeof a === 'string' ? a : a.original;\n        const bStr = typeof b === 'string' ? b : b.original;\n        return aStr.localeCompare(bStr);\n    }\n};\nMenuInfo = MenuInfo_1 = __decorate([\n    __param(3, ICommandService),\n    __param(4, IKeybindingService),\n    __param(5, IContextKeyService)\n], MenuInfo);\nlet MenuImpl = class MenuImpl {\n    constructor(id, hiddenStates, options, commandService, keybindingService, contextKeyService) {\n        this._disposables = new DisposableStore();\n        this._menuInfo = new MenuInfo(id, hiddenStates, options.emitEventsForSubmenuChanges, commandService, keybindingService, contextKeyService);\n        // Rebuild this menu whenever the menu registry reports an event for this MenuId.\n        // This usually happen while code and extensions are loaded and affects the over\n        // structure of the menu\n        const rebuildMenuSoon = new RunOnceScheduler(() => {\n            this._menuInfo.refresh();\n            this._onDidChange.fire({ menu: this, isStructuralChange: true, isEnablementChange: true, isToggleChange: true });\n        }, options.eventDebounceDelay);\n        this._disposables.add(rebuildMenuSoon);\n        this._disposables.add(MenuRegistry.onDidChangeMenu(e => {\n            for (const id of this._menuInfo.allMenuIds) {\n                if (e.has(id)) {\n                    rebuildMenuSoon.schedule();\n                    break;\n                }\n            }\n        }));\n        // When context keys or storage state changes we need to check if the menu also has changed. However,\n        // we only do that when someone listens on this menu because (1) these events are\n        // firing often and (2) menu are often leaked\n        const lazyListener = this._disposables.add(new DisposableStore());\n        const merge = (events) => {\n            let isStructuralChange = false;\n            let isEnablementChange = false;\n            let isToggleChange = false;\n            for (const item of events) {\n                isStructuralChange = isStructuralChange || item.isStructuralChange;\n                isEnablementChange = isEnablementChange || item.isEnablementChange;\n                isToggleChange = isToggleChange || item.isToggleChange;\n                if (isStructuralChange && isEnablementChange && isToggleChange) {\n                    // everything is TRUE, no need to continue iterating\n                    break;\n                }\n            }\n            return { menu: this, isStructuralChange, isEnablementChange, isToggleChange };\n        };\n        const startLazyListener = () => {\n            lazyListener.add(contextKeyService.onDidChangeContext(e => {\n                const isStructuralChange = e.affectsSome(this._menuInfo.structureContextKeys);\n                const isEnablementChange = e.affectsSome(this._menuInfo.preconditionContextKeys);\n                const isToggleChange = e.affectsSome(this._menuInfo.toggledContextKeys);\n                if (isStructuralChange || isEnablementChange || isToggleChange) {\n                    this._onDidChange.fire({ menu: this, isStructuralChange, isEnablementChange, isToggleChange });\n                }\n            }));\n            lazyListener.add(hiddenStates.onDidChange(e => {\n                this._onDidChange.fire({ menu: this, isStructuralChange: true, isEnablementChange: false, isToggleChange: false });\n            }));\n        };\n        this._onDidChange = new DebounceEmitter({\n            // start/stop context key listener\n            onWillAddFirstListener: startLazyListener,\n            onDidRemoveLastListener: lazyListener.clear.bind(lazyListener),\n            delay: options.eventDebounceDelay,\n            merge\n        });\n        this.onDidChange = this._onDidChange.event;\n    }\n    getActions(options) {\n        return this._menuInfo.createActionGroups(options);\n    }\n    dispose() {\n        this._disposables.dispose();\n        this._onDidChange.dispose();\n    }\n};\nMenuImpl = __decorate([\n    __param(3, ICommandService),\n    __param(4, IKeybindingService),\n    __param(5, IContextKeyService)\n], MenuImpl);\nfunction createMenuHide(menu, command, states) {\n    const id = isISubmenuItem(command) ? command.submenu.id : command.id;\n    const title = typeof command.title === 'string' ? command.title : command.title.value;\n    const hide = toAction({\n        id: `hide/${menu.id}/${id}`,\n        label: localize('hide.label', 'Hide \\'{0}\\'', title),\n        run() { states.updateHidden(menu, id, true); }\n    });\n    const toggle = toAction({\n        id: `toggle/${menu.id}/${id}`,\n        label: title,\n        get checked() { return !states.isHidden(menu, id); },\n        run() { states.updateHidden(menu, id, !!this.checked); }\n    });\n    return {\n        hide,\n        toggle,\n        get isHidden() { return !toggle.checked; },\n    };\n}\nexport function createConfigureKeybindingAction(commandService, keybindingService, commandId, when = undefined, enabled = true) {\n    return toAction({\n        id: `configureKeybinding/${commandId}`,\n        label: localize('configure keybinding', \"Configure Keybinding\"),\n        enabled,\n        run() {\n            // Only set the when clause when there is no keybinding\n            // It is possible that the action and the keybinding have different when clauses\n            const hasKeybinding = !!keybindingService.lookupKeybinding(commandId); // This may only be called inside the `run()` method as it can be expensive on startup. #210529\n            const whenValue = !hasKeybinding && when ? when.serialize() : undefined;\n            commandService.executeCommand('workbench.action.openGlobalKeybindings', `@command:${commandId}` + (whenValue ? ` +when:${whenValue}` : ''));\n        }\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}