{"ast":null,"code":"'use strict';\n\nconst tspan = require('tspan');\n\n// ----- ✂ ------------------------------------------------------------\n\nconst round = Math.round;\nconst getSVG = (w, h) => ['svg', {\n  xmlns: 'http://www.w3.org/2000/svg',\n  // TODO link ns?\n  width: w,\n  height: h,\n  viewBox: [0, 0, w, h].join(' ')\n}];\nconst tt = (x, y, obj) => Object.assign({\n  transform: 'translate(' + x + (y ? ',' + y : '') + ')'\n}, typeof obj === 'object' ? obj : {});\nconst colors = {\n  // TODO compare with WaveDrom\n  2: '#ff0000',\n  // 'hsl(0,100%,50%)'\n  3: '#aaff00',\n  // 'hsl(80,100%,50%)'\n  4: '#00ffd5',\n  // 'hsl(170,100%,50%)'\n  5: '#ffbf00',\n  // 'hsl(45,100%,50%)'\n  6: '#00ff19',\n  // 'hsl(126,100%,50%)'\n  7: '#006aff' // 'hsl(215,100%,50%)'\n};\nconst typeStyle = t => colors[t] !== undefined ? ';fill:' + colors[t] : '';\nconst norm = (obj, other) => Object.assign(Object.keys(obj).reduce((prev, key) => {\n  const val = Number(obj[key]);\n  const valInt = isNaN(val) ? 0 : Math.round(val);\n  if (valInt !== 0) {\n    prev[key] = valInt;\n  }\n  return prev;\n}, {}), other);\nconst trimText = (text, availableSpace, charWidth) => {\n  if (!(typeof text === 'string' || text instanceof String)) return text;\n  const textWidth = text.length * charWidth;\n  if (textWidth <= availableSpace) return text;\n  var end = text.length - (textWidth - availableSpace) / charWidth - 3;\n  if (end > 0) return text.substring(0, round(end)) + '...';\n  return text.substring(0, 1) + '...';\n};\nconst text = (body, x, y, rotate) => {\n  const props = {\n    y: 6\n  };\n  if (rotate !== undefined) {\n    props.transform = 'rotate(' + rotate + ')';\n  }\n  return ['g', tt(round(x), round(y)), ['text', props].concat(tspan.parse(body))];\n};\nconst hline = (len, x, y) => ['line', norm({\n  x1: x,\n  x2: x + len,\n  y1: y,\n  y2: y\n})];\nconst vline = (len, x, y) => ['line', norm({\n  x1: x,\n  x2: x,\n  y1: y,\n  y2: y + len\n})];\nconst getLabel = (val, x, y, step, len, rotate) => {\n  if (typeof val !== 'number') {\n    return text(val, x, y, rotate);\n  }\n  const res = ['g', {}];\n  for (let i = 0; i < len; i++) {\n    res.push(text(val >> i & 1, x + step * (len / 2 - i - 0.5), y));\n  }\n  return res;\n};\nconst getAttr = (e, opt, step, lsbm, msbm) => {\n  const x = opt.vflip ? step * ((msbm + lsbm) / 2) : step * (opt.mod - (msbm + lsbm) / 2 - 1);\n  if (!Array.isArray(e.attr)) {\n    return getLabel(e.attr, x, 0, step, e.bits);\n  }\n  return e.attr.reduce((prev, a, i) => a === undefined || a === null ? prev : prev.concat([getLabel(a, x, opt.fontsize * i, step, e.bits)]), ['g', {}]);\n};\nconst labelArr = (desc, opt) => {\n  const {\n    margin,\n    hspace,\n    vspace,\n    mod,\n    index,\n    fontsize,\n    vflip,\n    trim,\n    compact,\n    offset\n  } = opt;\n  const width = hspace - margin.left - margin.right - 1;\n  const height = vspace - margin.top - margin.bottom;\n  const step = width / mod;\n  const blanks = ['g'];\n  const bits = ['g', tt(round(step / 2), -round(0.5 * fontsize + 4))];\n  const names = ['g', tt(round(step / 2), round(0.5 * height + 0.4 * fontsize - 6))];\n  const attrs = ['g', tt(round(step / 2), round(height + 0.7 * fontsize - 2))];\n  desc.map(e => {\n    let lsbm = 0;\n    let msbm = mod - 1;\n    let lsb = index * mod;\n    let msb = (index + 1) * mod - 1;\n    if (e.lsb / mod >> 0 === index) {\n      lsbm = e.lsbm;\n      lsb = e.lsb;\n      if (e.msb / mod >> 0 === index) {\n        msb = e.msb;\n        msbm = e.msbm;\n      }\n    } else {\n      if (e.msb / mod >> 0 === index) {\n        msb = e.msb;\n        msbm = e.msbm;\n      } else if (!(lsb > e.lsb && msb < e.msb)) {\n        return;\n      }\n    }\n    if (!compact) {\n      bits.push(text(lsb + offset, step * (vflip ? lsbm : mod - lsbm - 1)));\n      if (lsbm !== msbm) {\n        bits.push(text(msb + offset, step * (vflip ? msbm : mod - msbm - 1)));\n      }\n    }\n    if (e.name !== undefined) {\n      names.push(getLabel(trim ? trimText(e.name, step * e.bits, trim) : e.name, step * (vflip ? (msbm + lsbm) / 2 : mod - (msbm + lsbm) / 2 - 1), 0, step, e.bits, e.rotate));\n    }\n    if (e.name === undefined || e.type !== undefined) {\n      if (!(opt.compact && e.type === undefined)) {\n        blanks.push(['rect', Object.assign({}, norm({\n          x: step * (vflip ? lsbm : mod - msbm - 1),\n          width: step * (msbm - lsbm + 1),\n          height: height\n        }, {\n          field: e.name,\n          style: 'fill-opacity:0.1' + typeStyle(e.type)\n        }), e.rect !== undefined ? e.rect : {})]);\n      }\n    }\n    if (e.attr !== undefined) {\n      attrs.push(getAttr(e, opt, step, lsbm, msbm));\n    }\n  });\n  return ['g', blanks, bits, names, attrs];\n};\nconst getLabelMask = (desc, mod) => {\n  const mask = [];\n  let idx = 0;\n  desc.map(e => {\n    mask[idx % mod] = true;\n    idx += e.bits;\n    mask[(idx - 1) % mod] = true;\n  });\n  return mask;\n};\nconst getLegendItems = opt => {\n  const {\n    hspace,\n    margin,\n    fontsize,\n    legend\n  } = opt;\n  const width = hspace - margin.left - margin.right - 1;\n  const items = ['g', tt(margin.left, -10)];\n  const legendSquarePadding = 36;\n  const legendNamePadding = 24;\n  let x = width / 2 - Object.keys(legend).length / 2 * (legendSquarePadding + legendNamePadding);\n  for (const key in legend) {\n    const value = legend[key];\n    items.push(['rect', norm({\n      x: x,\n      width: 12,\n      height: 12\n    }, {\n      style: 'fill-opacity:0.15; stroke: #000; stroke-width: 1.2;' + typeStyle(value)\n    })]);\n    x += legendSquarePadding;\n    items.push(text(key, x, 0.1 * fontsize + 4));\n    x += legendNamePadding;\n  }\n  return items;\n};\nconst compactLabels = (desc, opt) => {\n  const {\n    hspace,\n    margin,\n    mod,\n    fontsize,\n    vflip,\n    legend,\n    offset\n  } = opt;\n  const width = hspace - margin.left - margin.right - 1;\n  const step = width / mod;\n  const labels = ['g', tt(margin.left, legend ? 0 : -3)];\n  const mask = getLabelMask(desc, mod);\n  for (let i = 0; i < mod; i++) {\n    const idx = vflip ? i : mod - i - 1;\n    if (mask[idx]) {\n      labels.push(text(idx + offset, step * (i + .5), 0.5 * fontsize + 4));\n    }\n  }\n  return labels;\n};\nconst skipField = (desc, opt, globalIndex) => {\n  if (!opt.compact) {\n    return false;\n  }\n  const emptyField = e => e.name === undefined && e.type === undefined;\n  if (desc.findIndex(e => emptyField(e) && globalIndex > e.lsb && globalIndex <= e.msb + 1) !== -1) {\n    return true;\n  }\n  return false;\n};\nconst cage = (desc, opt) => {\n  const {\n    hspace,\n    vspace,\n    mod,\n    margin,\n    index,\n    vflip\n  } = opt;\n  const width = hspace - margin.left - margin.right - 1;\n  const height = vspace - margin.top - margin.bottom;\n  const res = ['g', {\n    stroke: 'black',\n    'stroke-width': 1,\n    'stroke-linecap': 'round'\n  }];\n  if (opt.sparse) {\n    const skipEdge = opt.uneven && opt.bits % 2 === 1 && index === opt.lanes - 1;\n    if (skipEdge) {\n      if (vflip) {\n        res.push(hline(width - width / mod, 0, 0), hline(width - width / mod, 0, height));\n      } else {\n        res.push(hline(width - width / mod, width / mod, 0), hline(width - width / mod, width / mod, height));\n      }\n    } else if (!opt.compact) {\n      res.push(hline(width, 0, 0), hline(width, 0, height), vline(height, vflip ? width : 0, 0));\n    }\n  } else {\n    res.push(hline(width, 0, 0), vline(height, vflip ? width : 0, 0), hline(width, 0, height));\n  }\n  let i = index * mod;\n  const delta = vflip ? 1 : -1;\n  let j = vflip ? 0 : mod;\n  if (opt.sparse) {\n    for (let k = 0; k <= mod; k++) {\n      const xj = j * (width / mod);\n      if (!skipField(desc, opt, i) && k !== 0 || !skipField(desc, opt, i + 1) && k !== mod) {\n        if (k === 0 || k === mod || desc.some(e => e.msb + 1 === i)) {\n          res.push(vline(height, xj, 0));\n        } else {\n          res.push(vline(height >>> 3, xj, 0));\n          res.push(vline(-(height >>> 3), xj, height));\n        }\n      }\n      if (opt.compact && k !== 0 && !skipField(desc, opt, i)) {\n        res.push(hline(width / mod, xj, 0));\n        res.push(hline(width / mod, xj, height));\n      }\n      i++;\n      j += delta;\n    }\n  } else {\n    for (let k = 0; k < mod; k++) {\n      const xj = j * (width / mod);\n      if (k === 0 || desc.some(e => e.lsb === i)) {\n        res.push(vline(height, xj, 0));\n      } else {\n        res.push(vline(height >>> 3, xj, 0), vline(-(height >>> 3), xj, height));\n      }\n      i++;\n      j += delta;\n    }\n  }\n  return res;\n} /* eslint complexity: [1, 30] */;\nconst lane = (desc, opt) => {\n  const {\n    index,\n    vspace,\n    hspace,\n    margin,\n    hflip,\n    lanes,\n    compact,\n    label\n  } = opt;\n  const height = vspace - margin.top - margin.bottom;\n  const width = hspace - margin.left - margin.right - 1;\n  let tx = margin.left;\n  const idx = hflip ? index : lanes - index - 1;\n  let ty = round(idx * vspace + margin.top);\n  if (compact) {\n    ty = round(idx * height + margin.top);\n  }\n  const res = ['g', tt(tx, ty), cage(desc, opt), labelArr(desc, opt)];\n  if (label && label.left !== undefined) {\n    const lab = label.left;\n    let txt = index;\n    if (typeof lab === 'string') {\n      txt = lab;\n    } else if (typeof lab === 'number') {\n      txt += lab;\n    } else if (typeof lab === 'object') {\n      txt = lab[index] || txt;\n    }\n    res.push(['g', {\n      'text-anchor': 'end'\n    }, text(txt, -4, round(height / 2))]);\n  }\n  if (label && label.right !== undefined) {\n    const lab = label.right;\n    let txt = index;\n    if (typeof lab === 'string') {\n      txt = lab;\n    } else if (typeof lab === 'number') {\n      txt += lab;\n    } else if (typeof lab === 'object') {\n      txt = lab[index] || txt;\n    }\n    res.push(['g', {\n      'text-anchor': 'start'\n    }, text(txt, width + 4, round(height / 2))]);\n  }\n  return res;\n};\n\n// Maximum number of attributes across all fields\nconst getMaxAttributes = desc => desc.reduce((prev, field) => Math.max(prev, field.attr === undefined ? 0 : Array.isArray(field.attr) ? field.attr.length : 1), 0);\nconst getTotalBits = desc => desc.reduce((prev, field) => prev + (field.bits === undefined ? 0 : field.bits), 0);\nconst isIntGTorDefault = opt => row => {\n  const [key, min, def] = row;\n  const val = Math.round(opt[key]);\n  opt[key] = typeof val === 'number' && val >= min ? val : def;\n};\nconst optDefaults = opt => {\n  opt = typeof opt === 'object' ? opt : {};\n  [\n  // key         min default\n  // ['vspace', 20, 60],\n  ['hspace', 40, 800], ['lanes', 1, 1], ['bits', 1, undefined], ['fontsize', 6, 14]].map(isIntGTorDefault(opt));\n  opt.fontfamily = opt.fontfamily || 'sans-serif';\n  opt.fontweight = opt.fontweight || 'normal';\n  opt.compact = opt.compact || false;\n  opt.hflip = opt.hflip || false;\n  opt.uneven = opt.uneven || false;\n  opt.margin = opt.margin || {};\n  opt.offset = opt.offset || 0;\n  return opt;\n};\nconst render = (desc, opt) => {\n  opt = optDefaults(opt);\n  const maxAttributes = getMaxAttributes(desc);\n  opt.vspace = opt.vspace || (maxAttributes + 4) * opt.fontsize;\n  if (opt.bits === undefined) {\n    opt.bits = getTotalBits(desc);\n  }\n  const {\n    hspace,\n    vspace,\n    lanes,\n    margin,\n    compact,\n    fontsize,\n    bits,\n    label,\n    legend\n  } = opt;\n  if (margin.right === undefined) {\n    if (label && label.right !== undefined) {\n      margin.right = round(.1 * hspace);\n    } else {\n      margin.right = 4;\n    }\n  }\n  if (margin.left === undefined) {\n    if (label && label.left !== undefined) {\n      margin.left = round(.1 * hspace);\n    } else {\n      margin.left = 4; // margin.right;\n    }\n  }\n  if (margin.top === undefined) {\n    margin.top = 1.5 * fontsize;\n    if (margin.bottom === undefined) {\n      margin.bottom = fontsize * maxAttributes + 4;\n    }\n  } else {\n    if (margin.bottom === undefined) {\n      margin.bottom = 4;\n    }\n  }\n  const width = hspace;\n  let height = vspace * lanes;\n  if (compact) {\n    height -= (lanes - 1) * (margin.top + margin.bottom);\n  }\n  if (legend) {\n    height += 12;\n  }\n  const res = ['g', tt(0.5, legend ? 12.5 : 0.5, {\n    'text-anchor': 'middle',\n    'font-size': opt.fontsize,\n    'font-family': opt.fontfamily,\n    'font-weight': opt.fontweight\n  })];\n  let lsb = 0;\n  const mod = Math.ceil(bits * 1.0 / lanes);\n  opt.mod = mod | 0;\n  desc.map(e => {\n    e.lsb = lsb;\n    e.lsbm = lsb % mod;\n    lsb += e.bits;\n    e.msb = lsb - 1;\n    e.msbm = e.msb % mod;\n  });\n  for (let i = 0; i < lanes; i++) {\n    opt.index = i;\n    res.push(lane(desc, opt));\n  }\n  if (compact) {\n    res.push(compactLabels(desc, opt));\n  }\n  if (legend) {\n    res.push(getLegendItems(opt));\n  }\n  return getSVG(width, height).concat([res]);\n};\n\n// ----- ✂ ------------------------------------------------------------\n\nmodule.exports = render;","map":{"version":3,"names":["tspan","require","round","Math","getSVG","w","h","xmlns","width","height","viewBox","join","tt","x","y","obj","Object","assign","transform","colors","typeStyle","t","undefined","norm","other","keys","reduce","prev","key","val","Number","valInt","isNaN","trimText","text","availableSpace","charWidth","String","textWidth","length","end","substring","body","rotate","props","concat","parse","hline","len","x1","x2","y1","y2","vline","getLabel","step","res","i","push","getAttr","e","opt","lsbm","msbm","vflip","mod","Array","isArray","attr","bits","a","fontsize","labelArr","desc","margin","hspace","vspace","index","trim","compact","offset","left","right","top","bottom","blanks","names","attrs","map","lsb","msb","name","type","field","style","rect","getLabelMask","mask","idx","getLegendItems","legend","items","legendSquarePadding","legendNamePadding","value","compactLabels","labels","skipField","globalIndex","emptyField","findIndex","cage","stroke","sparse","skipEdge","uneven","lanes","delta","j","k","xj","some","lane","hflip","label","tx","ty","lab","txt","getMaxAttributes","max","getTotalBits","isIntGTorDefault","row","min","def","optDefaults","fontfamily","fontweight","render","maxAttributes","ceil","module","exports"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/bit-field/lib/render.js"],"sourcesContent":["'use strict';\n\nconst tspan = require('tspan');\n\n// ----- ✂ ------------------------------------------------------------\n\nconst round = Math.round;\n\nconst getSVG = (w, h) => ['svg', {\n  xmlns: 'http://www.w3.org/2000/svg',\n  // TODO link ns?\n  width: w,\n  height: h,\n  viewBox: [0, 0, w, h].join(' ')\n}];\n\nconst tt = (x, y, obj) => Object.assign(\n  {transform: 'translate(' + x + (y ? (',' + y) : '') + ')'},\n  (typeof obj === 'object') ? obj : {}\n);\n\nconst colors = { // TODO compare with WaveDrom\n  2:  '#ff0000', // 'hsl(0,100%,50%)'\n  3:  '#aaff00', // 'hsl(80,100%,50%)'\n  4:  '#00ffd5', // 'hsl(170,100%,50%)'\n  5:  '#ffbf00', // 'hsl(45,100%,50%)'\n  6:  '#00ff19', // 'hsl(126,100%,50%)'\n  7:  '#006aff'  // 'hsl(215,100%,50%)'\n};\n\nconst typeStyle = t => (colors[t] !== undefined) ? ';fill:' + colors[t] : '';\n\nconst norm = (obj, other) => Object.assign(\n  Object\n    .keys(obj)\n    .reduce((prev, key) => {\n      const val = Number(obj[key]);\n      const valInt = isNaN(val) ? 0 : Math.round(val);\n      if (valInt !== 0) { prev[key] = valInt; }\n      return prev;\n    }, {}),\n  other\n);\n\nconst trimText = (text, availableSpace, charWidth) => {\n  if (!(typeof text === 'string' || text instanceof String))\n    return text;\n\n  const textWidth = text.length * charWidth;\n  if (textWidth <= availableSpace)\n    return text;\n\n  var end = text.length - ((textWidth - availableSpace) / charWidth) - 3;\n  if (end > 0)\n    return text.substring(0, round(end)) + '...';\n  return text.substring(0, 1) + '...';\n};\n\nconst text = (body, x, y, rotate) => {\n  const props = {y: 6};\n  if (rotate !== undefined) {\n    props.transform = 'rotate(' + rotate + ')';\n  }\n  return ['g', tt(round(x), round(y)), ['text', props].concat(tspan.parse(body))];\n};\n\nconst hline = (len, x, y) => ['line', norm({x1: x, x2: x + len, y1: y, y2: y})];\nconst vline = (len, x, y) => ['line', norm({x1: x, x2: x, y1: y, y2: y + len})];\n\nconst getLabel = (val, x, y, step, len, rotate) => {\n  if (typeof val !== 'number') {\n    return text(val, x, y, rotate);\n  }\n  const res = ['g', {}];\n  for (let i = 0; i < len; i++) {\n    res.push(text(\n      (val >> i) & 1,\n      x + step * (len / 2 - i - 0.5),\n      y\n    ));\n  }\n  return res;\n};\n\nconst getAttr = (e, opt, step, lsbm, msbm) => {\n  const x = opt.vflip\n    ? step * ((msbm + lsbm) / 2)\n    : step * (opt.mod - ((msbm + lsbm) / 2) - 1);\n\n  if (!Array.isArray(e.attr)) {\n    return getLabel(e.attr, x, 0, step, e.bits);\n  }\n  return e.attr.reduce((prev, a, i) =>\n    (a === undefined || a === null)\n      ? prev\n      : prev.concat([getLabel(a, x, opt.fontsize * i, step, e.bits)]),\n  ['g', {}]);\n};\n\nconst labelArr = (desc, opt) => {\n  const {margin, hspace, vspace, mod, index, fontsize, vflip, trim, compact, offset} = opt;\n  const width = hspace - margin.left - margin.right - 1;\n  const height = vspace - margin.top - margin.bottom;\n  const step = width / mod;\n  const blanks = ['g'];\n  const bits = ['g', tt(round(step / 2), -round(0.5 * fontsize + 4))];\n  const names = ['g', tt(round(step / 2), round(0.5 * height + 0.4 * fontsize - 6))];\n  const attrs = ['g', tt(round(step / 2), round(height + 0.7 * fontsize - 2))];\n  desc.map(e => {\n    let lsbm = 0;\n    let msbm = mod - 1;\n    let lsb = index * mod;\n    let msb = (index + 1) * mod - 1;\n    if (((e.lsb / mod) >> 0) === index) {\n      lsbm = e.lsbm;\n      lsb = e.lsb;\n      if (((e.msb / mod) >> 0) === index) {\n        msb = e.msb;\n        msbm = e.msbm;\n      }\n    } else {\n      if (((e.msb / mod) >> 0) === index) {\n        msb = e.msb;\n        msbm = e.msbm;\n      } else if (!(lsb > e.lsb && msb < e.msb)) {\n        return;\n      }\n    }\n    if (!compact) {\n      bits.push(text(lsb + offset, step * (vflip ? lsbm : (mod - lsbm - 1))));\n      if (lsbm !== msbm) {\n        bits.push(text(msb + offset, step * (vflip ? msbm : (mod - msbm - 1))));\n      }\n    }\n    if (e.name !== undefined) {\n      names.push(getLabel(\n        trim ? trimText(e.name, step * e.bits, trim) : e.name,\n        step * (vflip\n          ? ((msbm + lsbm) / 2)\n          : (mod - ((msbm + lsbm) / 2) - 1)\n        ),\n        0,\n        step,\n        e.bits,\n        e.rotate\n      ));\n    }\n\n    if ((e.name === undefined) || (e.type !== undefined)) {\n      if (!(opt.compact && e.type === undefined)) {\n        blanks.push(['rect', Object.assign({}, norm({\n          x: step * (vflip ? lsbm : (mod - msbm - 1)),\n          width: step * (msbm - lsbm + 1),\n          height: height\n        }, {\n          field: e.name,\n          style: 'fill-opacity:0.1' + typeStyle(e.type)\n        }),\n        e.rect !== undefined ? e.rect : {}\n        )]);\n      }\n    }\n    if (e.attr !== undefined) {\n      attrs.push(getAttr(e, opt, step, lsbm, msbm));\n    }\n  });\n  return ['g', blanks, bits, names, attrs];\n};\n\nconst getLabelMask = (desc, mod) => {\n  const mask = [];\n  let idx = 0;\n  desc.map(e => {\n    mask[idx % mod] = true;\n    idx += e.bits;\n    mask[(idx - 1) % mod] = true;\n  });\n  return mask;\n};\n\nconst getLegendItems = (opt) => {\n  const {hspace, margin, fontsize, legend} = opt;\n  const width = hspace - margin.left - margin.right - 1;\n  const items = ['g', tt(margin.left, -10)];\n  const legendSquarePadding = 36;\n  const legendNamePadding = 24;\n\n  let x = width / 2 - Object.keys(legend).length / 2 * (legendSquarePadding + legendNamePadding);\n  for(const key in legend) {\n    const value = legend[key];\n\n    items.push(['rect', norm({\n      x: x,\n      width: 12,\n      height: 12\n    }, {\n      style: 'fill-opacity:0.15; stroke: #000; stroke-width: 1.2;' + typeStyle(value)\n    })]);\n\n    x += legendSquarePadding;\n    items.push(text(\n      key,\n      x,\n      0.1 * fontsize + 4\n    ));\n    x += legendNamePadding;\n  }\n\n  return items;\n};\n\nconst compactLabels = (desc, opt) => {\n  const {hspace, margin, mod, fontsize, vflip, legend, offset} = opt;\n  const width = hspace - margin.left - margin.right - 1;\n  const step = width / mod;\n  const labels = ['g', tt(margin.left, legend ? 0 : -3)];\n\n  const mask = getLabelMask(desc, mod);\n\n  for (let i = 0; i < mod; i++) {\n    const idx = vflip ? i : (mod - i - 1);\n    if (mask[idx]) {\n      labels.push(text(\n        idx + offset,\n        step * (i + .5),\n        0.5 * fontsize + 4\n      ));\n    }\n  }\n\n  return labels;\n};\n\nconst skipField = (desc, opt, globalIndex) => {\n  if (!opt.compact) {\n    return false;\n  }\n\n  const emptyField = (e) => e.name === undefined && e.type === undefined;\n  if (desc.findIndex((e) => emptyField(e) && globalIndex > e.lsb && globalIndex <= e.msb + 1) !== -1) {\n    return true;\n  }\n\n  return false;\n};\n\nconst cage = (desc, opt) => {\n  const {hspace, vspace, mod, margin, index, vflip} = opt;\n  const width = hspace - margin.left - margin.right - 1;\n  const height = vspace - margin.top - margin.bottom;\n  const res = ['g',\n    {\n      stroke: 'black',\n      'stroke-width': 1,\n      'stroke-linecap': 'round'\n    }\n  ];\n  if (opt.sparse) {\n    const skipEdge = opt.uneven && (opt.bits % 2 === 1) && (index === (opt.lanes - 1));\n    if (skipEdge) {\n      if (vflip) {\n        res.push(\n          hline(width - (width / mod), 0, 0),\n          hline(width - (width / mod), 0, height)\n        );\n      } else {\n        res.push(\n          hline(width - (width / mod), width / mod, 0),\n          hline(width - (width / mod), width / mod, height)\n        );\n      }\n    } else if (!opt.compact) {\n      res.push(\n        hline(width, 0, 0),\n        hline(width, 0, height),\n        vline(height, (vflip ? width : 0), 0)\n      );\n    }\n  } else {\n    res.push(\n      hline(width, 0, 0),\n      vline(height, (vflip ? width : 0), 0),\n      hline(width, 0, height)\n    );\n  }\n\n  let i = index * mod;\n  const delta = vflip ? 1 : -1;\n  let j = vflip ? 0 : mod;\n\n  if (opt.sparse) {\n    for (let k = 0; k <= mod; k++) {\n\n      const xj = j * (width / mod);\n\n      if ((!skipField(desc, opt, i) && k !== 0) || (!skipField(desc, opt, i + 1) && k !== mod)) {\n        if ((k === 0) || (k === mod) || desc.some(e => (e.msb + 1 === i))) {\n          res.push(vline(height, xj, 0));\n        } else {\n          res.push(vline((height >>> 3), xj, 0));\n          res.push(vline(-(height >>> 3), xj, height));\n        }\n      }\n\n      if (opt.compact && k !== 0 && !skipField(desc, opt, i)) {\n        res.push(hline(width / mod, xj, 0));\n        res.push(hline(width / mod, xj, height));\n      }\n      i++;\n      j += delta;\n    }\n  } else {\n    for (let k = 0; k < mod; k++) {\n      const xj = j * (width / mod);\n      if ((k === 0) || desc.some(e => (e.lsb === i))) {\n        res.push(vline(height, xj, 0));\n      } else {\n        res.push(\n          vline((height >>> 3), xj, 0),\n          vline(-(height >>> 3), xj, height)\n        );\n      }\n      i++;\n      j += delta;\n    }\n  }\n  return res;\n} /* eslint complexity: [1, 30] */;\n\nconst lane = (desc, opt) => {\n  const {index, vspace, hspace, margin, hflip, lanes, compact, label} = opt;\n  const height = vspace - margin.top - margin.bottom;\n  const width = hspace - margin.left - margin.right - 1;\n\n  let tx = margin.left;\n  const idx = hflip ? index : (lanes - index - 1);\n  let ty = round(idx * vspace + margin.top);\n  if (compact) {\n    ty = round(idx * height + margin.top);\n  }\n  const res = ['g',\n    tt(tx, ty),\n    cage(desc, opt),\n    labelArr(desc, opt)\n  ];\n\n  if (label && label.left !== undefined) {\n    const lab = label.left;\n    let txt = index;\n    if (typeof lab === 'string') {\n      txt = lab;\n    } else if (typeof lab === 'number') {\n      txt += lab;\n    } else if (typeof lab === 'object') {\n      txt = lab[index] || txt;\n    }\n    res.push(['g', {'text-anchor': 'end'},\n      text(txt, -4, round(height / 2))\n    ]);\n  }\n\n  if (label && label.right !== undefined) {\n    const lab = label.right;\n    let txt = index;\n    if (typeof lab === 'string') {\n      txt = lab;\n    } else if (typeof lab === 'number') {\n      txt += lab;\n    } else if (typeof lab === 'object') {\n      txt = lab[index] || txt;\n    }\n    res.push(['g', {'text-anchor': 'start'},\n      text(txt, width + 4, round(height / 2))\n    ]);\n  }\n\n  return res;\n};\n\n// Maximum number of attributes across all fields\nconst getMaxAttributes = desc =>\n  desc.reduce((prev, field) =>\n    Math.max(\n      prev,\n      (field.attr === undefined)\n        ? 0\n        : Array.isArray(field.attr)\n          ? field.attr.length\n          : 1\n    ),\n  0);\n\nconst getTotalBits = desc =>\n  desc.reduce((prev, field) => prev + ((field.bits === undefined) ? 0 : field.bits), 0);\n\nconst isIntGTorDefault = opt => row => {\n  const [key, min, def] = row;\n  const val = Math.round(opt[key]);\n  opt[key] = (typeof val === 'number' && val >= min) ? val : def;\n};\n\nconst optDefaults = opt => {\n  opt = (typeof opt === 'object') ? opt : {};\n\n  [ // key         min default\n    // ['vspace', 20, 60],\n    ['hspace', 40, 800],\n    ['lanes', 1, 1],\n    ['bits', 1, undefined],\n    ['fontsize', 6, 14]\n  ].map(isIntGTorDefault(opt));\n\n  opt.fontfamily = opt.fontfamily || 'sans-serif';\n  opt.fontweight = opt.fontweight || 'normal';\n  opt.compact = opt.compact || false;\n  opt.hflip = opt.hflip || false;\n  opt.uneven = opt.uneven || false;\n  opt.margin = opt.margin || {};\n  opt.offset = opt.offset || 0;\n\n  return opt;\n};\n\nconst render = (desc, opt) => {\n  opt = optDefaults(opt);\n\n  const maxAttributes = getMaxAttributes(desc);\n\n  opt.vspace = opt.vspace || ((maxAttributes + 4) * opt.fontsize);\n\n  if (opt.bits === undefined) {\n    opt.bits = getTotalBits(desc);\n  }\n\n  const {hspace, vspace, lanes, margin, compact, fontsize, bits, label, legend} = opt;\n\n  if (margin.right === undefined) {\n    if (label && label.right !== undefined) {\n      margin.right = round(.1 * hspace);\n    } else {\n      margin.right = 4;\n    }\n  }\n\n  if (margin.left === undefined) {\n    if (label && label.left !== undefined) {\n      margin.left = round(.1 * hspace);\n    } else {\n      margin.left = 4; // margin.right;\n    }\n  }\n  if (margin.top === undefined) {\n    margin.top = 1.5 * fontsize;\n    if (margin.bottom === undefined) {\n      margin.bottom = fontsize * (maxAttributes) + 4;\n    }\n  } else {\n    if (margin.bottom === undefined) {\n      margin.bottom = 4;\n    }\n  }\n\n  const width = hspace;\n  let height = vspace * lanes;\n  if (compact) {\n    height -= (lanes - 1) * (margin.top + margin.bottom);\n  }\n\n  if (legend) {\n    height += 12;\n  }\n\n  const res = ['g',\n    tt(0.5, legend ? 12.5 : 0.5, {\n      'text-anchor': 'middle',\n      'font-size': opt.fontsize,\n      'font-family': opt.fontfamily,\n      'font-weight': opt.fontweight\n    })\n  ];\n\n  let lsb = 0;\n  const mod = Math.ceil(bits * 1.0 / lanes);\n  opt.mod = mod | 0;\n\n  desc.map(e => {\n    e.lsb = lsb;\n    e.lsbm = lsb % mod;\n    lsb += e.bits;\n    e.msb = lsb - 1;\n    e.msbm = e.msb % mod;\n  });\n\n  for (let i = 0; i < lanes; i++) {\n    opt.index = i;\n    res.push(lane(desc, opt));\n  }\n  if (compact) {\n    res.push(compactLabels(desc, opt));\n  }\n\n  if (legend) {\n    res.push(getLegendItems(opt));\n  }\n\n  return getSVG(width, height).concat([res]);\n};\n\n// ----- ✂ ------------------------------------------------------------\n\nmodule.exports = render;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}