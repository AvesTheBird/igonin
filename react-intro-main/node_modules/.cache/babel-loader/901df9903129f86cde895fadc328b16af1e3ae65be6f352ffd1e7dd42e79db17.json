{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Shape from '../geometry/Shape';\n/**\n * Creates a new image export instance to be used with an export canvas. Here\n * is an example that uses this class to create an image via a backend using\n * {@link XmlExportCanvas}.\n *\n * ```javascript\n * var xmlDoc = mxUtils.createXmlDocument();\n * var root = xmlDoc.createElement('output');\n * xmlDoc.appendChild(root);\n *\n * var xmlCanvas = new mxXmlCanvas2D(root);\n * var imgExport = new mxImageExport();\n * imgExport.drawState(graph.getView().getState(graph.model.root), xmlCanvas);\n *\n * var bounds = graph.getGraphBounds();\n * var w = Math.ceil(bounds.x + bounds.width);\n * var h = Math.ceil(bounds.y + bounds.height);\n *\n * var xml = mxUtils.getXml(root);\n * new MaxXmlRequest('export', 'format=png&w=' + w +\n * \t\t'&h=' + h + '&bg=#F9F7ED&xml=' + encodeURIComponent(xml))\n * \t\t.simulate(document, '_blank');\n * ```\n *\n * @class ImageExport\n */\nclass ImageExport {\n  constructor() {\n    /**\n     * Specifies if overlays should be included in the export. Default is false.\n     */\n    this.includeOverlays = false;\n  }\n  /**\n   * Draws the given state and all its descendants to the given canvas.\n   */\n  drawState(state, canvas) {\n    if (state) {\n      this.visitStatesRecursive(state, canvas, () => {\n        this.drawCellState(state, canvas);\n      });\n      // Paints the overlays\n      if (this.includeOverlays) {\n        this.visitStatesRecursive(state, canvas, () => {\n          this.drawOverlays(state, canvas);\n        });\n      }\n    }\n  }\n  /**\n   * Visits the given state and all its descendants to the given canvas recursively.\n   */\n  visitStatesRecursive(state, canvas, visitor) {\n    if (state) {\n      visitor(state, canvas);\n      const graph = state.view.graph;\n      const childCount = state.cell.getChildCount();\n      for (let i = 0; i < childCount; i += 1) {\n        const childState = graph.view.getState(state.cell.getChildAt(i));\n        if (childState) this.visitStatesRecursive(childState, canvas, visitor);\n      }\n    }\n  }\n  /**\n   * Returns the link for the given cell state and canvas. This returns null.\n   */\n  getLinkForCellState(state, canvas) {\n    return null;\n  }\n  /**\n   * Draws the given state to the given canvas.\n   */\n  drawCellState(state, canvas) {\n    // Experimental feature\n    const link = this.getLinkForCellState(state, canvas);\n    if (link) {\n      canvas.setLink(link);\n    }\n    // Paints the shape and text\n    this.drawShape(state, canvas);\n    this.drawText(state, canvas);\n    if (link) {\n      canvas.setLink(null);\n    }\n  }\n  /**\n   * Draws the shape of the given state.\n   */\n  drawShape(state, canvas) {\n    if (state.shape instanceof Shape && state.shape.checkBounds()) {\n      canvas.save();\n      state.shape.beforePaint(canvas);\n      state.shape.paint(canvas);\n      state.shape.afterPaint(canvas);\n      canvas.restore();\n    }\n  }\n  /**\n   * Draws the text of the given state.\n   */\n  drawText(state, canvas) {\n    if (state.text && state.text.checkBounds()) {\n      canvas.save();\n      state.text.beforePaint(canvas);\n      state.text.paint(canvas);\n      state.text.afterPaint(canvas);\n      canvas.restore();\n    }\n  }\n  /**\n   * Draws the overlays for the given state. This is called if <includeOverlays>\n   * is true.\n   */\n  drawOverlays(state, canvas) {\n    if (state.overlays != null) {\n      state.overlays.visit((id, shape) => {\n        if (shape instanceof Shape) {\n          shape.paint(canvas);\n        }\n      });\n    }\n  }\n}\nexport default ImageExport;","map":{"version":3,"names":["Shape","ImageExport","constructor","includeOverlays","drawState","state","canvas","visitStatesRecursive","drawCellState","drawOverlays","visitor","graph","view","childCount","cell","getChildCount","i","childState","getState","getChildAt","getLinkForCellState","link","setLink","drawShape","drawText","shape","checkBounds","save","beforePaint","paint","afterPaint","restore","text","overlays","visit","id"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/@maxgraph/core/dist/view/image/ImageExport.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Shape from '../geometry/Shape';\n/**\n * Creates a new image export instance to be used with an export canvas. Here\n * is an example that uses this class to create an image via a backend using\n * {@link XmlExportCanvas}.\n *\n * ```javascript\n * var xmlDoc = mxUtils.createXmlDocument();\n * var root = xmlDoc.createElement('output');\n * xmlDoc.appendChild(root);\n *\n * var xmlCanvas = new mxXmlCanvas2D(root);\n * var imgExport = new mxImageExport();\n * imgExport.drawState(graph.getView().getState(graph.model.root), xmlCanvas);\n *\n * var bounds = graph.getGraphBounds();\n * var w = Math.ceil(bounds.x + bounds.width);\n * var h = Math.ceil(bounds.y + bounds.height);\n *\n * var xml = mxUtils.getXml(root);\n * new MaxXmlRequest('export', 'format=png&w=' + w +\n * \t\t'&h=' + h + '&bg=#F9F7ED&xml=' + encodeURIComponent(xml))\n * \t\t.simulate(document, '_blank');\n * ```\n *\n * @class ImageExport\n */\nclass ImageExport {\n    constructor() {\n        /**\n         * Specifies if overlays should be included in the export. Default is false.\n         */\n        this.includeOverlays = false;\n    }\n    /**\n     * Draws the given state and all its descendants to the given canvas.\n     */\n    drawState(state, canvas) {\n        if (state) {\n            this.visitStatesRecursive(state, canvas, () => {\n                this.drawCellState(state, canvas);\n            });\n            // Paints the overlays\n            if (this.includeOverlays) {\n                this.visitStatesRecursive(state, canvas, () => {\n                    this.drawOverlays(state, canvas);\n                });\n            }\n        }\n    }\n    /**\n     * Visits the given state and all its descendants to the given canvas recursively.\n     */\n    visitStatesRecursive(state, canvas, visitor) {\n        if (state) {\n            visitor(state, canvas);\n            const graph = state.view.graph;\n            const childCount = state.cell.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                const childState = graph.view.getState(state.cell.getChildAt(i));\n                if (childState)\n                    this.visitStatesRecursive(childState, canvas, visitor);\n            }\n        }\n    }\n    /**\n     * Returns the link for the given cell state and canvas. This returns null.\n     */\n    getLinkForCellState(state, canvas) {\n        return null;\n    }\n    /**\n     * Draws the given state to the given canvas.\n     */\n    drawCellState(state, canvas) {\n        // Experimental feature\n        const link = this.getLinkForCellState(state, canvas);\n        if (link) {\n            canvas.setLink(link);\n        }\n        // Paints the shape and text\n        this.drawShape(state, canvas);\n        this.drawText(state, canvas);\n        if (link) {\n            canvas.setLink(null);\n        }\n    }\n    /**\n     * Draws the shape of the given state.\n     */\n    drawShape(state, canvas) {\n        if (state.shape instanceof Shape && state.shape.checkBounds()) {\n            canvas.save();\n            state.shape.beforePaint(canvas);\n            state.shape.paint(canvas);\n            state.shape.afterPaint(canvas);\n            canvas.restore();\n        }\n    }\n    /**\n     * Draws the text of the given state.\n     */\n    drawText(state, canvas) {\n        if (state.text && state.text.checkBounds()) {\n            canvas.save();\n            state.text.beforePaint(canvas);\n            state.text.paint(canvas);\n            state.text.afterPaint(canvas);\n            canvas.restore();\n        }\n    }\n    /**\n     * Draws the overlays for the given state. This is called if <includeOverlays>\n     * is true.\n     */\n    drawOverlays(state, canvas) {\n        if (state.overlays != null) {\n            state.overlays.visit((id, shape) => {\n                if (shape instanceof Shape) {\n                    shape.paint(canvas);\n                }\n            });\n        }\n    }\n}\nexport default ImageExport;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}