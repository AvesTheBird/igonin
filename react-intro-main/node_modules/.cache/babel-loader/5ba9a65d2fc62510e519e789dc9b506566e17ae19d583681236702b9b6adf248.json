{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from '../geometry/Rectangle';\nimport { CURSOR, DIALECT, HANDLE_FILLCOLOR, HANDLE_SIZE, HANDLE_STROKECOLOR, LABEL_HANDLE_FILLCOLOR, LABEL_HANDLE_SIZE, NONE, VERTEX_SELECTION_COLOR, VERTEX_SELECTION_DASHED, VERTEX_SELECTION_STROKEWIDTH } from '../../util/Constants';\nimport InternalEvent from '../event/InternalEvent';\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport ImageShape from '../geometry/node/ImageShape';\nimport EllipseShape from '../geometry/node/EllipseShape';\nimport Point from '../geometry/Point';\nimport { getRotatedPoint, intersects, mod, toRadians } from '../../util/mathUtils';\nimport Client from '../../Client';\nimport { isMouseEvent, isShiftDown } from '../../util/EventUtils';\n/**\n * Event handler for resizing cells. This handler is automatically created in\n * {@link Graph#createHandler}.\n *\n * Constructor: mxVertexHandler\n *\n * Constructs an event handler that allows to resize vertices\n * and groups.\n *\n * @param state <CellState> of the cell to be resized.\n */\nclass VertexHandler {\n  constructor(state) {\n    this.sizers = [];\n    /**\n     * Specifies if only one sizer handle at the bottom, right corner should be\n     * used. Default is false.\n     */\n    this.singleSizer = false;\n    /**\n     * Holds the index of the current handle.\n     */\n    this.index = null;\n    /**\n     * Specifies if the bounds of handles should be used for hit-detection in IE or\n     * if <tolerance> > 0. Default is true.\n     */\n    this.allowHandleBoundsCheck = true;\n    /**\n     * Optional {@link Image} to be used as handles. Default is null.\n     */\n    this.handleImage = null;\n    /**\n     * If handles are currently visible.\n     */\n    this.handlesVisible = true;\n    /**\n     * Optional tolerance for hit-detection in <getHandleForEvent>. Default is 0.\n     */\n    this.tolerance = 0;\n    /**\n     * Specifies if a rotation handle should be visible. Default is false.\n     */\n    this.rotationEnabled = false;\n    /**\n     * Specifies if the parent should be highlighted if a child cell is selected.\n     * Default is false.\n     */\n    this.parentHighlightEnabled = false;\n    /**\n     * Specifies if rotation steps should be \"rasterized\" depening on the distance\n     * to the handle. Default is true.\n     */\n    this.rotationRaster = true;\n    /**\n     * Specifies the cursor for the rotation handle. Default is 'crosshair'.\n     */\n    this.rotationCursor = 'crosshair';\n    /**\n     * Specifies if resize should change the cell in-place. This is an experimental\n     * feature for non-touch devices. Default is false.\n     */\n    this.livePreview = false;\n    /**\n     * Specifies if the live preview should be moved to the front.\n     */\n    this.movePreviewToFront = false;\n    /**\n     * Specifies if sizers should be hidden and spaced if the vertex is small.\n     * Default is false.\n     */\n    this.manageSizers = false;\n    /**\n     * Specifies if the size of groups should be constrained by the children.\n     * Default is false.\n     */\n    this.constrainGroupByChildren = false;\n    /**\n     * Vertical spacing for rotation icon. Default is -16.\n     */\n    this.rotationHandleVSpacing = -16;\n    /**\n     * The horizontal offset for the handles. This is updated in <redrawHandles>\n     * if {@link anageSizers} is true and the sizers are offset horizontally.\n     */\n    this.horizontalOffset = 0;\n    /**\n     * The horizontal offset for the handles. This is updated in <redrawHandles>\n     * if {@link anageSizers} is true and the sizers are offset vertically.\n     */\n    this.verticalOffset = 0;\n    this.minBounds = null;\n    this.x0 = 0;\n    this.y0 = 0;\n    this.customHandles = [];\n    this.inTolerance = false;\n    this.startX = 0;\n    this.startY = 0;\n    this.rotationShape = null;\n    this.currentAlpha = 100;\n    this.startAngle = 0;\n    this.startDist = 0;\n    this.ghostPreview = null;\n    this.livePreviewActive = false;\n    this.childOffsetX = 0;\n    this.childOffsetY = 0;\n    this.parentState = null;\n    this.parentHighlight = null;\n    this.unscaledBounds = null;\n    this.preview = null;\n    this.labelShape = null;\n    this.edgeHandlers = [];\n    this.EMPTY_POINT = new Point();\n    this.state = state;\n    this.graph = this.state.view.graph;\n    this.selectionBounds = this.getSelectionBounds(this.state);\n    this.bounds = new Rectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);\n    this.selectionBorder = this.createSelectionShape(this.bounds);\n    // VML dialect required here for event transparency in IE\n    this.selectionBorder.dialect = DIALECT.SVG;\n    this.selectionBorder.pointerEvents = false;\n    this.selectionBorder.rotation = this.state.style.rotation ?? 0;\n    this.selectionBorder.init(this.graph.getView().getOverlayPane());\n    InternalEvent.redirectMouseEvents(this.selectionBorder.node, this.graph, this.state);\n    if (this.graph.isCellMovable(this.state.cell)) {\n      this.selectionBorder.setCursor(CURSOR.MOVABLE_VERTEX);\n    }\n    const selectionHandler = this.graph.getPlugin('SelectionHandler');\n    // Adds the sizer handles\n    if (selectionHandler && (selectionHandler.maxCells <= 0 || this.graph.getSelectionCount() < selectionHandler.maxCells)) {\n      const resizable = this.graph.isCellResizable(this.state.cell);\n      this.sizers = [];\n      if (resizable || this.graph.isLabelMovable(this.state.cell) && this.state.width >= 2 && this.state.height >= 2) {\n        let i = 0;\n        if (resizable) {\n          if (!this.singleSizer) {\n            this.sizers.push(this.createSizer('nw-resize', i++));\n            this.sizers.push(this.createSizer('n-resize', i++));\n            this.sizers.push(this.createSizer('ne-resize', i++));\n            this.sizers.push(this.createSizer('w-resize', i++));\n            this.sizers.push(this.createSizer('e-resize', i++));\n            this.sizers.push(this.createSizer('sw-resize', i++));\n            this.sizers.push(this.createSizer('s-resize', i++));\n          }\n          this.sizers.push(this.createSizer('se-resize', i++));\n        }\n        const geo = this.state.cell.getGeometry();\n        if (geo != null && !geo.relative &&\n        //!this.graph.isSwimlane(this.state.cell) &&      disable for now\n        this.graph.isLabelMovable(this.state.cell)) {\n          // Marks this as the label handle for getHandleForEvent\n          this.labelShape = this.createSizer(CURSOR.LABEL_HANDLE, InternalEvent.LABEL_HANDLE, LABEL_HANDLE_SIZE, LABEL_HANDLE_FILLCOLOR);\n          this.sizers.push(this.labelShape);\n        }\n      } else if (this.graph.isCellMovable(this.state.cell) && !this.graph.isCellResizable(this.state.cell) && this.state.width < 2 && this.state.height < 2) {\n        this.labelShape = this.createSizer(CURSOR.MOVABLE_VERTEX, InternalEvent.LABEL_HANDLE, undefined, LABEL_HANDLE_FILLCOLOR);\n        this.sizers.push(this.labelShape);\n      }\n    }\n    // Adds the rotation handler\n    if (this.isRotationHandleVisible()) {\n      this.rotationShape = this.createSizer(this.rotationCursor, InternalEvent.ROTATION_HANDLE, HANDLE_SIZE + 3, HANDLE_FILLCOLOR);\n      this.sizers.push(this.rotationShape);\n    }\n    this.customHandles = this.createCustomHandles();\n    this.redraw();\n    if (this.constrainGroupByChildren) {\n      this.updateMinBounds();\n    }\n    // Handles escape keystrokes\n    this.escapeHandler = (sender, evt) => {\n      if (this.livePreview && this.index != null) {\n        // Redraws the live preview\n        this.state.view.graph.cellRenderer.redraw(this.state, true);\n        // Redraws connected edges\n        this.state.view.invalidate(this.state.cell);\n        this.state.invalid = false;\n        this.state.view.validate();\n      }\n      this.reset();\n    };\n    this.state.view.graph.addListener(InternalEvent.ESCAPE, this.escapeHandler);\n  }\n  /**\n   * Returns true if the rotation handle should be showing.\n   */\n  isRotationHandleVisible() {\n    const selectionHandler = this.graph.getPlugin('SelectionHandler');\n    const selectionHandlerCheck = selectionHandler ? selectionHandler.maxCells <= 0 || this.graph.getSelectionCount() < selectionHandler.maxCells : true;\n    return this.graph.isEnabled() && this.rotationEnabled && this.graph.isCellRotatable(this.state.cell) && selectionHandlerCheck;\n  }\n  /**\n   * Returns true if the aspect ratio if the cell should be maintained.\n   */\n  isConstrainedEvent(me) {\n    return isShiftDown(me.getEvent()) || this.state.style.aspect === 'fixed';\n  }\n  /**\n   * Returns true if the center of the vertex should be maintained during the resize.\n   */\n  isCenteredEvent(state, me) {\n    return false;\n  }\n  /**\n   * Returns an array of custom handles. This implementation returns null.\n   */\n  createCustomHandles() {\n    return [];\n  }\n  /**\n   * Initializes the shapes required for this vertex handler.\n   */\n  updateMinBounds() {\n    const children = this.graph.getChildCells(this.state.cell);\n    if (children.length > 0) {\n      this.minBounds = this.graph.view.getBounds(children);\n      if (this.minBounds) {\n        const s = this.state.view.scale;\n        const t = this.state.view.translate;\n        this.minBounds.x -= this.state.x;\n        this.minBounds.y -= this.state.y;\n        this.minBounds.x /= s;\n        this.minBounds.y /= s;\n        this.minBounds.width /= s;\n        this.minBounds.height /= s;\n        this.x0 = this.state.x / s - t.x;\n        this.y0 = this.state.y / s - t.y;\n      }\n    }\n  }\n  /**\n   * Returns the mxRectangle that defines the bounds of the selection\n   * border.\n   */\n  getSelectionBounds(state) {\n    return new Rectangle(Math.round(state.x), Math.round(state.y), Math.round(state.width), Math.round(state.height));\n  }\n  /**\n   * Creates the shape used to draw the selection border.\n   */\n  createParentHighlightShape(bounds) {\n    return this.createSelectionShape(bounds);\n  }\n  /**\n   * Creates the shape used to draw the selection border.\n   */\n  createSelectionShape(bounds) {\n    const shape = new RectangleShape(Rectangle.fromRectangle(bounds), NONE, this.getSelectionColor());\n    shape.strokeWidth = this.getSelectionStrokeWidth();\n    shape.isDashed = this.isSelectionDashed();\n    return shape;\n  }\n  /**\n   * Returns {@link Constants#VERTEX_SELECTION_COLOR}.\n   */\n  getSelectionColor() {\n    return VERTEX_SELECTION_COLOR;\n  }\n  /**\n   * Returns {@link Constants#VERTEX_SELECTION_STROKEWIDTH}.\n   */\n  getSelectionStrokeWidth() {\n    return VERTEX_SELECTION_STROKEWIDTH;\n  }\n  /**\n   * Returns {@link Constants#VERTEX_SELECTION_DASHED}.\n   */\n  isSelectionDashed() {\n    return VERTEX_SELECTION_DASHED;\n  }\n  /**\n   * Creates a sizer handle for the specified cursor and index and returns\n   * the new {@link RectangleShape} that represents the handle.\n   */\n  createSizer(cursor, index, size = HANDLE_SIZE, fillColor = HANDLE_FILLCOLOR) {\n    const bounds = new Rectangle(0, 0, size, size);\n    const sizer = this.createSizerShape(bounds, index, fillColor);\n    if (sizer.bounds && sizer.isHtmlAllowed() && this.state.text && this.state.text.node.parentNode === this.graph.container) {\n      sizer.bounds.height -= 1;\n      sizer.bounds.width -= 1;\n      sizer.dialect = DIALECT.STRICTHTML;\n      sizer.init(this.graph.container);\n    } else {\n      sizer.dialect = this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;\n      sizer.init(this.graph.getView().getOverlayPane());\n    }\n    InternalEvent.redirectMouseEvents(sizer.node, this.graph, this.state);\n    if (this.graph.isEnabled()) {\n      sizer.setCursor(cursor);\n    }\n    if (!this.isSizerVisible(index)) {\n      sizer.visible = false;\n    }\n    return sizer;\n  }\n  /**\n   * Returns true if the sizer for the given index is visible.\n   * This returns true for all given indices.\n   */\n  isSizerVisible(index) {\n    return true;\n  }\n  /**\n   * Creates the shape used for the sizer handle for the specified bounds an\n   * index. Only images and rectangles should be returned if support for HTML\n   * labels with not foreign objects is required.\n   */\n  createSizerShape(bounds, index, fillColor = HANDLE_FILLCOLOR) {\n    if (this.handleImage) {\n      bounds = new Rectangle(bounds.x, bounds.y, this.handleImage.width, this.handleImage.height);\n      const shape = new ImageShape(bounds, this.handleImage.src);\n      // Allows HTML rendering of the images\n      shape.preserveImageAspect = false;\n      return shape;\n    }\n    if (index === InternalEvent.ROTATION_HANDLE) {\n      return new EllipseShape(bounds, fillColor, HANDLE_STROKECOLOR);\n    }\n    return new RectangleShape(bounds, fillColor, HANDLE_STROKECOLOR);\n  }\n  /**\n   * Helper method to create an {@link Rectangle} around the given centerpoint\n   * with a width and height of 2*s or 6, if no s is given.\n   */\n  moveSizerTo(shape, x, y) {\n    if (shape && shape.bounds) {\n      shape.bounds.x = Math.floor(x - shape.bounds.width / 2);\n      shape.bounds.y = Math.floor(y - shape.bounds.height / 2);\n      // Fixes visible inactive handles in VML\n      if (shape.node && shape.node.style.display !== 'none') {\n        shape.redraw();\n      }\n    }\n  }\n  /**\n   * Returns the index of the handle for the given event. This returns the index\n   * of the sizer from where the event originated or {@link Event#LABEL_INDEX}.\n   */\n  getHandleForEvent(me) {\n    // Connection highlight may consume events before they reach sizer handle\n    const tol = !isMouseEvent(me.getEvent()) ? this.tolerance : 1;\n    const hit = this.allowHandleBoundsCheck && tol > 0 ? new Rectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;\n    const checkShape = shape => {\n      const st = shape && shape.constructor !== ImageShape && this.allowHandleBoundsCheck ? shape.strokeWidth + shape.svgStrokeTolerance : null;\n      const real = st ? new Rectangle(me.getGraphX() - Math.floor(st / 2), me.getGraphY() - Math.floor(st / 2), st, st) : hit;\n      return shape && shape.bounds && (me.isSource(shape) || real && intersects(shape.bounds, real) && shape.node.style.display !== 'none' && shape.node.style.visibility !== 'hidden');\n    };\n    if (checkShape(this.rotationShape)) {\n      return InternalEvent.ROTATION_HANDLE;\n    }\n    if (checkShape(this.labelShape)) {\n      return InternalEvent.LABEL_HANDLE;\n    }\n    for (let i = 0; i < this.sizers.length; i += 1) {\n      if (checkShape(this.sizers[i])) {\n        return i;\n      }\n    }\n    if (this.customHandles != null && this.isCustomHandleEvent(me)) {\n      // Inverse loop order to match display order\n      for (let i = this.customHandles.length - 1; i >= 0; i--) {\n        if (checkShape(this.customHandles[i].shape)) {\n          // LATER: Return reference to active shape\n          return InternalEvent.CUSTOM_HANDLE - i;\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Returns true if the given event allows custom handles to be changed. This\n   * implementation returns true.\n   */\n  isCustomHandleEvent(me) {\n    return true;\n  }\n  /**\n   * Handles the event if a handle has been clicked. By consuming the\n   * event all subsequent events of the gesture are redirected to this\n   * handler.\n   */\n  mouseDown(sender, me) {\n    if (!me.isConsumed() && this.graph.isEnabled()) {\n      const handle = this.getHandleForEvent(me);\n      if (handle) {\n        this.start(me.getGraphX(), me.getGraphY(), handle);\n        me.consume();\n      }\n    }\n  }\n  /**\n   * Called if <livePreview> is enabled to check if a border should be painted.\n   * This implementation returns true if the shape is transparent.\n   */\n  isLivePreviewBorder() {\n    return this.state.shape && this.state.shape.fill === NONE && this.state.shape.stroke === NONE;\n  }\n  /**\n   * Starts the handling of the mouse gesture.\n   */\n  start(x, y, index) {\n    this.livePreviewActive = this.livePreview && this.state.cell.getChildCount() === 0;\n    this.inTolerance = true;\n    this.childOffsetX = 0;\n    this.childOffsetY = 0;\n    this.index = index;\n    this.startX = x;\n    this.startY = y;\n    if (this.index <= InternalEvent.CUSTOM_HANDLE && this.isGhostPreview()) {\n      this.ghostPreview = this.createGhostPreview();\n    } else {\n      // Saves reference to parent state\n      const {\n        model\n      } = this.state.view.graph;\n      const parent = this.state.cell.getParent();\n      if (this.state.view.currentRoot !== parent && parent && (parent.isVertex() || parent.isEdge())) {\n        this.parentState = this.state.view.graph.view.getState(parent);\n      }\n      // Creates a preview that can be on top of any HTML label\n      this.selectionBorder.node.style.display = index === InternalEvent.ROTATION_HANDLE ? 'inline' : 'none';\n      // Creates the border that represents the new bounds\n      if (!this.livePreviewActive || this.isLivePreviewBorder()) {\n        this.preview = this.createSelectionShape(this.bounds);\n        if (!(Client.IS_SVG && Number(this.state.style.rotation || '0') !== 0) && this.state.text != null && this.state.text.node.parentNode === this.graph.container) {\n          this.preview.dialect = DIALECT.STRICTHTML;\n          this.preview.init(this.graph.container);\n        } else {\n          this.preview.dialect = DIALECT.SVG;\n          this.preview.init(this.graph.view.getOverlayPane());\n        }\n      }\n      if (index === InternalEvent.ROTATION_HANDLE) {\n        // With the rotation handle in a corner, need the angle and distance\n        const pos = this.getRotationHandlePosition();\n        const dx = pos.x - this.state.getCenterX();\n        const dy = pos.y - this.state.getCenterY();\n        this.startAngle = dx !== 0 ? Math.atan(dy / dx) * 180 / Math.PI + 90 : 0;\n        this.startDist = Math.sqrt(dx * dx + dy * dy);\n      }\n      // Prepares the handles for live preview\n      if (this.livePreviewActive) {\n        this.hideSizers();\n        if (index === InternalEvent.ROTATION_HANDLE && this.rotationShape) {\n          this.rotationShape.node.style.display = '';\n        } else if (index === InternalEvent.LABEL_HANDLE && this.labelShape) {\n          this.labelShape.node.style.display = '';\n        } else if (this.sizers[index]) {\n          this.sizers[index].node.style.display = '';\n        } else if (index <= InternalEvent.CUSTOM_HANDLE) {\n          this.customHandles[InternalEvent.CUSTOM_HANDLE - index].setVisible(true);\n        }\n        // Gets the array of connected edge handlers for redrawing\n        const edges = this.state.cell.getEdges();\n        this.edgeHandlers = [];\n        const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n        for (let i = 0; i < edges.length; i += 1) {\n          const handler = selectionCellsHandler?.getHandler(edges[i]);\n          if (handler) {\n            this.edgeHandlers.push(handler);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Starts the handling of the mouse gesture.\n   */\n  createGhostPreview() {\n    const shape = this.graph.cellRenderer.createShape(this.state);\n    shape.init(this.graph.view.getOverlayPane());\n    shape.scale = this.state.view.scale;\n    shape.bounds = this.bounds;\n    shape.outline = true;\n    return shape;\n  }\n  /**\n   * Shortcut to <hideSizers>.\n   */\n  setHandlesVisible(visible) {\n    this.handlesVisible = visible;\n    for (let i = 0; i < this.sizers.length; i += 1) {\n      this.sizers[i].node.style.display = visible ? '' : 'none';\n    }\n    for (let i = 0; i < this.customHandles.length; i += 1) {\n      this.customHandles[i].setVisible(visible);\n    }\n  }\n  /**\n   * Hides all sizers except.\n   *\n   * Starts the handling of the mouse gesture.\n   */\n  hideSizers() {\n    this.setHandlesVisible(false);\n  }\n  /**\n   * Checks if the coordinates for the given event are within the\n   * {@link Graph#tolerance}. If the event is a mouse event then the tolerance is\n   * ignored.\n   */\n  checkTolerance(me) {\n    if (this.inTolerance && this.startX !== null && this.startY !== null) {\n      if (isMouseEvent(me.getEvent()) || Math.abs(me.getGraphX() - this.startX) > this.graph.getEventTolerance() || Math.abs(me.getGraphY() - this.startY) > this.graph.getEventTolerance()) {\n        this.inTolerance = false;\n      }\n    }\n  }\n  /**\n   * Hook for subclassers do show details while the handler is active.\n   */\n  updateHint(me) {\n    return;\n  }\n  /**\n   * Hooks for subclassers to hide details when the handler gets inactive.\n   */\n  removeHint() {\n    return;\n  }\n  /**\n   * Hook for rounding the angle. This uses Math.round.\n   */\n  roundAngle(angle) {\n    return Math.round(angle * 10) / 10;\n  }\n  /**\n   * Hook for rounding the unscaled width or height. This uses Math.round.\n   */\n  roundLength(length) {\n    return Math.round(length * 100) / 100;\n  }\n  /**\n   * Handles the event by updating the preview.\n   */\n  mouseMove(sender, me) {\n    if (!me.isConsumed() && this.index != null) {\n      // Checks tolerance for ignoring single clicks\n      this.checkTolerance(me);\n      if (!this.inTolerance) {\n        if (this.index <= InternalEvent.CUSTOM_HANDLE) {\n          if (this.customHandles != null) {\n            this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].processEvent(me);\n            this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].active = true;\n            if (this.ghostPreview != null) {\n              this.ghostPreview.apply(this.state);\n              this.ghostPreview.strokeWidth = this.getSelectionStrokeWidth() / this.ghostPreview.scale / this.ghostPreview.scale;\n              this.ghostPreview.isDashed = this.isSelectionDashed();\n              this.ghostPreview.stroke = this.getSelectionColor();\n              this.ghostPreview.redraw();\n              if (this.selectionBounds != null) {\n                this.selectionBorder.node.style.display = 'none';\n              }\n            } else {\n              if (this.movePreviewToFront) {\n                this.moveToFront();\n              }\n              this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].positionChanged();\n            }\n          }\n        } else if (this.index === InternalEvent.LABEL_HANDLE) {\n          this.moveLabel(me);\n        } else {\n          if (this.index === InternalEvent.ROTATION_HANDLE) {\n            this.rotateVertex(me);\n          } else {\n            this.resizeVertex(me);\n          }\n          this.updateHint(me);\n        }\n      }\n      me.consume();\n    }\n    // Workaround for disabling the connect highlight when over handle\n    else if (!this.graph.isMouseDown && this.getHandleForEvent(me)) {\n      me.consume(false);\n    }\n  }\n  /**\n   * Returns true if a ghost preview should be used for custom handles.\n   */\n  isGhostPreview() {\n    return this.state.cell.getChildCount() > 0;\n  }\n  /**\n   * Moves the vertex.\n   */\n  moveLabel(me) {\n    const point = new Point(me.getGraphX(), me.getGraphY());\n    const tr = this.graph.view.translate;\n    const {\n      scale\n    } = this.graph.view;\n    if (this.graph.isGridEnabledEvent(me.getEvent())) {\n      point.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;\n      point.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;\n    }\n    const index = this.rotationShape ? this.sizers.length - 2 : this.sizers.length - 1;\n    this.moveSizerTo(this.sizers[index], point.x, point.y);\n  }\n  /**\n   * Rotates the vertex.\n   */\n  rotateVertex(me) {\n    const point = new Point(me.getGraphX(), me.getGraphY());\n    let dx = this.state.x + this.state.width / 2 - point.x;\n    let dy = this.state.y + this.state.height / 2 - point.y;\n    this.currentAlpha = dx !== 0 ? Math.atan(dy / dx) * 180 / Math.PI + 90 : dy < 0 ? 180 : 0;\n    if (dx > 0) {\n      this.currentAlpha -= 180;\n    }\n    this.currentAlpha -= this.startAngle;\n    // Rotation raster\n    if (this.rotationRaster && this.graph.isGridEnabledEvent(me.getEvent())) {\n      let raster;\n      dx = point.x - this.state.getCenterX();\n      dy = point.y - this.state.getCenterY();\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      if (dist - this.startDist < 2) {\n        raster = 15;\n      } else if (dist - this.startDist < 25) {\n        raster = 5;\n      } else {\n        raster = 1;\n      }\n      this.currentAlpha = Math.round(this.currentAlpha / raster) * raster;\n    } else {\n      this.currentAlpha = this.roundAngle(this.currentAlpha);\n    }\n    this.selectionBorder.rotation = this.currentAlpha;\n    this.selectionBorder.redraw();\n    if (this.livePreviewActive) {\n      this.redrawHandles();\n    }\n  }\n  /**\n   * Resizes the vertex.\n   */\n  resizeVertex(me) {\n    const ct = new Point(this.state.getCenterX(), this.state.getCenterY());\n    const alpha = toRadians(this.state.style.rotation ?? 0);\n    const point = new Point(me.getGraphX(), me.getGraphY());\n    const tr = this.graph.view.translate;\n    const {\n      scale\n    } = this.graph.view;\n    let cos = Math.cos(-alpha);\n    let sin = Math.sin(-alpha);\n    let dx = point.x - this.startX;\n    let dy = point.y - this.startY;\n    // Rotates vector for mouse gesture\n    const tx = cos * dx - sin * dy;\n    const ty = sin * dx + cos * dy;\n    dx = tx;\n    dy = ty;\n    const geo = this.state.cell.getGeometry();\n    if (geo && this.index !== null) {\n      this.unscaledBounds = this.union(geo, dx / scale, dy / scale, this.index, this.graph.isGridEnabledEvent(me.getEvent()), 1, new Point(0, 0), this.isConstrainedEvent(me), this.isCenteredEvent(this.state, me));\n    }\n    // Keeps vertex within maximum graph or parent bounds\n    if (geo && !geo.relative) {\n      let max = this.graph.getMaximumGraphBounds();\n      // Handles child cells\n      if (max != null && this.parentState != null) {\n        max = Rectangle.fromRectangle(max);\n        max.x -= (this.parentState.x - tr.x * scale) / scale;\n        max.y -= (this.parentState.y - tr.y * scale) / scale;\n      }\n      if (this.graph.isConstrainChild(this.state.cell)) {\n        let tmp = this.graph.getCellContainmentArea(this.state.cell);\n        if (tmp != null) {\n          const overlap = this.graph.getOverlap(this.state.cell);\n          if (overlap > 0) {\n            tmp = Rectangle.fromRectangle(tmp);\n            tmp.x -= tmp.width * overlap;\n            tmp.y -= tmp.height * overlap;\n            tmp.width += 2 * tmp.width * overlap;\n            tmp.height += 2 * tmp.height * overlap;\n          }\n          if (!max) {\n            max = tmp;\n          } else {\n            max = Rectangle.fromRectangle(max);\n            max.intersect(tmp);\n          }\n        }\n      }\n      if (max && this.unscaledBounds) {\n        if (this.unscaledBounds.x < max.x) {\n          this.unscaledBounds.width -= max.x - this.unscaledBounds.x;\n          this.unscaledBounds.x = max.x;\n        }\n        if (this.unscaledBounds.y < max.y) {\n          this.unscaledBounds.height -= max.y - this.unscaledBounds.y;\n          this.unscaledBounds.y = max.y;\n        }\n        if (this.unscaledBounds.x + this.unscaledBounds.width > max.x + max.width) {\n          this.unscaledBounds.width -= this.unscaledBounds.x + this.unscaledBounds.width - max.x - max.width;\n        }\n        if (this.unscaledBounds.y + this.unscaledBounds.height > max.y + max.height) {\n          this.unscaledBounds.height -= this.unscaledBounds.y + this.unscaledBounds.height - max.y - max.height;\n        }\n      }\n    }\n    if (this.unscaledBounds) {\n      const old = this.bounds;\n      this.bounds = new Rectangle((this.parentState ? this.parentState.x : tr.x * scale) + this.unscaledBounds.x * scale, (this.parentState ? this.parentState.y : tr.y * scale) + this.unscaledBounds.y * scale, this.unscaledBounds.width * scale, this.unscaledBounds.height * scale);\n      if (geo && geo.relative && this.parentState) {\n        this.bounds.x += this.state.x - this.parentState.x;\n        this.bounds.y += this.state.y - this.parentState.y;\n      }\n      cos = Math.cos(alpha);\n      sin = Math.sin(alpha);\n      const c2 = new Point(this.bounds.getCenterX(), this.bounds.getCenterY());\n      dx = c2.x - ct.x;\n      dy = c2.y - ct.y;\n      const dx2 = cos * dx - sin * dy;\n      const dy2 = sin * dx + cos * dy;\n      const dx3 = dx2 - dx;\n      const dy3 = dy2 - dy;\n      const dx4 = this.bounds.x - this.state.x;\n      const dy4 = this.bounds.y - this.state.y;\n      const dx5 = cos * dx4 - sin * dy4;\n      const dy5 = sin * dx4 + cos * dy4;\n      this.bounds.x += dx3;\n      this.bounds.y += dy3;\n      // Rounds unscaled bounds to int\n      this.unscaledBounds.x = this.roundLength(this.unscaledBounds.x + dx3 / scale);\n      this.unscaledBounds.y = this.roundLength(this.unscaledBounds.y + dy3 / scale);\n      this.unscaledBounds.width = this.roundLength(this.unscaledBounds.width);\n      this.unscaledBounds.height = this.roundLength(this.unscaledBounds.height);\n      // Shifts the children according to parent offset\n      if (!this.state.cell.isCollapsed() && (dx3 !== 0 || dy3 !== 0)) {\n        this.childOffsetX = this.state.x - this.bounds.x + dx5;\n        this.childOffsetY = this.state.y - this.bounds.y + dy5;\n      } else {\n        this.childOffsetX = 0;\n        this.childOffsetY = 0;\n      }\n      if (!old.equals(this.bounds)) {\n        if (this.livePreviewActive) {\n          this.updateLivePreview(me);\n        }\n        if (this.preview != null) {\n          this.drawPreview();\n        } else {\n          this.updateParentHighlight();\n        }\n      }\n    }\n  }\n  /**\n   * Repaints the live preview.\n   */\n  updateLivePreview(me) {\n    // TODO: Apply child offset to children in live preview\n    const {\n      scale\n    } = this.graph.view;\n    const tr = this.graph.view.translate;\n    // Saves current state\n    const tempState = this.state.clone();\n    // Temporarily changes size and origin\n    this.state.x = this.bounds.x;\n    this.state.y = this.bounds.y;\n    this.state.origin = new Point(this.state.x / scale - tr.x, this.state.y / scale - tr.y);\n    this.state.width = this.bounds.width;\n    this.state.height = this.bounds.height;\n    // Redraws cell and handles\n    let off = this.state.absoluteOffset;\n    off = new Point(off.x, off.y);\n    // Required to store and reset absolute offset for updating label position\n    this.state.absoluteOffset.x = 0;\n    this.state.absoluteOffset.y = 0;\n    const geo = this.state.cell.getGeometry();\n    if (geo != null) {\n      const offset = geo.offset || this.EMPTY_POINT;\n      if (offset != null && !geo.relative) {\n        this.state.absoluteOffset.x = this.state.view.scale * offset.x;\n        this.state.absoluteOffset.y = this.state.view.scale * offset.y;\n      }\n      this.state.view.updateVertexLabelOffset(this.state);\n    }\n    // Draws the live preview\n    this.state.view.graph.cellRenderer.redraw(this.state, true);\n    // Redraws connected edges TODO: Include child edges\n    this.state.view.invalidate(this.state.cell);\n    this.state.invalid = false;\n    this.state.view.validate();\n    this.redrawHandles();\n    // Moves live preview to front\n    if (this.movePreviewToFront) {\n      this.moveToFront();\n    }\n    // Hides folding icon\n    if (this.state.control != null && this.state.control.node != null) {\n      this.state.control.node.style.visibility = 'hidden';\n    }\n    // Restores current state\n    this.state.setState(tempState);\n  }\n  /**\n   * Handles the event by applying the changes to the geometry.\n   */\n  moveToFront() {\n    if (this.state.text && this.state.text.node && this.state.text.node.nextSibling || this.state.shape && this.state.shape.node && this.state.shape.node.nextSibling && (!this.state.text || this.state.shape.node.nextSibling !== this.state.text.node)) {\n      if (this.state.shape && this.state.shape.node && this.state.shape.node.parentNode) {\n        this.state.shape.node.parentNode.appendChild(this.state.shape.node);\n      }\n      if (this.state.text && this.state.text.node && this.state.text.node.parentNode) {\n        this.state.text.node.parentNode.appendChild(this.state.text.node);\n      }\n    }\n  }\n  /**\n   * Handles the event by applying the changes to the geometry.\n   */\n  mouseUp(sender, me) {\n    if (this.index != null && this.state != null) {\n      const point = new Point(me.getGraphX(), me.getGraphY());\n      const {\n        index\n      } = this;\n      this.index = null;\n      if (this.ghostPreview == null) {\n        // Required to restore order in case of no change\n        this.state.view.invalidate(this.state.cell, false, false);\n        this.state.view.validate();\n      }\n      this.graph.batchUpdate(() => {\n        if (index <= InternalEvent.CUSTOM_HANDLE) {\n          if (this.customHandles != null) {\n            // Creates style before changing cell state\n            const style = this.state.view.graph.getCellStyle(this.state.cell);\n            this.customHandles[InternalEvent.CUSTOM_HANDLE - index].active = false;\n            this.customHandles[InternalEvent.CUSTOM_HANDLE - index].execute(me);\n            // Sets style and apply on shape to force repaint and\n            // check if execute has removed custom handles\n            if (this.customHandles != null && this.customHandles[InternalEvent.CUSTOM_HANDLE - index] != null) {\n              this.state.style = style;\n              this.customHandles[InternalEvent.CUSTOM_HANDLE - index].positionChanged();\n            }\n          }\n        } else if (index === InternalEvent.ROTATION_HANDLE) {\n          if (this.currentAlpha != null) {\n            const delta = this.currentAlpha - (this.state.style.rotation ?? 0);\n            if (delta !== 0) {\n              this.rotateCell(this.state.cell, delta);\n            }\n          } else {\n            this.rotateClick();\n          }\n        } else {\n          const gridEnabled = this.graph.isGridEnabledEvent(me.getEvent());\n          const alpha = toRadians(this.state.style.rotation ?? 0);\n          const cos = Math.cos(-alpha);\n          const sin = Math.sin(-alpha);\n          let dx = point.x - this.startX;\n          let dy = point.y - this.startY;\n          // Rotates vector for mouse gesture\n          const tx = cos * dx - sin * dy;\n          const ty = sin * dx + cos * dy;\n          dx = tx;\n          dy = ty;\n          const s = this.graph.view.scale;\n          const recurse = this.isRecursiveResize(this.state, me);\n          this.resizeCell(this.state.cell, this.roundLength(dx / s), this.roundLength(dy / s), index, gridEnabled, this.isConstrainedEvent(me), recurse);\n        }\n      });\n      me.consume();\n      this.reset();\n      this.redrawHandles();\n    }\n  }\n  /**\n   * Returns the `recursiveResize` status of the given state.\n   * @param state the given {@link CellState}. This implementation takes the value of this state.\n   * @param me the mouse event.\n   */\n  isRecursiveResize(state, me) {\n    return this.graph.isRecursiveResize(this.state);\n  }\n  /**\n   * Hook for subclassers to implement a single click on the rotation handle.\n   * This code is executed as part of the model transaction. This implementation\n   * is empty.\n   */\n  rotateClick() {\n    return;\n  }\n  /**\n   * Rotates the given cell and its children by the given angle in degrees.\n   *\n   * @param cell <Cell> to be rotated.\n   * @param angle Angle in degrees.\n   */\n  rotateCell(cell, angle, parent) {\n    if (angle !== 0) {\n      const model = this.graph.getDataModel();\n      if (cell.isVertex() || cell.isEdge()) {\n        if (!cell.isEdge()) {\n          const style = this.graph.getCurrentCellStyle(cell);\n          const total = (style.rotation || 0) + angle;\n          this.graph.setCellStyles('rotation', total, [cell]);\n        }\n        let geo = cell.getGeometry();\n        if (geo && parent) {\n          const pgeo = parent.getGeometry();\n          if (pgeo != null && !parent.isEdge()) {\n            geo = geo.clone();\n            geo.rotate(angle, new Point(pgeo.width / 2, pgeo.height / 2));\n            model.setGeometry(cell, geo);\n          }\n          if (cell.isVertex() && !geo.relative || cell.isEdge()) {\n            // Recursive rotation\n            const childCount = cell.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n              this.rotateCell(cell.getChildAt(i), angle, cell);\n            }\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Resets the state of this handler.\n   */\n  reset() {\n    if (this.index !== null && this.sizers[this.index].node.style.display === 'none') {\n      this.sizers[this.index].node.style.display = '';\n    }\n    this.index = null;\n    // TODO: Reset and redraw cell states for live preview\n    if (this.preview) {\n      this.preview.destroy();\n      this.preview = null;\n    }\n    if (this.ghostPreview) {\n      this.ghostPreview.destroy();\n      this.ghostPreview = null;\n    }\n    if (this.livePreviewActive) {\n      for (let i = 0; i < this.sizers.length; i += 1) {\n        this.sizers[i].node.style.display = '';\n      }\n      // Shows folding icon\n      if (this.state.control && this.state.control.node) {\n        this.state.control.node.style.visibility = '';\n      }\n    }\n    for (let i = 0; i < this.customHandles.length; i += 1) {\n      if (this.customHandles[i].active) {\n        this.customHandles[i].active = false;\n        this.customHandles[i].reset();\n      } else {\n        this.customHandles[i].setVisible(true);\n      }\n    }\n    // Checks if handler has been destroyed\n    this.selectionBorder.node.style.display = 'inline';\n    this.selectionBounds = this.getSelectionBounds(this.state);\n    this.bounds = new Rectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);\n    this.drawPreview();\n    this.removeHint();\n    this.redrawHandles();\n    this.edgeHandlers = [];\n    this.handlesVisible = true;\n    this.unscaledBounds = null;\n  }\n  /**\n   * Uses the given vector to change the bounds of the given cell\n   * in the graph using {@link Graph#resizeCell}.\n   */\n  resizeCell(cell, dx, dy, index, gridEnabled, constrained, recurse) {\n    let geo = cell.getGeometry();\n    if (geo) {\n      if (index === InternalEvent.LABEL_HANDLE && this.labelShape && this.labelShape.bounds) {\n        const alpha = -toRadians(this.state.style.rotation ?? 0);\n        const cos = Math.cos(alpha);\n        const sin = Math.sin(alpha);\n        const {\n          scale\n        } = this.graph.view;\n        const pt = getRotatedPoint(new Point(Math.round((this.labelShape.bounds.getCenterX() - this.startX) / scale), Math.round((this.labelShape.bounds.getCenterY() - this.startY) / scale)), cos, sin);\n        geo = geo.clone();\n        if (geo.offset == null) {\n          geo.offset = pt;\n        } else {\n          geo.offset.x += pt.x;\n          geo.offset.y += pt.y;\n        }\n        this.graph.model.setGeometry(cell, geo);\n      } else if (this.unscaledBounds) {\n        const {\n          scale\n        } = this.graph.view;\n        if (this.childOffsetX !== 0 || this.childOffsetY !== 0) {\n          this.moveChildren(cell, Math.round(this.childOffsetX / scale), Math.round(this.childOffsetY / scale));\n        }\n        this.graph.resizeCell(cell, this.unscaledBounds, recurse);\n      }\n    }\n  }\n  /**\n   * Moves the children of the given cell by the given vector.\n   */\n  moveChildren(cell, dx, dy) {\n    const model = this.graph.getDataModel();\n    const childCount = cell.getChildCount();\n    for (let i = 0; i < childCount; i += 1) {\n      const child = cell.getChildAt(i);\n      let geo = child.getGeometry();\n      if (geo != null) {\n        geo = geo.clone();\n        geo.translate(dx, dy);\n        model.setGeometry(child, geo);\n      }\n    }\n  }\n  /**\n   * Returns the union of the given bounds and location for the specified\n   * handle index.\n   *\n   * To override this to limit the size of vertex via a minWidth/-Height style,\n   * the following code can be used.\n   *\n   * ```javascript\n   * let vertexHandlerUnion = union;\n   * union = (bounds, dx, dy, index, gridEnabled, scale, tr, constrained)=>\n   * {\n   *   let result = vertexHandlerUnion.apply(this, arguments);\n   *\n   *   result.width = Math.max(result.width, mxUtils.getNumber(this.state.style, 'minWidth', 0));\n   *   result.height = Math.max(result.height, mxUtils.getNumber(this.state.style, 'minHeight', 0));\n   *\n   *   return result;\n   * };\n   * ```\n   *\n   * The minWidth/-Height style can then be used as follows:\n   *\n   * ```javascript\n   * graph.insertVertex(parent, null, 'Hello,', 20, 20, 80, 30, 'minWidth=100;minHeight=100;');\n   * ```\n   *\n   * To override this to update the height for a wrapped text if the width of a vertex is\n   * changed, the following can be used.\n   *\n   * ```javascript\n   * let mxVertexHandlerUnion = union;\n   * union = (bounds, dx, dy, index, gridEnabled, scale, tr, constrained)=>\n   * {\n   *   let result = mxVertexHandlerUnion.apply(this, arguments);\n   *   let s = this.state;\n   *\n   *   if (this.graph.isHtmlLabel(s.cell) && (index == 3 || index == 4) &&\n   *       s.text != null && s.style.whiteSpace == 'wrap')\n   *   {\n   *     let label = this.graph.getLabel(s.cell);\n   *     let fontSize = mxUtils.getNumber(s.style, 'fontSize', mxConstants.DEFAULT_FONTSIZE);\n   *     let ww = result.width / s.view.scale - s.text.spacingRight - s.text.spacingLeft\n   *\n   *     result.height = mxUtils.getSizeForString(label, fontSize, s.style.fontFamily, ww).height;\n   *   }\n   *\n   *   return result;\n   * };\n   * ```\n   */\n  union(bounds, dx, dy, index, gridEnabled, scale, tr, constrained, centered) {\n    gridEnabled = gridEnabled && this.graph.isGridEnabled();\n    if (this.singleSizer) {\n      let x = bounds.x + bounds.width + dx;\n      let y = bounds.y + bounds.height + dy;\n      if (gridEnabled) {\n        x = this.graph.snap(x / scale) * scale;\n        y = this.graph.snap(y / scale) * scale;\n      }\n      const rect = new Rectangle(bounds.x, bounds.y, 0, 0);\n      rect.add(new Rectangle(x, y, 0, 0));\n      return rect;\n    }\n    const w0 = bounds.width;\n    const h0 = bounds.height;\n    let left = bounds.x - tr.x * scale;\n    let right = left + w0;\n    let top = bounds.y - tr.y * scale;\n    let bottom = top + h0;\n    const cx = left + w0 / 2;\n    const cy = top + h0 / 2;\n    if (index > 4 /* Bottom Row */) {\n      bottom += dy;\n      if (gridEnabled) {\n        bottom = this.graph.snap(bottom / scale) * scale;\n      } else {\n        bottom = Math.round(bottom / scale) * scale;\n      }\n    } else if (index < 3 /* Top Row */) {\n      top += dy;\n      if (gridEnabled) {\n        top = this.graph.snap(top / scale) * scale;\n      } else {\n        top = Math.round(top / scale) * scale;\n      }\n    }\n    if (index === 0 || index === 3 || index === 5 /* Left */) {\n      left += dx;\n      if (gridEnabled) {\n        left = this.graph.snap(left / scale) * scale;\n      } else {\n        left = Math.round(left / scale) * scale;\n      }\n    } else if (index === 2 || index === 4 || index === 7 /* Right */) {\n      right += dx;\n      if (gridEnabled) {\n        right = this.graph.snap(right / scale) * scale;\n      } else {\n        right = Math.round(right / scale) * scale;\n      }\n    }\n    let width = right - left;\n    let height = bottom - top;\n    if (constrained) {\n      const geo = this.state.cell.getGeometry();\n      if (geo != null) {\n        const aspect = geo.width / geo.height;\n        if (index === 1 || index === 2 || index === 7 || index === 6) {\n          width = height * aspect;\n        } else {\n          height = width / aspect;\n        }\n        if (index === 0) {\n          left = right - width;\n          top = bottom - height;\n        }\n      }\n    }\n    if (centered) {\n      width += width - w0;\n      height += height - h0;\n      const cdx = cx - (left + width / 2);\n      const cdy = cy - (top + height / 2);\n      left += cdx;\n      top += cdy;\n      right += cdx;\n      bottom += cdy;\n    }\n    // Flips over left side\n    if (width < 0) {\n      left += width;\n      width = Math.abs(width);\n    }\n    // Flips over top side\n    if (height < 0) {\n      top += height;\n      height = Math.abs(height);\n    }\n    const result = new Rectangle(left + tr.x * scale, top + tr.y * scale, width, height);\n    if (this.minBounds != null) {\n      result.width = Math.max(result.width, this.minBounds.x * scale + this.minBounds.width * scale + Math.max(0, this.x0 * scale - result.x));\n      result.height = Math.max(result.height, this.minBounds.y * scale + this.minBounds.height * scale + Math.max(0, this.y0 * scale - result.y));\n    }\n    return result;\n  }\n  /**\n   * Redraws the handles and the preview.\n   */\n  redraw(ignoreHandles) {\n    this.selectionBounds = this.getSelectionBounds(this.state);\n    this.bounds = new Rectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);\n    this.drawPreview();\n    if (!ignoreHandles) {\n      this.redrawHandles();\n    }\n  }\n  /**\n   * Returns the padding to be used for drawing handles for the current <bounds>.\n   */\n  getHandlePadding() {\n    // KNOWN: Tolerance depends on event type (eg. 0 for mouse events)\n    const result = new Point(0, 0);\n    let tol = this.tolerance;\n    if (this.sizers.length > 0 && this.sizers[0].bounds && (this.bounds.width < 2 * this.sizers[0].bounds.width + 2 * tol || this.bounds.height < 2 * this.sizers[0].bounds.height + 2 * tol)) {\n      tol /= 2;\n      result.x = this.sizers[0].bounds.width + tol;\n      result.y = this.sizers[0].bounds.height + tol;\n    }\n    return result;\n  }\n  /**\n   * Returns the bounds used to paint the resize handles.\n   */\n  getSizerBounds() {\n    return this.bounds;\n  }\n  /**\n   * Redraws the handles. To hide certain handles the following code can be used.\n   *\n   * ```javascript\n   * redrawHandles()\n   * {\n   *   mxVertexHandlerRedrawHandles.apply(this, arguments);\n   *\n   *   if (this.sizers != null && this.sizers.length > 7)\n   *   {\n   *     this.sizers[1].node.style.display = 'none';\n   *     this.sizers[6].node.style.display = 'none';\n   *   }\n   * };\n   * ```\n   */\n  redrawHandles() {\n    let s = this.getSizerBounds();\n    const tol = this.tolerance;\n    this.horizontalOffset = 0;\n    this.verticalOffset = 0;\n    for (let i = 0; i < this.customHandles.length; i += 1) {\n      const shape = this.customHandles[i].shape;\n      if (shape) {\n        const temp = shape.node.style.display;\n        this.customHandles[i].redraw();\n        shape.node.style.display = temp;\n        // Hides custom handles during text editing\n        shape.node.style.visibility = this.handlesVisible && this.isCustomHandleVisible(this.customHandles[i]) ? '' : 'hidden';\n      }\n    }\n    if (this.sizers.length > 0 && this.sizers[0]) {\n      if (this.index === null && this.manageSizers && this.sizers.length >= 8) {\n        // KNOWN: Tolerance depends on event type (eg. 0 for mouse events)\n        const padding = this.getHandlePadding();\n        this.horizontalOffset = padding.x;\n        this.verticalOffset = padding.y;\n        if (this.horizontalOffset !== 0 || this.verticalOffset !== 0) {\n          s = new Rectangle(s.x, s.y, s.width, s.height);\n          s.x -= this.horizontalOffset / 2;\n          s.width += this.horizontalOffset;\n          s.y -= this.verticalOffset / 2;\n          s.height += this.verticalOffset;\n        }\n        if (this.sizers.length >= 8) {\n          if (this.sizers[0].bounds && (s.width < 2 * this.sizers[0].bounds.width + 2 * tol || s.height < 2 * this.sizers[0].bounds.height + 2 * tol)) {\n            this.sizers[0].node.style.display = 'none';\n            this.sizers[2].node.style.display = 'none';\n            this.sizers[5].node.style.display = 'none';\n            this.sizers[7].node.style.display = 'none';\n          } else if (this.handlesVisible) {\n            this.sizers[0].node.style.display = '';\n            this.sizers[2].node.style.display = '';\n            this.sizers[5].node.style.display = '';\n            this.sizers[7].node.style.display = '';\n          }\n        }\n      }\n      const r = s.x + s.width;\n      const b = s.y + s.height;\n      if (this.singleSizer) {\n        this.moveSizerTo(this.sizers[0], r, b);\n      } else {\n        const cx = s.x + s.width / 2;\n        const cy = s.y + s.height / 2;\n        if (this.sizers.length >= 8) {\n          const crs = ['nw-resize', 'n-resize', 'ne-resize', 'e-resize', 'se-resize', 's-resize', 'sw-resize', 'w-resize'];\n          const alpha = toRadians(this.state.style.rotation ?? 0);\n          const cos = Math.cos(alpha);\n          const sin = Math.sin(alpha);\n          const da = Math.round(alpha * 4 / Math.PI);\n          const ct = new Point(s.getCenterX(), s.getCenterY());\n          let pt = getRotatedPoint(new Point(s.x, s.y), cos, sin, ct);\n          this.moveSizerTo(this.sizers[0], pt.x, pt.y);\n          this.sizers[0].setCursor(crs[mod(0 + da, crs.length)]);\n          pt.x = cx;\n          pt.y = s.y;\n          pt = getRotatedPoint(pt, cos, sin, ct);\n          this.moveSizerTo(this.sizers[1], pt.x, pt.y);\n          this.sizers[1].setCursor(crs[mod(1 + da, crs.length)]);\n          pt.x = r;\n          pt.y = s.y;\n          pt = getRotatedPoint(pt, cos, sin, ct);\n          this.moveSizerTo(this.sizers[2], pt.x, pt.y);\n          this.sizers[2].setCursor(crs[mod(2 + da, crs.length)]);\n          pt.x = s.x;\n          pt.y = cy;\n          pt = getRotatedPoint(pt, cos, sin, ct);\n          this.moveSizerTo(this.sizers[3], pt.x, pt.y);\n          this.sizers[3].setCursor(crs[mod(7 + da, crs.length)]);\n          pt.x = r;\n          pt.y = cy;\n          pt = getRotatedPoint(pt, cos, sin, ct);\n          this.moveSizerTo(this.sizers[4], pt.x, pt.y);\n          this.sizers[4].setCursor(crs[mod(3 + da, crs.length)]);\n          pt.x = s.x;\n          pt.y = b;\n          pt = getRotatedPoint(pt, cos, sin, ct);\n          this.moveSizerTo(this.sizers[5], pt.x, pt.y);\n          this.sizers[5].setCursor(crs[mod(6 + da, crs.length)]);\n          pt.x = cx;\n          pt.y = b;\n          pt = getRotatedPoint(pt, cos, sin, ct);\n          this.moveSizerTo(this.sizers[6], pt.x, pt.y);\n          this.sizers[6].setCursor(crs[mod(5 + da, crs.length)]);\n          pt.x = r;\n          pt.y = b;\n          pt = getRotatedPoint(pt, cos, sin, ct);\n          this.moveSizerTo(this.sizers[7], pt.x, pt.y);\n          this.sizers[7].setCursor(crs[mod(4 + da, crs.length)]);\n          pt.x = cx + this.state.absoluteOffset.x;\n          pt.y = cy + this.state.absoluteOffset.y;\n          pt = getRotatedPoint(pt, cos, sin, ct);\n          this.moveSizerTo(this.sizers[8], pt.x, pt.y);\n        } else if (this.state.width >= 2 && this.state.height >= 2) {\n          this.moveSizerTo(this.sizers[0], cx + this.state.absoluteOffset.x, cy + this.state.absoluteOffset.y);\n        } else {\n          this.moveSizerTo(this.sizers[0], this.state.x, this.state.y);\n        }\n      }\n    }\n    if (this.rotationShape) {\n      const alpha = toRadians(this.currentAlpha);\n      const cos = Math.cos(alpha);\n      const sin = Math.sin(alpha);\n      const ct = new Point(this.state.getCenterX(), this.state.getCenterY());\n      const pt = getRotatedPoint(this.getRotationHandlePosition(), cos, sin, ct);\n      if (this.rotationShape.node != null) {\n        this.moveSizerTo(this.rotationShape, pt.x, pt.y);\n        // Hides rotation handle during text editing\n        this.rotationShape.node.style.visibility = this.state.view.graph.isEditing() || !this.handlesVisible ? 'hidden' : '';\n      }\n    }\n    if (this.selectionBorder != null) {\n      this.selectionBorder.rotation = this.state.style.rotation ?? 0;\n    }\n    if (this.edgeHandlers != null) {\n      for (let i = 0; i < this.edgeHandlers.length; i += 1) {\n        this.edgeHandlers[i].redraw();\n      }\n    }\n  }\n  /**\n   * Returns true if the given custom handle is visible.\n   */\n  isCustomHandleVisible(handle) {\n    return !this.graph.isEditing() && this.state.view.graph.getSelectionCount() === 1;\n  }\n  /**\n   * Returns an {@link Point} that defines the rotation handle position.\n   */\n  getRotationHandlePosition() {\n    return new Point(this.bounds.x + this.bounds.width / 2, this.bounds.y + this.rotationHandleVSpacing);\n  }\n  /**\n   * Returns true if the parent highlight should be visible. This implementation\n   * always returns true.\n   */\n  isParentHighlightVisible() {\n    const parent = this.state.cell.getParent();\n    return parent ? !this.graph.isCellSelected(parent) : false;\n  }\n  /**\n   * Updates the highlight of the parent if <parentHighlightEnabled> is true.\n   */\n  updateParentHighlight() {\n    if (!this.isDestroyed()) {\n      const visible = this.isParentHighlightVisible();\n      const parent = this.state.cell.getParent();\n      const pstate = parent ? this.graph.view.getState(parent) : null;\n      if (this.parentHighlight) {\n        if (parent && parent.isVertex() && visible) {\n          const b = this.parentHighlight.bounds;\n          if (pstate && b && (b.x !== pstate.x || b.y !== pstate.y || b.width !== pstate.width || b.height !== pstate.height)) {\n            this.parentHighlight.bounds = Rectangle.fromRectangle(pstate);\n            this.parentHighlight.redraw();\n          }\n        } else {\n          if (pstate != null && pstate.parentHighlight === this.parentHighlight) {\n            pstate.parentHighlight = null;\n          }\n          this.parentHighlight.destroy();\n          this.parentHighlight = null;\n        }\n      } else if (this.parentHighlightEnabled && visible) {\n        if (parent && parent.isVertex() && pstate != null && pstate.parentHighlight == null) {\n          this.parentHighlight = this.createParentHighlightShape(pstate);\n          // VML dialect required here for event transparency in IE\n          this.parentHighlight.dialect = DIALECT.SVG;\n          this.parentHighlight.pointerEvents = false;\n          this.parentHighlight.rotation = pstate.style.rotation ?? 0;\n          this.parentHighlight.init(this.graph.getView().getOverlayPane());\n          this.parentHighlight.redraw();\n          // Shows highlight once per parent\n          pstate.parentHighlight = this.parentHighlight;\n        }\n      }\n    }\n  }\n  /**\n   * Redraws the preview.\n   */\n  drawPreview() {\n    if (this.preview != null) {\n      this.preview.bounds = this.bounds;\n      if (this.preview.node.parentNode === this.graph.container) {\n        this.preview.bounds.width = Math.max(0, this.preview.bounds.width - 1);\n        this.preview.bounds.height = Math.max(0, this.preview.bounds.height - 1);\n      }\n      this.preview.rotation = this.state.style.rotation ?? 0;\n      this.preview.redraw();\n    }\n    this.selectionBorder.bounds = this.getSelectionBorderBounds();\n    this.selectionBorder.redraw();\n    this.updateParentHighlight();\n  }\n  /**\n   * Returns the bounds for the selection border.\n   */\n  getSelectionBorderBounds() {\n    return this.bounds;\n  }\n  /**\n   * Returns true if this handler was destroyed or not initialized.\n   */\n  isDestroyed() {\n    return this.selectionBorder == null;\n  }\n  /**\n   * Destroys the handler and all its resources and DOM nodes.\n   */\n  onDestroy() {\n    this.state.view.graph.removeListener(this.escapeHandler);\n    this.escapeHandler = () => {\n      return;\n    };\n    if (this.preview) {\n      this.preview.destroy();\n      this.preview = null;\n    }\n    if (this.parentHighlight) {\n      const parent = this.state.cell.getParent();\n      const pstate = parent ? this.graph.view.getState(parent) : null;\n      if (pstate && pstate.parentHighlight === this.parentHighlight) {\n        pstate.parentHighlight = null;\n      }\n      this.parentHighlight.destroy();\n      this.parentHighlight = null;\n    }\n    if (this.ghostPreview) {\n      this.ghostPreview.destroy();\n      this.ghostPreview = null;\n    }\n    if (this.selectionBorder) {\n      this.selectionBorder.destroy();\n    }\n    this.labelShape = null;\n    this.removeHint();\n    for (let i = 0; i < this.sizers.length; i += 1) {\n      this.sizers[i].destroy();\n    }\n    this.sizers = [];\n    for (let i = 0; i < this.customHandles.length; i += 1) {\n      this.customHandles[i].destroy();\n    }\n    this.customHandles = [];\n  }\n}\nexport default VertexHandler;","map":{"version":3,"names":["Rectangle","CURSOR","DIALECT","HANDLE_FILLCOLOR","HANDLE_SIZE","HANDLE_STROKECOLOR","LABEL_HANDLE_FILLCOLOR","LABEL_HANDLE_SIZE","NONE","VERTEX_SELECTION_COLOR","VERTEX_SELECTION_DASHED","VERTEX_SELECTION_STROKEWIDTH","InternalEvent","RectangleShape","ImageShape","EllipseShape","Point","getRotatedPoint","intersects","mod","toRadians","Client","isMouseEvent","isShiftDown","VertexHandler","constructor","state","sizers","singleSizer","index","allowHandleBoundsCheck","handleImage","handlesVisible","tolerance","rotationEnabled","parentHighlightEnabled","rotationRaster","rotationCursor","livePreview","movePreviewToFront","manageSizers","constrainGroupByChildren","rotationHandleVSpacing","horizontalOffset","verticalOffset","minBounds","x0","y0","customHandles","inTolerance","startX","startY","rotationShape","currentAlpha","startAngle","startDist","ghostPreview","livePreviewActive","childOffsetX","childOffsetY","parentState","parentHighlight","unscaledBounds","preview","labelShape","edgeHandlers","EMPTY_POINT","graph","view","selectionBounds","getSelectionBounds","bounds","x","y","width","height","selectionBorder","createSelectionShape","dialect","SVG","pointerEvents","rotation","style","init","getView","getOverlayPane","redirectMouseEvents","node","isCellMovable","cell","setCursor","MOVABLE_VERTEX","selectionHandler","getPlugin","maxCells","getSelectionCount","resizable","isCellResizable","isLabelMovable","i","push","createSizer","geo","getGeometry","relative","LABEL_HANDLE","undefined","isRotationHandleVisible","ROTATION_HANDLE","createCustomHandles","redraw","updateMinBounds","escapeHandler","sender","evt","cellRenderer","invalidate","invalid","validate","reset","addListener","ESCAPE","selectionHandlerCheck","isEnabled","isCellRotatable","isConstrainedEvent","me","getEvent","aspect","isCenteredEvent","children","getChildCells","length","getBounds","s","scale","t","translate","Math","round","createParentHighlightShape","shape","fromRectangle","getSelectionColor","strokeWidth","getSelectionStrokeWidth","isDashed","isSelectionDashed","cursor","size","fillColor","sizer","createSizerShape","isHtmlAllowed","text","parentNode","container","STRICTHTML","MIXEDHTML","isSizerVisible","visible","src","preserveImageAspect","moveSizerTo","floor","display","getHandleForEvent","tol","hit","getGraphX","getGraphY","checkShape","st","svgStrokeTolerance","real","isSource","visibility","isCustomHandleEvent","CUSTOM_HANDLE","mouseDown","isConsumed","handle","start","consume","isLivePreviewBorder","fill","stroke","getChildCount","isGhostPreview","createGhostPreview","model","parent","getParent","currentRoot","isVertex","isEdge","getState","IS_SVG","Number","pos","getRotationHandlePosition","dx","getCenterX","dy","getCenterY","atan","PI","sqrt","hideSizers","setVisible","edges","getEdges","selectionCellsHandler","handler","getHandler","createShape","outline","setHandlesVisible","checkTolerance","abs","getEventTolerance","updateHint","removeHint","roundAngle","angle","roundLength","mouseMove","processEvent","active","apply","moveToFront","positionChanged","moveLabel","rotateVertex","resizeVertex","isMouseDown","point","tr","isGridEnabledEvent","snap","raster","dist","redrawHandles","ct","alpha","cos","sin","tx","ty","union","max","getMaximumGraphBounds","isConstrainChild","tmp","getCellContainmentArea","overlap","getOverlap","intersect","old","c2","dx2","dy2","dx3","dy3","dx4","dy4","dx5","dy5","isCollapsed","equals","updateLivePreview","drawPreview","updateParentHighlight","tempState","clone","origin","off","absoluteOffset","offset","updateVertexLabelOffset","control","setState","nextSibling","appendChild","mouseUp","batchUpdate","getCellStyle","execute","delta","rotateCell","rotateClick","gridEnabled","recurse","isRecursiveResize","resizeCell","getDataModel","getCurrentCellStyle","total","setCellStyles","pgeo","rotate","setGeometry","childCount","getChildAt","destroy","constrained","pt","moveChildren","child","centered","isGridEnabled","rect","add","w0","h0","left","right","top","bottom","cx","cy","cdx","cdy","result","ignoreHandles","getHandlePadding","getSizerBounds","temp","isCustomHandleVisible","padding","r","b","crs","da","isEditing","isParentHighlightVisible","isCellSelected","isDestroyed","pstate","getSelectionBorderBounds","onDestroy","removeListener"],"sources":["D:/ospanel/domains/react/react-intro/node_modules/@maxgraph/core/dist/view/handler/VertexHandler.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from '../geometry/Rectangle';\nimport { CURSOR, DIALECT, HANDLE_FILLCOLOR, HANDLE_SIZE, HANDLE_STROKECOLOR, LABEL_HANDLE_FILLCOLOR, LABEL_HANDLE_SIZE, NONE, VERTEX_SELECTION_COLOR, VERTEX_SELECTION_DASHED, VERTEX_SELECTION_STROKEWIDTH, } from '../../util/Constants';\nimport InternalEvent from '../event/InternalEvent';\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport ImageShape from '../geometry/node/ImageShape';\nimport EllipseShape from '../geometry/node/EllipseShape';\nimport Point from '../geometry/Point';\nimport { getRotatedPoint, intersects, mod, toRadians } from '../../util/mathUtils';\nimport Client from '../../Client';\nimport { isMouseEvent, isShiftDown } from '../../util/EventUtils';\n/**\n * Event handler for resizing cells. This handler is automatically created in\n * {@link Graph#createHandler}.\n *\n * Constructor: mxVertexHandler\n *\n * Constructs an event handler that allows to resize vertices\n * and groups.\n *\n * @param state <CellState> of the cell to be resized.\n */\nclass VertexHandler {\n    constructor(state) {\n        this.sizers = [];\n        /**\n         * Specifies if only one sizer handle at the bottom, right corner should be\n         * used. Default is false.\n         */\n        this.singleSizer = false;\n        /**\n         * Holds the index of the current handle.\n         */\n        this.index = null;\n        /**\n         * Specifies if the bounds of handles should be used for hit-detection in IE or\n         * if <tolerance> > 0. Default is true.\n         */\n        this.allowHandleBoundsCheck = true;\n        /**\n         * Optional {@link Image} to be used as handles. Default is null.\n         */\n        this.handleImage = null;\n        /**\n         * If handles are currently visible.\n         */\n        this.handlesVisible = true;\n        /**\n         * Optional tolerance for hit-detection in <getHandleForEvent>. Default is 0.\n         */\n        this.tolerance = 0;\n        /**\n         * Specifies if a rotation handle should be visible. Default is false.\n         */\n        this.rotationEnabled = false;\n        /**\n         * Specifies if the parent should be highlighted if a child cell is selected.\n         * Default is false.\n         */\n        this.parentHighlightEnabled = false;\n        /**\n         * Specifies if rotation steps should be \"rasterized\" depening on the distance\n         * to the handle. Default is true.\n         */\n        this.rotationRaster = true;\n        /**\n         * Specifies the cursor for the rotation handle. Default is 'crosshair'.\n         */\n        this.rotationCursor = 'crosshair';\n        /**\n         * Specifies if resize should change the cell in-place. This is an experimental\n         * feature for non-touch devices. Default is false.\n         */\n        this.livePreview = false;\n        /**\n         * Specifies if the live preview should be moved to the front.\n         */\n        this.movePreviewToFront = false;\n        /**\n         * Specifies if sizers should be hidden and spaced if the vertex is small.\n         * Default is false.\n         */\n        this.manageSizers = false;\n        /**\n         * Specifies if the size of groups should be constrained by the children.\n         * Default is false.\n         */\n        this.constrainGroupByChildren = false;\n        /**\n         * Vertical spacing for rotation icon. Default is -16.\n         */\n        this.rotationHandleVSpacing = -16;\n        /**\n         * The horizontal offset for the handles. This is updated in <redrawHandles>\n         * if {@link anageSizers} is true and the sizers are offset horizontally.\n         */\n        this.horizontalOffset = 0;\n        /**\n         * The horizontal offset for the handles. This is updated in <redrawHandles>\n         * if {@link anageSizers} is true and the sizers are offset vertically.\n         */\n        this.verticalOffset = 0;\n        this.minBounds = null;\n        this.x0 = 0;\n        this.y0 = 0;\n        this.customHandles = [];\n        this.inTolerance = false;\n        this.startX = 0;\n        this.startY = 0;\n        this.rotationShape = null;\n        this.currentAlpha = 100;\n        this.startAngle = 0;\n        this.startDist = 0;\n        this.ghostPreview = null;\n        this.livePreviewActive = false;\n        this.childOffsetX = 0;\n        this.childOffsetY = 0;\n        this.parentState = null;\n        this.parentHighlight = null;\n        this.unscaledBounds = null;\n        this.preview = null;\n        this.labelShape = null;\n        this.edgeHandlers = [];\n        this.EMPTY_POINT = new Point();\n        this.state = state;\n        this.graph = this.state.view.graph;\n        this.selectionBounds = this.getSelectionBounds(this.state);\n        this.bounds = new Rectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);\n        this.selectionBorder = this.createSelectionShape(this.bounds);\n        // VML dialect required here for event transparency in IE\n        this.selectionBorder.dialect = DIALECT.SVG;\n        this.selectionBorder.pointerEvents = false;\n        this.selectionBorder.rotation = this.state.style.rotation ?? 0;\n        this.selectionBorder.init(this.graph.getView().getOverlayPane());\n        InternalEvent.redirectMouseEvents(this.selectionBorder.node, this.graph, this.state);\n        if (this.graph.isCellMovable(this.state.cell)) {\n            this.selectionBorder.setCursor(CURSOR.MOVABLE_VERTEX);\n        }\n        const selectionHandler = this.graph.getPlugin('SelectionHandler');\n        // Adds the sizer handles\n        if (selectionHandler &&\n            (selectionHandler.maxCells <= 0 ||\n                this.graph.getSelectionCount() < selectionHandler.maxCells)) {\n            const resizable = this.graph.isCellResizable(this.state.cell);\n            this.sizers = [];\n            if (resizable ||\n                (this.graph.isLabelMovable(this.state.cell) &&\n                    this.state.width >= 2 &&\n                    this.state.height >= 2)) {\n                let i = 0;\n                if (resizable) {\n                    if (!this.singleSizer) {\n                        this.sizers.push(this.createSizer('nw-resize', i++));\n                        this.sizers.push(this.createSizer('n-resize', i++));\n                        this.sizers.push(this.createSizer('ne-resize', i++));\n                        this.sizers.push(this.createSizer('w-resize', i++));\n                        this.sizers.push(this.createSizer('e-resize', i++));\n                        this.sizers.push(this.createSizer('sw-resize', i++));\n                        this.sizers.push(this.createSizer('s-resize', i++));\n                    }\n                    this.sizers.push(this.createSizer('se-resize', i++));\n                }\n                const geo = this.state.cell.getGeometry();\n                if (geo != null &&\n                    !geo.relative &&\n                    //!this.graph.isSwimlane(this.state.cell) &&      disable for now\n                    this.graph.isLabelMovable(this.state.cell)) {\n                    // Marks this as the label handle for getHandleForEvent\n                    this.labelShape = this.createSizer(CURSOR.LABEL_HANDLE, InternalEvent.LABEL_HANDLE, LABEL_HANDLE_SIZE, LABEL_HANDLE_FILLCOLOR);\n                    this.sizers.push(this.labelShape);\n                }\n            }\n            else if (this.graph.isCellMovable(this.state.cell) &&\n                !this.graph.isCellResizable(this.state.cell) &&\n                this.state.width < 2 &&\n                this.state.height < 2) {\n                this.labelShape = this.createSizer(CURSOR.MOVABLE_VERTEX, InternalEvent.LABEL_HANDLE, undefined, LABEL_HANDLE_FILLCOLOR);\n                this.sizers.push(this.labelShape);\n            }\n        }\n        // Adds the rotation handler\n        if (this.isRotationHandleVisible()) {\n            this.rotationShape = this.createSizer(this.rotationCursor, InternalEvent.ROTATION_HANDLE, HANDLE_SIZE + 3, HANDLE_FILLCOLOR);\n            this.sizers.push(this.rotationShape);\n        }\n        this.customHandles = this.createCustomHandles();\n        this.redraw();\n        if (this.constrainGroupByChildren) {\n            this.updateMinBounds();\n        }\n        // Handles escape keystrokes\n        this.escapeHandler = (sender, evt) => {\n            if (this.livePreview && this.index != null) {\n                // Redraws the live preview\n                this.state.view.graph.cellRenderer.redraw(this.state, true);\n                // Redraws connected edges\n                this.state.view.invalidate(this.state.cell);\n                this.state.invalid = false;\n                this.state.view.validate();\n            }\n            this.reset();\n        };\n        this.state.view.graph.addListener(InternalEvent.ESCAPE, this.escapeHandler);\n    }\n    /**\n     * Returns true if the rotation handle should be showing.\n     */\n    isRotationHandleVisible() {\n        const selectionHandler = this.graph.getPlugin('SelectionHandler');\n        const selectionHandlerCheck = selectionHandler\n            ? selectionHandler.maxCells <= 0 ||\n                this.graph.getSelectionCount() < selectionHandler.maxCells\n            : true;\n        return (this.graph.isEnabled() &&\n            this.rotationEnabled &&\n            this.graph.isCellRotatable(this.state.cell) &&\n            selectionHandlerCheck);\n    }\n    /**\n     * Returns true if the aspect ratio if the cell should be maintained.\n     */\n    isConstrainedEvent(me) {\n        return isShiftDown(me.getEvent()) || this.state.style.aspect === 'fixed';\n    }\n    /**\n     * Returns true if the center of the vertex should be maintained during the resize.\n     */\n    isCenteredEvent(state, me) {\n        return false;\n    }\n    /**\n     * Returns an array of custom handles. This implementation returns null.\n     */\n    createCustomHandles() {\n        return [];\n    }\n    /**\n     * Initializes the shapes required for this vertex handler.\n     */\n    updateMinBounds() {\n        const children = this.graph.getChildCells(this.state.cell);\n        if (children.length > 0) {\n            this.minBounds = this.graph.view.getBounds(children);\n            if (this.minBounds) {\n                const s = this.state.view.scale;\n                const t = this.state.view.translate;\n                this.minBounds.x -= this.state.x;\n                this.minBounds.y -= this.state.y;\n                this.minBounds.x /= s;\n                this.minBounds.y /= s;\n                this.minBounds.width /= s;\n                this.minBounds.height /= s;\n                this.x0 = this.state.x / s - t.x;\n                this.y0 = this.state.y / s - t.y;\n            }\n        }\n    }\n    /**\n     * Returns the mxRectangle that defines the bounds of the selection\n     * border.\n     */\n    getSelectionBounds(state) {\n        return new Rectangle(Math.round(state.x), Math.round(state.y), Math.round(state.width), Math.round(state.height));\n    }\n    /**\n     * Creates the shape used to draw the selection border.\n     */\n    createParentHighlightShape(bounds) {\n        return this.createSelectionShape(bounds);\n    }\n    /**\n     * Creates the shape used to draw the selection border.\n     */\n    createSelectionShape(bounds) {\n        const shape = new RectangleShape(Rectangle.fromRectangle(bounds), NONE, this.getSelectionColor());\n        shape.strokeWidth = this.getSelectionStrokeWidth();\n        shape.isDashed = this.isSelectionDashed();\n        return shape;\n    }\n    /**\n     * Returns {@link Constants#VERTEX_SELECTION_COLOR}.\n     */\n    getSelectionColor() {\n        return VERTEX_SELECTION_COLOR;\n    }\n    /**\n     * Returns {@link Constants#VERTEX_SELECTION_STROKEWIDTH}.\n     */\n    getSelectionStrokeWidth() {\n        return VERTEX_SELECTION_STROKEWIDTH;\n    }\n    /**\n     * Returns {@link Constants#VERTEX_SELECTION_DASHED}.\n     */\n    isSelectionDashed() {\n        return VERTEX_SELECTION_DASHED;\n    }\n    /**\n     * Creates a sizer handle for the specified cursor and index and returns\n     * the new {@link RectangleShape} that represents the handle.\n     */\n    createSizer(cursor, index, size = HANDLE_SIZE, fillColor = HANDLE_FILLCOLOR) {\n        const bounds = new Rectangle(0, 0, size, size);\n        const sizer = this.createSizerShape(bounds, index, fillColor);\n        if (sizer.bounds &&\n            sizer.isHtmlAllowed() &&\n            this.state.text &&\n            this.state.text.node.parentNode === this.graph.container) {\n            sizer.bounds.height -= 1;\n            sizer.bounds.width -= 1;\n            sizer.dialect = DIALECT.STRICTHTML;\n            sizer.init(this.graph.container);\n        }\n        else {\n            sizer.dialect =\n                this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;\n            sizer.init(this.graph.getView().getOverlayPane());\n        }\n        InternalEvent.redirectMouseEvents(sizer.node, this.graph, this.state);\n        if (this.graph.isEnabled()) {\n            sizer.setCursor(cursor);\n        }\n        if (!this.isSizerVisible(index)) {\n            sizer.visible = false;\n        }\n        return sizer;\n    }\n    /**\n     * Returns true if the sizer for the given index is visible.\n     * This returns true for all given indices.\n     */\n    isSizerVisible(index) {\n        return true;\n    }\n    /**\n     * Creates the shape used for the sizer handle for the specified bounds an\n     * index. Only images and rectangles should be returned if support for HTML\n     * labels with not foreign objects is required.\n     */\n    createSizerShape(bounds, index, fillColor = HANDLE_FILLCOLOR) {\n        if (this.handleImage) {\n            bounds = new Rectangle(bounds.x, bounds.y, this.handleImage.width, this.handleImage.height);\n            const shape = new ImageShape(bounds, this.handleImage.src);\n            // Allows HTML rendering of the images\n            shape.preserveImageAspect = false;\n            return shape;\n        }\n        if (index === InternalEvent.ROTATION_HANDLE) {\n            return new EllipseShape(bounds, fillColor, HANDLE_STROKECOLOR);\n        }\n        return new RectangleShape(bounds, fillColor, HANDLE_STROKECOLOR);\n    }\n    /**\n     * Helper method to create an {@link Rectangle} around the given centerpoint\n     * with a width and height of 2*s or 6, if no s is given.\n     */\n    moveSizerTo(shape, x, y) {\n        if (shape && shape.bounds) {\n            shape.bounds.x = Math.floor(x - shape.bounds.width / 2);\n            shape.bounds.y = Math.floor(y - shape.bounds.height / 2);\n            // Fixes visible inactive handles in VML\n            if (shape.node && shape.node.style.display !== 'none') {\n                shape.redraw();\n            }\n        }\n    }\n    /**\n     * Returns the index of the handle for the given event. This returns the index\n     * of the sizer from where the event originated or {@link Event#LABEL_INDEX}.\n     */\n    getHandleForEvent(me) {\n        // Connection highlight may consume events before they reach sizer handle\n        const tol = !isMouseEvent(me.getEvent()) ? this.tolerance : 1;\n        const hit = this.allowHandleBoundsCheck && tol > 0\n            ? new Rectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol)\n            : null;\n        const checkShape = (shape) => {\n            const st = shape && shape.constructor !== ImageShape && this.allowHandleBoundsCheck\n                ? shape.strokeWidth + shape.svgStrokeTolerance\n                : null;\n            const real = st\n                ? new Rectangle(me.getGraphX() - Math.floor(st / 2), me.getGraphY() - Math.floor(st / 2), st, st)\n                : hit;\n            return (shape &&\n                shape.bounds &&\n                (me.isSource(shape) ||\n                    (real &&\n                        intersects(shape.bounds, real) &&\n                        shape.node.style.display !== 'none' &&\n                        shape.node.style.visibility !== 'hidden')));\n        };\n        if (checkShape(this.rotationShape)) {\n            return InternalEvent.ROTATION_HANDLE;\n        }\n        if (checkShape(this.labelShape)) {\n            return InternalEvent.LABEL_HANDLE;\n        }\n        for (let i = 0; i < this.sizers.length; i += 1) {\n            if (checkShape(this.sizers[i])) {\n                return i;\n            }\n        }\n        if (this.customHandles != null && this.isCustomHandleEvent(me)) {\n            // Inverse loop order to match display order\n            for (let i = this.customHandles.length - 1; i >= 0; i--) {\n                if (checkShape(this.customHandles[i].shape)) {\n                    // LATER: Return reference to active shape\n                    return InternalEvent.CUSTOM_HANDLE - i;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Returns true if the given event allows custom handles to be changed. This\n     * implementation returns true.\n     */\n    isCustomHandleEvent(me) {\n        return true;\n    }\n    /**\n     * Handles the event if a handle has been clicked. By consuming the\n     * event all subsequent events of the gesture are redirected to this\n     * handler.\n     */\n    mouseDown(sender, me) {\n        if (!me.isConsumed() && this.graph.isEnabled()) {\n            const handle = this.getHandleForEvent(me);\n            if (handle) {\n                this.start(me.getGraphX(), me.getGraphY(), handle);\n                me.consume();\n            }\n        }\n    }\n    /**\n     * Called if <livePreview> is enabled to check if a border should be painted.\n     * This implementation returns true if the shape is transparent.\n     */\n    isLivePreviewBorder() {\n        return (this.state.shape &&\n            this.state.shape.fill === NONE &&\n            this.state.shape.stroke === NONE);\n    }\n    /**\n     * Starts the handling of the mouse gesture.\n     */\n    start(x, y, index) {\n        this.livePreviewActive = this.livePreview && this.state.cell.getChildCount() === 0;\n        this.inTolerance = true;\n        this.childOffsetX = 0;\n        this.childOffsetY = 0;\n        this.index = index;\n        this.startX = x;\n        this.startY = y;\n        if (this.index <= InternalEvent.CUSTOM_HANDLE && this.isGhostPreview()) {\n            this.ghostPreview = this.createGhostPreview();\n        }\n        else {\n            // Saves reference to parent state\n            const { model } = this.state.view.graph;\n            const parent = this.state.cell.getParent();\n            if (this.state.view.currentRoot !== parent &&\n                parent &&\n                (parent.isVertex() || parent.isEdge())) {\n                this.parentState = this.state.view.graph.view.getState(parent);\n            }\n            // Creates a preview that can be on top of any HTML label\n            this.selectionBorder.node.style.display =\n                index === InternalEvent.ROTATION_HANDLE ? 'inline' : 'none';\n            // Creates the border that represents the new bounds\n            if (!this.livePreviewActive || this.isLivePreviewBorder()) {\n                this.preview = this.createSelectionShape(this.bounds);\n                if (!(Client.IS_SVG && Number(this.state.style.rotation || '0') !== 0) &&\n                    this.state.text != null &&\n                    this.state.text.node.parentNode === this.graph.container) {\n                    this.preview.dialect = DIALECT.STRICTHTML;\n                    this.preview.init(this.graph.container);\n                }\n                else {\n                    this.preview.dialect = DIALECT.SVG;\n                    this.preview.init(this.graph.view.getOverlayPane());\n                }\n            }\n            if (index === InternalEvent.ROTATION_HANDLE) {\n                // With the rotation handle in a corner, need the angle and distance\n                const pos = this.getRotationHandlePosition();\n                const dx = pos.x - this.state.getCenterX();\n                const dy = pos.y - this.state.getCenterY();\n                this.startAngle = dx !== 0 ? (Math.atan(dy / dx) * 180) / Math.PI + 90 : 0;\n                this.startDist = Math.sqrt(dx * dx + dy * dy);\n            }\n            // Prepares the handles for live preview\n            if (this.livePreviewActive) {\n                this.hideSizers();\n                if (index === InternalEvent.ROTATION_HANDLE && this.rotationShape) {\n                    this.rotationShape.node.style.display = '';\n                }\n                else if (index === InternalEvent.LABEL_HANDLE && this.labelShape) {\n                    this.labelShape.node.style.display = '';\n                }\n                else if (this.sizers[index]) {\n                    this.sizers[index].node.style.display = '';\n                }\n                else if (index <= InternalEvent.CUSTOM_HANDLE) {\n                    this.customHandles[InternalEvent.CUSTOM_HANDLE - index].setVisible(true);\n                }\n                // Gets the array of connected edge handlers for redrawing\n                const edges = this.state.cell.getEdges();\n                this.edgeHandlers = [];\n                const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n                for (let i = 0; i < edges.length; i += 1) {\n                    const handler = selectionCellsHandler?.getHandler(edges[i]);\n                    if (handler) {\n                        this.edgeHandlers.push(handler);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Starts the handling of the mouse gesture.\n     */\n    createGhostPreview() {\n        const shape = this.graph.cellRenderer.createShape(this.state);\n        shape.init(this.graph.view.getOverlayPane());\n        shape.scale = this.state.view.scale;\n        shape.bounds = this.bounds;\n        shape.outline = true;\n        return shape;\n    }\n    /**\n     * Shortcut to <hideSizers>.\n     */\n    setHandlesVisible(visible) {\n        this.handlesVisible = visible;\n        for (let i = 0; i < this.sizers.length; i += 1) {\n            this.sizers[i].node.style.display = visible ? '' : 'none';\n        }\n        for (let i = 0; i < this.customHandles.length; i += 1) {\n            this.customHandles[i].setVisible(visible);\n        }\n    }\n    /**\n     * Hides all sizers except.\n     *\n     * Starts the handling of the mouse gesture.\n     */\n    hideSizers() {\n        this.setHandlesVisible(false);\n    }\n    /**\n     * Checks if the coordinates for the given event are within the\n     * {@link Graph#tolerance}. If the event is a mouse event then the tolerance is\n     * ignored.\n     */\n    checkTolerance(me) {\n        if (this.inTolerance && this.startX !== null && this.startY !== null) {\n            if (isMouseEvent(me.getEvent()) ||\n                Math.abs(me.getGraphX() - this.startX) > this.graph.getEventTolerance() ||\n                Math.abs(me.getGraphY() - this.startY) > this.graph.getEventTolerance()) {\n                this.inTolerance = false;\n            }\n        }\n    }\n    /**\n     * Hook for subclassers do show details while the handler is active.\n     */\n    updateHint(me) {\n        return;\n    }\n    /**\n     * Hooks for subclassers to hide details when the handler gets inactive.\n     */\n    removeHint() {\n        return;\n    }\n    /**\n     * Hook for rounding the angle. This uses Math.round.\n     */\n    roundAngle(angle) {\n        return Math.round(angle * 10) / 10;\n    }\n    /**\n     * Hook for rounding the unscaled width or height. This uses Math.round.\n     */\n    roundLength(length) {\n        return Math.round(length * 100) / 100;\n    }\n    /**\n     * Handles the event by updating the preview.\n     */\n    mouseMove(sender, me) {\n        if (!me.isConsumed() && this.index != null) {\n            // Checks tolerance for ignoring single clicks\n            this.checkTolerance(me);\n            if (!this.inTolerance) {\n                if (this.index <= InternalEvent.CUSTOM_HANDLE) {\n                    if (this.customHandles != null) {\n                        this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].processEvent(me);\n                        this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].active = true;\n                        if (this.ghostPreview != null) {\n                            this.ghostPreview.apply(this.state);\n                            this.ghostPreview.strokeWidth =\n                                this.getSelectionStrokeWidth() /\n                                    this.ghostPreview.scale /\n                                    this.ghostPreview.scale;\n                            this.ghostPreview.isDashed = this.isSelectionDashed();\n                            this.ghostPreview.stroke = this.getSelectionColor();\n                            this.ghostPreview.redraw();\n                            if (this.selectionBounds != null) {\n                                this.selectionBorder.node.style.display = 'none';\n                            }\n                        }\n                        else {\n                            if (this.movePreviewToFront) {\n                                this.moveToFront();\n                            }\n                            this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].positionChanged();\n                        }\n                    }\n                }\n                else if (this.index === InternalEvent.LABEL_HANDLE) {\n                    this.moveLabel(me);\n                }\n                else {\n                    if (this.index === InternalEvent.ROTATION_HANDLE) {\n                        this.rotateVertex(me);\n                    }\n                    else {\n                        this.resizeVertex(me);\n                    }\n                    this.updateHint(me);\n                }\n            }\n            me.consume();\n        }\n        // Workaround for disabling the connect highlight when over handle\n        else if (!this.graph.isMouseDown && this.getHandleForEvent(me)) {\n            me.consume(false);\n        }\n    }\n    /**\n     * Returns true if a ghost preview should be used for custom handles.\n     */\n    isGhostPreview() {\n        return this.state.cell.getChildCount() > 0;\n    }\n    /**\n     * Moves the vertex.\n     */\n    moveLabel(me) {\n        const point = new Point(me.getGraphX(), me.getGraphY());\n        const tr = this.graph.view.translate;\n        const { scale } = this.graph.view;\n        if (this.graph.isGridEnabledEvent(me.getEvent())) {\n            point.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;\n            point.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;\n        }\n        const index = this.rotationShape ? this.sizers.length - 2 : this.sizers.length - 1;\n        this.moveSizerTo(this.sizers[index], point.x, point.y);\n    }\n    /**\n     * Rotates the vertex.\n     */\n    rotateVertex(me) {\n        const point = new Point(me.getGraphX(), me.getGraphY());\n        let dx = this.state.x + this.state.width / 2 - point.x;\n        let dy = this.state.y + this.state.height / 2 - point.y;\n        this.currentAlpha =\n            dx !== 0 ? (Math.atan(dy / dx) * 180) / Math.PI + 90 : dy < 0 ? 180 : 0;\n        if (dx > 0) {\n            this.currentAlpha -= 180;\n        }\n        this.currentAlpha -= this.startAngle;\n        // Rotation raster\n        if (this.rotationRaster && this.graph.isGridEnabledEvent(me.getEvent())) {\n            let raster;\n            dx = point.x - this.state.getCenterX();\n            dy = point.y - this.state.getCenterY();\n            const dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist - this.startDist < 2) {\n                raster = 15;\n            }\n            else if (dist - this.startDist < 25) {\n                raster = 5;\n            }\n            else {\n                raster = 1;\n            }\n            this.currentAlpha = Math.round(this.currentAlpha / raster) * raster;\n        }\n        else {\n            this.currentAlpha = this.roundAngle(this.currentAlpha);\n        }\n        this.selectionBorder.rotation = this.currentAlpha;\n        this.selectionBorder.redraw();\n        if (this.livePreviewActive) {\n            this.redrawHandles();\n        }\n    }\n    /**\n     * Resizes the vertex.\n     */\n    resizeVertex(me) {\n        const ct = new Point(this.state.getCenterX(), this.state.getCenterY());\n        const alpha = toRadians(this.state.style.rotation ?? 0);\n        const point = new Point(me.getGraphX(), me.getGraphY());\n        const tr = this.graph.view.translate;\n        const { scale } = this.graph.view;\n        let cos = Math.cos(-alpha);\n        let sin = Math.sin(-alpha);\n        let dx = point.x - this.startX;\n        let dy = point.y - this.startY;\n        // Rotates vector for mouse gesture\n        const tx = cos * dx - sin * dy;\n        const ty = sin * dx + cos * dy;\n        dx = tx;\n        dy = ty;\n        const geo = this.state.cell.getGeometry();\n        if (geo && this.index !== null) {\n            this.unscaledBounds = this.union(geo, dx / scale, dy / scale, this.index, this.graph.isGridEnabledEvent(me.getEvent()), 1, new Point(0, 0), this.isConstrainedEvent(me), this.isCenteredEvent(this.state, me));\n        }\n        // Keeps vertex within maximum graph or parent bounds\n        if (geo && !geo.relative) {\n            let max = this.graph.getMaximumGraphBounds();\n            // Handles child cells\n            if (max != null && this.parentState != null) {\n                max = Rectangle.fromRectangle(max);\n                max.x -= (this.parentState.x - tr.x * scale) / scale;\n                max.y -= (this.parentState.y - tr.y * scale) / scale;\n            }\n            if (this.graph.isConstrainChild(this.state.cell)) {\n                let tmp = this.graph.getCellContainmentArea(this.state.cell);\n                if (tmp != null) {\n                    const overlap = this.graph.getOverlap(this.state.cell);\n                    if (overlap > 0) {\n                        tmp = Rectangle.fromRectangle(tmp);\n                        tmp.x -= tmp.width * overlap;\n                        tmp.y -= tmp.height * overlap;\n                        tmp.width += 2 * tmp.width * overlap;\n                        tmp.height += 2 * tmp.height * overlap;\n                    }\n                    if (!max) {\n                        max = tmp;\n                    }\n                    else {\n                        max = Rectangle.fromRectangle(max);\n                        max.intersect(tmp);\n                    }\n                }\n            }\n            if (max && this.unscaledBounds) {\n                if (this.unscaledBounds.x < max.x) {\n                    this.unscaledBounds.width -= max.x - this.unscaledBounds.x;\n                    this.unscaledBounds.x = max.x;\n                }\n                if (this.unscaledBounds.y < max.y) {\n                    this.unscaledBounds.height -= max.y - this.unscaledBounds.y;\n                    this.unscaledBounds.y = max.y;\n                }\n                if (this.unscaledBounds.x + this.unscaledBounds.width > max.x + max.width) {\n                    this.unscaledBounds.width -=\n                        this.unscaledBounds.x + this.unscaledBounds.width - max.x - max.width;\n                }\n                if (this.unscaledBounds.y + this.unscaledBounds.height > max.y + max.height) {\n                    this.unscaledBounds.height -=\n                        this.unscaledBounds.y + this.unscaledBounds.height - max.y - max.height;\n                }\n            }\n        }\n        if (this.unscaledBounds) {\n            const old = this.bounds;\n            this.bounds = new Rectangle((this.parentState ? this.parentState.x : tr.x * scale) +\n                this.unscaledBounds.x * scale, (this.parentState ? this.parentState.y : tr.y * scale) +\n                this.unscaledBounds.y * scale, this.unscaledBounds.width * scale, this.unscaledBounds.height * scale);\n            if (geo && geo.relative && this.parentState) {\n                this.bounds.x += this.state.x - this.parentState.x;\n                this.bounds.y += this.state.y - this.parentState.y;\n            }\n            cos = Math.cos(alpha);\n            sin = Math.sin(alpha);\n            const c2 = new Point(this.bounds.getCenterX(), this.bounds.getCenterY());\n            dx = c2.x - ct.x;\n            dy = c2.y - ct.y;\n            const dx2 = cos * dx - sin * dy;\n            const dy2 = sin * dx + cos * dy;\n            const dx3 = dx2 - dx;\n            const dy3 = dy2 - dy;\n            const dx4 = this.bounds.x - this.state.x;\n            const dy4 = this.bounds.y - this.state.y;\n            const dx5 = cos * dx4 - sin * dy4;\n            const dy5 = sin * dx4 + cos * dy4;\n            this.bounds.x += dx3;\n            this.bounds.y += dy3;\n            // Rounds unscaled bounds to int\n            this.unscaledBounds.x = this.roundLength(this.unscaledBounds.x + dx3 / scale);\n            this.unscaledBounds.y = this.roundLength(this.unscaledBounds.y + dy3 / scale);\n            this.unscaledBounds.width = this.roundLength(this.unscaledBounds.width);\n            this.unscaledBounds.height = this.roundLength(this.unscaledBounds.height);\n            // Shifts the children according to parent offset\n            if (!this.state.cell.isCollapsed() && (dx3 !== 0 || dy3 !== 0)) {\n                this.childOffsetX = this.state.x - this.bounds.x + dx5;\n                this.childOffsetY = this.state.y - this.bounds.y + dy5;\n            }\n            else {\n                this.childOffsetX = 0;\n                this.childOffsetY = 0;\n            }\n            if (!old.equals(this.bounds)) {\n                if (this.livePreviewActive) {\n                    this.updateLivePreview(me);\n                }\n                if (this.preview != null) {\n                    this.drawPreview();\n                }\n                else {\n                    this.updateParentHighlight();\n                }\n            }\n        }\n    }\n    /**\n     * Repaints the live preview.\n     */\n    updateLivePreview(me) {\n        // TODO: Apply child offset to children in live preview\n        const { scale } = this.graph.view;\n        const tr = this.graph.view.translate;\n        // Saves current state\n        const tempState = this.state.clone();\n        // Temporarily changes size and origin\n        this.state.x = this.bounds.x;\n        this.state.y = this.bounds.y;\n        this.state.origin = new Point(this.state.x / scale - tr.x, this.state.y / scale - tr.y);\n        this.state.width = this.bounds.width;\n        this.state.height = this.bounds.height;\n        // Redraws cell and handles\n        let off = this.state.absoluteOffset;\n        off = new Point(off.x, off.y);\n        // Required to store and reset absolute offset for updating label position\n        this.state.absoluteOffset.x = 0;\n        this.state.absoluteOffset.y = 0;\n        const geo = this.state.cell.getGeometry();\n        if (geo != null) {\n            const offset = geo.offset || this.EMPTY_POINT;\n            if (offset != null && !geo.relative) {\n                this.state.absoluteOffset.x = this.state.view.scale * offset.x;\n                this.state.absoluteOffset.y = this.state.view.scale * offset.y;\n            }\n            this.state.view.updateVertexLabelOffset(this.state);\n        }\n        // Draws the live preview\n        this.state.view.graph.cellRenderer.redraw(this.state, true);\n        // Redraws connected edges TODO: Include child edges\n        this.state.view.invalidate(this.state.cell);\n        this.state.invalid = false;\n        this.state.view.validate();\n        this.redrawHandles();\n        // Moves live preview to front\n        if (this.movePreviewToFront) {\n            this.moveToFront();\n        }\n        // Hides folding icon\n        if (this.state.control != null && this.state.control.node != null) {\n            this.state.control.node.style.visibility = 'hidden';\n        }\n        // Restores current state\n        this.state.setState(tempState);\n    }\n    /**\n     * Handles the event by applying the changes to the geometry.\n     */\n    moveToFront() {\n        if ((this.state.text && this.state.text.node && this.state.text.node.nextSibling) ||\n            (this.state.shape &&\n                this.state.shape.node &&\n                this.state.shape.node.nextSibling &&\n                (!this.state.text || this.state.shape.node.nextSibling !== this.state.text.node))) {\n            if (this.state.shape && this.state.shape.node && this.state.shape.node.parentNode) {\n                this.state.shape.node.parentNode.appendChild(this.state.shape.node);\n            }\n            if (this.state.text && this.state.text.node && this.state.text.node.parentNode) {\n                this.state.text.node.parentNode.appendChild(this.state.text.node);\n            }\n        }\n    }\n    /**\n     * Handles the event by applying the changes to the geometry.\n     */\n    mouseUp(sender, me) {\n        if (this.index != null && this.state != null) {\n            const point = new Point(me.getGraphX(), me.getGraphY());\n            const { index } = this;\n            this.index = null;\n            if (this.ghostPreview == null) {\n                // Required to restore order in case of no change\n                this.state.view.invalidate(this.state.cell, false, false);\n                this.state.view.validate();\n            }\n            this.graph.batchUpdate(() => {\n                if (index <= InternalEvent.CUSTOM_HANDLE) {\n                    if (this.customHandles != null) {\n                        // Creates style before changing cell state\n                        const style = this.state.view.graph.getCellStyle(this.state.cell);\n                        this.customHandles[InternalEvent.CUSTOM_HANDLE - index].active = false;\n                        this.customHandles[InternalEvent.CUSTOM_HANDLE - index].execute(me);\n                        // Sets style and apply on shape to force repaint and\n                        // check if execute has removed custom handles\n                        if (this.customHandles != null &&\n                            this.customHandles[InternalEvent.CUSTOM_HANDLE - index] != null) {\n                            this.state.style = style;\n                            this.customHandles[InternalEvent.CUSTOM_HANDLE - index].positionChanged();\n                        }\n                    }\n                }\n                else if (index === InternalEvent.ROTATION_HANDLE) {\n                    if (this.currentAlpha != null) {\n                        const delta = this.currentAlpha - (this.state.style.rotation ?? 0);\n                        if (delta !== 0) {\n                            this.rotateCell(this.state.cell, delta);\n                        }\n                    }\n                    else {\n                        this.rotateClick();\n                    }\n                }\n                else {\n                    const gridEnabled = this.graph.isGridEnabledEvent(me.getEvent());\n                    const alpha = toRadians(this.state.style.rotation ?? 0);\n                    const cos = Math.cos(-alpha);\n                    const sin = Math.sin(-alpha);\n                    let dx = point.x - this.startX;\n                    let dy = point.y - this.startY;\n                    // Rotates vector for mouse gesture\n                    const tx = cos * dx - sin * dy;\n                    const ty = sin * dx + cos * dy;\n                    dx = tx;\n                    dy = ty;\n                    const s = this.graph.view.scale;\n                    const recurse = this.isRecursiveResize(this.state, me);\n                    this.resizeCell(this.state.cell, this.roundLength(dx / s), this.roundLength(dy / s), index, gridEnabled, this.isConstrainedEvent(me), recurse);\n                }\n            });\n            me.consume();\n            this.reset();\n            this.redrawHandles();\n        }\n    }\n    /**\n     * Returns the `recursiveResize` status of the given state.\n     * @param state the given {@link CellState}. This implementation takes the value of this state.\n     * @param me the mouse event.\n     */\n    isRecursiveResize(state, me) {\n        return this.graph.isRecursiveResize(this.state);\n    }\n    /**\n     * Hook for subclassers to implement a single click on the rotation handle.\n     * This code is executed as part of the model transaction. This implementation\n     * is empty.\n     */\n    rotateClick() {\n        return;\n    }\n    /**\n     * Rotates the given cell and its children by the given angle in degrees.\n     *\n     * @param cell <Cell> to be rotated.\n     * @param angle Angle in degrees.\n     */\n    rotateCell(cell, angle, parent) {\n        if (angle !== 0) {\n            const model = this.graph.getDataModel();\n            if (cell.isVertex() || cell.isEdge()) {\n                if (!cell.isEdge()) {\n                    const style = this.graph.getCurrentCellStyle(cell);\n                    const total = (style.rotation || 0) + angle;\n                    this.graph.setCellStyles('rotation', total, [cell]);\n                }\n                let geo = cell.getGeometry();\n                if (geo && parent) {\n                    const pgeo = parent.getGeometry();\n                    if (pgeo != null && !parent.isEdge()) {\n                        geo = geo.clone();\n                        geo.rotate(angle, new Point(pgeo.width / 2, pgeo.height / 2));\n                        model.setGeometry(cell, geo);\n                    }\n                    if ((cell.isVertex() && !geo.relative) || cell.isEdge()) {\n                        // Recursive rotation\n                        const childCount = cell.getChildCount();\n                        for (let i = 0; i < childCount; i += 1) {\n                            this.rotateCell(cell.getChildAt(i), angle, cell);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Resets the state of this handler.\n     */\n    reset() {\n        if (this.index !== null && this.sizers[this.index].node.style.display === 'none') {\n            this.sizers[this.index].node.style.display = '';\n        }\n        this.index = null;\n        // TODO: Reset and redraw cell states for live preview\n        if (this.preview) {\n            this.preview.destroy();\n            this.preview = null;\n        }\n        if (this.ghostPreview) {\n            this.ghostPreview.destroy();\n            this.ghostPreview = null;\n        }\n        if (this.livePreviewActive) {\n            for (let i = 0; i < this.sizers.length; i += 1) {\n                this.sizers[i].node.style.display = '';\n            }\n            // Shows folding icon\n            if (this.state.control && this.state.control.node) {\n                this.state.control.node.style.visibility = '';\n            }\n        }\n        for (let i = 0; i < this.customHandles.length; i += 1) {\n            if (this.customHandles[i].active) {\n                this.customHandles[i].active = false;\n                this.customHandles[i].reset();\n            }\n            else {\n                this.customHandles[i].setVisible(true);\n            }\n        }\n        // Checks if handler has been destroyed\n        this.selectionBorder.node.style.display = 'inline';\n        this.selectionBounds = this.getSelectionBounds(this.state);\n        this.bounds = new Rectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);\n        this.drawPreview();\n        this.removeHint();\n        this.redrawHandles();\n        this.edgeHandlers = [];\n        this.handlesVisible = true;\n        this.unscaledBounds = null;\n    }\n    /**\n     * Uses the given vector to change the bounds of the given cell\n     * in the graph using {@link Graph#resizeCell}.\n     */\n    resizeCell(cell, dx, dy, index, gridEnabled, constrained, recurse) {\n        let geo = cell.getGeometry();\n        if (geo) {\n            if (index === InternalEvent.LABEL_HANDLE &&\n                this.labelShape &&\n                this.labelShape.bounds) {\n                const alpha = -toRadians(this.state.style.rotation ?? 0);\n                const cos = Math.cos(alpha);\n                const sin = Math.sin(alpha);\n                const { scale } = this.graph.view;\n                const pt = getRotatedPoint(new Point(Math.round((this.labelShape.bounds.getCenterX() - this.startX) / scale), Math.round((this.labelShape.bounds.getCenterY() - this.startY) / scale)), cos, sin);\n                geo = geo.clone();\n                if (geo.offset == null) {\n                    geo.offset = pt;\n                }\n                else {\n                    geo.offset.x += pt.x;\n                    geo.offset.y += pt.y;\n                }\n                this.graph.model.setGeometry(cell, geo);\n            }\n            else if (this.unscaledBounds) {\n                const { scale } = this.graph.view;\n                if (this.childOffsetX !== 0 || this.childOffsetY !== 0) {\n                    this.moveChildren(cell, Math.round(this.childOffsetX / scale), Math.round(this.childOffsetY / scale));\n                }\n                this.graph.resizeCell(cell, this.unscaledBounds, recurse);\n            }\n        }\n    }\n    /**\n     * Moves the children of the given cell by the given vector.\n     */\n    moveChildren(cell, dx, dy) {\n        const model = this.graph.getDataModel();\n        const childCount = cell.getChildCount();\n        for (let i = 0; i < childCount; i += 1) {\n            const child = cell.getChildAt(i);\n            let geo = child.getGeometry();\n            if (geo != null) {\n                geo = geo.clone();\n                geo.translate(dx, dy);\n                model.setGeometry(child, geo);\n            }\n        }\n    }\n    /**\n     * Returns the union of the given bounds and location for the specified\n     * handle index.\n     *\n     * To override this to limit the size of vertex via a minWidth/-Height style,\n     * the following code can be used.\n     *\n     * ```javascript\n     * let vertexHandlerUnion = union;\n     * union = (bounds, dx, dy, index, gridEnabled, scale, tr, constrained)=>\n     * {\n     *   let result = vertexHandlerUnion.apply(this, arguments);\n     *\n     *   result.width = Math.max(result.width, mxUtils.getNumber(this.state.style, 'minWidth', 0));\n     *   result.height = Math.max(result.height, mxUtils.getNumber(this.state.style, 'minHeight', 0));\n     *\n     *   return result;\n     * };\n     * ```\n     *\n     * The minWidth/-Height style can then be used as follows:\n     *\n     * ```javascript\n     * graph.insertVertex(parent, null, 'Hello,', 20, 20, 80, 30, 'minWidth=100;minHeight=100;');\n     * ```\n     *\n     * To override this to update the height for a wrapped text if the width of a vertex is\n     * changed, the following can be used.\n     *\n     * ```javascript\n     * let mxVertexHandlerUnion = union;\n     * union = (bounds, dx, dy, index, gridEnabled, scale, tr, constrained)=>\n     * {\n     *   let result = mxVertexHandlerUnion.apply(this, arguments);\n     *   let s = this.state;\n     *\n     *   if (this.graph.isHtmlLabel(s.cell) && (index == 3 || index == 4) &&\n     *       s.text != null && s.style.whiteSpace == 'wrap')\n     *   {\n     *     let label = this.graph.getLabel(s.cell);\n     *     let fontSize = mxUtils.getNumber(s.style, 'fontSize', mxConstants.DEFAULT_FONTSIZE);\n     *     let ww = result.width / s.view.scale - s.text.spacingRight - s.text.spacingLeft\n     *\n     *     result.height = mxUtils.getSizeForString(label, fontSize, s.style.fontFamily, ww).height;\n     *   }\n     *\n     *   return result;\n     * };\n     * ```\n     */\n    union(bounds, dx, dy, index, gridEnabled, scale, tr, constrained, centered) {\n        gridEnabled = gridEnabled && this.graph.isGridEnabled();\n        if (this.singleSizer) {\n            let x = bounds.x + bounds.width + dx;\n            let y = bounds.y + bounds.height + dy;\n            if (gridEnabled) {\n                x = this.graph.snap(x / scale) * scale;\n                y = this.graph.snap(y / scale) * scale;\n            }\n            const rect = new Rectangle(bounds.x, bounds.y, 0, 0);\n            rect.add(new Rectangle(x, y, 0, 0));\n            return rect;\n        }\n        const w0 = bounds.width;\n        const h0 = bounds.height;\n        let left = bounds.x - tr.x * scale;\n        let right = left + w0;\n        let top = bounds.y - tr.y * scale;\n        let bottom = top + h0;\n        const cx = left + w0 / 2;\n        const cy = top + h0 / 2;\n        if (index > 4 /* Bottom Row */) {\n            bottom += dy;\n            if (gridEnabled) {\n                bottom = this.graph.snap(bottom / scale) * scale;\n            }\n            else {\n                bottom = Math.round(bottom / scale) * scale;\n            }\n        }\n        else if (index < 3 /* Top Row */) {\n            top += dy;\n            if (gridEnabled) {\n                top = this.graph.snap(top / scale) * scale;\n            }\n            else {\n                top = Math.round(top / scale) * scale;\n            }\n        }\n        if (index === 0 || index === 3 || index === 5 /* Left */) {\n            left += dx;\n            if (gridEnabled) {\n                left = this.graph.snap(left / scale) * scale;\n            }\n            else {\n                left = Math.round(left / scale) * scale;\n            }\n        }\n        else if (index === 2 || index === 4 || index === 7 /* Right */) {\n            right += dx;\n            if (gridEnabled) {\n                right = this.graph.snap(right / scale) * scale;\n            }\n            else {\n                right = Math.round(right / scale) * scale;\n            }\n        }\n        let width = right - left;\n        let height = bottom - top;\n        if (constrained) {\n            const geo = this.state.cell.getGeometry();\n            if (geo != null) {\n                const aspect = geo.width / geo.height;\n                if (index === 1 || index === 2 || index === 7 || index === 6) {\n                    width = height * aspect;\n                }\n                else {\n                    height = width / aspect;\n                }\n                if (index === 0) {\n                    left = right - width;\n                    top = bottom - height;\n                }\n            }\n        }\n        if (centered) {\n            width += width - w0;\n            height += height - h0;\n            const cdx = cx - (left + width / 2);\n            const cdy = cy - (top + height / 2);\n            left += cdx;\n            top += cdy;\n            right += cdx;\n            bottom += cdy;\n        }\n        // Flips over left side\n        if (width < 0) {\n            left += width;\n            width = Math.abs(width);\n        }\n        // Flips over top side\n        if (height < 0) {\n            top += height;\n            height = Math.abs(height);\n        }\n        const result = new Rectangle(left + tr.x * scale, top + tr.y * scale, width, height);\n        if (this.minBounds != null) {\n            result.width = Math.max(result.width, this.minBounds.x * scale +\n                this.minBounds.width * scale +\n                Math.max(0, this.x0 * scale - result.x));\n            result.height = Math.max(result.height, this.minBounds.y * scale +\n                this.minBounds.height * scale +\n                Math.max(0, this.y0 * scale - result.y));\n        }\n        return result;\n    }\n    /**\n     * Redraws the handles and the preview.\n     */\n    redraw(ignoreHandles) {\n        this.selectionBounds = this.getSelectionBounds(this.state);\n        this.bounds = new Rectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);\n        this.drawPreview();\n        if (!ignoreHandles) {\n            this.redrawHandles();\n        }\n    }\n    /**\n     * Returns the padding to be used for drawing handles for the current <bounds>.\n     */\n    getHandlePadding() {\n        // KNOWN: Tolerance depends on event type (eg. 0 for mouse events)\n        const result = new Point(0, 0);\n        let tol = this.tolerance;\n        if (this.sizers.length > 0 &&\n            this.sizers[0].bounds &&\n            (this.bounds.width < 2 * this.sizers[0].bounds.width + 2 * tol ||\n                this.bounds.height < 2 * this.sizers[0].bounds.height + 2 * tol)) {\n            tol /= 2;\n            result.x = this.sizers[0].bounds.width + tol;\n            result.y = this.sizers[0].bounds.height + tol;\n        }\n        return result;\n    }\n    /**\n     * Returns the bounds used to paint the resize handles.\n     */\n    getSizerBounds() {\n        return this.bounds;\n    }\n    /**\n     * Redraws the handles. To hide certain handles the following code can be used.\n     *\n     * ```javascript\n     * redrawHandles()\n     * {\n     *   mxVertexHandlerRedrawHandles.apply(this, arguments);\n     *\n     *   if (this.sizers != null && this.sizers.length > 7)\n     *   {\n     *     this.sizers[1].node.style.display = 'none';\n     *     this.sizers[6].node.style.display = 'none';\n     *   }\n     * };\n     * ```\n     */\n    redrawHandles() {\n        let s = this.getSizerBounds();\n        const tol = this.tolerance;\n        this.horizontalOffset = 0;\n        this.verticalOffset = 0;\n        for (let i = 0; i < this.customHandles.length; i += 1) {\n            const shape = this.customHandles[i].shape;\n            if (shape) {\n                const temp = shape.node.style.display;\n                this.customHandles[i].redraw();\n                shape.node.style.display = temp;\n                // Hides custom handles during text editing\n                shape.node.style.visibility =\n                    this.handlesVisible && this.isCustomHandleVisible(this.customHandles[i])\n                        ? ''\n                        : 'hidden';\n            }\n        }\n        if (this.sizers.length > 0 && this.sizers[0]) {\n            if (this.index === null && this.manageSizers && this.sizers.length >= 8) {\n                // KNOWN: Tolerance depends on event type (eg. 0 for mouse events)\n                const padding = this.getHandlePadding();\n                this.horizontalOffset = padding.x;\n                this.verticalOffset = padding.y;\n                if (this.horizontalOffset !== 0 || this.verticalOffset !== 0) {\n                    s = new Rectangle(s.x, s.y, s.width, s.height);\n                    s.x -= this.horizontalOffset / 2;\n                    s.width += this.horizontalOffset;\n                    s.y -= this.verticalOffset / 2;\n                    s.height += this.verticalOffset;\n                }\n                if (this.sizers.length >= 8) {\n                    if (this.sizers[0].bounds &&\n                        (s.width < 2 * this.sizers[0].bounds.width + 2 * tol ||\n                            s.height < 2 * this.sizers[0].bounds.height + 2 * tol)) {\n                        this.sizers[0].node.style.display = 'none';\n                        this.sizers[2].node.style.display = 'none';\n                        this.sizers[5].node.style.display = 'none';\n                        this.sizers[7].node.style.display = 'none';\n                    }\n                    else if (this.handlesVisible) {\n                        this.sizers[0].node.style.display = '';\n                        this.sizers[2].node.style.display = '';\n                        this.sizers[5].node.style.display = '';\n                        this.sizers[7].node.style.display = '';\n                    }\n                }\n            }\n            const r = s.x + s.width;\n            const b = s.y + s.height;\n            if (this.singleSizer) {\n                this.moveSizerTo(this.sizers[0], r, b);\n            }\n            else {\n                const cx = s.x + s.width / 2;\n                const cy = s.y + s.height / 2;\n                if (this.sizers.length >= 8) {\n                    const crs = [\n                        'nw-resize',\n                        'n-resize',\n                        'ne-resize',\n                        'e-resize',\n                        'se-resize',\n                        's-resize',\n                        'sw-resize',\n                        'w-resize',\n                    ];\n                    const alpha = toRadians(this.state.style.rotation ?? 0);\n                    const cos = Math.cos(alpha);\n                    const sin = Math.sin(alpha);\n                    const da = Math.round((alpha * 4) / Math.PI);\n                    const ct = new Point(s.getCenterX(), s.getCenterY());\n                    let pt = getRotatedPoint(new Point(s.x, s.y), cos, sin, ct);\n                    this.moveSizerTo(this.sizers[0], pt.x, pt.y);\n                    this.sizers[0].setCursor(crs[mod(0 + da, crs.length)]);\n                    pt.x = cx;\n                    pt.y = s.y;\n                    pt = getRotatedPoint(pt, cos, sin, ct);\n                    this.moveSizerTo(this.sizers[1], pt.x, pt.y);\n                    this.sizers[1].setCursor(crs[mod(1 + da, crs.length)]);\n                    pt.x = r;\n                    pt.y = s.y;\n                    pt = getRotatedPoint(pt, cos, sin, ct);\n                    this.moveSizerTo(this.sizers[2], pt.x, pt.y);\n                    this.sizers[2].setCursor(crs[mod(2 + da, crs.length)]);\n                    pt.x = s.x;\n                    pt.y = cy;\n                    pt = getRotatedPoint(pt, cos, sin, ct);\n                    this.moveSizerTo(this.sizers[3], pt.x, pt.y);\n                    this.sizers[3].setCursor(crs[mod(7 + da, crs.length)]);\n                    pt.x = r;\n                    pt.y = cy;\n                    pt = getRotatedPoint(pt, cos, sin, ct);\n                    this.moveSizerTo(this.sizers[4], pt.x, pt.y);\n                    this.sizers[4].setCursor(crs[mod(3 + da, crs.length)]);\n                    pt.x = s.x;\n                    pt.y = b;\n                    pt = getRotatedPoint(pt, cos, sin, ct);\n                    this.moveSizerTo(this.sizers[5], pt.x, pt.y);\n                    this.sizers[5].setCursor(crs[mod(6 + da, crs.length)]);\n                    pt.x = cx;\n                    pt.y = b;\n                    pt = getRotatedPoint(pt, cos, sin, ct);\n                    this.moveSizerTo(this.sizers[6], pt.x, pt.y);\n                    this.sizers[6].setCursor(crs[mod(5 + da, crs.length)]);\n                    pt.x = r;\n                    pt.y = b;\n                    pt = getRotatedPoint(pt, cos, sin, ct);\n                    this.moveSizerTo(this.sizers[7], pt.x, pt.y);\n                    this.sizers[7].setCursor(crs[mod(4 + da, crs.length)]);\n                    pt.x = cx + this.state.absoluteOffset.x;\n                    pt.y = cy + this.state.absoluteOffset.y;\n                    pt = getRotatedPoint(pt, cos, sin, ct);\n                    this.moveSizerTo(this.sizers[8], pt.x, pt.y);\n                }\n                else if (this.state.width >= 2 && this.state.height >= 2) {\n                    this.moveSizerTo(this.sizers[0], cx + this.state.absoluteOffset.x, cy + this.state.absoluteOffset.y);\n                }\n                else {\n                    this.moveSizerTo(this.sizers[0], this.state.x, this.state.y);\n                }\n            }\n        }\n        if (this.rotationShape) {\n            const alpha = toRadians(this.currentAlpha);\n            const cos = Math.cos(alpha);\n            const sin = Math.sin(alpha);\n            const ct = new Point(this.state.getCenterX(), this.state.getCenterY());\n            const pt = getRotatedPoint(this.getRotationHandlePosition(), cos, sin, ct);\n            if (this.rotationShape.node != null) {\n                this.moveSizerTo(this.rotationShape, pt.x, pt.y);\n                // Hides rotation handle during text editing\n                this.rotationShape.node.style.visibility =\n                    this.state.view.graph.isEditing() || !this.handlesVisible\n                        ? 'hidden'\n                        : '';\n            }\n        }\n        if (this.selectionBorder != null) {\n            this.selectionBorder.rotation = this.state.style.rotation ?? 0;\n        }\n        if (this.edgeHandlers != null) {\n            for (let i = 0; i < this.edgeHandlers.length; i += 1) {\n                this.edgeHandlers[i].redraw();\n            }\n        }\n    }\n    /**\n     * Returns true if the given custom handle is visible.\n     */\n    isCustomHandleVisible(handle) {\n        return (!this.graph.isEditing() && this.state.view.graph.getSelectionCount() === 1);\n    }\n    /**\n     * Returns an {@link Point} that defines the rotation handle position.\n     */\n    getRotationHandlePosition() {\n        return new Point(this.bounds.x + this.bounds.width / 2, this.bounds.y + this.rotationHandleVSpacing);\n    }\n    /**\n     * Returns true if the parent highlight should be visible. This implementation\n     * always returns true.\n     */\n    isParentHighlightVisible() {\n        const parent = this.state.cell.getParent();\n        return parent ? !this.graph.isCellSelected(parent) : false;\n    }\n    /**\n     * Updates the highlight of the parent if <parentHighlightEnabled> is true.\n     */\n    updateParentHighlight() {\n        if (!this.isDestroyed()) {\n            const visible = this.isParentHighlightVisible();\n            const parent = this.state.cell.getParent();\n            const pstate = parent ? this.graph.view.getState(parent) : null;\n            if (this.parentHighlight) {\n                if (parent && parent.isVertex() && visible) {\n                    const b = this.parentHighlight.bounds;\n                    if (pstate &&\n                        b &&\n                        (b.x !== pstate.x ||\n                            b.y !== pstate.y ||\n                            b.width !== pstate.width ||\n                            b.height !== pstate.height)) {\n                        this.parentHighlight.bounds = Rectangle.fromRectangle(pstate);\n                        this.parentHighlight.redraw();\n                    }\n                }\n                else {\n                    if (pstate != null && pstate.parentHighlight === this.parentHighlight) {\n                        pstate.parentHighlight = null;\n                    }\n                    this.parentHighlight.destroy();\n                    this.parentHighlight = null;\n                }\n            }\n            else if (this.parentHighlightEnabled && visible) {\n                if (parent &&\n                    parent.isVertex() &&\n                    pstate != null &&\n                    pstate.parentHighlight == null) {\n                    this.parentHighlight = this.createParentHighlightShape(pstate);\n                    // VML dialect required here for event transparency in IE\n                    this.parentHighlight.dialect = DIALECT.SVG;\n                    this.parentHighlight.pointerEvents = false;\n                    this.parentHighlight.rotation = pstate.style.rotation ?? 0;\n                    this.parentHighlight.init(this.graph.getView().getOverlayPane());\n                    this.parentHighlight.redraw();\n                    // Shows highlight once per parent\n                    pstate.parentHighlight = this.parentHighlight;\n                }\n            }\n        }\n    }\n    /**\n     * Redraws the preview.\n     */\n    drawPreview() {\n        if (this.preview != null) {\n            this.preview.bounds = this.bounds;\n            if (this.preview.node.parentNode === this.graph.container) {\n                this.preview.bounds.width = Math.max(0, this.preview.bounds.width - 1);\n                this.preview.bounds.height = Math.max(0, this.preview.bounds.height - 1);\n            }\n            this.preview.rotation = this.state.style.rotation ?? 0;\n            this.preview.redraw();\n        }\n        this.selectionBorder.bounds = this.getSelectionBorderBounds();\n        this.selectionBorder.redraw();\n        this.updateParentHighlight();\n    }\n    /**\n     * Returns the bounds for the selection border.\n     */\n    getSelectionBorderBounds() {\n        return this.bounds;\n    }\n    /**\n     * Returns true if this handler was destroyed or not initialized.\n     */\n    isDestroyed() {\n        return this.selectionBorder == null;\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes.\n     */\n    onDestroy() {\n        this.state.view.graph.removeListener(this.escapeHandler);\n        this.escapeHandler = () => {\n            return;\n        };\n        if (this.preview) {\n            this.preview.destroy();\n            this.preview = null;\n        }\n        if (this.parentHighlight) {\n            const parent = this.state.cell.getParent();\n            const pstate = parent ? this.graph.view.getState(parent) : null;\n            if (pstate && pstate.parentHighlight === this.parentHighlight) {\n                pstate.parentHighlight = null;\n            }\n            this.parentHighlight.destroy();\n            this.parentHighlight = null;\n        }\n        if (this.ghostPreview) {\n            this.ghostPreview.destroy();\n            this.ghostPreview = null;\n        }\n        if (this.selectionBorder) {\n            this.selectionBorder.destroy();\n        }\n        this.labelShape = null;\n        this.removeHint();\n        for (let i = 0; i < this.sizers.length; i += 1) {\n            this.sizers[i].destroy();\n        }\n        this.sizers = [];\n        for (let i = 0; i < this.customHandles.length; i += 1) {\n            this.customHandles[i].destroy();\n        }\n        this.customHandles = [];\n    }\n}\nexport default VertexHandler;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,SAAS,MAAM,uBAAuB;AAC7C,SAASC,MAAM,EAAEC,OAAO,EAAEC,gBAAgB,EAAEC,WAAW,EAAEC,kBAAkB,EAAEC,sBAAsB,EAAEC,iBAAiB,EAAEC,IAAI,EAAEC,sBAAsB,EAAEC,uBAAuB,EAAEC,4BAA4B,QAAS,sBAAsB;AAC1O,OAAOC,aAAa,MAAM,wBAAwB;AAClD,OAAOC,cAAc,MAAM,iCAAiC;AAC5D,OAAOC,UAAU,MAAM,6BAA6B;AACpD,OAAOC,YAAY,MAAM,+BAA+B;AACxD,OAAOC,KAAK,MAAM,mBAAmB;AACrC,SAASC,eAAe,EAAEC,UAAU,EAAEC,GAAG,EAAEC,SAAS,QAAQ,sBAAsB;AAClF,OAAOC,MAAM,MAAM,cAAc;AACjC,SAASC,YAAY,EAAEC,WAAW,QAAQ,uBAAuB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,aAAa,CAAC;EAChBC,WAAWA,CAACC,KAAK,EAAE;IACf,IAAI,CAACC,MAAM,GAAG,EAAE;IAChB;AACR;AACA;AACA;IACQ,IAAI,CAACC,WAAW,GAAG,KAAK;IACxB;AACR;AACA;IACQ,IAAI,CAACC,KAAK,GAAG,IAAI;IACjB;AACR;AACA;AACA;IACQ,IAAI,CAACC,sBAAsB,GAAG,IAAI;IAClC;AACR;AACA;IACQ,IAAI,CAACC,WAAW,GAAG,IAAI;IACvB;AACR;AACA;IACQ,IAAI,CAACC,cAAc,GAAG,IAAI;IAC1B;AACR;AACA;IACQ,IAAI,CAACC,SAAS,GAAG,CAAC;IAClB;AACR;AACA;IACQ,IAAI,CAACC,eAAe,GAAG,KAAK;IAC5B;AACR;AACA;AACA;IACQ,IAAI,CAACC,sBAAsB,GAAG,KAAK;IACnC;AACR;AACA;AACA;IACQ,IAAI,CAACC,cAAc,GAAG,IAAI;IAC1B;AACR;AACA;IACQ,IAAI,CAACC,cAAc,GAAG,WAAW;IACjC;AACR;AACA;AACA;IACQ,IAAI,CAACC,WAAW,GAAG,KAAK;IACxB;AACR;AACA;IACQ,IAAI,CAACC,kBAAkB,GAAG,KAAK;IAC/B;AACR;AACA;AACA;IACQ,IAAI,CAACC,YAAY,GAAG,KAAK;IACzB;AACR;AACA;AACA;IACQ,IAAI,CAACC,wBAAwB,GAAG,KAAK;IACrC;AACR;AACA;IACQ,IAAI,CAACC,sBAAsB,GAAG,CAAC,EAAE;IACjC;AACR;AACA;AACA;IACQ,IAAI,CAACC,gBAAgB,GAAG,CAAC;IACzB;AACR;AACA;AACA;IACQ,IAAI,CAACC,cAAc,GAAG,CAAC;IACvB,IAAI,CAACC,SAAS,GAAG,IAAI;IACrB,IAAI,CAACC,EAAE,GAAG,CAAC;IACX,IAAI,CAACC,EAAE,GAAG,CAAC;IACX,IAAI,CAACC,aAAa,GAAG,EAAE;IACvB,IAAI,CAACC,WAAW,GAAG,KAAK;IACxB,IAAI,CAACC,MAAM,GAAG,CAAC;IACf,IAAI,CAACC,MAAM,GAAG,CAAC;IACf,IAAI,CAACC,aAAa,GAAG,IAAI;IACzB,IAAI,CAACC,YAAY,GAAG,GAAG;IACvB,IAAI,CAACC,UAAU,GAAG,CAAC;IACnB,IAAI,CAACC,SAAS,GAAG,CAAC;IAClB,IAAI,CAACC,YAAY,GAAG,IAAI;IACxB,IAAI,CAACC,iBAAiB,GAAG,KAAK;IAC9B,IAAI,CAACC,YAAY,GAAG,CAAC;IACrB,IAAI,CAACC,YAAY,GAAG,CAAC;IACrB,IAAI,CAACC,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,eAAe,GAAG,IAAI;IAC3B,IAAI,CAACC,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACC,OAAO,GAAG,IAAI;IACnB,IAAI,CAACC,UAAU,GAAG,IAAI;IACtB,IAAI,CAACC,YAAY,GAAG,EAAE;IACtB,IAAI,CAACC,WAAW,GAAG,IAAIlD,KAAK,CAAC,CAAC;IAC9B,IAAI,CAACU,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACyC,KAAK,GAAG,IAAI,CAACzC,KAAK,CAAC0C,IAAI,CAACD,KAAK;IAClC,IAAI,CAACE,eAAe,GAAG,IAAI,CAACC,kBAAkB,CAAC,IAAI,CAAC5C,KAAK,CAAC;IAC1D,IAAI,CAAC6C,MAAM,GAAG,IAAIvE,SAAS,CAAC,IAAI,CAACqE,eAAe,CAACG,CAAC,EAAE,IAAI,CAACH,eAAe,CAACI,CAAC,EAAE,IAAI,CAACJ,eAAe,CAACK,KAAK,EAAE,IAAI,CAACL,eAAe,CAACM,MAAM,CAAC;IACpI,IAAI,CAACC,eAAe,GAAG,IAAI,CAACC,oBAAoB,CAAC,IAAI,CAACN,MAAM,CAAC;IAC7D;IACA,IAAI,CAACK,eAAe,CAACE,OAAO,GAAG5E,OAAO,CAAC6E,GAAG;IAC1C,IAAI,CAACH,eAAe,CAACI,aAAa,GAAG,KAAK;IAC1C,IAAI,CAACJ,eAAe,CAACK,QAAQ,GAAG,IAAI,CAACvD,KAAK,CAACwD,KAAK,CAACD,QAAQ,IAAI,CAAC;IAC9D,IAAI,CAACL,eAAe,CAACO,IAAI,CAAC,IAAI,CAAChB,KAAK,CAACiB,OAAO,CAAC,CAAC,CAACC,cAAc,CAAC,CAAC,CAAC;IAChEzE,aAAa,CAAC0E,mBAAmB,CAAC,IAAI,CAACV,eAAe,CAACW,IAAI,EAAE,IAAI,CAACpB,KAAK,EAAE,IAAI,CAACzC,KAAK,CAAC;IACpF,IAAI,IAAI,CAACyC,KAAK,CAACqB,aAAa,CAAC,IAAI,CAAC9D,KAAK,CAAC+D,IAAI,CAAC,EAAE;MAC3C,IAAI,CAACb,eAAe,CAACc,SAAS,CAACzF,MAAM,CAAC0F,cAAc,CAAC;IACzD;IACA,MAAMC,gBAAgB,GAAG,IAAI,CAACzB,KAAK,CAAC0B,SAAS,CAAC,kBAAkB,CAAC;IACjE;IACA,IAAID,gBAAgB,KACfA,gBAAgB,CAACE,QAAQ,IAAI,CAAC,IAC3B,IAAI,CAAC3B,KAAK,CAAC4B,iBAAiB,CAAC,CAAC,GAAGH,gBAAgB,CAACE,QAAQ,CAAC,EAAE;MACjE,MAAME,SAAS,GAAG,IAAI,CAAC7B,KAAK,CAAC8B,eAAe,CAAC,IAAI,CAACvE,KAAK,CAAC+D,IAAI,CAAC;MAC7D,IAAI,CAAC9D,MAAM,GAAG,EAAE;MAChB,IAAIqE,SAAS,IACR,IAAI,CAAC7B,KAAK,CAAC+B,cAAc,CAAC,IAAI,CAACxE,KAAK,CAAC+D,IAAI,CAAC,IACvC,IAAI,CAAC/D,KAAK,CAACgD,KAAK,IAAI,CAAC,IACrB,IAAI,CAAChD,KAAK,CAACiD,MAAM,IAAI,CAAE,EAAE;QAC7B,IAAIwB,CAAC,GAAG,CAAC;QACT,IAAIH,SAAS,EAAE;UACX,IAAI,CAAC,IAAI,CAACpE,WAAW,EAAE;YACnB,IAAI,CAACD,MAAM,CAACyE,IAAI,CAAC,IAAI,CAACC,WAAW,CAAC,WAAW,EAAEF,CAAC,EAAE,CAAC,CAAC;YACpD,IAAI,CAACxE,MAAM,CAACyE,IAAI,CAAC,IAAI,CAACC,WAAW,CAAC,UAAU,EAAEF,CAAC,EAAE,CAAC,CAAC;YACnD,IAAI,CAACxE,MAAM,CAACyE,IAAI,CAAC,IAAI,CAACC,WAAW,CAAC,WAAW,EAAEF,CAAC,EAAE,CAAC,CAAC;YACpD,IAAI,CAACxE,MAAM,CAACyE,IAAI,CAAC,IAAI,CAACC,WAAW,CAAC,UAAU,EAAEF,CAAC,EAAE,CAAC,CAAC;YACnD,IAAI,CAACxE,MAAM,CAACyE,IAAI,CAAC,IAAI,CAACC,WAAW,CAAC,UAAU,EAAEF,CAAC,EAAE,CAAC,CAAC;YACnD,IAAI,CAACxE,MAAM,CAACyE,IAAI,CAAC,IAAI,CAACC,WAAW,CAAC,WAAW,EAAEF,CAAC,EAAE,CAAC,CAAC;YACpD,IAAI,CAACxE,MAAM,CAACyE,IAAI,CAAC,IAAI,CAACC,WAAW,CAAC,UAAU,EAAEF,CAAC,EAAE,CAAC,CAAC;UACvD;UACA,IAAI,CAACxE,MAAM,CAACyE,IAAI,CAAC,IAAI,CAACC,WAAW,CAAC,WAAW,EAAEF,CAAC,EAAE,CAAC,CAAC;QACxD;QACA,MAAMG,GAAG,GAAG,IAAI,CAAC5E,KAAK,CAAC+D,IAAI,CAACc,WAAW,CAAC,CAAC;QACzC,IAAID,GAAG,IAAI,IAAI,IACX,CAACA,GAAG,CAACE,QAAQ;QACb;QACA,IAAI,CAACrC,KAAK,CAAC+B,cAAc,CAAC,IAAI,CAACxE,KAAK,CAAC+D,IAAI,CAAC,EAAE;UAC5C;UACA,IAAI,CAACzB,UAAU,GAAG,IAAI,CAACqC,WAAW,CAACpG,MAAM,CAACwG,YAAY,EAAE7F,aAAa,CAAC6F,YAAY,EAAElG,iBAAiB,EAAED,sBAAsB,CAAC;UAC9H,IAAI,CAACqB,MAAM,CAACyE,IAAI,CAAC,IAAI,CAACpC,UAAU,CAAC;QACrC;MACJ,CAAC,MACI,IAAI,IAAI,CAACG,KAAK,CAACqB,aAAa,CAAC,IAAI,CAAC9D,KAAK,CAAC+D,IAAI,CAAC,IAC9C,CAAC,IAAI,CAACtB,KAAK,CAAC8B,eAAe,CAAC,IAAI,CAACvE,KAAK,CAAC+D,IAAI,CAAC,IAC5C,IAAI,CAAC/D,KAAK,CAACgD,KAAK,GAAG,CAAC,IACpB,IAAI,CAAChD,KAAK,CAACiD,MAAM,GAAG,CAAC,EAAE;QACvB,IAAI,CAACX,UAAU,GAAG,IAAI,CAACqC,WAAW,CAACpG,MAAM,CAAC0F,cAAc,EAAE/E,aAAa,CAAC6F,YAAY,EAAEC,SAAS,EAAEpG,sBAAsB,CAAC;QACxH,IAAI,CAACqB,MAAM,CAACyE,IAAI,CAAC,IAAI,CAACpC,UAAU,CAAC;MACrC;IACJ;IACA;IACA,IAAI,IAAI,CAAC2C,uBAAuB,CAAC,CAAC,EAAE;MAChC,IAAI,CAACvD,aAAa,GAAG,IAAI,CAACiD,WAAW,CAAC,IAAI,CAAChE,cAAc,EAAEzB,aAAa,CAACgG,eAAe,EAAExG,WAAW,GAAG,CAAC,EAAED,gBAAgB,CAAC;MAC5H,IAAI,CAACwB,MAAM,CAACyE,IAAI,CAAC,IAAI,CAAChD,aAAa,CAAC;IACxC;IACA,IAAI,CAACJ,aAAa,GAAG,IAAI,CAAC6D,mBAAmB,CAAC,CAAC;IAC/C,IAAI,CAACC,MAAM,CAAC,CAAC;IACb,IAAI,IAAI,CAACrE,wBAAwB,EAAE;MAC/B,IAAI,CAACsE,eAAe,CAAC,CAAC;IAC1B;IACA;IACA,IAAI,CAACC,aAAa,GAAG,CAACC,MAAM,EAAEC,GAAG,KAAK;MAClC,IAAI,IAAI,CAAC5E,WAAW,IAAI,IAAI,CAACT,KAAK,IAAI,IAAI,EAAE;QACxC;QACA,IAAI,CAACH,KAAK,CAAC0C,IAAI,CAACD,KAAK,CAACgD,YAAY,CAACL,MAAM,CAAC,IAAI,CAACpF,KAAK,EAAE,IAAI,CAAC;QAC3D;QACA,IAAI,CAACA,KAAK,CAAC0C,IAAI,CAACgD,UAAU,CAAC,IAAI,CAAC1F,KAAK,CAAC+D,IAAI,CAAC;QAC3C,IAAI,CAAC/D,KAAK,CAAC2F,OAAO,GAAG,KAAK;QAC1B,IAAI,CAAC3F,KAAK,CAAC0C,IAAI,CAACkD,QAAQ,CAAC,CAAC;MAC9B;MACA,IAAI,CAACC,KAAK,CAAC,CAAC;IAChB,CAAC;IACD,IAAI,CAAC7F,KAAK,CAAC0C,IAAI,CAACD,KAAK,CAACqD,WAAW,CAAC5G,aAAa,CAAC6G,MAAM,EAAE,IAAI,CAACT,aAAa,CAAC;EAC/E;EACA;AACJ;AACA;EACIL,uBAAuBA,CAAA,EAAG;IACtB,MAAMf,gBAAgB,GAAG,IAAI,CAACzB,KAAK,CAAC0B,SAAS,CAAC,kBAAkB,CAAC;IACjE,MAAM6B,qBAAqB,GAAG9B,gBAAgB,GACxCA,gBAAgB,CAACE,QAAQ,IAAI,CAAC,IAC5B,IAAI,CAAC3B,KAAK,CAAC4B,iBAAiB,CAAC,CAAC,GAAGH,gBAAgB,CAACE,QAAQ,GAC5D,IAAI;IACV,OAAQ,IAAI,CAAC3B,KAAK,CAACwD,SAAS,CAAC,CAAC,IAC1B,IAAI,CAACzF,eAAe,IACpB,IAAI,CAACiC,KAAK,CAACyD,eAAe,CAAC,IAAI,CAAClG,KAAK,CAAC+D,IAAI,CAAC,IAC3CiC,qBAAqB;EAC7B;EACA;AACJ;AACA;EACIG,kBAAkBA,CAACC,EAAE,EAAE;IACnB,OAAOvG,WAAW,CAACuG,EAAE,CAACC,QAAQ,CAAC,CAAC,CAAC,IAAI,IAAI,CAACrG,KAAK,CAACwD,KAAK,CAAC8C,MAAM,KAAK,OAAO;EAC5E;EACA;AACJ;AACA;EACIC,eAAeA,CAACvG,KAAK,EAAEoG,EAAE,EAAE;IACvB,OAAO,KAAK;EAChB;EACA;AACJ;AACA;EACIjB,mBAAmBA,CAAA,EAAG;IAClB,OAAO,EAAE;EACb;EACA;AACJ;AACA;EACIE,eAAeA,CAAA,EAAG;IACd,MAAMmB,QAAQ,GAAG,IAAI,CAAC/D,KAAK,CAACgE,aAAa,CAAC,IAAI,CAACzG,KAAK,CAAC+D,IAAI,CAAC;IAC1D,IAAIyC,QAAQ,CAACE,MAAM,GAAG,CAAC,EAAE;MACrB,IAAI,CAACvF,SAAS,GAAG,IAAI,CAACsB,KAAK,CAACC,IAAI,CAACiE,SAAS,CAACH,QAAQ,CAAC;MACpD,IAAI,IAAI,CAACrF,SAAS,EAAE;QAChB,MAAMyF,CAAC,GAAG,IAAI,CAAC5G,KAAK,CAAC0C,IAAI,CAACmE,KAAK;QAC/B,MAAMC,CAAC,GAAG,IAAI,CAAC9G,KAAK,CAAC0C,IAAI,CAACqE,SAAS;QACnC,IAAI,CAAC5F,SAAS,CAAC2B,CAAC,IAAI,IAAI,CAAC9C,KAAK,CAAC8C,CAAC;QAChC,IAAI,CAAC3B,SAAS,CAAC4B,CAAC,IAAI,IAAI,CAAC/C,KAAK,CAAC+C,CAAC;QAChC,IAAI,CAAC5B,SAAS,CAAC2B,CAAC,IAAI8D,CAAC;QACrB,IAAI,CAACzF,SAAS,CAAC4B,CAAC,IAAI6D,CAAC;QACrB,IAAI,CAACzF,SAAS,CAAC6B,KAAK,IAAI4D,CAAC;QACzB,IAAI,CAACzF,SAAS,CAAC8B,MAAM,IAAI2D,CAAC;QAC1B,IAAI,CAACxF,EAAE,GAAG,IAAI,CAACpB,KAAK,CAAC8C,CAAC,GAAG8D,CAAC,GAAGE,CAAC,CAAChE,CAAC;QAChC,IAAI,CAACzB,EAAE,GAAG,IAAI,CAACrB,KAAK,CAAC+C,CAAC,GAAG6D,CAAC,GAAGE,CAAC,CAAC/D,CAAC;MACpC;IACJ;EACJ;EACA;AACJ;AACA;AACA;EACIH,kBAAkBA,CAAC5C,KAAK,EAAE;IACtB,OAAO,IAAI1B,SAAS,CAAC0I,IAAI,CAACC,KAAK,CAACjH,KAAK,CAAC8C,CAAC,CAAC,EAAEkE,IAAI,CAACC,KAAK,CAACjH,KAAK,CAAC+C,CAAC,CAAC,EAAEiE,IAAI,CAACC,KAAK,CAACjH,KAAK,CAACgD,KAAK,CAAC,EAAEgE,IAAI,CAACC,KAAK,CAACjH,KAAK,CAACiD,MAAM,CAAC,CAAC;EACrH;EACA;AACJ;AACA;EACIiE,0BAA0BA,CAACrE,MAAM,EAAE;IAC/B,OAAO,IAAI,CAACM,oBAAoB,CAACN,MAAM,CAAC;EAC5C;EACA;AACJ;AACA;EACIM,oBAAoBA,CAACN,MAAM,EAAE;IACzB,MAAMsE,KAAK,GAAG,IAAIhI,cAAc,CAACb,SAAS,CAAC8I,aAAa,CAACvE,MAAM,CAAC,EAAE/D,IAAI,EAAE,IAAI,CAACuI,iBAAiB,CAAC,CAAC,CAAC;IACjGF,KAAK,CAACG,WAAW,GAAG,IAAI,CAACC,uBAAuB,CAAC,CAAC;IAClDJ,KAAK,CAACK,QAAQ,GAAG,IAAI,CAACC,iBAAiB,CAAC,CAAC;IACzC,OAAON,KAAK;EAChB;EACA;AACJ;AACA;EACIE,iBAAiBA,CAAA,EAAG;IAChB,OAAOtI,sBAAsB;EACjC;EACA;AACJ;AACA;EACIwI,uBAAuBA,CAAA,EAAG;IACtB,OAAOtI,4BAA4B;EACvC;EACA;AACJ;AACA;EACIwI,iBAAiBA,CAAA,EAAG;IAChB,OAAOzI,uBAAuB;EAClC;EACA;AACJ;AACA;AACA;EACI2F,WAAWA,CAAC+C,MAAM,EAAEvH,KAAK,EAAEwH,IAAI,GAAGjJ,WAAW,EAAEkJ,SAAS,GAAGnJ,gBAAgB,EAAE;IACzE,MAAMoE,MAAM,GAAG,IAAIvE,SAAS,CAAC,CAAC,EAAE,CAAC,EAAEqJ,IAAI,EAAEA,IAAI,CAAC;IAC9C,MAAME,KAAK,GAAG,IAAI,CAACC,gBAAgB,CAACjF,MAAM,EAAE1C,KAAK,EAAEyH,SAAS,CAAC;IAC7D,IAAIC,KAAK,CAAChF,MAAM,IACZgF,KAAK,CAACE,aAAa,CAAC,CAAC,IACrB,IAAI,CAAC/H,KAAK,CAACgI,IAAI,IACf,IAAI,CAAChI,KAAK,CAACgI,IAAI,CAACnE,IAAI,CAACoE,UAAU,KAAK,IAAI,CAACxF,KAAK,CAACyF,SAAS,EAAE;MAC1DL,KAAK,CAAChF,MAAM,CAACI,MAAM,IAAI,CAAC;MACxB4E,KAAK,CAAChF,MAAM,CAACG,KAAK,IAAI,CAAC;MACvB6E,KAAK,CAACzE,OAAO,GAAG5E,OAAO,CAAC2J,UAAU;MAClCN,KAAK,CAACpE,IAAI,CAAC,IAAI,CAAChB,KAAK,CAACyF,SAAS,CAAC;IACpC,CAAC,MACI;MACDL,KAAK,CAACzE,OAAO,GACT,IAAI,CAACX,KAAK,CAACW,OAAO,KAAK5E,OAAO,CAAC6E,GAAG,GAAG7E,OAAO,CAAC4J,SAAS,GAAG5J,OAAO,CAAC6E,GAAG;MACxEwE,KAAK,CAACpE,IAAI,CAAC,IAAI,CAAChB,KAAK,CAACiB,OAAO,CAAC,CAAC,CAACC,cAAc,CAAC,CAAC,CAAC;IACrD;IACAzE,aAAa,CAAC0E,mBAAmB,CAACiE,KAAK,CAAChE,IAAI,EAAE,IAAI,CAACpB,KAAK,EAAE,IAAI,CAACzC,KAAK,CAAC;IACrE,IAAI,IAAI,CAACyC,KAAK,CAACwD,SAAS,CAAC,CAAC,EAAE;MACxB4B,KAAK,CAAC7D,SAAS,CAAC0D,MAAM,CAAC;IAC3B;IACA,IAAI,CAAC,IAAI,CAACW,cAAc,CAAClI,KAAK,CAAC,EAAE;MAC7B0H,KAAK,CAACS,OAAO,GAAG,KAAK;IACzB;IACA,OAAOT,KAAK;EAChB;EACA;AACJ;AACA;AACA;EACIQ,cAAcA,CAAClI,KAAK,EAAE;IAClB,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;EACI2H,gBAAgBA,CAACjF,MAAM,EAAE1C,KAAK,EAAEyH,SAAS,GAAGnJ,gBAAgB,EAAE;IAC1D,IAAI,IAAI,CAAC4B,WAAW,EAAE;MAClBwC,MAAM,GAAG,IAAIvE,SAAS,CAACuE,MAAM,CAACC,CAAC,EAAED,MAAM,CAACE,CAAC,EAAE,IAAI,CAAC1C,WAAW,CAAC2C,KAAK,EAAE,IAAI,CAAC3C,WAAW,CAAC4C,MAAM,CAAC;MAC3F,MAAMkE,KAAK,GAAG,IAAI/H,UAAU,CAACyD,MAAM,EAAE,IAAI,CAACxC,WAAW,CAACkI,GAAG,CAAC;MAC1D;MACApB,KAAK,CAACqB,mBAAmB,GAAG,KAAK;MACjC,OAAOrB,KAAK;IAChB;IACA,IAAIhH,KAAK,KAAKjB,aAAa,CAACgG,eAAe,EAAE;MACzC,OAAO,IAAI7F,YAAY,CAACwD,MAAM,EAAE+E,SAAS,EAAEjJ,kBAAkB,CAAC;IAClE;IACA,OAAO,IAAIQ,cAAc,CAAC0D,MAAM,EAAE+E,SAAS,EAAEjJ,kBAAkB,CAAC;EACpE;EACA;AACJ;AACA;AACA;EACI8J,WAAWA,CAACtB,KAAK,EAAErE,CAAC,EAAEC,CAAC,EAAE;IACrB,IAAIoE,KAAK,IAAIA,KAAK,CAACtE,MAAM,EAAE;MACvBsE,KAAK,CAACtE,MAAM,CAACC,CAAC,GAAGkE,IAAI,CAAC0B,KAAK,CAAC5F,CAAC,GAAGqE,KAAK,CAACtE,MAAM,CAACG,KAAK,GAAG,CAAC,CAAC;MACvDmE,KAAK,CAACtE,MAAM,CAACE,CAAC,GAAGiE,IAAI,CAAC0B,KAAK,CAAC3F,CAAC,GAAGoE,KAAK,CAACtE,MAAM,CAACI,MAAM,GAAG,CAAC,CAAC;MACxD;MACA,IAAIkE,KAAK,CAACtD,IAAI,IAAIsD,KAAK,CAACtD,IAAI,CAACL,KAAK,CAACmF,OAAO,KAAK,MAAM,EAAE;QACnDxB,KAAK,CAAC/B,MAAM,CAAC,CAAC;MAClB;IACJ;EACJ;EACA;AACJ;AACA;AACA;EACIwD,iBAAiBA,CAACxC,EAAE,EAAE;IAClB;IACA,MAAMyC,GAAG,GAAG,CAACjJ,YAAY,CAACwG,EAAE,CAACC,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC9F,SAAS,GAAG,CAAC;IAC7D,MAAMuI,GAAG,GAAG,IAAI,CAAC1I,sBAAsB,IAAIyI,GAAG,GAAG,CAAC,GAC5C,IAAIvK,SAAS,CAAC8H,EAAE,CAAC2C,SAAS,CAAC,CAAC,GAAGF,GAAG,EAAEzC,EAAE,CAAC4C,SAAS,CAAC,CAAC,GAAGH,GAAG,EAAE,CAAC,GAAGA,GAAG,EAAE,CAAC,GAAGA,GAAG,CAAC,GAC3E,IAAI;IACV,MAAMI,UAAU,GAAI9B,KAAK,IAAK;MAC1B,MAAM+B,EAAE,GAAG/B,KAAK,IAAIA,KAAK,CAACpH,WAAW,KAAKX,UAAU,IAAI,IAAI,CAACgB,sBAAsB,GAC7E+G,KAAK,CAACG,WAAW,GAAGH,KAAK,CAACgC,kBAAkB,GAC5C,IAAI;MACV,MAAMC,IAAI,GAAGF,EAAE,GACT,IAAI5K,SAAS,CAAC8H,EAAE,CAAC2C,SAAS,CAAC,CAAC,GAAG/B,IAAI,CAAC0B,KAAK,CAACQ,EAAE,GAAG,CAAC,CAAC,EAAE9C,EAAE,CAAC4C,SAAS,CAAC,CAAC,GAAGhC,IAAI,CAAC0B,KAAK,CAACQ,EAAE,GAAG,CAAC,CAAC,EAAEA,EAAE,EAAEA,EAAE,CAAC,GAC/FJ,GAAG;MACT,OAAQ3B,KAAK,IACTA,KAAK,CAACtE,MAAM,KACXuD,EAAE,CAACiD,QAAQ,CAAClC,KAAK,CAAC,IACdiC,IAAI,IACD5J,UAAU,CAAC2H,KAAK,CAACtE,MAAM,EAAEuG,IAAI,CAAC,IAC9BjC,KAAK,CAACtD,IAAI,CAACL,KAAK,CAACmF,OAAO,KAAK,MAAM,IACnCxB,KAAK,CAACtD,IAAI,CAACL,KAAK,CAAC8F,UAAU,KAAK,QAAS,CAAC;IAC1D,CAAC;IACD,IAAIL,UAAU,CAAC,IAAI,CAACvH,aAAa,CAAC,EAAE;MAChC,OAAOxC,aAAa,CAACgG,eAAe;IACxC;IACA,IAAI+D,UAAU,CAAC,IAAI,CAAC3G,UAAU,CAAC,EAAE;MAC7B,OAAOpD,aAAa,CAAC6F,YAAY;IACrC;IACA,KAAK,IAAIN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACxE,MAAM,CAACyG,MAAM,EAAEjC,CAAC,IAAI,CAAC,EAAE;MAC5C,IAAIwE,UAAU,CAAC,IAAI,CAAChJ,MAAM,CAACwE,CAAC,CAAC,CAAC,EAAE;QAC5B,OAAOA,CAAC;MACZ;IACJ;IACA,IAAI,IAAI,CAACnD,aAAa,IAAI,IAAI,IAAI,IAAI,CAACiI,mBAAmB,CAACnD,EAAE,CAAC,EAAE;MAC5D;MACA,KAAK,IAAI3B,CAAC,GAAG,IAAI,CAACnD,aAAa,CAACoF,MAAM,GAAG,CAAC,EAAEjC,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;QACrD,IAAIwE,UAAU,CAAC,IAAI,CAAC3H,aAAa,CAACmD,CAAC,CAAC,CAAC0C,KAAK,CAAC,EAAE;UACzC;UACA,OAAOjI,aAAa,CAACsK,aAAa,GAAG/E,CAAC;QAC1C;MACJ;IACJ;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;EACI8E,mBAAmBA,CAACnD,EAAE,EAAE;IACpB,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;EACIqD,SAASA,CAAClE,MAAM,EAAEa,EAAE,EAAE;IAClB,IAAI,CAACA,EAAE,CAACsD,UAAU,CAAC,CAAC,IAAI,IAAI,CAACjH,KAAK,CAACwD,SAAS,CAAC,CAAC,EAAE;MAC5C,MAAM0D,MAAM,GAAG,IAAI,CAACf,iBAAiB,CAACxC,EAAE,CAAC;MACzC,IAAIuD,MAAM,EAAE;QACR,IAAI,CAACC,KAAK,CAACxD,EAAE,CAAC2C,SAAS,CAAC,CAAC,EAAE3C,EAAE,CAAC4C,SAAS,CAAC,CAAC,EAAEW,MAAM,CAAC;QAClDvD,EAAE,CAACyD,OAAO,CAAC,CAAC;MAChB;IACJ;EACJ;EACA;AACJ;AACA;AACA;EACIC,mBAAmBA,CAAA,EAAG;IAClB,OAAQ,IAAI,CAAC9J,KAAK,CAACmH,KAAK,IACpB,IAAI,CAACnH,KAAK,CAACmH,KAAK,CAAC4C,IAAI,KAAKjL,IAAI,IAC9B,IAAI,CAACkB,KAAK,CAACmH,KAAK,CAAC6C,MAAM,KAAKlL,IAAI;EACxC;EACA;AACJ;AACA;EACI8K,KAAKA,CAAC9G,CAAC,EAAEC,CAAC,EAAE5C,KAAK,EAAE;IACf,IAAI,CAAC4B,iBAAiB,GAAG,IAAI,CAACnB,WAAW,IAAI,IAAI,CAACZ,KAAK,CAAC+D,IAAI,CAACkG,aAAa,CAAC,CAAC,KAAK,CAAC;IAClF,IAAI,CAAC1I,WAAW,GAAG,IAAI;IACvB,IAAI,CAACS,YAAY,GAAG,CAAC;IACrB,IAAI,CAACC,YAAY,GAAG,CAAC;IACrB,IAAI,CAAC9B,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACqB,MAAM,GAAGsB,CAAC;IACf,IAAI,CAACrB,MAAM,GAAGsB,CAAC;IACf,IAAI,IAAI,CAAC5C,KAAK,IAAIjB,aAAa,CAACsK,aAAa,IAAI,IAAI,CAACU,cAAc,CAAC,CAAC,EAAE;MACpE,IAAI,CAACpI,YAAY,GAAG,IAAI,CAACqI,kBAAkB,CAAC,CAAC;IACjD,CAAC,MACI;MACD;MACA,MAAM;QAAEC;MAAM,CAAC,GAAG,IAAI,CAACpK,KAAK,CAAC0C,IAAI,CAACD,KAAK;MACvC,MAAM4H,MAAM,GAAG,IAAI,CAACrK,KAAK,CAAC+D,IAAI,CAACuG,SAAS,CAAC,CAAC;MAC1C,IAAI,IAAI,CAACtK,KAAK,CAAC0C,IAAI,CAAC6H,WAAW,KAAKF,MAAM,IACtCA,MAAM,KACLA,MAAM,CAACG,QAAQ,CAAC,CAAC,IAAIH,MAAM,CAACI,MAAM,CAAC,CAAC,CAAC,EAAE;QACxC,IAAI,CAACvI,WAAW,GAAG,IAAI,CAAClC,KAAK,CAAC0C,IAAI,CAACD,KAAK,CAACC,IAAI,CAACgI,QAAQ,CAACL,MAAM,CAAC;MAClE;MACA;MACA,IAAI,CAACnH,eAAe,CAACW,IAAI,CAACL,KAAK,CAACmF,OAAO,GACnCxI,KAAK,KAAKjB,aAAa,CAACgG,eAAe,GAAG,QAAQ,GAAG,MAAM;MAC/D;MACA,IAAI,CAAC,IAAI,CAACnD,iBAAiB,IAAI,IAAI,CAAC+H,mBAAmB,CAAC,CAAC,EAAE;QACvD,IAAI,CAACzH,OAAO,GAAG,IAAI,CAACc,oBAAoB,CAAC,IAAI,CAACN,MAAM,CAAC;QACrD,IAAI,EAAElD,MAAM,CAACgL,MAAM,IAAIC,MAAM,CAAC,IAAI,CAAC5K,KAAK,CAACwD,KAAK,CAACD,QAAQ,IAAI,GAAG,CAAC,KAAK,CAAC,CAAC,IAClE,IAAI,CAACvD,KAAK,CAACgI,IAAI,IAAI,IAAI,IACvB,IAAI,CAAChI,KAAK,CAACgI,IAAI,CAACnE,IAAI,CAACoE,UAAU,KAAK,IAAI,CAACxF,KAAK,CAACyF,SAAS,EAAE;UAC1D,IAAI,CAAC7F,OAAO,CAACe,OAAO,GAAG5E,OAAO,CAAC2J,UAAU;UACzC,IAAI,CAAC9F,OAAO,CAACoB,IAAI,CAAC,IAAI,CAAChB,KAAK,CAACyF,SAAS,CAAC;QAC3C,CAAC,MACI;UACD,IAAI,CAAC7F,OAAO,CAACe,OAAO,GAAG5E,OAAO,CAAC6E,GAAG;UAClC,IAAI,CAAChB,OAAO,CAACoB,IAAI,CAAC,IAAI,CAAChB,KAAK,CAACC,IAAI,CAACiB,cAAc,CAAC,CAAC,CAAC;QACvD;MACJ;MACA,IAAIxD,KAAK,KAAKjB,aAAa,CAACgG,eAAe,EAAE;QACzC;QACA,MAAM2F,GAAG,GAAG,IAAI,CAACC,yBAAyB,CAAC,CAAC;QAC5C,MAAMC,EAAE,GAAGF,GAAG,CAAC/H,CAAC,GAAG,IAAI,CAAC9C,KAAK,CAACgL,UAAU,CAAC,CAAC;QAC1C,MAAMC,EAAE,GAAGJ,GAAG,CAAC9H,CAAC,GAAG,IAAI,CAAC/C,KAAK,CAACkL,UAAU,CAAC,CAAC;QAC1C,IAAI,CAACtJ,UAAU,GAAGmJ,EAAE,KAAK,CAAC,GAAI/D,IAAI,CAACmE,IAAI,CAACF,EAAE,GAAGF,EAAE,CAAC,GAAG,GAAG,GAAI/D,IAAI,CAACoE,EAAE,GAAG,EAAE,GAAG,CAAC;QAC1E,IAAI,CAACvJ,SAAS,GAAGmF,IAAI,CAACqE,IAAI,CAACN,EAAE,GAAGA,EAAE,GAAGE,EAAE,GAAGA,EAAE,CAAC;MACjD;MACA;MACA,IAAI,IAAI,CAAClJ,iBAAiB,EAAE;QACxB,IAAI,CAACuJ,UAAU,CAAC,CAAC;QACjB,IAAInL,KAAK,KAAKjB,aAAa,CAACgG,eAAe,IAAI,IAAI,CAACxD,aAAa,EAAE;UAC/D,IAAI,CAACA,aAAa,CAACmC,IAAI,CAACL,KAAK,CAACmF,OAAO,GAAG,EAAE;QAC9C,CAAC,MACI,IAAIxI,KAAK,KAAKjB,aAAa,CAAC6F,YAAY,IAAI,IAAI,CAACzC,UAAU,EAAE;UAC9D,IAAI,CAACA,UAAU,CAACuB,IAAI,CAACL,KAAK,CAACmF,OAAO,GAAG,EAAE;QAC3C,CAAC,MACI,IAAI,IAAI,CAAC1I,MAAM,CAACE,KAAK,CAAC,EAAE;UACzB,IAAI,CAACF,MAAM,CAACE,KAAK,CAAC,CAAC0D,IAAI,CAACL,KAAK,CAACmF,OAAO,GAAG,EAAE;QAC9C,CAAC,MACI,IAAIxI,KAAK,IAAIjB,aAAa,CAACsK,aAAa,EAAE;UAC3C,IAAI,CAAClI,aAAa,CAACpC,aAAa,CAACsK,aAAa,GAAGrJ,KAAK,CAAC,CAACoL,UAAU,CAAC,IAAI,CAAC;QAC5E;QACA;QACA,MAAMC,KAAK,GAAG,IAAI,CAACxL,KAAK,CAAC+D,IAAI,CAAC0H,QAAQ,CAAC,CAAC;QACxC,IAAI,CAAClJ,YAAY,GAAG,EAAE;QACtB,MAAMmJ,qBAAqB,GAAG,IAAI,CAACjJ,KAAK,CAAC0B,SAAS,CAAC,uBAAuB,CAAC;QAC3E,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+G,KAAK,CAAC9E,MAAM,EAAEjC,CAAC,IAAI,CAAC,EAAE;UACtC,MAAMkH,OAAO,GAAGD,qBAAqB,EAAEE,UAAU,CAACJ,KAAK,CAAC/G,CAAC,CAAC,CAAC;UAC3D,IAAIkH,OAAO,EAAE;YACT,IAAI,CAACpJ,YAAY,CAACmC,IAAI,CAACiH,OAAO,CAAC;UACnC;QACJ;MACJ;IACJ;EACJ;EACA;AACJ;AACA;EACIxB,kBAAkBA,CAAA,EAAG;IACjB,MAAMhD,KAAK,GAAG,IAAI,CAAC1E,KAAK,CAACgD,YAAY,CAACoG,WAAW,CAAC,IAAI,CAAC7L,KAAK,CAAC;IAC7DmH,KAAK,CAAC1D,IAAI,CAAC,IAAI,CAAChB,KAAK,CAACC,IAAI,CAACiB,cAAc,CAAC,CAAC,CAAC;IAC5CwD,KAAK,CAACN,KAAK,GAAG,IAAI,CAAC7G,KAAK,CAAC0C,IAAI,CAACmE,KAAK;IACnCM,KAAK,CAACtE,MAAM,GAAG,IAAI,CAACA,MAAM;IAC1BsE,KAAK,CAAC2E,OAAO,GAAG,IAAI;IACpB,OAAO3E,KAAK;EAChB;EACA;AACJ;AACA;EACI4E,iBAAiBA,CAACzD,OAAO,EAAE;IACvB,IAAI,CAAChI,cAAc,GAAGgI,OAAO;IAC7B,KAAK,IAAI7D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACxE,MAAM,CAACyG,MAAM,EAAEjC,CAAC,IAAI,CAAC,EAAE;MAC5C,IAAI,CAACxE,MAAM,CAACwE,CAAC,CAAC,CAACZ,IAAI,CAACL,KAAK,CAACmF,OAAO,GAAGL,OAAO,GAAG,EAAE,GAAG,MAAM;IAC7D;IACA,KAAK,IAAI7D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACnD,aAAa,CAACoF,MAAM,EAAEjC,CAAC,IAAI,CAAC,EAAE;MACnD,IAAI,CAACnD,aAAa,CAACmD,CAAC,CAAC,CAAC8G,UAAU,CAACjD,OAAO,CAAC;IAC7C;EACJ;EACA;AACJ;AACA;AACA;AACA;EACIgD,UAAUA,CAAA,EAAG;IACT,IAAI,CAACS,iBAAiB,CAAC,KAAK,CAAC;EACjC;EACA;AACJ;AACA;AACA;AACA;EACIC,cAAcA,CAAC5F,EAAE,EAAE;IACf,IAAI,IAAI,CAAC7E,WAAW,IAAI,IAAI,CAACC,MAAM,KAAK,IAAI,IAAI,IAAI,CAACC,MAAM,KAAK,IAAI,EAAE;MAClE,IAAI7B,YAAY,CAACwG,EAAE,CAACC,QAAQ,CAAC,CAAC,CAAC,IAC3BW,IAAI,CAACiF,GAAG,CAAC7F,EAAE,CAAC2C,SAAS,CAAC,CAAC,GAAG,IAAI,CAACvH,MAAM,CAAC,GAAG,IAAI,CAACiB,KAAK,CAACyJ,iBAAiB,CAAC,CAAC,IACvElF,IAAI,CAACiF,GAAG,CAAC7F,EAAE,CAAC4C,SAAS,CAAC,CAAC,GAAG,IAAI,CAACvH,MAAM,CAAC,GAAG,IAAI,CAACgB,KAAK,CAACyJ,iBAAiB,CAAC,CAAC,EAAE;QACzE,IAAI,CAAC3K,WAAW,GAAG,KAAK;MAC5B;IACJ;EACJ;EACA;AACJ;AACA;EACI4K,UAAUA,CAAC/F,EAAE,EAAE;IACX;EACJ;EACA;AACJ;AACA;EACIgG,UAAUA,CAAA,EAAG;IACT;EACJ;EACA;AACJ;AACA;EACIC,UAAUA,CAACC,KAAK,EAAE;IACd,OAAOtF,IAAI,CAACC,KAAK,CAACqF,KAAK,GAAG,EAAE,CAAC,GAAG,EAAE;EACtC;EACA;AACJ;AACA;EACIC,WAAWA,CAAC7F,MAAM,EAAE;IAChB,OAAOM,IAAI,CAACC,KAAK,CAACP,MAAM,GAAG,GAAG,CAAC,GAAG,GAAG;EACzC;EACA;AACJ;AACA;EACI8F,SAASA,CAACjH,MAAM,EAAEa,EAAE,EAAE;IAClB,IAAI,CAACA,EAAE,CAACsD,UAAU,CAAC,CAAC,IAAI,IAAI,CAACvJ,KAAK,IAAI,IAAI,EAAE;MACxC;MACA,IAAI,CAAC6L,cAAc,CAAC5F,EAAE,CAAC;MACvB,IAAI,CAAC,IAAI,CAAC7E,WAAW,EAAE;QACnB,IAAI,IAAI,CAACpB,KAAK,IAAIjB,aAAa,CAACsK,aAAa,EAAE;UAC3C,IAAI,IAAI,CAAClI,aAAa,IAAI,IAAI,EAAE;YAC5B,IAAI,CAACA,aAAa,CAACpC,aAAa,CAACsK,aAAa,GAAG,IAAI,CAACrJ,KAAK,CAAC,CAACsM,YAAY,CAACrG,EAAE,CAAC;YAC7E,IAAI,CAAC9E,aAAa,CAACpC,aAAa,CAACsK,aAAa,GAAG,IAAI,CAACrJ,KAAK,CAAC,CAACuM,MAAM,GAAG,IAAI;YAC1E,IAAI,IAAI,CAAC5K,YAAY,IAAI,IAAI,EAAE;cAC3B,IAAI,CAACA,YAAY,CAAC6K,KAAK,CAAC,IAAI,CAAC3M,KAAK,CAAC;cACnC,IAAI,CAAC8B,YAAY,CAACwF,WAAW,GACzB,IAAI,CAACC,uBAAuB,CAAC,CAAC,GAC1B,IAAI,CAACzF,YAAY,CAAC+E,KAAK,GACvB,IAAI,CAAC/E,YAAY,CAAC+E,KAAK;cAC/B,IAAI,CAAC/E,YAAY,CAAC0F,QAAQ,GAAG,IAAI,CAACC,iBAAiB,CAAC,CAAC;cACrD,IAAI,CAAC3F,YAAY,CAACkI,MAAM,GAAG,IAAI,CAAC3C,iBAAiB,CAAC,CAAC;cACnD,IAAI,CAACvF,YAAY,CAACsD,MAAM,CAAC,CAAC;cAC1B,IAAI,IAAI,CAACzC,eAAe,IAAI,IAAI,EAAE;gBAC9B,IAAI,CAACO,eAAe,CAACW,IAAI,CAACL,KAAK,CAACmF,OAAO,GAAG,MAAM;cACpD;YACJ,CAAC,MACI;cACD,IAAI,IAAI,CAAC9H,kBAAkB,EAAE;gBACzB,IAAI,CAAC+L,WAAW,CAAC,CAAC;cACtB;cACA,IAAI,CAACtL,aAAa,CAACpC,aAAa,CAACsK,aAAa,GAAG,IAAI,CAACrJ,KAAK,CAAC,CAAC0M,eAAe,CAAC,CAAC;YAClF;UACJ;QACJ,CAAC,MACI,IAAI,IAAI,CAAC1M,KAAK,KAAKjB,aAAa,CAAC6F,YAAY,EAAE;UAChD,IAAI,CAAC+H,SAAS,CAAC1G,EAAE,CAAC;QACtB,CAAC,MACI;UACD,IAAI,IAAI,CAACjG,KAAK,KAAKjB,aAAa,CAACgG,eAAe,EAAE;YAC9C,IAAI,CAAC6H,YAAY,CAAC3G,EAAE,CAAC;UACzB,CAAC,MACI;YACD,IAAI,CAAC4G,YAAY,CAAC5G,EAAE,CAAC;UACzB;UACA,IAAI,CAAC+F,UAAU,CAAC/F,EAAE,CAAC;QACvB;MACJ;MACAA,EAAE,CAACyD,OAAO,CAAC,CAAC;IAChB;IACA;IAAA,KACK,IAAI,CAAC,IAAI,CAACpH,KAAK,CAACwK,WAAW,IAAI,IAAI,CAACrE,iBAAiB,CAACxC,EAAE,CAAC,EAAE;MAC5DA,EAAE,CAACyD,OAAO,CAAC,KAAK,CAAC;IACrB;EACJ;EACA;AACJ;AACA;EACIK,cAAcA,CAAA,EAAG;IACb,OAAO,IAAI,CAAClK,KAAK,CAAC+D,IAAI,CAACkG,aAAa,CAAC,CAAC,GAAG,CAAC;EAC9C;EACA;AACJ;AACA;EACI6C,SAASA,CAAC1G,EAAE,EAAE;IACV,MAAM8G,KAAK,GAAG,IAAI5N,KAAK,CAAC8G,EAAE,CAAC2C,SAAS,CAAC,CAAC,EAAE3C,EAAE,CAAC4C,SAAS,CAAC,CAAC,CAAC;IACvD,MAAMmE,EAAE,GAAG,IAAI,CAAC1K,KAAK,CAACC,IAAI,CAACqE,SAAS;IACpC,MAAM;MAAEF;IAAM,CAAC,GAAG,IAAI,CAACpE,KAAK,CAACC,IAAI;IACjC,IAAI,IAAI,CAACD,KAAK,CAAC2K,kBAAkB,CAAChH,EAAE,CAACC,QAAQ,CAAC,CAAC,CAAC,EAAE;MAC9C6G,KAAK,CAACpK,CAAC,GAAG,CAAC,IAAI,CAACL,KAAK,CAAC4K,IAAI,CAACH,KAAK,CAACpK,CAAC,GAAG+D,KAAK,GAAGsG,EAAE,CAACrK,CAAC,CAAC,GAAGqK,EAAE,CAACrK,CAAC,IAAI+D,KAAK;MAClEqG,KAAK,CAACnK,CAAC,GAAG,CAAC,IAAI,CAACN,KAAK,CAAC4K,IAAI,CAACH,KAAK,CAACnK,CAAC,GAAG8D,KAAK,GAAGsG,EAAE,CAACpK,CAAC,CAAC,GAAGoK,EAAE,CAACpK,CAAC,IAAI8D,KAAK;IACtE;IACA,MAAM1G,KAAK,GAAG,IAAI,CAACuB,aAAa,GAAG,IAAI,CAACzB,MAAM,CAACyG,MAAM,GAAG,CAAC,GAAG,IAAI,CAACzG,MAAM,CAACyG,MAAM,GAAG,CAAC;IAClF,IAAI,CAAC+B,WAAW,CAAC,IAAI,CAACxI,MAAM,CAACE,KAAK,CAAC,EAAE+M,KAAK,CAACpK,CAAC,EAAEoK,KAAK,CAACnK,CAAC,CAAC;EAC1D;EACA;AACJ;AACA;EACIgK,YAAYA,CAAC3G,EAAE,EAAE;IACb,MAAM8G,KAAK,GAAG,IAAI5N,KAAK,CAAC8G,EAAE,CAAC2C,SAAS,CAAC,CAAC,EAAE3C,EAAE,CAAC4C,SAAS,CAAC,CAAC,CAAC;IACvD,IAAI+B,EAAE,GAAG,IAAI,CAAC/K,KAAK,CAAC8C,CAAC,GAAG,IAAI,CAAC9C,KAAK,CAACgD,KAAK,GAAG,CAAC,GAAGkK,KAAK,CAACpK,CAAC;IACtD,IAAImI,EAAE,GAAG,IAAI,CAACjL,KAAK,CAAC+C,CAAC,GAAG,IAAI,CAAC/C,KAAK,CAACiD,MAAM,GAAG,CAAC,GAAGiK,KAAK,CAACnK,CAAC;IACvD,IAAI,CAACpB,YAAY,GACboJ,EAAE,KAAK,CAAC,GAAI/D,IAAI,CAACmE,IAAI,CAACF,EAAE,GAAGF,EAAE,CAAC,GAAG,GAAG,GAAI/D,IAAI,CAACoE,EAAE,GAAG,EAAE,GAAGH,EAAE,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC;IAC3E,IAAIF,EAAE,GAAG,CAAC,EAAE;MACR,IAAI,CAACpJ,YAAY,IAAI,GAAG;IAC5B;IACA,IAAI,CAACA,YAAY,IAAI,IAAI,CAACC,UAAU;IACpC;IACA,IAAI,IAAI,CAAClB,cAAc,IAAI,IAAI,CAAC+B,KAAK,CAAC2K,kBAAkB,CAAChH,EAAE,CAACC,QAAQ,CAAC,CAAC,CAAC,EAAE;MACrE,IAAIiH,MAAM;MACVvC,EAAE,GAAGmC,KAAK,CAACpK,CAAC,GAAG,IAAI,CAAC9C,KAAK,CAACgL,UAAU,CAAC,CAAC;MACtCC,EAAE,GAAGiC,KAAK,CAACnK,CAAC,GAAG,IAAI,CAAC/C,KAAK,CAACkL,UAAU,CAAC,CAAC;MACtC,MAAMqC,IAAI,GAAGvG,IAAI,CAACqE,IAAI,CAACN,EAAE,GAAGA,EAAE,GAAGE,EAAE,GAAGA,EAAE,CAAC;MACzC,IAAIsC,IAAI,GAAG,IAAI,CAAC1L,SAAS,GAAG,CAAC,EAAE;QAC3ByL,MAAM,GAAG,EAAE;MACf,CAAC,MACI,IAAIC,IAAI,GAAG,IAAI,CAAC1L,SAAS,GAAG,EAAE,EAAE;QACjCyL,MAAM,GAAG,CAAC;MACd,CAAC,MACI;QACDA,MAAM,GAAG,CAAC;MACd;MACA,IAAI,CAAC3L,YAAY,GAAGqF,IAAI,CAACC,KAAK,CAAC,IAAI,CAACtF,YAAY,GAAG2L,MAAM,CAAC,GAAGA,MAAM;IACvE,CAAC,MACI;MACD,IAAI,CAAC3L,YAAY,GAAG,IAAI,CAAC0K,UAAU,CAAC,IAAI,CAAC1K,YAAY,CAAC;IAC1D;IACA,IAAI,CAACuB,eAAe,CAACK,QAAQ,GAAG,IAAI,CAAC5B,YAAY;IACjD,IAAI,CAACuB,eAAe,CAACkC,MAAM,CAAC,CAAC;IAC7B,IAAI,IAAI,CAACrD,iBAAiB,EAAE;MACxB,IAAI,CAACyL,aAAa,CAAC,CAAC;IACxB;EACJ;EACA;AACJ;AACA;EACIR,YAAYA,CAAC5G,EAAE,EAAE;IACb,MAAMqH,EAAE,GAAG,IAAInO,KAAK,CAAC,IAAI,CAACU,KAAK,CAACgL,UAAU,CAAC,CAAC,EAAE,IAAI,CAAChL,KAAK,CAACkL,UAAU,CAAC,CAAC,CAAC;IACtE,MAAMwC,KAAK,GAAGhO,SAAS,CAAC,IAAI,CAACM,KAAK,CAACwD,KAAK,CAACD,QAAQ,IAAI,CAAC,CAAC;IACvD,MAAM2J,KAAK,GAAG,IAAI5N,KAAK,CAAC8G,EAAE,CAAC2C,SAAS,CAAC,CAAC,EAAE3C,EAAE,CAAC4C,SAAS,CAAC,CAAC,CAAC;IACvD,MAAMmE,EAAE,GAAG,IAAI,CAAC1K,KAAK,CAACC,IAAI,CAACqE,SAAS;IACpC,MAAM;MAAEF;IAAM,CAAC,GAAG,IAAI,CAACpE,KAAK,CAACC,IAAI;IACjC,IAAIiL,GAAG,GAAG3G,IAAI,CAAC2G,GAAG,CAAC,CAACD,KAAK,CAAC;IAC1B,IAAIE,GAAG,GAAG5G,IAAI,CAAC4G,GAAG,CAAC,CAACF,KAAK,CAAC;IAC1B,IAAI3C,EAAE,GAAGmC,KAAK,CAACpK,CAAC,GAAG,IAAI,CAACtB,MAAM;IAC9B,IAAIyJ,EAAE,GAAGiC,KAAK,CAACnK,CAAC,GAAG,IAAI,CAACtB,MAAM;IAC9B;IACA,MAAMoM,EAAE,GAAGF,GAAG,GAAG5C,EAAE,GAAG6C,GAAG,GAAG3C,EAAE;IAC9B,MAAM6C,EAAE,GAAGF,GAAG,GAAG7C,EAAE,GAAG4C,GAAG,GAAG1C,EAAE;IAC9BF,EAAE,GAAG8C,EAAE;IACP5C,EAAE,GAAG6C,EAAE;IACP,MAAMlJ,GAAG,GAAG,IAAI,CAAC5E,KAAK,CAAC+D,IAAI,CAACc,WAAW,CAAC,CAAC;IACzC,IAAID,GAAG,IAAI,IAAI,CAACzE,KAAK,KAAK,IAAI,EAAE;MAC5B,IAAI,CAACiC,cAAc,GAAG,IAAI,CAAC2L,KAAK,CAACnJ,GAAG,EAAEmG,EAAE,GAAGlE,KAAK,EAAEoE,EAAE,GAAGpE,KAAK,EAAE,IAAI,CAAC1G,KAAK,EAAE,IAAI,CAACsC,KAAK,CAAC2K,kBAAkB,CAAChH,EAAE,CAACC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI/G,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC6G,kBAAkB,CAACC,EAAE,CAAC,EAAE,IAAI,CAACG,eAAe,CAAC,IAAI,CAACvG,KAAK,EAAEoG,EAAE,CAAC,CAAC;IAClN;IACA;IACA,IAAIxB,GAAG,IAAI,CAACA,GAAG,CAACE,QAAQ,EAAE;MACtB,IAAIkJ,GAAG,GAAG,IAAI,CAACvL,KAAK,CAACwL,qBAAqB,CAAC,CAAC;MAC5C;MACA,IAAID,GAAG,IAAI,IAAI,IAAI,IAAI,CAAC9L,WAAW,IAAI,IAAI,EAAE;QACzC8L,GAAG,GAAG1P,SAAS,CAAC8I,aAAa,CAAC4G,GAAG,CAAC;QAClCA,GAAG,CAAClL,CAAC,IAAI,CAAC,IAAI,CAACZ,WAAW,CAACY,CAAC,GAAGqK,EAAE,CAACrK,CAAC,GAAG+D,KAAK,IAAIA,KAAK;QACpDmH,GAAG,CAACjL,CAAC,IAAI,CAAC,IAAI,CAACb,WAAW,CAACa,CAAC,GAAGoK,EAAE,CAACpK,CAAC,GAAG8D,KAAK,IAAIA,KAAK;MACxD;MACA,IAAI,IAAI,CAACpE,KAAK,CAACyL,gBAAgB,CAAC,IAAI,CAAClO,KAAK,CAAC+D,IAAI,CAAC,EAAE;QAC9C,IAAIoK,GAAG,GAAG,IAAI,CAAC1L,KAAK,CAAC2L,sBAAsB,CAAC,IAAI,CAACpO,KAAK,CAAC+D,IAAI,CAAC;QAC5D,IAAIoK,GAAG,IAAI,IAAI,EAAE;UACb,MAAME,OAAO,GAAG,IAAI,CAAC5L,KAAK,CAAC6L,UAAU,CAAC,IAAI,CAACtO,KAAK,CAAC+D,IAAI,CAAC;UACtD,IAAIsK,OAAO,GAAG,CAAC,EAAE;YACbF,GAAG,GAAG7P,SAAS,CAAC8I,aAAa,CAAC+G,GAAG,CAAC;YAClCA,GAAG,CAACrL,CAAC,IAAIqL,GAAG,CAACnL,KAAK,GAAGqL,OAAO;YAC5BF,GAAG,CAACpL,CAAC,IAAIoL,GAAG,CAAClL,MAAM,GAAGoL,OAAO;YAC7BF,GAAG,CAACnL,KAAK,IAAI,CAAC,GAAGmL,GAAG,CAACnL,KAAK,GAAGqL,OAAO;YACpCF,GAAG,CAAClL,MAAM,IAAI,CAAC,GAAGkL,GAAG,CAAClL,MAAM,GAAGoL,OAAO;UAC1C;UACA,IAAI,CAACL,GAAG,EAAE;YACNA,GAAG,GAAGG,GAAG;UACb,CAAC,MACI;YACDH,GAAG,GAAG1P,SAAS,CAAC8I,aAAa,CAAC4G,GAAG,CAAC;YAClCA,GAAG,CAACO,SAAS,CAACJ,GAAG,CAAC;UACtB;QACJ;MACJ;MACA,IAAIH,GAAG,IAAI,IAAI,CAAC5L,cAAc,EAAE;QAC5B,IAAI,IAAI,CAACA,cAAc,CAACU,CAAC,GAAGkL,GAAG,CAAClL,CAAC,EAAE;UAC/B,IAAI,CAACV,cAAc,CAACY,KAAK,IAAIgL,GAAG,CAAClL,CAAC,GAAG,IAAI,CAACV,cAAc,CAACU,CAAC;UAC1D,IAAI,CAACV,cAAc,CAACU,CAAC,GAAGkL,GAAG,CAAClL,CAAC;QACjC;QACA,IAAI,IAAI,CAACV,cAAc,CAACW,CAAC,GAAGiL,GAAG,CAACjL,CAAC,EAAE;UAC/B,IAAI,CAACX,cAAc,CAACa,MAAM,IAAI+K,GAAG,CAACjL,CAAC,GAAG,IAAI,CAACX,cAAc,CAACW,CAAC;UAC3D,IAAI,CAACX,cAAc,CAACW,CAAC,GAAGiL,GAAG,CAACjL,CAAC;QACjC;QACA,IAAI,IAAI,CAACX,cAAc,CAACU,CAAC,GAAG,IAAI,CAACV,cAAc,CAACY,KAAK,GAAGgL,GAAG,CAAClL,CAAC,GAAGkL,GAAG,CAAChL,KAAK,EAAE;UACvE,IAAI,CAACZ,cAAc,CAACY,KAAK,IACrB,IAAI,CAACZ,cAAc,CAACU,CAAC,GAAG,IAAI,CAACV,cAAc,CAACY,KAAK,GAAGgL,GAAG,CAAClL,CAAC,GAAGkL,GAAG,CAAChL,KAAK;QAC7E;QACA,IAAI,IAAI,CAACZ,cAAc,CAACW,CAAC,GAAG,IAAI,CAACX,cAAc,CAACa,MAAM,GAAG+K,GAAG,CAACjL,CAAC,GAAGiL,GAAG,CAAC/K,MAAM,EAAE;UACzE,IAAI,CAACb,cAAc,CAACa,MAAM,IACtB,IAAI,CAACb,cAAc,CAACW,CAAC,GAAG,IAAI,CAACX,cAAc,CAACa,MAAM,GAAG+K,GAAG,CAACjL,CAAC,GAAGiL,GAAG,CAAC/K,MAAM;QAC/E;MACJ;IACJ;IACA,IAAI,IAAI,CAACb,cAAc,EAAE;MACrB,MAAMoM,GAAG,GAAG,IAAI,CAAC3L,MAAM;MACvB,IAAI,CAACA,MAAM,GAAG,IAAIvE,SAAS,CAAC,CAAC,IAAI,CAAC4D,WAAW,GAAG,IAAI,CAACA,WAAW,CAACY,CAAC,GAAGqK,EAAE,CAACrK,CAAC,GAAG+D,KAAK,IAC7E,IAAI,CAACzE,cAAc,CAACU,CAAC,GAAG+D,KAAK,EAAE,CAAC,IAAI,CAAC3E,WAAW,GAAG,IAAI,CAACA,WAAW,CAACa,CAAC,GAAGoK,EAAE,CAACpK,CAAC,GAAG8D,KAAK,IACpF,IAAI,CAACzE,cAAc,CAACW,CAAC,GAAG8D,KAAK,EAAE,IAAI,CAACzE,cAAc,CAACY,KAAK,GAAG6D,KAAK,EAAE,IAAI,CAACzE,cAAc,CAACa,MAAM,GAAG4D,KAAK,CAAC;MACzG,IAAIjC,GAAG,IAAIA,GAAG,CAACE,QAAQ,IAAI,IAAI,CAAC5C,WAAW,EAAE;QACzC,IAAI,CAACW,MAAM,CAACC,CAAC,IAAI,IAAI,CAAC9C,KAAK,CAAC8C,CAAC,GAAG,IAAI,CAACZ,WAAW,CAACY,CAAC;QAClD,IAAI,CAACD,MAAM,CAACE,CAAC,IAAI,IAAI,CAAC/C,KAAK,CAAC+C,CAAC,GAAG,IAAI,CAACb,WAAW,CAACa,CAAC;MACtD;MACA4K,GAAG,GAAG3G,IAAI,CAAC2G,GAAG,CAACD,KAAK,CAAC;MACrBE,GAAG,GAAG5G,IAAI,CAAC4G,GAAG,CAACF,KAAK,CAAC;MACrB,MAAMe,EAAE,GAAG,IAAInP,KAAK,CAAC,IAAI,CAACuD,MAAM,CAACmI,UAAU,CAAC,CAAC,EAAE,IAAI,CAACnI,MAAM,CAACqI,UAAU,CAAC,CAAC,CAAC;MACxEH,EAAE,GAAG0D,EAAE,CAAC3L,CAAC,GAAG2K,EAAE,CAAC3K,CAAC;MAChBmI,EAAE,GAAGwD,EAAE,CAAC1L,CAAC,GAAG0K,EAAE,CAAC1K,CAAC;MAChB,MAAM2L,GAAG,GAAGf,GAAG,GAAG5C,EAAE,GAAG6C,GAAG,GAAG3C,EAAE;MAC/B,MAAM0D,GAAG,GAAGf,GAAG,GAAG7C,EAAE,GAAG4C,GAAG,GAAG1C,EAAE;MAC/B,MAAM2D,GAAG,GAAGF,GAAG,GAAG3D,EAAE;MACpB,MAAM8D,GAAG,GAAGF,GAAG,GAAG1D,EAAE;MACpB,MAAM6D,GAAG,GAAG,IAAI,CAACjM,MAAM,CAACC,CAAC,GAAG,IAAI,CAAC9C,KAAK,CAAC8C,CAAC;MACxC,MAAMiM,GAAG,GAAG,IAAI,CAAClM,MAAM,CAACE,CAAC,GAAG,IAAI,CAAC/C,KAAK,CAAC+C,CAAC;MACxC,MAAMiM,GAAG,GAAGrB,GAAG,GAAGmB,GAAG,GAAGlB,GAAG,GAAGmB,GAAG;MACjC,MAAME,GAAG,GAAGrB,GAAG,GAAGkB,GAAG,GAAGnB,GAAG,GAAGoB,GAAG;MACjC,IAAI,CAAClM,MAAM,CAACC,CAAC,IAAI8L,GAAG;MACpB,IAAI,CAAC/L,MAAM,CAACE,CAAC,IAAI8L,GAAG;MACpB;MACA,IAAI,CAACzM,cAAc,CAACU,CAAC,GAAG,IAAI,CAACyJ,WAAW,CAAC,IAAI,CAACnK,cAAc,CAACU,CAAC,GAAG8L,GAAG,GAAG/H,KAAK,CAAC;MAC7E,IAAI,CAACzE,cAAc,CAACW,CAAC,GAAG,IAAI,CAACwJ,WAAW,CAAC,IAAI,CAACnK,cAAc,CAACW,CAAC,GAAG8L,GAAG,GAAGhI,KAAK,CAAC;MAC7E,IAAI,CAACzE,cAAc,CAACY,KAAK,GAAG,IAAI,CAACuJ,WAAW,CAAC,IAAI,CAACnK,cAAc,CAACY,KAAK,CAAC;MACvE,IAAI,CAACZ,cAAc,CAACa,MAAM,GAAG,IAAI,CAACsJ,WAAW,CAAC,IAAI,CAACnK,cAAc,CAACa,MAAM,CAAC;MACzE;MACA,IAAI,CAAC,IAAI,CAACjD,KAAK,CAAC+D,IAAI,CAACmL,WAAW,CAAC,CAAC,KAAKN,GAAG,KAAK,CAAC,IAAIC,GAAG,KAAK,CAAC,CAAC,EAAE;QAC5D,IAAI,CAAC7M,YAAY,GAAG,IAAI,CAAChC,KAAK,CAAC8C,CAAC,GAAG,IAAI,CAACD,MAAM,CAACC,CAAC,GAAGkM,GAAG;QACtD,IAAI,CAAC/M,YAAY,GAAG,IAAI,CAACjC,KAAK,CAAC+C,CAAC,GAAG,IAAI,CAACF,MAAM,CAACE,CAAC,GAAGkM,GAAG;MAC1D,CAAC,MACI;QACD,IAAI,CAACjN,YAAY,GAAG,CAAC;QACrB,IAAI,CAACC,YAAY,GAAG,CAAC;MACzB;MACA,IAAI,CAACuM,GAAG,CAACW,MAAM,CAAC,IAAI,CAACtM,MAAM,CAAC,EAAE;QAC1B,IAAI,IAAI,CAACd,iBAAiB,EAAE;UACxB,IAAI,CAACqN,iBAAiB,CAAChJ,EAAE,CAAC;QAC9B;QACA,IAAI,IAAI,CAAC/D,OAAO,IAAI,IAAI,EAAE;UACtB,IAAI,CAACgN,WAAW,CAAC,CAAC;QACtB,CAAC,MACI;UACD,IAAI,CAACC,qBAAqB,CAAC,CAAC;QAChC;MACJ;IACJ;EACJ;EACA;AACJ;AACA;EACIF,iBAAiBA,CAAChJ,EAAE,EAAE;IAClB;IACA,MAAM;MAAES;IAAM,CAAC,GAAG,IAAI,CAACpE,KAAK,CAACC,IAAI;IACjC,MAAMyK,EAAE,GAAG,IAAI,CAAC1K,KAAK,CAACC,IAAI,CAACqE,SAAS;IACpC;IACA,MAAMwI,SAAS,GAAG,IAAI,CAACvP,KAAK,CAACwP,KAAK,CAAC,CAAC;IACpC;IACA,IAAI,CAACxP,KAAK,CAAC8C,CAAC,GAAG,IAAI,CAACD,MAAM,CAACC,CAAC;IAC5B,IAAI,CAAC9C,KAAK,CAAC+C,CAAC,GAAG,IAAI,CAACF,MAAM,CAACE,CAAC;IAC5B,IAAI,CAAC/C,KAAK,CAACyP,MAAM,GAAG,IAAInQ,KAAK,CAAC,IAAI,CAACU,KAAK,CAAC8C,CAAC,GAAG+D,KAAK,GAAGsG,EAAE,CAACrK,CAAC,EAAE,IAAI,CAAC9C,KAAK,CAAC+C,CAAC,GAAG8D,KAAK,GAAGsG,EAAE,CAACpK,CAAC,CAAC;IACvF,IAAI,CAAC/C,KAAK,CAACgD,KAAK,GAAG,IAAI,CAACH,MAAM,CAACG,KAAK;IACpC,IAAI,CAAChD,KAAK,CAACiD,MAAM,GAAG,IAAI,CAACJ,MAAM,CAACI,MAAM;IACtC;IACA,IAAIyM,GAAG,GAAG,IAAI,CAAC1P,KAAK,CAAC2P,cAAc;IACnCD,GAAG,GAAG,IAAIpQ,KAAK,CAACoQ,GAAG,CAAC5M,CAAC,EAAE4M,GAAG,CAAC3M,CAAC,CAAC;IAC7B;IACA,IAAI,CAAC/C,KAAK,CAAC2P,cAAc,CAAC7M,CAAC,GAAG,CAAC;IAC/B,IAAI,CAAC9C,KAAK,CAAC2P,cAAc,CAAC5M,CAAC,GAAG,CAAC;IAC/B,MAAM6B,GAAG,GAAG,IAAI,CAAC5E,KAAK,CAAC+D,IAAI,CAACc,WAAW,CAAC,CAAC;IACzC,IAAID,GAAG,IAAI,IAAI,EAAE;MACb,MAAMgL,MAAM,GAAGhL,GAAG,CAACgL,MAAM,IAAI,IAAI,CAACpN,WAAW;MAC7C,IAAIoN,MAAM,IAAI,IAAI,IAAI,CAAChL,GAAG,CAACE,QAAQ,EAAE;QACjC,IAAI,CAAC9E,KAAK,CAAC2P,cAAc,CAAC7M,CAAC,GAAG,IAAI,CAAC9C,KAAK,CAAC0C,IAAI,CAACmE,KAAK,GAAG+I,MAAM,CAAC9M,CAAC;QAC9D,IAAI,CAAC9C,KAAK,CAAC2P,cAAc,CAAC5M,CAAC,GAAG,IAAI,CAAC/C,KAAK,CAAC0C,IAAI,CAACmE,KAAK,GAAG+I,MAAM,CAAC7M,CAAC;MAClE;MACA,IAAI,CAAC/C,KAAK,CAAC0C,IAAI,CAACmN,uBAAuB,CAAC,IAAI,CAAC7P,KAAK,CAAC;IACvD;IACA;IACA,IAAI,CAACA,KAAK,CAAC0C,IAAI,CAACD,KAAK,CAACgD,YAAY,CAACL,MAAM,CAAC,IAAI,CAACpF,KAAK,EAAE,IAAI,CAAC;IAC3D;IACA,IAAI,CAACA,KAAK,CAAC0C,IAAI,CAACgD,UAAU,CAAC,IAAI,CAAC1F,KAAK,CAAC+D,IAAI,CAAC;IAC3C,IAAI,CAAC/D,KAAK,CAAC2F,OAAO,GAAG,KAAK;IAC1B,IAAI,CAAC3F,KAAK,CAAC0C,IAAI,CAACkD,QAAQ,CAAC,CAAC;IAC1B,IAAI,CAAC4H,aAAa,CAAC,CAAC;IACpB;IACA,IAAI,IAAI,CAAC3M,kBAAkB,EAAE;MACzB,IAAI,CAAC+L,WAAW,CAAC,CAAC;IACtB;IACA;IACA,IAAI,IAAI,CAAC5M,KAAK,CAAC8P,OAAO,IAAI,IAAI,IAAI,IAAI,CAAC9P,KAAK,CAAC8P,OAAO,CAACjM,IAAI,IAAI,IAAI,EAAE;MAC/D,IAAI,CAAC7D,KAAK,CAAC8P,OAAO,CAACjM,IAAI,CAACL,KAAK,CAAC8F,UAAU,GAAG,QAAQ;IACvD;IACA;IACA,IAAI,CAACtJ,KAAK,CAAC+P,QAAQ,CAACR,SAAS,CAAC;EAClC;EACA;AACJ;AACA;EACI3C,WAAWA,CAAA,EAAG;IACV,IAAK,IAAI,CAAC5M,KAAK,CAACgI,IAAI,IAAI,IAAI,CAAChI,KAAK,CAACgI,IAAI,CAACnE,IAAI,IAAI,IAAI,CAAC7D,KAAK,CAACgI,IAAI,CAACnE,IAAI,CAACmM,WAAW,IAC3E,IAAI,CAAChQ,KAAK,CAACmH,KAAK,IACb,IAAI,CAACnH,KAAK,CAACmH,KAAK,CAACtD,IAAI,IACrB,IAAI,CAAC7D,KAAK,CAACmH,KAAK,CAACtD,IAAI,CAACmM,WAAW,KAChC,CAAC,IAAI,CAAChQ,KAAK,CAACgI,IAAI,IAAI,IAAI,CAAChI,KAAK,CAACmH,KAAK,CAACtD,IAAI,CAACmM,WAAW,KAAK,IAAI,CAAChQ,KAAK,CAACgI,IAAI,CAACnE,IAAI,CAAE,EAAE;MACvF,IAAI,IAAI,CAAC7D,KAAK,CAACmH,KAAK,IAAI,IAAI,CAACnH,KAAK,CAACmH,KAAK,CAACtD,IAAI,IAAI,IAAI,CAAC7D,KAAK,CAACmH,KAAK,CAACtD,IAAI,CAACoE,UAAU,EAAE;QAC/E,IAAI,CAACjI,KAAK,CAACmH,KAAK,CAACtD,IAAI,CAACoE,UAAU,CAACgI,WAAW,CAAC,IAAI,CAACjQ,KAAK,CAACmH,KAAK,CAACtD,IAAI,CAAC;MACvE;MACA,IAAI,IAAI,CAAC7D,KAAK,CAACgI,IAAI,IAAI,IAAI,CAAChI,KAAK,CAACgI,IAAI,CAACnE,IAAI,IAAI,IAAI,CAAC7D,KAAK,CAACgI,IAAI,CAACnE,IAAI,CAACoE,UAAU,EAAE;QAC5E,IAAI,CAACjI,KAAK,CAACgI,IAAI,CAACnE,IAAI,CAACoE,UAAU,CAACgI,WAAW,CAAC,IAAI,CAACjQ,KAAK,CAACgI,IAAI,CAACnE,IAAI,CAAC;MACrE;IACJ;EACJ;EACA;AACJ;AACA;EACIqM,OAAOA,CAAC3K,MAAM,EAAEa,EAAE,EAAE;IAChB,IAAI,IAAI,CAACjG,KAAK,IAAI,IAAI,IAAI,IAAI,CAACH,KAAK,IAAI,IAAI,EAAE;MAC1C,MAAMkN,KAAK,GAAG,IAAI5N,KAAK,CAAC8G,EAAE,CAAC2C,SAAS,CAAC,CAAC,EAAE3C,EAAE,CAAC4C,SAAS,CAAC,CAAC,CAAC;MACvD,MAAM;QAAE7I;MAAM,CAAC,GAAG,IAAI;MACtB,IAAI,CAACA,KAAK,GAAG,IAAI;MACjB,IAAI,IAAI,CAAC2B,YAAY,IAAI,IAAI,EAAE;QAC3B;QACA,IAAI,CAAC9B,KAAK,CAAC0C,IAAI,CAACgD,UAAU,CAAC,IAAI,CAAC1F,KAAK,CAAC+D,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC;QACzD,IAAI,CAAC/D,KAAK,CAAC0C,IAAI,CAACkD,QAAQ,CAAC,CAAC;MAC9B;MACA,IAAI,CAACnD,KAAK,CAAC0N,WAAW,CAAC,MAAM;QACzB,IAAIhQ,KAAK,IAAIjB,aAAa,CAACsK,aAAa,EAAE;UACtC,IAAI,IAAI,CAAClI,aAAa,IAAI,IAAI,EAAE;YAC5B;YACA,MAAMkC,KAAK,GAAG,IAAI,CAACxD,KAAK,CAAC0C,IAAI,CAACD,KAAK,CAAC2N,YAAY,CAAC,IAAI,CAACpQ,KAAK,CAAC+D,IAAI,CAAC;YACjE,IAAI,CAACzC,aAAa,CAACpC,aAAa,CAACsK,aAAa,GAAGrJ,KAAK,CAAC,CAACuM,MAAM,GAAG,KAAK;YACtE,IAAI,CAACpL,aAAa,CAACpC,aAAa,CAACsK,aAAa,GAAGrJ,KAAK,CAAC,CAACkQ,OAAO,CAACjK,EAAE,CAAC;YACnE;YACA;YACA,IAAI,IAAI,CAAC9E,aAAa,IAAI,IAAI,IAC1B,IAAI,CAACA,aAAa,CAACpC,aAAa,CAACsK,aAAa,GAAGrJ,KAAK,CAAC,IAAI,IAAI,EAAE;cACjE,IAAI,CAACH,KAAK,CAACwD,KAAK,GAAGA,KAAK;cACxB,IAAI,CAAClC,aAAa,CAACpC,aAAa,CAACsK,aAAa,GAAGrJ,KAAK,CAAC,CAAC0M,eAAe,CAAC,CAAC;YAC7E;UACJ;QACJ,CAAC,MACI,IAAI1M,KAAK,KAAKjB,aAAa,CAACgG,eAAe,EAAE;UAC9C,IAAI,IAAI,CAACvD,YAAY,IAAI,IAAI,EAAE;YAC3B,MAAM2O,KAAK,GAAG,IAAI,CAAC3O,YAAY,IAAI,IAAI,CAAC3B,KAAK,CAACwD,KAAK,CAACD,QAAQ,IAAI,CAAC,CAAC;YAClE,IAAI+M,KAAK,KAAK,CAAC,EAAE;cACb,IAAI,CAACC,UAAU,CAAC,IAAI,CAACvQ,KAAK,CAAC+D,IAAI,EAAEuM,KAAK,CAAC;YAC3C;UACJ,CAAC,MACI;YACD,IAAI,CAACE,WAAW,CAAC,CAAC;UACtB;QACJ,CAAC,MACI;UACD,MAAMC,WAAW,GAAG,IAAI,CAAChO,KAAK,CAAC2K,kBAAkB,CAAChH,EAAE,CAACC,QAAQ,CAAC,CAAC,CAAC;UAChE,MAAMqH,KAAK,GAAGhO,SAAS,CAAC,IAAI,CAACM,KAAK,CAACwD,KAAK,CAACD,QAAQ,IAAI,CAAC,CAAC;UACvD,MAAMoK,GAAG,GAAG3G,IAAI,CAAC2G,GAAG,CAAC,CAACD,KAAK,CAAC;UAC5B,MAAME,GAAG,GAAG5G,IAAI,CAAC4G,GAAG,CAAC,CAACF,KAAK,CAAC;UAC5B,IAAI3C,EAAE,GAAGmC,KAAK,CAACpK,CAAC,GAAG,IAAI,CAACtB,MAAM;UAC9B,IAAIyJ,EAAE,GAAGiC,KAAK,CAACnK,CAAC,GAAG,IAAI,CAACtB,MAAM;UAC9B;UACA,MAAMoM,EAAE,GAAGF,GAAG,GAAG5C,EAAE,GAAG6C,GAAG,GAAG3C,EAAE;UAC9B,MAAM6C,EAAE,GAAGF,GAAG,GAAG7C,EAAE,GAAG4C,GAAG,GAAG1C,EAAE;UAC9BF,EAAE,GAAG8C,EAAE;UACP5C,EAAE,GAAG6C,EAAE;UACP,MAAMlH,CAAC,GAAG,IAAI,CAACnE,KAAK,CAACC,IAAI,CAACmE,KAAK;UAC/B,MAAM6J,OAAO,GAAG,IAAI,CAACC,iBAAiB,CAAC,IAAI,CAAC3Q,KAAK,EAAEoG,EAAE,CAAC;UACtD,IAAI,CAACwK,UAAU,CAAC,IAAI,CAAC5Q,KAAK,CAAC+D,IAAI,EAAE,IAAI,CAACwI,WAAW,CAACxB,EAAE,GAAGnE,CAAC,CAAC,EAAE,IAAI,CAAC2F,WAAW,CAACtB,EAAE,GAAGrE,CAAC,CAAC,EAAEzG,KAAK,EAAEsQ,WAAW,EAAE,IAAI,CAACtK,kBAAkB,CAACC,EAAE,CAAC,EAAEsK,OAAO,CAAC;QAClJ;MACJ,CAAC,CAAC;MACFtK,EAAE,CAACyD,OAAO,CAAC,CAAC;MACZ,IAAI,CAAChE,KAAK,CAAC,CAAC;MACZ,IAAI,CAAC2H,aAAa,CAAC,CAAC;IACxB;EACJ;EACA;AACJ;AACA;AACA;AACA;EACImD,iBAAiBA,CAAC3Q,KAAK,EAAEoG,EAAE,EAAE;IACzB,OAAO,IAAI,CAAC3D,KAAK,CAACkO,iBAAiB,CAAC,IAAI,CAAC3Q,KAAK,CAAC;EACnD;EACA;AACJ;AACA;AACA;AACA;EACIwQ,WAAWA,CAAA,EAAG;IACV;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;EACID,UAAUA,CAACxM,IAAI,EAAEuI,KAAK,EAAEjC,MAAM,EAAE;IAC5B,IAAIiC,KAAK,KAAK,CAAC,EAAE;MACb,MAAMlC,KAAK,GAAG,IAAI,CAAC3H,KAAK,CAACoO,YAAY,CAAC,CAAC;MACvC,IAAI9M,IAAI,CAACyG,QAAQ,CAAC,CAAC,IAAIzG,IAAI,CAAC0G,MAAM,CAAC,CAAC,EAAE;QAClC,IAAI,CAAC1G,IAAI,CAAC0G,MAAM,CAAC,CAAC,EAAE;UAChB,MAAMjH,KAAK,GAAG,IAAI,CAACf,KAAK,CAACqO,mBAAmB,CAAC/M,IAAI,CAAC;UAClD,MAAMgN,KAAK,GAAG,CAACvN,KAAK,CAACD,QAAQ,IAAI,CAAC,IAAI+I,KAAK;UAC3C,IAAI,CAAC7J,KAAK,CAACuO,aAAa,CAAC,UAAU,EAAED,KAAK,EAAE,CAAChN,IAAI,CAAC,CAAC;QACvD;QACA,IAAIa,GAAG,GAAGb,IAAI,CAACc,WAAW,CAAC,CAAC;QAC5B,IAAID,GAAG,IAAIyF,MAAM,EAAE;UACf,MAAM4G,IAAI,GAAG5G,MAAM,CAACxF,WAAW,CAAC,CAAC;UACjC,IAAIoM,IAAI,IAAI,IAAI,IAAI,CAAC5G,MAAM,CAACI,MAAM,CAAC,CAAC,EAAE;YAClC7F,GAAG,GAAGA,GAAG,CAAC4K,KAAK,CAAC,CAAC;YACjB5K,GAAG,CAACsM,MAAM,CAAC5E,KAAK,EAAE,IAAIhN,KAAK,CAAC2R,IAAI,CAACjO,KAAK,GAAG,CAAC,EAAEiO,IAAI,CAAChO,MAAM,GAAG,CAAC,CAAC,CAAC;YAC7DmH,KAAK,CAAC+G,WAAW,CAACpN,IAAI,EAAEa,GAAG,CAAC;UAChC;UACA,IAAKb,IAAI,CAACyG,QAAQ,CAAC,CAAC,IAAI,CAAC5F,GAAG,CAACE,QAAQ,IAAKf,IAAI,CAAC0G,MAAM,CAAC,CAAC,EAAE;YACrD;YACA,MAAM2G,UAAU,GAAGrN,IAAI,CAACkG,aAAa,CAAC,CAAC;YACvC,KAAK,IAAIxF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2M,UAAU,EAAE3M,CAAC,IAAI,CAAC,EAAE;cACpC,IAAI,CAAC8L,UAAU,CAACxM,IAAI,CAACsN,UAAU,CAAC5M,CAAC,CAAC,EAAE6H,KAAK,EAAEvI,IAAI,CAAC;YACpD;UACJ;QACJ;MACJ;IACJ;EACJ;EACA;AACJ;AACA;EACI8B,KAAKA,CAAA,EAAG;IACJ,IAAI,IAAI,CAAC1F,KAAK,KAAK,IAAI,IAAI,IAAI,CAACF,MAAM,CAAC,IAAI,CAACE,KAAK,CAAC,CAAC0D,IAAI,CAACL,KAAK,CAACmF,OAAO,KAAK,MAAM,EAAE;MAC9E,IAAI,CAAC1I,MAAM,CAAC,IAAI,CAACE,KAAK,CAAC,CAAC0D,IAAI,CAACL,KAAK,CAACmF,OAAO,GAAG,EAAE;IACnD;IACA,IAAI,CAACxI,KAAK,GAAG,IAAI;IACjB;IACA,IAAI,IAAI,CAACkC,OAAO,EAAE;MACd,IAAI,CAACA,OAAO,CAACiP,OAAO,CAAC,CAAC;MACtB,IAAI,CAACjP,OAAO,GAAG,IAAI;IACvB;IACA,IAAI,IAAI,CAACP,YAAY,EAAE;MACnB,IAAI,CAACA,YAAY,CAACwP,OAAO,CAAC,CAAC;MAC3B,IAAI,CAACxP,YAAY,GAAG,IAAI;IAC5B;IACA,IAAI,IAAI,CAACC,iBAAiB,EAAE;MACxB,KAAK,IAAI0C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACxE,MAAM,CAACyG,MAAM,EAAEjC,CAAC,IAAI,CAAC,EAAE;QAC5C,IAAI,CAACxE,MAAM,CAACwE,CAAC,CAAC,CAACZ,IAAI,CAACL,KAAK,CAACmF,OAAO,GAAG,EAAE;MAC1C;MACA;MACA,IAAI,IAAI,CAAC3I,KAAK,CAAC8P,OAAO,IAAI,IAAI,CAAC9P,KAAK,CAAC8P,OAAO,CAACjM,IAAI,EAAE;QAC/C,IAAI,CAAC7D,KAAK,CAAC8P,OAAO,CAACjM,IAAI,CAACL,KAAK,CAAC8F,UAAU,GAAG,EAAE;MACjD;IACJ;IACA,KAAK,IAAI7E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACnD,aAAa,CAACoF,MAAM,EAAEjC,CAAC,IAAI,CAAC,EAAE;MACnD,IAAI,IAAI,CAACnD,aAAa,CAACmD,CAAC,CAAC,CAACiI,MAAM,EAAE;QAC9B,IAAI,CAACpL,aAAa,CAACmD,CAAC,CAAC,CAACiI,MAAM,GAAG,KAAK;QACpC,IAAI,CAACpL,aAAa,CAACmD,CAAC,CAAC,CAACoB,KAAK,CAAC,CAAC;MACjC,CAAC,MACI;QACD,IAAI,CAACvE,aAAa,CAACmD,CAAC,CAAC,CAAC8G,UAAU,CAAC,IAAI,CAAC;MAC1C;IACJ;IACA;IACA,IAAI,CAACrI,eAAe,CAACW,IAAI,CAACL,KAAK,CAACmF,OAAO,GAAG,QAAQ;IAClD,IAAI,CAAChG,eAAe,GAAG,IAAI,CAACC,kBAAkB,CAAC,IAAI,CAAC5C,KAAK,CAAC;IAC1D,IAAI,CAAC6C,MAAM,GAAG,IAAIvE,SAAS,CAAC,IAAI,CAACqE,eAAe,CAACG,CAAC,EAAE,IAAI,CAACH,eAAe,CAACI,CAAC,EAAE,IAAI,CAACJ,eAAe,CAACK,KAAK,EAAE,IAAI,CAACL,eAAe,CAACM,MAAM,CAAC;IACpI,IAAI,CAACoM,WAAW,CAAC,CAAC;IAClB,IAAI,CAACjD,UAAU,CAAC,CAAC;IACjB,IAAI,CAACoB,aAAa,CAAC,CAAC;IACpB,IAAI,CAACjL,YAAY,GAAG,EAAE;IACtB,IAAI,CAACjC,cAAc,GAAG,IAAI;IAC1B,IAAI,CAAC8B,cAAc,GAAG,IAAI;EAC9B;EACA;AACJ;AACA;AACA;EACIwO,UAAUA,CAAC7M,IAAI,EAAEgH,EAAE,EAAEE,EAAE,EAAE9K,KAAK,EAAEsQ,WAAW,EAAEc,WAAW,EAAEb,OAAO,EAAE;IAC/D,IAAI9L,GAAG,GAAGb,IAAI,CAACc,WAAW,CAAC,CAAC;IAC5B,IAAID,GAAG,EAAE;MACL,IAAIzE,KAAK,KAAKjB,aAAa,CAAC6F,YAAY,IACpC,IAAI,CAACzC,UAAU,IACf,IAAI,CAACA,UAAU,CAACO,MAAM,EAAE;QACxB,MAAM6K,KAAK,GAAG,CAAChO,SAAS,CAAC,IAAI,CAACM,KAAK,CAACwD,KAAK,CAACD,QAAQ,IAAI,CAAC,CAAC;QACxD,MAAMoK,GAAG,GAAG3G,IAAI,CAAC2G,GAAG,CAACD,KAAK,CAAC;QAC3B,MAAME,GAAG,GAAG5G,IAAI,CAAC4G,GAAG,CAACF,KAAK,CAAC;QAC3B,MAAM;UAAE7G;QAAM,CAAC,GAAG,IAAI,CAACpE,KAAK,CAACC,IAAI;QACjC,MAAM8O,EAAE,GAAGjS,eAAe,CAAC,IAAID,KAAK,CAAC0H,IAAI,CAACC,KAAK,CAAC,CAAC,IAAI,CAAC3E,UAAU,CAACO,MAAM,CAACmI,UAAU,CAAC,CAAC,GAAG,IAAI,CAACxJ,MAAM,IAAIqF,KAAK,CAAC,EAAEG,IAAI,CAACC,KAAK,CAAC,CAAC,IAAI,CAAC3E,UAAU,CAACO,MAAM,CAACqI,UAAU,CAAC,CAAC,GAAG,IAAI,CAACzJ,MAAM,IAAIoF,KAAK,CAAC,CAAC,EAAE8G,GAAG,EAAEC,GAAG,CAAC;QACjMhJ,GAAG,GAAGA,GAAG,CAAC4K,KAAK,CAAC,CAAC;QACjB,IAAI5K,GAAG,CAACgL,MAAM,IAAI,IAAI,EAAE;UACpBhL,GAAG,CAACgL,MAAM,GAAG4B,EAAE;QACnB,CAAC,MACI;UACD5M,GAAG,CAACgL,MAAM,CAAC9M,CAAC,IAAI0O,EAAE,CAAC1O,CAAC;UACpB8B,GAAG,CAACgL,MAAM,CAAC7M,CAAC,IAAIyO,EAAE,CAACzO,CAAC;QACxB;QACA,IAAI,CAACN,KAAK,CAAC2H,KAAK,CAAC+G,WAAW,CAACpN,IAAI,EAAEa,GAAG,CAAC;MAC3C,CAAC,MACI,IAAI,IAAI,CAACxC,cAAc,EAAE;QAC1B,MAAM;UAAEyE;QAAM,CAAC,GAAG,IAAI,CAACpE,KAAK,CAACC,IAAI;QACjC,IAAI,IAAI,CAACV,YAAY,KAAK,CAAC,IAAI,IAAI,CAACC,YAAY,KAAK,CAAC,EAAE;UACpD,IAAI,CAACwP,YAAY,CAAC1N,IAAI,EAAEiD,IAAI,CAACC,KAAK,CAAC,IAAI,CAACjF,YAAY,GAAG6E,KAAK,CAAC,EAAEG,IAAI,CAACC,KAAK,CAAC,IAAI,CAAChF,YAAY,GAAG4E,KAAK,CAAC,CAAC;QACzG;QACA,IAAI,CAACpE,KAAK,CAACmO,UAAU,CAAC7M,IAAI,EAAE,IAAI,CAAC3B,cAAc,EAAEsO,OAAO,CAAC;MAC7D;IACJ;EACJ;EACA;AACJ;AACA;EACIe,YAAYA,CAAC1N,IAAI,EAAEgH,EAAE,EAAEE,EAAE,EAAE;IACvB,MAAMb,KAAK,GAAG,IAAI,CAAC3H,KAAK,CAACoO,YAAY,CAAC,CAAC;IACvC,MAAMO,UAAU,GAAGrN,IAAI,CAACkG,aAAa,CAAC,CAAC;IACvC,KAAK,IAAIxF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2M,UAAU,EAAE3M,CAAC,IAAI,CAAC,EAAE;MACpC,MAAMiN,KAAK,GAAG3N,IAAI,CAACsN,UAAU,CAAC5M,CAAC,CAAC;MAChC,IAAIG,GAAG,GAAG8M,KAAK,CAAC7M,WAAW,CAAC,CAAC;MAC7B,IAAID,GAAG,IAAI,IAAI,EAAE;QACbA,GAAG,GAAGA,GAAG,CAAC4K,KAAK,CAAC,CAAC;QACjB5K,GAAG,CAACmC,SAAS,CAACgE,EAAE,EAAEE,EAAE,CAAC;QACrBb,KAAK,CAAC+G,WAAW,CAACO,KAAK,EAAE9M,GAAG,CAAC;MACjC;IACJ;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACImJ,KAAKA,CAAClL,MAAM,EAAEkI,EAAE,EAAEE,EAAE,EAAE9K,KAAK,EAAEsQ,WAAW,EAAE5J,KAAK,EAAEsG,EAAE,EAAEoE,WAAW,EAAEI,QAAQ,EAAE;IACxElB,WAAW,GAAGA,WAAW,IAAI,IAAI,CAAChO,KAAK,CAACmP,aAAa,CAAC,CAAC;IACvD,IAAI,IAAI,CAAC1R,WAAW,EAAE;MAClB,IAAI4C,CAAC,GAAGD,MAAM,CAACC,CAAC,GAAGD,MAAM,CAACG,KAAK,GAAG+H,EAAE;MACpC,IAAIhI,CAAC,GAAGF,MAAM,CAACE,CAAC,GAAGF,MAAM,CAACI,MAAM,GAAGgI,EAAE;MACrC,IAAIwF,WAAW,EAAE;QACb3N,CAAC,GAAG,IAAI,CAACL,KAAK,CAAC4K,IAAI,CAACvK,CAAC,GAAG+D,KAAK,CAAC,GAAGA,KAAK;QACtC9D,CAAC,GAAG,IAAI,CAACN,KAAK,CAAC4K,IAAI,CAACtK,CAAC,GAAG8D,KAAK,CAAC,GAAGA,KAAK;MAC1C;MACA,MAAMgL,IAAI,GAAG,IAAIvT,SAAS,CAACuE,MAAM,CAACC,CAAC,EAAED,MAAM,CAACE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACpD8O,IAAI,CAACC,GAAG,CAAC,IAAIxT,SAAS,CAACwE,CAAC,EAAEC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;MACnC,OAAO8O,IAAI;IACf;IACA,MAAME,EAAE,GAAGlP,MAAM,CAACG,KAAK;IACvB,MAAMgP,EAAE,GAAGnP,MAAM,CAACI,MAAM;IACxB,IAAIgP,IAAI,GAAGpP,MAAM,CAACC,CAAC,GAAGqK,EAAE,CAACrK,CAAC,GAAG+D,KAAK;IAClC,IAAIqL,KAAK,GAAGD,IAAI,GAAGF,EAAE;IACrB,IAAII,GAAG,GAAGtP,MAAM,CAACE,CAAC,GAAGoK,EAAE,CAACpK,CAAC,GAAG8D,KAAK;IACjC,IAAIuL,MAAM,GAAGD,GAAG,GAAGH,EAAE;IACrB,MAAMK,EAAE,GAAGJ,IAAI,GAAGF,EAAE,GAAG,CAAC;IACxB,MAAMO,EAAE,GAAGH,GAAG,GAAGH,EAAE,GAAG,CAAC;IACvB,IAAI7R,KAAK,GAAG,CAAC,CAAC,kBAAkB;MAC5BiS,MAAM,IAAInH,EAAE;MACZ,IAAIwF,WAAW,EAAE;QACb2B,MAAM,GAAG,IAAI,CAAC3P,KAAK,CAAC4K,IAAI,CAAC+E,MAAM,GAAGvL,KAAK,CAAC,GAAGA,KAAK;MACpD,CAAC,MACI;QACDuL,MAAM,GAAGpL,IAAI,CAACC,KAAK,CAACmL,MAAM,GAAGvL,KAAK,CAAC,GAAGA,KAAK;MAC/C;IACJ,CAAC,MACI,IAAI1G,KAAK,GAAG,CAAC,CAAC,eAAe;MAC9BgS,GAAG,IAAIlH,EAAE;MACT,IAAIwF,WAAW,EAAE;QACb0B,GAAG,GAAG,IAAI,CAAC1P,KAAK,CAAC4K,IAAI,CAAC8E,GAAG,GAAGtL,KAAK,CAAC,GAAGA,KAAK;MAC9C,CAAC,MACI;QACDsL,GAAG,GAAGnL,IAAI,CAACC,KAAK,CAACkL,GAAG,GAAGtL,KAAK,CAAC,GAAGA,KAAK;MACzC;IACJ;IACA,IAAI1G,KAAK,KAAK,CAAC,IAAIA,KAAK,KAAK,CAAC,IAAIA,KAAK,KAAK,CAAC,CAAC,YAAY;MACtD8R,IAAI,IAAIlH,EAAE;MACV,IAAI0F,WAAW,EAAE;QACbwB,IAAI,GAAG,IAAI,CAACxP,KAAK,CAAC4K,IAAI,CAAC4E,IAAI,GAAGpL,KAAK,CAAC,GAAGA,KAAK;MAChD,CAAC,MACI;QACDoL,IAAI,GAAGjL,IAAI,CAACC,KAAK,CAACgL,IAAI,GAAGpL,KAAK,CAAC,GAAGA,KAAK;MAC3C;IACJ,CAAC,MACI,IAAI1G,KAAK,KAAK,CAAC,IAAIA,KAAK,KAAK,CAAC,IAAIA,KAAK,KAAK,CAAC,CAAC,aAAa;MAC5D+R,KAAK,IAAInH,EAAE;MACX,IAAI0F,WAAW,EAAE;QACbyB,KAAK,GAAG,IAAI,CAACzP,KAAK,CAAC4K,IAAI,CAAC6E,KAAK,GAAGrL,KAAK,CAAC,GAAGA,KAAK;MAClD,CAAC,MACI;QACDqL,KAAK,GAAGlL,IAAI,CAACC,KAAK,CAACiL,KAAK,GAAGrL,KAAK,CAAC,GAAGA,KAAK;MAC7C;IACJ;IACA,IAAI7D,KAAK,GAAGkP,KAAK,GAAGD,IAAI;IACxB,IAAIhP,MAAM,GAAGmP,MAAM,GAAGD,GAAG;IACzB,IAAIZ,WAAW,EAAE;MACb,MAAM3M,GAAG,GAAG,IAAI,CAAC5E,KAAK,CAAC+D,IAAI,CAACc,WAAW,CAAC,CAAC;MACzC,IAAID,GAAG,IAAI,IAAI,EAAE;QACb,MAAM0B,MAAM,GAAG1B,GAAG,CAAC5B,KAAK,GAAG4B,GAAG,CAAC3B,MAAM;QACrC,IAAI9C,KAAK,KAAK,CAAC,IAAIA,KAAK,KAAK,CAAC,IAAIA,KAAK,KAAK,CAAC,IAAIA,KAAK,KAAK,CAAC,EAAE;UAC1D6C,KAAK,GAAGC,MAAM,GAAGqD,MAAM;QAC3B,CAAC,MACI;UACDrD,MAAM,GAAGD,KAAK,GAAGsD,MAAM;QAC3B;QACA,IAAInG,KAAK,KAAK,CAAC,EAAE;UACb8R,IAAI,GAAGC,KAAK,GAAGlP,KAAK;UACpBmP,GAAG,GAAGC,MAAM,GAAGnP,MAAM;QACzB;MACJ;IACJ;IACA,IAAI0O,QAAQ,EAAE;MACV3O,KAAK,IAAIA,KAAK,GAAG+O,EAAE;MACnB9O,MAAM,IAAIA,MAAM,GAAG+O,EAAE;MACrB,MAAMO,GAAG,GAAGF,EAAE,IAAIJ,IAAI,GAAGjP,KAAK,GAAG,CAAC,CAAC;MACnC,MAAMwP,GAAG,GAAGF,EAAE,IAAIH,GAAG,GAAGlP,MAAM,GAAG,CAAC,CAAC;MACnCgP,IAAI,IAAIM,GAAG;MACXJ,GAAG,IAAIK,GAAG;MACVN,KAAK,IAAIK,GAAG;MACZH,MAAM,IAAII,GAAG;IACjB;IACA;IACA,IAAIxP,KAAK,GAAG,CAAC,EAAE;MACXiP,IAAI,IAAIjP,KAAK;MACbA,KAAK,GAAGgE,IAAI,CAACiF,GAAG,CAACjJ,KAAK,CAAC;IAC3B;IACA;IACA,IAAIC,MAAM,GAAG,CAAC,EAAE;MACZkP,GAAG,IAAIlP,MAAM;MACbA,MAAM,GAAG+D,IAAI,CAACiF,GAAG,CAAChJ,MAAM,CAAC;IAC7B;IACA,MAAMwP,MAAM,GAAG,IAAInU,SAAS,CAAC2T,IAAI,GAAG9E,EAAE,CAACrK,CAAC,GAAG+D,KAAK,EAAEsL,GAAG,GAAGhF,EAAE,CAACpK,CAAC,GAAG8D,KAAK,EAAE7D,KAAK,EAAEC,MAAM,CAAC;IACpF,IAAI,IAAI,CAAC9B,SAAS,IAAI,IAAI,EAAE;MACxBsR,MAAM,CAACzP,KAAK,GAAGgE,IAAI,CAACgH,GAAG,CAACyE,MAAM,CAACzP,KAAK,EAAE,IAAI,CAAC7B,SAAS,CAAC2B,CAAC,GAAG+D,KAAK,GAC1D,IAAI,CAAC1F,SAAS,CAAC6B,KAAK,GAAG6D,KAAK,GAC5BG,IAAI,CAACgH,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC5M,EAAE,GAAGyF,KAAK,GAAG4L,MAAM,CAAC3P,CAAC,CAAC,CAAC;MAC5C2P,MAAM,CAACxP,MAAM,GAAG+D,IAAI,CAACgH,GAAG,CAACyE,MAAM,CAACxP,MAAM,EAAE,IAAI,CAAC9B,SAAS,CAAC4B,CAAC,GAAG8D,KAAK,GAC5D,IAAI,CAAC1F,SAAS,CAAC8B,MAAM,GAAG4D,KAAK,GAC7BG,IAAI,CAACgH,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC3M,EAAE,GAAGwF,KAAK,GAAG4L,MAAM,CAAC1P,CAAC,CAAC,CAAC;IAChD;IACA,OAAO0P,MAAM;EACjB;EACA;AACJ;AACA;EACIrN,MAAMA,CAACsN,aAAa,EAAE;IAClB,IAAI,CAAC/P,eAAe,GAAG,IAAI,CAACC,kBAAkB,CAAC,IAAI,CAAC5C,KAAK,CAAC;IAC1D,IAAI,CAAC6C,MAAM,GAAG,IAAIvE,SAAS,CAAC,IAAI,CAACqE,eAAe,CAACG,CAAC,EAAE,IAAI,CAACH,eAAe,CAACI,CAAC,EAAE,IAAI,CAACJ,eAAe,CAACK,KAAK,EAAE,IAAI,CAACL,eAAe,CAACM,MAAM,CAAC;IACpI,IAAI,CAACoM,WAAW,CAAC,CAAC;IAClB,IAAI,CAACqD,aAAa,EAAE;MAChB,IAAI,CAAClF,aAAa,CAAC,CAAC;IACxB;EACJ;EACA;AACJ;AACA;EACImF,gBAAgBA,CAAA,EAAG;IACf;IACA,MAAMF,MAAM,GAAG,IAAInT,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;IAC9B,IAAIuJ,GAAG,GAAG,IAAI,CAACtI,SAAS;IACxB,IAAI,IAAI,CAACN,MAAM,CAACyG,MAAM,GAAG,CAAC,IACtB,IAAI,CAACzG,MAAM,CAAC,CAAC,CAAC,CAAC4C,MAAM,KACpB,IAAI,CAACA,MAAM,CAACG,KAAK,GAAG,CAAC,GAAG,IAAI,CAAC/C,MAAM,CAAC,CAAC,CAAC,CAAC4C,MAAM,CAACG,KAAK,GAAG,CAAC,GAAG6F,GAAG,IAC1D,IAAI,CAAChG,MAAM,CAACI,MAAM,GAAG,CAAC,GAAG,IAAI,CAAChD,MAAM,CAAC,CAAC,CAAC,CAAC4C,MAAM,CAACI,MAAM,GAAG,CAAC,GAAG4F,GAAG,CAAC,EAAE;MACtEA,GAAG,IAAI,CAAC;MACR4J,MAAM,CAAC3P,CAAC,GAAG,IAAI,CAAC7C,MAAM,CAAC,CAAC,CAAC,CAAC4C,MAAM,CAACG,KAAK,GAAG6F,GAAG;MAC5C4J,MAAM,CAAC1P,CAAC,GAAG,IAAI,CAAC9C,MAAM,CAAC,CAAC,CAAC,CAAC4C,MAAM,CAACI,MAAM,GAAG4F,GAAG;IACjD;IACA,OAAO4J,MAAM;EACjB;EACA;AACJ;AACA;EACIG,cAAcA,CAAA,EAAG;IACb,OAAO,IAAI,CAAC/P,MAAM;EACtB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI2K,aAAaA,CAAA,EAAG;IACZ,IAAI5G,CAAC,GAAG,IAAI,CAACgM,cAAc,CAAC,CAAC;IAC7B,MAAM/J,GAAG,GAAG,IAAI,CAACtI,SAAS;IAC1B,IAAI,CAACU,gBAAgB,GAAG,CAAC;IACzB,IAAI,CAACC,cAAc,GAAG,CAAC;IACvB,KAAK,IAAIuD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACnD,aAAa,CAACoF,MAAM,EAAEjC,CAAC,IAAI,CAAC,EAAE;MACnD,MAAM0C,KAAK,GAAG,IAAI,CAAC7F,aAAa,CAACmD,CAAC,CAAC,CAAC0C,KAAK;MACzC,IAAIA,KAAK,EAAE;QACP,MAAM0L,IAAI,GAAG1L,KAAK,CAACtD,IAAI,CAACL,KAAK,CAACmF,OAAO;QACrC,IAAI,CAACrH,aAAa,CAACmD,CAAC,CAAC,CAACW,MAAM,CAAC,CAAC;QAC9B+B,KAAK,CAACtD,IAAI,CAACL,KAAK,CAACmF,OAAO,GAAGkK,IAAI;QAC/B;QACA1L,KAAK,CAACtD,IAAI,CAACL,KAAK,CAAC8F,UAAU,GACvB,IAAI,CAAChJ,cAAc,IAAI,IAAI,CAACwS,qBAAqB,CAAC,IAAI,CAACxR,aAAa,CAACmD,CAAC,CAAC,CAAC,GAClE,EAAE,GACF,QAAQ;MACtB;IACJ;IACA,IAAI,IAAI,CAACxE,MAAM,CAACyG,MAAM,GAAG,CAAC,IAAI,IAAI,CAACzG,MAAM,CAAC,CAAC,CAAC,EAAE;MAC1C,IAAI,IAAI,CAACE,KAAK,KAAK,IAAI,IAAI,IAAI,CAACW,YAAY,IAAI,IAAI,CAACb,MAAM,CAACyG,MAAM,IAAI,CAAC,EAAE;QACrE;QACA,MAAMqM,OAAO,GAAG,IAAI,CAACJ,gBAAgB,CAAC,CAAC;QACvC,IAAI,CAAC1R,gBAAgB,GAAG8R,OAAO,CAACjQ,CAAC;QACjC,IAAI,CAAC5B,cAAc,GAAG6R,OAAO,CAAChQ,CAAC;QAC/B,IAAI,IAAI,CAAC9B,gBAAgB,KAAK,CAAC,IAAI,IAAI,CAACC,cAAc,KAAK,CAAC,EAAE;UAC1D0F,CAAC,GAAG,IAAItI,SAAS,CAACsI,CAAC,CAAC9D,CAAC,EAAE8D,CAAC,CAAC7D,CAAC,EAAE6D,CAAC,CAAC5D,KAAK,EAAE4D,CAAC,CAAC3D,MAAM,CAAC;UAC9C2D,CAAC,CAAC9D,CAAC,IAAI,IAAI,CAAC7B,gBAAgB,GAAG,CAAC;UAChC2F,CAAC,CAAC5D,KAAK,IAAI,IAAI,CAAC/B,gBAAgB;UAChC2F,CAAC,CAAC7D,CAAC,IAAI,IAAI,CAAC7B,cAAc,GAAG,CAAC;UAC9B0F,CAAC,CAAC3D,MAAM,IAAI,IAAI,CAAC/B,cAAc;QACnC;QACA,IAAI,IAAI,CAACjB,MAAM,CAACyG,MAAM,IAAI,CAAC,EAAE;UACzB,IAAI,IAAI,CAACzG,MAAM,CAAC,CAAC,CAAC,CAAC4C,MAAM,KACpB+D,CAAC,CAAC5D,KAAK,GAAG,CAAC,GAAG,IAAI,CAAC/C,MAAM,CAAC,CAAC,CAAC,CAAC4C,MAAM,CAACG,KAAK,GAAG,CAAC,GAAG6F,GAAG,IAChDjC,CAAC,CAAC3D,MAAM,GAAG,CAAC,GAAG,IAAI,CAAChD,MAAM,CAAC,CAAC,CAAC,CAAC4C,MAAM,CAACI,MAAM,GAAG,CAAC,GAAG4F,GAAG,CAAC,EAAE;YAC5D,IAAI,CAAC5I,MAAM,CAAC,CAAC,CAAC,CAAC4D,IAAI,CAACL,KAAK,CAACmF,OAAO,GAAG,MAAM;YAC1C,IAAI,CAAC1I,MAAM,CAAC,CAAC,CAAC,CAAC4D,IAAI,CAACL,KAAK,CAACmF,OAAO,GAAG,MAAM;YAC1C,IAAI,CAAC1I,MAAM,CAAC,CAAC,CAAC,CAAC4D,IAAI,CAACL,KAAK,CAACmF,OAAO,GAAG,MAAM;YAC1C,IAAI,CAAC1I,MAAM,CAAC,CAAC,CAAC,CAAC4D,IAAI,CAACL,KAAK,CAACmF,OAAO,GAAG,MAAM;UAC9C,CAAC,MACI,IAAI,IAAI,CAACrI,cAAc,EAAE;YAC1B,IAAI,CAACL,MAAM,CAAC,CAAC,CAAC,CAAC4D,IAAI,CAACL,KAAK,CAACmF,OAAO,GAAG,EAAE;YACtC,IAAI,CAAC1I,MAAM,CAAC,CAAC,CAAC,CAAC4D,IAAI,CAACL,KAAK,CAACmF,OAAO,GAAG,EAAE;YACtC,IAAI,CAAC1I,MAAM,CAAC,CAAC,CAAC,CAAC4D,IAAI,CAACL,KAAK,CAACmF,OAAO,GAAG,EAAE;YACtC,IAAI,CAAC1I,MAAM,CAAC,CAAC,CAAC,CAAC4D,IAAI,CAACL,KAAK,CAACmF,OAAO,GAAG,EAAE;UAC1C;QACJ;MACJ;MACA,MAAMqK,CAAC,GAAGpM,CAAC,CAAC9D,CAAC,GAAG8D,CAAC,CAAC5D,KAAK;MACvB,MAAMiQ,CAAC,GAAGrM,CAAC,CAAC7D,CAAC,GAAG6D,CAAC,CAAC3D,MAAM;MACxB,IAAI,IAAI,CAAC/C,WAAW,EAAE;QAClB,IAAI,CAACuI,WAAW,CAAC,IAAI,CAACxI,MAAM,CAAC,CAAC,CAAC,EAAE+S,CAAC,EAAEC,CAAC,CAAC;MAC1C,CAAC,MACI;QACD,MAAMZ,EAAE,GAAGzL,CAAC,CAAC9D,CAAC,GAAG8D,CAAC,CAAC5D,KAAK,GAAG,CAAC;QAC5B,MAAMsP,EAAE,GAAG1L,CAAC,CAAC7D,CAAC,GAAG6D,CAAC,CAAC3D,MAAM,GAAG,CAAC;QAC7B,IAAI,IAAI,CAAChD,MAAM,CAACyG,MAAM,IAAI,CAAC,EAAE;UACzB,MAAMwM,GAAG,GAAG,CACR,WAAW,EACX,UAAU,EACV,WAAW,EACX,UAAU,EACV,WAAW,EACX,UAAU,EACV,WAAW,EACX,UAAU,CACb;UACD,MAAMxF,KAAK,GAAGhO,SAAS,CAAC,IAAI,CAACM,KAAK,CAACwD,KAAK,CAACD,QAAQ,IAAI,CAAC,CAAC;UACvD,MAAMoK,GAAG,GAAG3G,IAAI,CAAC2G,GAAG,CAACD,KAAK,CAAC;UAC3B,MAAME,GAAG,GAAG5G,IAAI,CAAC4G,GAAG,CAACF,KAAK,CAAC;UAC3B,MAAMyF,EAAE,GAAGnM,IAAI,CAACC,KAAK,CAAEyG,KAAK,GAAG,CAAC,GAAI1G,IAAI,CAACoE,EAAE,CAAC;UAC5C,MAAMqC,EAAE,GAAG,IAAInO,KAAK,CAACsH,CAAC,CAACoE,UAAU,CAAC,CAAC,EAAEpE,CAAC,CAACsE,UAAU,CAAC,CAAC,CAAC;UACpD,IAAIsG,EAAE,GAAGjS,eAAe,CAAC,IAAID,KAAK,CAACsH,CAAC,CAAC9D,CAAC,EAAE8D,CAAC,CAAC7D,CAAC,CAAC,EAAE4K,GAAG,EAAEC,GAAG,EAAEH,EAAE,CAAC;UAC3D,IAAI,CAAChF,WAAW,CAAC,IAAI,CAACxI,MAAM,CAAC,CAAC,CAAC,EAAEuR,EAAE,CAAC1O,CAAC,EAAE0O,EAAE,CAACzO,CAAC,CAAC;UAC5C,IAAI,CAAC9C,MAAM,CAAC,CAAC,CAAC,CAAC+D,SAAS,CAACkP,GAAG,CAACzT,GAAG,CAAC,CAAC,GAAG0T,EAAE,EAAED,GAAG,CAACxM,MAAM,CAAC,CAAC,CAAC;UACtD8K,EAAE,CAAC1O,CAAC,GAAGuP,EAAE;UACTb,EAAE,CAACzO,CAAC,GAAG6D,CAAC,CAAC7D,CAAC;UACVyO,EAAE,GAAGjS,eAAe,CAACiS,EAAE,EAAE7D,GAAG,EAAEC,GAAG,EAAEH,EAAE,CAAC;UACtC,IAAI,CAAChF,WAAW,CAAC,IAAI,CAACxI,MAAM,CAAC,CAAC,CAAC,EAAEuR,EAAE,CAAC1O,CAAC,EAAE0O,EAAE,CAACzO,CAAC,CAAC;UAC5C,IAAI,CAAC9C,MAAM,CAAC,CAAC,CAAC,CAAC+D,SAAS,CAACkP,GAAG,CAACzT,GAAG,CAAC,CAAC,GAAG0T,EAAE,EAAED,GAAG,CAACxM,MAAM,CAAC,CAAC,CAAC;UACtD8K,EAAE,CAAC1O,CAAC,GAAGkQ,CAAC;UACRxB,EAAE,CAACzO,CAAC,GAAG6D,CAAC,CAAC7D,CAAC;UACVyO,EAAE,GAAGjS,eAAe,CAACiS,EAAE,EAAE7D,GAAG,EAAEC,GAAG,EAAEH,EAAE,CAAC;UACtC,IAAI,CAAChF,WAAW,CAAC,IAAI,CAACxI,MAAM,CAAC,CAAC,CAAC,EAAEuR,EAAE,CAAC1O,CAAC,EAAE0O,EAAE,CAACzO,CAAC,CAAC;UAC5C,IAAI,CAAC9C,MAAM,CAAC,CAAC,CAAC,CAAC+D,SAAS,CAACkP,GAAG,CAACzT,GAAG,CAAC,CAAC,GAAG0T,EAAE,EAAED,GAAG,CAACxM,MAAM,CAAC,CAAC,CAAC;UACtD8K,EAAE,CAAC1O,CAAC,GAAG8D,CAAC,CAAC9D,CAAC;UACV0O,EAAE,CAACzO,CAAC,GAAGuP,EAAE;UACTd,EAAE,GAAGjS,eAAe,CAACiS,EAAE,EAAE7D,GAAG,EAAEC,GAAG,EAAEH,EAAE,CAAC;UACtC,IAAI,CAAChF,WAAW,CAAC,IAAI,CAACxI,MAAM,CAAC,CAAC,CAAC,EAAEuR,EAAE,CAAC1O,CAAC,EAAE0O,EAAE,CAACzO,CAAC,CAAC;UAC5C,IAAI,CAAC9C,MAAM,CAAC,CAAC,CAAC,CAAC+D,SAAS,CAACkP,GAAG,CAACzT,GAAG,CAAC,CAAC,GAAG0T,EAAE,EAAED,GAAG,CAACxM,MAAM,CAAC,CAAC,CAAC;UACtD8K,EAAE,CAAC1O,CAAC,GAAGkQ,CAAC;UACRxB,EAAE,CAACzO,CAAC,GAAGuP,EAAE;UACTd,EAAE,GAAGjS,eAAe,CAACiS,EAAE,EAAE7D,GAAG,EAAEC,GAAG,EAAEH,EAAE,CAAC;UACtC,IAAI,CAAChF,WAAW,CAAC,IAAI,CAACxI,MAAM,CAAC,CAAC,CAAC,EAAEuR,EAAE,CAAC1O,CAAC,EAAE0O,EAAE,CAACzO,CAAC,CAAC;UAC5C,IAAI,CAAC9C,MAAM,CAAC,CAAC,CAAC,CAAC+D,SAAS,CAACkP,GAAG,CAACzT,GAAG,CAAC,CAAC,GAAG0T,EAAE,EAAED,GAAG,CAACxM,MAAM,CAAC,CAAC,CAAC;UACtD8K,EAAE,CAAC1O,CAAC,GAAG8D,CAAC,CAAC9D,CAAC;UACV0O,EAAE,CAACzO,CAAC,GAAGkQ,CAAC;UACRzB,EAAE,GAAGjS,eAAe,CAACiS,EAAE,EAAE7D,GAAG,EAAEC,GAAG,EAAEH,EAAE,CAAC;UACtC,IAAI,CAAChF,WAAW,CAAC,IAAI,CAACxI,MAAM,CAAC,CAAC,CAAC,EAAEuR,EAAE,CAAC1O,CAAC,EAAE0O,EAAE,CAACzO,CAAC,CAAC;UAC5C,IAAI,CAAC9C,MAAM,CAAC,CAAC,CAAC,CAAC+D,SAAS,CAACkP,GAAG,CAACzT,GAAG,CAAC,CAAC,GAAG0T,EAAE,EAAED,GAAG,CAACxM,MAAM,CAAC,CAAC,CAAC;UACtD8K,EAAE,CAAC1O,CAAC,GAAGuP,EAAE;UACTb,EAAE,CAACzO,CAAC,GAAGkQ,CAAC;UACRzB,EAAE,GAAGjS,eAAe,CAACiS,EAAE,EAAE7D,GAAG,EAAEC,GAAG,EAAEH,EAAE,CAAC;UACtC,IAAI,CAAChF,WAAW,CAAC,IAAI,CAACxI,MAAM,CAAC,CAAC,CAAC,EAAEuR,EAAE,CAAC1O,CAAC,EAAE0O,EAAE,CAACzO,CAAC,CAAC;UAC5C,IAAI,CAAC9C,MAAM,CAAC,CAAC,CAAC,CAAC+D,SAAS,CAACkP,GAAG,CAACzT,GAAG,CAAC,CAAC,GAAG0T,EAAE,EAAED,GAAG,CAACxM,MAAM,CAAC,CAAC,CAAC;UACtD8K,EAAE,CAAC1O,CAAC,GAAGkQ,CAAC;UACRxB,EAAE,CAACzO,CAAC,GAAGkQ,CAAC;UACRzB,EAAE,GAAGjS,eAAe,CAACiS,EAAE,EAAE7D,GAAG,EAAEC,GAAG,EAAEH,EAAE,CAAC;UACtC,IAAI,CAAChF,WAAW,CAAC,IAAI,CAACxI,MAAM,CAAC,CAAC,CAAC,EAAEuR,EAAE,CAAC1O,CAAC,EAAE0O,EAAE,CAACzO,CAAC,CAAC;UAC5C,IAAI,CAAC9C,MAAM,CAAC,CAAC,CAAC,CAAC+D,SAAS,CAACkP,GAAG,CAACzT,GAAG,CAAC,CAAC,GAAG0T,EAAE,EAAED,GAAG,CAACxM,MAAM,CAAC,CAAC,CAAC;UACtD8K,EAAE,CAAC1O,CAAC,GAAGuP,EAAE,GAAG,IAAI,CAACrS,KAAK,CAAC2P,cAAc,CAAC7M,CAAC;UACvC0O,EAAE,CAACzO,CAAC,GAAGuP,EAAE,GAAG,IAAI,CAACtS,KAAK,CAAC2P,cAAc,CAAC5M,CAAC;UACvCyO,EAAE,GAAGjS,eAAe,CAACiS,EAAE,EAAE7D,GAAG,EAAEC,GAAG,EAAEH,EAAE,CAAC;UACtC,IAAI,CAAChF,WAAW,CAAC,IAAI,CAACxI,MAAM,CAAC,CAAC,CAAC,EAAEuR,EAAE,CAAC1O,CAAC,EAAE0O,EAAE,CAACzO,CAAC,CAAC;QAChD,CAAC,MACI,IAAI,IAAI,CAAC/C,KAAK,CAACgD,KAAK,IAAI,CAAC,IAAI,IAAI,CAAChD,KAAK,CAACiD,MAAM,IAAI,CAAC,EAAE;UACtD,IAAI,CAACwF,WAAW,CAAC,IAAI,CAACxI,MAAM,CAAC,CAAC,CAAC,EAAEoS,EAAE,GAAG,IAAI,CAACrS,KAAK,CAAC2P,cAAc,CAAC7M,CAAC,EAAEwP,EAAE,GAAG,IAAI,CAACtS,KAAK,CAAC2P,cAAc,CAAC5M,CAAC,CAAC;QACxG,CAAC,MACI;UACD,IAAI,CAAC0F,WAAW,CAAC,IAAI,CAACxI,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAACD,KAAK,CAAC8C,CAAC,EAAE,IAAI,CAAC9C,KAAK,CAAC+C,CAAC,CAAC;QAChE;MACJ;IACJ;IACA,IAAI,IAAI,CAACrB,aAAa,EAAE;MACpB,MAAMgM,KAAK,GAAGhO,SAAS,CAAC,IAAI,CAACiC,YAAY,CAAC;MAC1C,MAAMgM,GAAG,GAAG3G,IAAI,CAAC2G,GAAG,CAACD,KAAK,CAAC;MAC3B,MAAME,GAAG,GAAG5G,IAAI,CAAC4G,GAAG,CAACF,KAAK,CAAC;MAC3B,MAAMD,EAAE,GAAG,IAAInO,KAAK,CAAC,IAAI,CAACU,KAAK,CAACgL,UAAU,CAAC,CAAC,EAAE,IAAI,CAAChL,KAAK,CAACkL,UAAU,CAAC,CAAC,CAAC;MACtE,MAAMsG,EAAE,GAAGjS,eAAe,CAAC,IAAI,CAACuL,yBAAyB,CAAC,CAAC,EAAE6C,GAAG,EAAEC,GAAG,EAAEH,EAAE,CAAC;MAC1E,IAAI,IAAI,CAAC/L,aAAa,CAACmC,IAAI,IAAI,IAAI,EAAE;QACjC,IAAI,CAAC4E,WAAW,CAAC,IAAI,CAAC/G,aAAa,EAAE8P,EAAE,CAAC1O,CAAC,EAAE0O,EAAE,CAACzO,CAAC,CAAC;QAChD;QACA,IAAI,CAACrB,aAAa,CAACmC,IAAI,CAACL,KAAK,CAAC8F,UAAU,GACpC,IAAI,CAACtJ,KAAK,CAAC0C,IAAI,CAACD,KAAK,CAAC2Q,SAAS,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC9S,cAAc,GACnD,QAAQ,GACR,EAAE;MAChB;IACJ;IACA,IAAI,IAAI,CAAC4C,eAAe,IAAI,IAAI,EAAE;MAC9B,IAAI,CAACA,eAAe,CAACK,QAAQ,GAAG,IAAI,CAACvD,KAAK,CAACwD,KAAK,CAACD,QAAQ,IAAI,CAAC;IAClE;IACA,IAAI,IAAI,CAAChB,YAAY,IAAI,IAAI,EAAE;MAC3B,KAAK,IAAIkC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAClC,YAAY,CAACmE,MAAM,EAAEjC,CAAC,IAAI,CAAC,EAAE;QAClD,IAAI,CAAClC,YAAY,CAACkC,CAAC,CAAC,CAACW,MAAM,CAAC,CAAC;MACjC;IACJ;EACJ;EACA;AACJ;AACA;EACI0N,qBAAqBA,CAACnJ,MAAM,EAAE;IAC1B,OAAQ,CAAC,IAAI,CAAClH,KAAK,CAAC2Q,SAAS,CAAC,CAAC,IAAI,IAAI,CAACpT,KAAK,CAAC0C,IAAI,CAACD,KAAK,CAAC4B,iBAAiB,CAAC,CAAC,KAAK,CAAC;EACtF;EACA;AACJ;AACA;EACIyG,yBAAyBA,CAAA,EAAG;IACxB,OAAO,IAAIxL,KAAK,CAAC,IAAI,CAACuD,MAAM,CAACC,CAAC,GAAG,IAAI,CAACD,MAAM,CAACG,KAAK,GAAG,CAAC,EAAE,IAAI,CAACH,MAAM,CAACE,CAAC,GAAG,IAAI,CAAC/B,sBAAsB,CAAC;EACxG;EACA;AACJ;AACA;AACA;EACIqS,wBAAwBA,CAAA,EAAG;IACvB,MAAMhJ,MAAM,GAAG,IAAI,CAACrK,KAAK,CAAC+D,IAAI,CAACuG,SAAS,CAAC,CAAC;IAC1C,OAAOD,MAAM,GAAG,CAAC,IAAI,CAAC5H,KAAK,CAAC6Q,cAAc,CAACjJ,MAAM,CAAC,GAAG,KAAK;EAC9D;EACA;AACJ;AACA;EACIiF,qBAAqBA,CAAA,EAAG;IACpB,IAAI,CAAC,IAAI,CAACiE,WAAW,CAAC,CAAC,EAAE;MACrB,MAAMjL,OAAO,GAAG,IAAI,CAAC+K,wBAAwB,CAAC,CAAC;MAC/C,MAAMhJ,MAAM,GAAG,IAAI,CAACrK,KAAK,CAAC+D,IAAI,CAACuG,SAAS,CAAC,CAAC;MAC1C,MAAMkJ,MAAM,GAAGnJ,MAAM,GAAG,IAAI,CAAC5H,KAAK,CAACC,IAAI,CAACgI,QAAQ,CAACL,MAAM,CAAC,GAAG,IAAI;MAC/D,IAAI,IAAI,CAAClI,eAAe,EAAE;QACtB,IAAIkI,MAAM,IAAIA,MAAM,CAACG,QAAQ,CAAC,CAAC,IAAIlC,OAAO,EAAE;UACxC,MAAM2K,CAAC,GAAG,IAAI,CAAC9Q,eAAe,CAACU,MAAM;UACrC,IAAI2Q,MAAM,IACNP,CAAC,KACAA,CAAC,CAACnQ,CAAC,KAAK0Q,MAAM,CAAC1Q,CAAC,IACbmQ,CAAC,CAAClQ,CAAC,KAAKyQ,MAAM,CAACzQ,CAAC,IAChBkQ,CAAC,CAACjQ,KAAK,KAAKwQ,MAAM,CAACxQ,KAAK,IACxBiQ,CAAC,CAAChQ,MAAM,KAAKuQ,MAAM,CAACvQ,MAAM,CAAC,EAAE;YACjC,IAAI,CAACd,eAAe,CAACU,MAAM,GAAGvE,SAAS,CAAC8I,aAAa,CAACoM,MAAM,CAAC;YAC7D,IAAI,CAACrR,eAAe,CAACiD,MAAM,CAAC,CAAC;UACjC;QACJ,CAAC,MACI;UACD,IAAIoO,MAAM,IAAI,IAAI,IAAIA,MAAM,CAACrR,eAAe,KAAK,IAAI,CAACA,eAAe,EAAE;YACnEqR,MAAM,CAACrR,eAAe,GAAG,IAAI;UACjC;UACA,IAAI,CAACA,eAAe,CAACmP,OAAO,CAAC,CAAC;UAC9B,IAAI,CAACnP,eAAe,GAAG,IAAI;QAC/B;MACJ,CAAC,MACI,IAAI,IAAI,CAAC1B,sBAAsB,IAAI6H,OAAO,EAAE;QAC7C,IAAI+B,MAAM,IACNA,MAAM,CAACG,QAAQ,CAAC,CAAC,IACjBgJ,MAAM,IAAI,IAAI,IACdA,MAAM,CAACrR,eAAe,IAAI,IAAI,EAAE;UAChC,IAAI,CAACA,eAAe,GAAG,IAAI,CAAC+E,0BAA0B,CAACsM,MAAM,CAAC;UAC9D;UACA,IAAI,CAACrR,eAAe,CAACiB,OAAO,GAAG5E,OAAO,CAAC6E,GAAG;UAC1C,IAAI,CAAClB,eAAe,CAACmB,aAAa,GAAG,KAAK;UAC1C,IAAI,CAACnB,eAAe,CAACoB,QAAQ,GAAGiQ,MAAM,CAAChQ,KAAK,CAACD,QAAQ,IAAI,CAAC;UAC1D,IAAI,CAACpB,eAAe,CAACsB,IAAI,CAAC,IAAI,CAAChB,KAAK,CAACiB,OAAO,CAAC,CAAC,CAACC,cAAc,CAAC,CAAC,CAAC;UAChE,IAAI,CAACxB,eAAe,CAACiD,MAAM,CAAC,CAAC;UAC7B;UACAoO,MAAM,CAACrR,eAAe,GAAG,IAAI,CAACA,eAAe;QACjD;MACJ;IACJ;EACJ;EACA;AACJ;AACA;EACIkN,WAAWA,CAAA,EAAG;IACV,IAAI,IAAI,CAAChN,OAAO,IAAI,IAAI,EAAE;MACtB,IAAI,CAACA,OAAO,CAACQ,MAAM,GAAG,IAAI,CAACA,MAAM;MACjC,IAAI,IAAI,CAACR,OAAO,CAACwB,IAAI,CAACoE,UAAU,KAAK,IAAI,CAACxF,KAAK,CAACyF,SAAS,EAAE;QACvD,IAAI,CAAC7F,OAAO,CAACQ,MAAM,CAACG,KAAK,GAAGgE,IAAI,CAACgH,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC3L,OAAO,CAACQ,MAAM,CAACG,KAAK,GAAG,CAAC,CAAC;QACtE,IAAI,CAACX,OAAO,CAACQ,MAAM,CAACI,MAAM,GAAG+D,IAAI,CAACgH,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC3L,OAAO,CAACQ,MAAM,CAACI,MAAM,GAAG,CAAC,CAAC;MAC5E;MACA,IAAI,CAACZ,OAAO,CAACkB,QAAQ,GAAG,IAAI,CAACvD,KAAK,CAACwD,KAAK,CAACD,QAAQ,IAAI,CAAC;MACtD,IAAI,CAAClB,OAAO,CAAC+C,MAAM,CAAC,CAAC;IACzB;IACA,IAAI,CAAClC,eAAe,CAACL,MAAM,GAAG,IAAI,CAAC4Q,wBAAwB,CAAC,CAAC;IAC7D,IAAI,CAACvQ,eAAe,CAACkC,MAAM,CAAC,CAAC;IAC7B,IAAI,CAACkK,qBAAqB,CAAC,CAAC;EAChC;EACA;AACJ;AACA;EACImE,wBAAwBA,CAAA,EAAG;IACvB,OAAO,IAAI,CAAC5Q,MAAM;EACtB;EACA;AACJ;AACA;EACI0Q,WAAWA,CAAA,EAAG;IACV,OAAO,IAAI,CAACrQ,eAAe,IAAI,IAAI;EACvC;EACA;AACJ;AACA;EACIwQ,SAASA,CAAA,EAAG;IACR,IAAI,CAAC1T,KAAK,CAAC0C,IAAI,CAACD,KAAK,CAACkR,cAAc,CAAC,IAAI,CAACrO,aAAa,CAAC;IACxD,IAAI,CAACA,aAAa,GAAG,MAAM;MACvB;IACJ,CAAC;IACD,IAAI,IAAI,CAACjD,OAAO,EAAE;MACd,IAAI,CAACA,OAAO,CAACiP,OAAO,CAAC,CAAC;MACtB,IAAI,CAACjP,OAAO,GAAG,IAAI;IACvB;IACA,IAAI,IAAI,CAACF,eAAe,EAAE;MACtB,MAAMkI,MAAM,GAAG,IAAI,CAACrK,KAAK,CAAC+D,IAAI,CAACuG,SAAS,CAAC,CAAC;MAC1C,MAAMkJ,MAAM,GAAGnJ,MAAM,GAAG,IAAI,CAAC5H,KAAK,CAACC,IAAI,CAACgI,QAAQ,CAACL,MAAM,CAAC,GAAG,IAAI;MAC/D,IAAImJ,MAAM,IAAIA,MAAM,CAACrR,eAAe,KAAK,IAAI,CAACA,eAAe,EAAE;QAC3DqR,MAAM,CAACrR,eAAe,GAAG,IAAI;MACjC;MACA,IAAI,CAACA,eAAe,CAACmP,OAAO,CAAC,CAAC;MAC9B,IAAI,CAACnP,eAAe,GAAG,IAAI;IAC/B;IACA,IAAI,IAAI,CAACL,YAAY,EAAE;MACnB,IAAI,CAACA,YAAY,CAACwP,OAAO,CAAC,CAAC;MAC3B,IAAI,CAACxP,YAAY,GAAG,IAAI;IAC5B;IACA,IAAI,IAAI,CAACoB,eAAe,EAAE;MACtB,IAAI,CAACA,eAAe,CAACoO,OAAO,CAAC,CAAC;IAClC;IACA,IAAI,CAAChP,UAAU,GAAG,IAAI;IACtB,IAAI,CAAC8J,UAAU,CAAC,CAAC;IACjB,KAAK,IAAI3H,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACxE,MAAM,CAACyG,MAAM,EAAEjC,CAAC,IAAI,CAAC,EAAE;MAC5C,IAAI,CAACxE,MAAM,CAACwE,CAAC,CAAC,CAAC6M,OAAO,CAAC,CAAC;IAC5B;IACA,IAAI,CAACrR,MAAM,GAAG,EAAE;IAChB,KAAK,IAAIwE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACnD,aAAa,CAACoF,MAAM,EAAEjC,CAAC,IAAI,CAAC,EAAE;MACnD,IAAI,CAACnD,aAAa,CAACmD,CAAC,CAAC,CAAC6M,OAAO,CAAC,CAAC;IACnC;IACA,IAAI,CAAChQ,aAAa,GAAG,EAAE;EAC3B;AACJ;AACA,eAAexB,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}