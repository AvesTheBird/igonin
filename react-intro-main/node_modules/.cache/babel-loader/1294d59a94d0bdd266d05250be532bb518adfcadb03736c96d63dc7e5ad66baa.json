{"ast":null,"code":"var _Parser, _ContextKeyExpr, _ContextKeyFalseExpr, _ContextKeyTrueExpr, _RawContextKey;\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isChrome, isEdge, isFirefox, isLinux, isMacintosh, isSafari, isWeb, isWindows } from '../../../base/common/platform.js';\nimport { isFalsyOrWhitespace } from '../../../base/common/strings.js';\nimport { Scanner } from './scanner.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { localize } from '../../../nls.js';\nconst CONSTANT_VALUES = new Map();\nCONSTANT_VALUES.set('false', false);\nCONSTANT_VALUES.set('true', true);\nCONSTANT_VALUES.set('isMac', isMacintosh);\nCONSTANT_VALUES.set('isLinux', isLinux);\nCONSTANT_VALUES.set('isWindows', isWindows);\nCONSTANT_VALUES.set('isWeb', isWeb);\nCONSTANT_VALUES.set('isMacNative', isMacintosh && !isWeb);\nCONSTANT_VALUES.set('isEdge', isEdge);\nCONSTANT_VALUES.set('isFirefox', isFirefox);\nCONSTANT_VALUES.set('isChrome', isChrome);\nCONSTANT_VALUES.set('isSafari', isSafari);\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst defaultConfig = {\n  regexParsingWithErrorRecovery: true\n};\nconst errorEmptyString = localize('contextkey.parser.error.emptyString', \"Empty context key expression\");\nconst hintEmptyString = localize('contextkey.parser.error.emptyString.hint', \"Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively.\");\nconst errorNoInAfterNot = localize('contextkey.parser.error.noInAfterNot', \"'in' after 'not'.\");\nconst errorClosingParenthesis = localize('contextkey.parser.error.closingParenthesis', \"closing parenthesis ')'\");\nconst errorUnexpectedToken = localize('contextkey.parser.error.unexpectedToken', \"Unexpected token\");\nconst hintUnexpectedToken = localize('contextkey.parser.error.unexpectedToken.hint', \"Did you forget to put && or || before the token?\");\nconst errorUnexpectedEOF = localize('contextkey.parser.error.unexpectedEOF', \"Unexpected end of expression\");\nconst hintUnexpectedEOF = localize('contextkey.parser.error.unexpectedEOF.hint', \"Did you forget to put a context key?\");\n/**\n * A parser for context key expressions.\n *\n * Example:\n * ```ts\n * const parser = new Parser();\n * const expr = parser.parse('foo == \"bar\" && baz == true');\n *\n * if (expr === undefined) {\n * \t// there were lexing or parsing errors\n * \t// process lexing errors with `parser.lexingErrors`\n *  // process parsing errors with `parser.parsingErrors`\n * } else {\n * \t// expr is a valid expression\n * }\n * ```\n */\nexport class Parser {\n  constructor() {\n    let _config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultConfig;\n    this._config = _config;\n    // lifetime note: `_scanner` lives as long as the parser does, i.e., is not reset between calls to `parse`\n    this._scanner = new Scanner();\n    // lifetime note: `_tokens`, `_current`, and `_parsingErrors` must be reset between calls to `parse`\n    this._tokens = [];\n    this._current = 0; // invariant: 0 <= this._current < this._tokens.length ; any incrementation of this value must first call `_isAtEnd`\n    this._parsingErrors = [];\n    this._flagsGYRe = /g|y/g;\n  }\n  /**\n   * Parse a context key expression.\n   *\n   * @param input the expression to parse\n   * @returns the parsed expression or `undefined` if there's an error - call `lexingErrors` and `parsingErrors` to see the errors\n   */\n  parse(input) {\n    if (input === '') {\n      this._parsingErrors.push({\n        message: errorEmptyString,\n        offset: 0,\n        lexeme: '',\n        additionalInfo: hintEmptyString\n      });\n      return undefined;\n    }\n    this._tokens = this._scanner.reset(input).scan();\n    // @ulugbekna: we do not stop parsing if there are lexing errors to be able to reconstruct regexes with unescaped slashes; TODO@ulugbekna: make this respect config option for recovery\n    this._current = 0;\n    this._parsingErrors = [];\n    try {\n      const expr = this._expr();\n      if (!this._isAtEnd()) {\n        const peek = this._peek();\n        const additionalInfo = peek.type === 17 /* TokenType.Str */ ? hintUnexpectedToken : undefined;\n        this._parsingErrors.push({\n          message: errorUnexpectedToken,\n          offset: peek.offset,\n          lexeme: Scanner.getLexeme(peek),\n          additionalInfo\n        });\n        throw Parser._parseError;\n      }\n      return expr;\n    } catch (e) {\n      if (!(e === Parser._parseError)) {\n        throw e;\n      }\n      return undefined;\n    }\n  }\n  _expr() {\n    return this._or();\n  }\n  _or() {\n    const expr = [this._and()];\n    while (this._matchOne(16 /* TokenType.Or */)) {\n      const right = this._and();\n      expr.push(right);\n    }\n    return expr.length === 1 ? expr[0] : ContextKeyExpr.or(...expr);\n  }\n  _and() {\n    const expr = [this._term()];\n    while (this._matchOne(15 /* TokenType.And */)) {\n      const right = this._term();\n      expr.push(right);\n    }\n    return expr.length === 1 ? expr[0] : ContextKeyExpr.and(...expr);\n  }\n  _term() {\n    if (this._matchOne(2 /* TokenType.Neg */)) {\n      const peek = this._peek();\n      switch (peek.type) {\n        case 11 /* TokenType.True */:\n          this._advance();\n          return ContextKeyFalseExpr.INSTANCE;\n        case 12 /* TokenType.False */:\n          this._advance();\n          return ContextKeyTrueExpr.INSTANCE;\n        case 0 /* TokenType.LParen */:\n          {\n            this._advance();\n            const expr = this._expr();\n            this._consume(1 /* TokenType.RParen */, errorClosingParenthesis);\n            return expr === null || expr === void 0 ? void 0 : expr.negate();\n          }\n        case 17 /* TokenType.Str */:\n          this._advance();\n          return ContextKeyNotExpr.create(peek.lexeme);\n        default:\n          throw this._errExpectedButGot(\"KEY | true | false | '(' expression ')'\", peek);\n      }\n    }\n    return this._primary();\n  }\n  _primary() {\n    const peek = this._peek();\n    switch (peek.type) {\n      case 11 /* TokenType.True */:\n        this._advance();\n        return ContextKeyExpr.true();\n      case 12 /* TokenType.False */:\n        this._advance();\n        return ContextKeyExpr.false();\n      case 0 /* TokenType.LParen */:\n        {\n          this._advance();\n          const expr = this._expr();\n          this._consume(1 /* TokenType.RParen */, errorClosingParenthesis);\n          return expr;\n        }\n      case 17 /* TokenType.Str */:\n        {\n          // KEY\n          const key = peek.lexeme;\n          this._advance();\n          // =~ regex\n          if (this._matchOne(9 /* TokenType.RegexOp */)) {\n            // @ulugbekna: we need to reconstruct the regex from the tokens because some extensions use unescaped slashes in regexes\n            const expr = this._peek();\n            if (!this._config.regexParsingWithErrorRecovery) {\n              this._advance();\n              if (expr.type !== 10 /* TokenType.RegexStr */) {\n                throw this._errExpectedButGot(\"REGEX\", expr);\n              }\n              const regexLexeme = expr.lexeme;\n              const closingSlashIndex = regexLexeme.lastIndexOf('/');\n              const flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));\n              let regexp;\n              try {\n                regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);\n              } catch (e) {\n                throw this._errExpectedButGot(\"REGEX\", expr);\n              }\n              return ContextKeyRegexExpr.create(key, regexp);\n            }\n            switch (expr.type) {\n              case 10 /* TokenType.RegexStr */:\n              case 19 /* TokenType.Error */:\n                {\n                  // also handle an ErrorToken in case of smth such as /(/file)/\n                  const lexemeReconstruction = [expr.lexeme]; // /REGEX/ or /REGEX/FLAGS\n                  this._advance();\n                  let followingToken = this._peek();\n                  let parenBalance = 0;\n                  for (let i = 0; i < expr.lexeme.length; i++) {\n                    if (expr.lexeme.charCodeAt(i) === 40 /* CharCode.OpenParen */) {\n                      parenBalance++;\n                    } else if (expr.lexeme.charCodeAt(i) === 41 /* CharCode.CloseParen */) {\n                      parenBalance--;\n                    }\n                  }\n                  while (!this._isAtEnd() && followingToken.type !== 15 /* TokenType.And */ && followingToken.type !== 16 /* TokenType.Or */) {\n                    switch (followingToken.type) {\n                      case 0 /* TokenType.LParen */:\n                        parenBalance++;\n                        break;\n                      case 1 /* TokenType.RParen */:\n                        parenBalance--;\n                        break;\n                      case 10 /* TokenType.RegexStr */:\n                      case 18 /* TokenType.QuotedStr */:\n                        for (let i = 0; i < followingToken.lexeme.length; i++) {\n                          if (followingToken.lexeme.charCodeAt(i) === 40 /* CharCode.OpenParen */) {\n                            parenBalance++;\n                          } else if (expr.lexeme.charCodeAt(i) === 41 /* CharCode.CloseParen */) {\n                            parenBalance--;\n                          }\n                        }\n                    }\n                    if (parenBalance < 0) {\n                      break;\n                    }\n                    lexemeReconstruction.push(Scanner.getLexeme(followingToken));\n                    this._advance();\n                    followingToken = this._peek();\n                  }\n                  const regexLexeme = lexemeReconstruction.join('');\n                  const closingSlashIndex = regexLexeme.lastIndexOf('/');\n                  const flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));\n                  let regexp;\n                  try {\n                    regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);\n                  } catch (e) {\n                    throw this._errExpectedButGot(\"REGEX\", expr);\n                  }\n                  return ContextKeyExpr.regex(key, regexp);\n                }\n              case 18 /* TokenType.QuotedStr */:\n                {\n                  const serializedValue = expr.lexeme;\n                  this._advance();\n                  // replicate old regex parsing behavior\n                  let regex = null;\n                  if (!isFalsyOrWhitespace(serializedValue)) {\n                    const start = serializedValue.indexOf('/');\n                    const end = serializedValue.lastIndexOf('/');\n                    if (start !== end && start >= 0) {\n                      const value = serializedValue.slice(start + 1, end);\n                      const caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n                      try {\n                        regex = new RegExp(value, caseIgnoreFlag);\n                      } catch (_e) {\n                        throw this._errExpectedButGot(\"REGEX\", expr);\n                      }\n                    }\n                  }\n                  if (regex === null) {\n                    throw this._errExpectedButGot('REGEX', expr);\n                  }\n                  return ContextKeyRegexExpr.create(key, regex);\n                }\n              default:\n                throw this._errExpectedButGot('REGEX', this._peek());\n            }\n          }\n          // [ 'not' 'in' value ]\n          if (this._matchOne(14 /* TokenType.Not */)) {\n            this._consume(13 /* TokenType.In */, errorNoInAfterNot);\n            const right = this._value();\n            return ContextKeyExpr.notIn(key, right);\n          }\n          // [ ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in') value ]\n          const maybeOp = this._peek().type;\n          switch (maybeOp) {\n            case 3 /* TokenType.Eq */:\n              {\n                this._advance();\n                const right = this._value();\n                if (this._previous().type === 18 /* TokenType.QuotedStr */) {\n                  // to preserve old parser behavior: \"foo == 'true'\" is preserved as \"foo == 'true'\", but \"foo == true\" is optimized as \"foo\"\n                  return ContextKeyExpr.equals(key, right);\n                }\n                switch (right) {\n                  case 'true':\n                    return ContextKeyExpr.has(key);\n                  case 'false':\n                    return ContextKeyExpr.not(key);\n                  default:\n                    return ContextKeyExpr.equals(key, right);\n                }\n              }\n            case 4 /* TokenType.NotEq */:\n              {\n                this._advance();\n                const right = this._value();\n                if (this._previous().type === 18 /* TokenType.QuotedStr */) {\n                  // same as above with \"foo != 'true'\"\n                  return ContextKeyExpr.notEquals(key, right);\n                }\n                switch (right) {\n                  case 'true':\n                    return ContextKeyExpr.not(key);\n                  case 'false':\n                    return ContextKeyExpr.has(key);\n                  default:\n                    return ContextKeyExpr.notEquals(key, right);\n                }\n              }\n            // TODO: ContextKeyExpr.smaller(key, right) accepts only `number` as `right` AND during eval of this node, we just eval to `false` if `right` is not a number\n            // consequently, package.json linter should _warn_ the user if they're passing undesired things to ops\n            case 5 /* TokenType.Lt */:\n              this._advance();\n              return ContextKeySmallerExpr.create(key, this._value());\n            case 6 /* TokenType.LtEq */:\n              this._advance();\n              return ContextKeySmallerEqualsExpr.create(key, this._value());\n            case 7 /* TokenType.Gt */:\n              this._advance();\n              return ContextKeyGreaterExpr.create(key, this._value());\n            case 8 /* TokenType.GtEq */:\n              this._advance();\n              return ContextKeyGreaterEqualsExpr.create(key, this._value());\n            case 13 /* TokenType.In */:\n              this._advance();\n              return ContextKeyExpr.in(key, this._value());\n            default:\n              return ContextKeyExpr.has(key);\n          }\n        }\n      case 20 /* TokenType.EOF */:\n        this._parsingErrors.push({\n          message: errorUnexpectedEOF,\n          offset: peek.offset,\n          lexeme: '',\n          additionalInfo: hintUnexpectedEOF\n        });\n        throw Parser._parseError;\n      default:\n        throw this._errExpectedButGot(\"true | false | KEY \\n\\t| KEY '=~' REGEX \\n\\t| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value\", this._peek());\n    }\n  }\n  _value() {\n    const token = this._peek();\n    switch (token.type) {\n      case 17 /* TokenType.Str */:\n      case 18 /* TokenType.QuotedStr */:\n        this._advance();\n        return token.lexeme;\n      case 11 /* TokenType.True */:\n        this._advance();\n        return 'true';\n      case 12 /* TokenType.False */:\n        this._advance();\n        return 'false';\n      case 13 /* TokenType.In */:\n        // we support `in` as a value, e.g., \"when\": \"languageId == in\" - exists in existing extensions\n        this._advance();\n        return 'in';\n      default:\n        // this allows \"when\": \"foo == \" which's used by existing extensions\n        // we do not call `_advance` on purpose - we don't want to eat unintended tokens\n        return '';\n    }\n  }\n  _removeFlagsGY(flags) {\n    return flags.replaceAll(this._flagsGYRe, '');\n  }\n  // careful: this can throw if current token is the initial one (ie index = 0)\n  _previous() {\n    return this._tokens[this._current - 1];\n  }\n  _matchOne(token) {\n    if (this._check(token)) {\n      this._advance();\n      return true;\n    }\n    return false;\n  }\n  _advance() {\n    if (!this._isAtEnd()) {\n      this._current++;\n    }\n    return this._previous();\n  }\n  _consume(type, message) {\n    if (this._check(type)) {\n      return this._advance();\n    }\n    throw this._errExpectedButGot(message, this._peek());\n  }\n  _errExpectedButGot(expected, got, additionalInfo) {\n    const message = localize('contextkey.parser.error.expectedButGot', \"Expected: {0}\\nReceived: '{1}'.\", expected, Scanner.getLexeme(got));\n    const offset = got.offset;\n    const lexeme = Scanner.getLexeme(got);\n    this._parsingErrors.push({\n      message,\n      offset,\n      lexeme,\n      additionalInfo\n    });\n    return Parser._parseError;\n  }\n  _check(type) {\n    return this._peek().type === type;\n  }\n  _peek() {\n    return this._tokens[this._current];\n  }\n  _isAtEnd() {\n    return this._peek().type === 20 /* TokenType.EOF */;\n  }\n}\n_Parser = Parser;\n// Note: this doesn't produce an exact syntax tree but a normalized one\n// ContextKeyExpression's that we use as AST nodes do not expose constructors that do not normalize\n_Parser._parseError = new Error();\nexport class ContextKeyExpr {\n  static false() {\n    return ContextKeyFalseExpr.INSTANCE;\n  }\n  static true() {\n    return ContextKeyTrueExpr.INSTANCE;\n  }\n  static has(key) {\n    return ContextKeyDefinedExpr.create(key);\n  }\n  static equals(key, value) {\n    return ContextKeyEqualsExpr.create(key, value);\n  }\n  static notEquals(key, value) {\n    return ContextKeyNotEqualsExpr.create(key, value);\n  }\n  static regex(key, value) {\n    return ContextKeyRegexExpr.create(key, value);\n  }\n  static in(key, value) {\n    return ContextKeyInExpr.create(key, value);\n  }\n  static notIn(key, value) {\n    return ContextKeyNotInExpr.create(key, value);\n  }\n  static not(key) {\n    return ContextKeyNotExpr.create(key);\n  }\n  static and() {\n    for (var _len = arguments.length, expr = new Array(_len), _key = 0; _key < _len; _key++) {\n      expr[_key] = arguments[_key];\n    }\n    return ContextKeyAndExpr.create(expr, null, true);\n  }\n  static or() {\n    for (var _len2 = arguments.length, expr = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      expr[_key2] = arguments[_key2];\n    }\n    return ContextKeyOrExpr.create(expr, null, true);\n  }\n  static deserialize(serialized) {\n    if (serialized === undefined || serialized === null) {\n      // an empty string needs to be handled by the parser to get a corresponding parsing error reported\n      return undefined;\n    }\n    const expr = this._parser.parse(serialized);\n    return expr;\n  }\n}\n_ContextKeyExpr = ContextKeyExpr;\n_ContextKeyExpr._parser = new Parser({\n  regexParsingWithErrorRecovery: false\n});\nexport function expressionsAreEqualWithConstantSubstitution(a, b) {\n  const aExpr = a ? a.substituteConstants() : undefined;\n  const bExpr = b ? b.substituteConstants() : undefined;\n  if (!aExpr && !bExpr) {\n    return true;\n  }\n  if (!aExpr || !bExpr) {\n    return false;\n  }\n  return aExpr.equals(bExpr);\n}\nfunction cmp(a, b) {\n  return a.cmp(b);\n}\nexport class ContextKeyFalseExpr {\n  constructor() {\n    this.type = 0 /* ContextKeyExprType.False */;\n  }\n  cmp(other) {\n    return this.type - other.type;\n  }\n  equals(other) {\n    return other.type === this.type;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    return false;\n  }\n  serialize() {\n    return 'false';\n  }\n  keys() {\n    return [];\n  }\n  negate() {\n    return ContextKeyTrueExpr.INSTANCE;\n  }\n}\n_ContextKeyFalseExpr = ContextKeyFalseExpr;\n_ContextKeyFalseExpr.INSTANCE = new _ContextKeyFalseExpr();\nexport class ContextKeyTrueExpr {\n  constructor() {\n    this.type = 1 /* ContextKeyExprType.True */;\n  }\n  cmp(other) {\n    return this.type - other.type;\n  }\n  equals(other) {\n    return other.type === this.type;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    return true;\n  }\n  serialize() {\n    return 'true';\n  }\n  keys() {\n    return [];\n  }\n  negate() {\n    return ContextKeyFalseExpr.INSTANCE;\n  }\n}\n_ContextKeyTrueExpr = ContextKeyTrueExpr;\n_ContextKeyTrueExpr.INSTANCE = new _ContextKeyTrueExpr();\nexport class ContextKeyDefinedExpr {\n  static create(key) {\n    let negated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const constantValue = CONSTANT_VALUES.get(key);\n    if (typeof constantValue === 'boolean') {\n      return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n    }\n    return new ContextKeyDefinedExpr(key, negated);\n  }\n  constructor(key, negated) {\n    this.key = key;\n    this.negated = negated;\n    this.type = 2 /* ContextKeyExprType.Defined */;\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp1(this.key, other.key);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key;\n    }\n    return false;\n  }\n  substituteConstants() {\n    const constantValue = CONSTANT_VALUES.get(this.key);\n    if (typeof constantValue === 'boolean') {\n      return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n    }\n    return this;\n  }\n  evaluate(context) {\n    return !!context.getValue(this.key);\n  }\n  serialize() {\n    return this.key;\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyNotExpr.create(this.key, this);\n    }\n    return this.negated;\n  }\n}\nexport class ContextKeyEqualsExpr {\n  static create(key, value) {\n    let negated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    if (typeof value === 'boolean') {\n      return value ? ContextKeyDefinedExpr.create(key, negated) : ContextKeyNotExpr.create(key, negated);\n    }\n    const constantValue = CONSTANT_VALUES.get(key);\n    if (typeof constantValue === 'boolean') {\n      const trueValue = constantValue ? 'true' : 'false';\n      return value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n    }\n    return new ContextKeyEqualsExpr(key, value, negated);\n  }\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 4 /* ContextKeyExprType.Equals */;\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n    return false;\n  }\n  substituteConstants() {\n    const constantValue = CONSTANT_VALUES.get(this.key);\n    if (typeof constantValue === 'boolean') {\n      const trueValue = constantValue ? 'true' : 'false';\n      return this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n    }\n    return this;\n  }\n  evaluate(context) {\n    // Intentional ==\n    // eslint-disable-next-line eqeqeq\n    return context.getValue(this.key) == this.value;\n  }\n  serialize() {\n    return \"\".concat(this.key, \" == '\").concat(this.value, \"'\");\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);\n    }\n    return this.negated;\n  }\n}\nexport class ContextKeyInExpr {\n  static create(key, valueKey) {\n    return new ContextKeyInExpr(key, valueKey);\n  }\n  constructor(key, valueKey) {\n    this.key = key;\n    this.valueKey = valueKey;\n    this.type = 10 /* ContextKeyExprType.In */;\n    this.negated = null;\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.valueKey, other.key, other.valueKey);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.valueKey === other.valueKey;\n    }\n    return false;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    const source = context.getValue(this.valueKey);\n    const item = context.getValue(this.key);\n    if (Array.isArray(source)) {\n      return source.includes(item);\n    }\n    if (typeof item === 'string' && typeof source === 'object' && source !== null) {\n      return hasOwnProperty.call(source, item);\n    }\n    return false;\n  }\n  serialize() {\n    return \"\".concat(this.key, \" in '\").concat(this.valueKey, \"'\");\n  }\n  keys() {\n    return [this.key, this.valueKey];\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyNotInExpr.create(this.key, this.valueKey);\n    }\n    return this.negated;\n  }\n}\nexport class ContextKeyNotInExpr {\n  static create(key, valueKey) {\n    return new ContextKeyNotInExpr(key, valueKey);\n  }\n  constructor(key, valueKey) {\n    this.key = key;\n    this.valueKey = valueKey;\n    this.type = 11 /* ContextKeyExprType.NotIn */;\n    this._negated = ContextKeyInExpr.create(key, valueKey);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return this._negated.cmp(other._negated);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this._negated.equals(other._negated);\n    }\n    return false;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    return !this._negated.evaluate(context);\n  }\n  serialize() {\n    return \"\".concat(this.key, \" not in '\").concat(this.valueKey, \"'\");\n  }\n  keys() {\n    return this._negated.keys();\n  }\n  negate() {\n    return this._negated;\n  }\n}\nexport class ContextKeyNotEqualsExpr {\n  static create(key, value) {\n    let negated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    if (typeof value === 'boolean') {\n      if (value) {\n        return ContextKeyNotExpr.create(key, negated);\n      }\n      return ContextKeyDefinedExpr.create(key, negated);\n    }\n    const constantValue = CONSTANT_VALUES.get(key);\n    if (typeof constantValue === 'boolean') {\n      const falseValue = constantValue ? 'true' : 'false';\n      return value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n    }\n    return new ContextKeyNotEqualsExpr(key, value, negated);\n  }\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 5 /* ContextKeyExprType.NotEquals */;\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n    return false;\n  }\n  substituteConstants() {\n    const constantValue = CONSTANT_VALUES.get(this.key);\n    if (typeof constantValue === 'boolean') {\n      const falseValue = constantValue ? 'true' : 'false';\n      return this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n    }\n    return this;\n  }\n  evaluate(context) {\n    // Intentional !=\n    // eslint-disable-next-line eqeqeq\n    return context.getValue(this.key) != this.value;\n  }\n  serialize() {\n    return \"\".concat(this.key, \" != '\").concat(this.value, \"'\");\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);\n    }\n    return this.negated;\n  }\n}\nexport class ContextKeyNotExpr {\n  static create(key) {\n    let negated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const constantValue = CONSTANT_VALUES.get(key);\n    if (typeof constantValue === 'boolean') {\n      return constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n    }\n    return new ContextKeyNotExpr(key, negated);\n  }\n  constructor(key, negated) {\n    this.key = key;\n    this.negated = negated;\n    this.type = 3 /* ContextKeyExprType.Not */;\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp1(this.key, other.key);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key;\n    }\n    return false;\n  }\n  substituteConstants() {\n    const constantValue = CONSTANT_VALUES.get(this.key);\n    if (typeof constantValue === 'boolean') {\n      return constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n    }\n    return this;\n  }\n  evaluate(context) {\n    return !context.getValue(this.key);\n  }\n  serialize() {\n    return \"!\".concat(this.key);\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyDefinedExpr.create(this.key, this);\n    }\n    return this.negated;\n  }\n}\nfunction withFloatOrStr(value, callback) {\n  if (typeof value === 'string') {\n    const n = parseFloat(value);\n    if (!isNaN(n)) {\n      value = n;\n    }\n  }\n  if (typeof value === 'string' || typeof value === 'number') {\n    return callback(value);\n  }\n  return ContextKeyFalseExpr.INSTANCE;\n}\nexport class ContextKeyGreaterExpr {\n  static create(key, _value) {\n    let negated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return withFloatOrStr(_value, value => new ContextKeyGreaterExpr(key, value, negated));\n  }\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 12 /* ContextKeyExprType.Greater */;\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n    return false;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    if (typeof this.value === 'string') {\n      return false;\n    }\n    return parseFloat(context.getValue(this.key)) > this.value;\n  }\n  serialize() {\n    return \"\".concat(this.key, \" > \").concat(this.value);\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);\n    }\n    return this.negated;\n  }\n}\nexport class ContextKeyGreaterEqualsExpr {\n  static create(key, _value) {\n    let negated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return withFloatOrStr(_value, value => new ContextKeyGreaterEqualsExpr(key, value, negated));\n  }\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 13 /* ContextKeyExprType.GreaterEquals */;\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n    return false;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    if (typeof this.value === 'string') {\n      return false;\n    }\n    return parseFloat(context.getValue(this.key)) >= this.value;\n  }\n  serialize() {\n    return \"\".concat(this.key, \" >= \").concat(this.value);\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeySmallerExpr.create(this.key, this.value, this);\n    }\n    return this.negated;\n  }\n}\nexport class ContextKeySmallerExpr {\n  static create(key, _value) {\n    let negated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return withFloatOrStr(_value, value => new ContextKeySmallerExpr(key, value, negated));\n  }\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 14 /* ContextKeyExprType.Smaller */;\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n    return false;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    if (typeof this.value === 'string') {\n      return false;\n    }\n    return parseFloat(context.getValue(this.key)) < this.value;\n  }\n  serialize() {\n    return \"\".concat(this.key, \" < \").concat(this.value);\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);\n    }\n    return this.negated;\n  }\n}\nexport class ContextKeySmallerEqualsExpr {\n  static create(key, _value) {\n    let negated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return withFloatOrStr(_value, value => new ContextKeySmallerEqualsExpr(key, value, negated));\n  }\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 15 /* ContextKeyExprType.SmallerEquals */;\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n    return false;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    if (typeof this.value === 'string') {\n      return false;\n    }\n    return parseFloat(context.getValue(this.key)) <= this.value;\n  }\n  serialize() {\n    return \"\".concat(this.key, \" <= \").concat(this.value);\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);\n    }\n    return this.negated;\n  }\n}\nexport class ContextKeyRegexExpr {\n  static create(key, regexp) {\n    return new ContextKeyRegexExpr(key, regexp);\n  }\n  constructor(key, regexp) {\n    this.key = key;\n    this.regexp = regexp;\n    this.type = 7 /* ContextKeyExprType.Regex */;\n    this.negated = null;\n    //\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    if (this.key < other.key) {\n      return -1;\n    }\n    if (this.key > other.key) {\n      return 1;\n    }\n    const thisSource = this.regexp ? this.regexp.source : '';\n    const otherSource = other.regexp ? other.regexp.source : '';\n    if (thisSource < otherSource) {\n      return -1;\n    }\n    if (thisSource > otherSource) {\n      return 1;\n    }\n    return 0;\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      const thisSource = this.regexp ? this.regexp.source : '';\n      const otherSource = other.regexp ? other.regexp.source : '';\n      return this.key === other.key && thisSource === otherSource;\n    }\n    return false;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    const value = context.getValue(this.key);\n    return this.regexp ? this.regexp.test(value) : false;\n  }\n  serialize() {\n    const value = this.regexp ? \"/\".concat(this.regexp.source, \"/\").concat(this.regexp.flags) : '/invalid/';\n    return \"\".concat(this.key, \" =~ \").concat(value);\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyNotRegexExpr.create(this);\n    }\n    return this.negated;\n  }\n}\nexport class ContextKeyNotRegexExpr {\n  static create(actual) {\n    return new ContextKeyNotRegexExpr(actual);\n  }\n  constructor(_actual) {\n    this._actual = _actual;\n    this.type = 8 /* ContextKeyExprType.NotRegex */;\n    //\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return this._actual.cmp(other._actual);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this._actual.equals(other._actual);\n    }\n    return false;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    return !this._actual.evaluate(context);\n  }\n  serialize() {\n    return \"!(\".concat(this._actual.serialize(), \")\");\n  }\n  keys() {\n    return this._actual.keys();\n  }\n  negate() {\n    return this._actual;\n  }\n}\n/**\n * @returns the same instance if nothing changed.\n */\nfunction eliminateConstantsInArray(arr) {\n  // Allocate array only if there is a difference\n  let newArr = null;\n  for (let i = 0, len = arr.length; i < len; i++) {\n    const newExpr = arr[i].substituteConstants();\n    if (arr[i] !== newExpr) {\n      // something has changed!\n      // allocate array on first difference\n      if (newArr === null) {\n        newArr = [];\n        for (let j = 0; j < i; j++) {\n          newArr[j] = arr[j];\n        }\n      }\n    }\n    if (newArr !== null) {\n      newArr[i] = newExpr;\n    }\n  }\n  if (newArr === null) {\n    return arr;\n  }\n  return newArr;\n}\nexport class ContextKeyAndExpr {\n  static create(_expr, negated, extraRedundantCheck) {\n    return ContextKeyAndExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n  }\n  constructor(expr, negated) {\n    this.expr = expr;\n    this.negated = negated;\n    this.type = 6 /* ContextKeyExprType.And */;\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    if (this.expr.length < other.expr.length) {\n      return -1;\n    }\n    if (this.expr.length > other.expr.length) {\n      return 1;\n    }\n    for (let i = 0, len = this.expr.length; i < len; i++) {\n      const r = cmp(this.expr[i], other.expr[i]);\n      if (r !== 0) {\n        return r;\n      }\n    }\n    return 0;\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      if (this.expr.length !== other.expr.length) {\n        return false;\n      }\n      for (let i = 0, len = this.expr.length; i < len; i++) {\n        if (!this.expr[i].equals(other.expr[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  substituteConstants() {\n    const exprArr = eliminateConstantsInArray(this.expr);\n    if (exprArr === this.expr) {\n      // no change\n      return this;\n    }\n    return ContextKeyAndExpr.create(exprArr, this.negated, false);\n  }\n  evaluate(context) {\n    for (let i = 0, len = this.expr.length; i < len; i++) {\n      if (!this.expr[i].evaluate(context)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  static _normalizeArr(arr, negated, extraRedundantCheck) {\n    const expr = [];\n    let hasTrue = false;\n    for (const e of arr) {\n      if (!e) {\n        continue;\n      }\n      if (e.type === 1 /* ContextKeyExprType.True */) {\n        // anything && true ==> anything\n        hasTrue = true;\n        continue;\n      }\n      if (e.type === 0 /* ContextKeyExprType.False */) {\n        // anything && false ==> false\n        return ContextKeyFalseExpr.INSTANCE;\n      }\n      if (e.type === 6 /* ContextKeyExprType.And */) {\n        expr.push(...e.expr);\n        continue;\n      }\n      expr.push(e);\n    }\n    if (expr.length === 0 && hasTrue) {\n      return ContextKeyTrueExpr.INSTANCE;\n    }\n    if (expr.length === 0) {\n      return undefined;\n    }\n    if (expr.length === 1) {\n      return expr[0];\n    }\n    expr.sort(cmp);\n    // eliminate duplicate terms\n    for (let i = 1; i < expr.length; i++) {\n      if (expr[i - 1].equals(expr[i])) {\n        expr.splice(i, 1);\n        i--;\n      }\n    }\n    if (expr.length === 1) {\n      return expr[0];\n    }\n    // We must distribute any OR expression because we don't support parens\n    // OR extensions will be at the end (due to sorting rules)\n    while (expr.length > 1) {\n      const lastElement = expr[expr.length - 1];\n      if (lastElement.type !== 9 /* ContextKeyExprType.Or */) {\n        break;\n      }\n      // pop the last element\n      expr.pop();\n      // pop the second to last element\n      const secondToLastElement = expr.pop();\n      const isFinished = expr.length === 0;\n      // distribute `lastElement` over `secondToLastElement`\n      const resultElement = ContextKeyOrExpr.create(lastElement.expr.map(el => ContextKeyAndExpr.create([el, secondToLastElement], null, extraRedundantCheck)), null, isFinished);\n      if (resultElement) {\n        expr.push(resultElement);\n        expr.sort(cmp);\n      }\n    }\n    if (expr.length === 1) {\n      return expr[0];\n    }\n    // resolve false AND expressions\n    if (extraRedundantCheck) {\n      for (let i = 0; i < expr.length; i++) {\n        for (let j = i + 1; j < expr.length; j++) {\n          if (expr[i].negate().equals(expr[j])) {\n            // A && !A case\n            return ContextKeyFalseExpr.INSTANCE;\n          }\n        }\n      }\n      if (expr.length === 1) {\n        return expr[0];\n      }\n    }\n    return new ContextKeyAndExpr(expr, negated);\n  }\n  serialize() {\n    return this.expr.map(e => e.serialize()).join(' && ');\n  }\n  keys() {\n    const result = [];\n    for (const expr of this.expr) {\n      result.push(...expr.keys());\n    }\n    return result;\n  }\n  negate() {\n    if (!this.negated) {\n      const result = [];\n      for (const expr of this.expr) {\n        result.push(expr.negate());\n      }\n      this.negated = ContextKeyOrExpr.create(result, this, true);\n    }\n    return this.negated;\n  }\n}\nexport class ContextKeyOrExpr {\n  static create(_expr, negated, extraRedundantCheck) {\n    return ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n  }\n  constructor(expr, negated) {\n    this.expr = expr;\n    this.negated = negated;\n    this.type = 9 /* ContextKeyExprType.Or */;\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    if (this.expr.length < other.expr.length) {\n      return -1;\n    }\n    if (this.expr.length > other.expr.length) {\n      return 1;\n    }\n    for (let i = 0, len = this.expr.length; i < len; i++) {\n      const r = cmp(this.expr[i], other.expr[i]);\n      if (r !== 0) {\n        return r;\n      }\n    }\n    return 0;\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      if (this.expr.length !== other.expr.length) {\n        return false;\n      }\n      for (let i = 0, len = this.expr.length; i < len; i++) {\n        if (!this.expr[i].equals(other.expr[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  substituteConstants() {\n    const exprArr = eliminateConstantsInArray(this.expr);\n    if (exprArr === this.expr) {\n      // no change\n      return this;\n    }\n    return ContextKeyOrExpr.create(exprArr, this.negated, false);\n  }\n  evaluate(context) {\n    for (let i = 0, len = this.expr.length; i < len; i++) {\n      if (this.expr[i].evaluate(context)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  static _normalizeArr(arr, negated, extraRedundantCheck) {\n    let expr = [];\n    let hasFalse = false;\n    if (arr) {\n      for (let i = 0, len = arr.length; i < len; i++) {\n        const e = arr[i];\n        if (!e) {\n          continue;\n        }\n        if (e.type === 0 /* ContextKeyExprType.False */) {\n          // anything || false ==> anything\n          hasFalse = true;\n          continue;\n        }\n        if (e.type === 1 /* ContextKeyExprType.True */) {\n          // anything || true ==> true\n          return ContextKeyTrueExpr.INSTANCE;\n        }\n        if (e.type === 9 /* ContextKeyExprType.Or */) {\n          expr = expr.concat(e.expr);\n          continue;\n        }\n        expr.push(e);\n      }\n      if (expr.length === 0 && hasFalse) {\n        return ContextKeyFalseExpr.INSTANCE;\n      }\n      expr.sort(cmp);\n    }\n    if (expr.length === 0) {\n      return undefined;\n    }\n    if (expr.length === 1) {\n      return expr[0];\n    }\n    // eliminate duplicate terms\n    for (let i = 1; i < expr.length; i++) {\n      if (expr[i - 1].equals(expr[i])) {\n        expr.splice(i, 1);\n        i--;\n      }\n    }\n    if (expr.length === 1) {\n      return expr[0];\n    }\n    // resolve true OR expressions\n    if (extraRedundantCheck) {\n      for (let i = 0; i < expr.length; i++) {\n        for (let j = i + 1; j < expr.length; j++) {\n          if (expr[i].negate().equals(expr[j])) {\n            // A || !A case\n            return ContextKeyTrueExpr.INSTANCE;\n          }\n        }\n      }\n      if (expr.length === 1) {\n        return expr[0];\n      }\n    }\n    return new ContextKeyOrExpr(expr, negated);\n  }\n  serialize() {\n    return this.expr.map(e => e.serialize()).join(' || ');\n  }\n  keys() {\n    const result = [];\n    for (const expr of this.expr) {\n      result.push(...expr.keys());\n    }\n    return result;\n  }\n  negate() {\n    if (!this.negated) {\n      const result = [];\n      for (const expr of this.expr) {\n        result.push(expr.negate());\n      }\n      // We don't support parens, so here we distribute the AND over the OR terminals\n      // We always take the first 2 AND pairs and distribute them\n      while (result.length > 1) {\n        const LEFT = result.shift();\n        const RIGHT = result.shift();\n        const all = [];\n        for (const left of getTerminals(LEFT)) {\n          for (const right of getTerminals(RIGHT)) {\n            all.push(ContextKeyAndExpr.create([left, right], null, false));\n          }\n        }\n        result.unshift(ContextKeyOrExpr.create(all, null, false));\n      }\n      this.negated = ContextKeyOrExpr.create(result, this, true);\n    }\n    return this.negated;\n  }\n}\nexport class RawContextKey extends ContextKeyDefinedExpr {\n  static all() {\n    return RawContextKey._info.values();\n  }\n  constructor(key, defaultValue, metaOrHide) {\n    super(key, null);\n    this._defaultValue = defaultValue;\n    // collect all context keys into a central place\n    if (typeof metaOrHide === 'object') {\n      RawContextKey._info.push({\n        ...metaOrHide,\n        key\n      });\n    } else if (metaOrHide !== true) {\n      RawContextKey._info.push({\n        key,\n        description: metaOrHide,\n        type: defaultValue !== null && defaultValue !== undefined ? typeof defaultValue : undefined\n      });\n    }\n  }\n  bindTo(target) {\n    return target.createKey(this.key, this._defaultValue);\n  }\n  getValue(target) {\n    return target.getContextKeyValue(this.key);\n  }\n  toNegated() {\n    return this.negate();\n  }\n  isEqualTo(value) {\n    return ContextKeyEqualsExpr.create(this.key, value);\n  }\n}\n_RawContextKey = RawContextKey;\n_RawContextKey._info = [];\nexport const IContextKeyService = createDecorator('contextKeyService');\nfunction cmp1(key1, key2) {\n  if (key1 < key2) {\n    return -1;\n  }\n  if (key1 > key2) {\n    return 1;\n  }\n  return 0;\n}\nfunction cmp2(key1, value1, key2, value2) {\n  if (key1 < key2) {\n    return -1;\n  }\n  if (key1 > key2) {\n    return 1;\n  }\n  if (value1 < value2) {\n    return -1;\n  }\n  if (value1 > value2) {\n    return 1;\n  }\n  return 0;\n}\n/**\n * Returns true if it is provable `p` implies `q`.\n */\nexport function implies(p, q) {\n  if (p.type === 0 /* ContextKeyExprType.False */ || q.type === 1 /* ContextKeyExprType.True */) {\n    // false implies anything\n    // anything implies true\n    return true;\n  }\n  if (p.type === 9 /* ContextKeyExprType.Or */) {\n    if (q.type === 9 /* ContextKeyExprType.Or */) {\n      // `a || b || c` can only imply something like `a || b || c || d`\n      return allElementsIncluded(p.expr, q.expr);\n    }\n    return false;\n  }\n  if (q.type === 9 /* ContextKeyExprType.Or */) {\n    for (const element of q.expr) {\n      if (implies(p, element)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  if (p.type === 6 /* ContextKeyExprType.And */) {\n    if (q.type === 6 /* ContextKeyExprType.And */) {\n      // `a && b && c` implies `a && c`\n      return allElementsIncluded(q.expr, p.expr);\n    }\n    for (const element of p.expr) {\n      if (implies(element, q)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  return p.equals(q);\n}\n/**\n * Returns true if all elements in `p` are also present in `q`.\n * The two arrays are assumed to be sorted\n */\nfunction allElementsIncluded(p, q) {\n  let pIndex = 0;\n  let qIndex = 0;\n  while (pIndex < p.length && qIndex < q.length) {\n    const cmp = p[pIndex].cmp(q[qIndex]);\n    if (cmp < 0) {\n      // an element from `p` is missing from `q`\n      return false;\n    } else if (cmp === 0) {\n      pIndex++;\n      qIndex++;\n    } else {\n      qIndex++;\n    }\n  }\n  return pIndex === p.length;\n}\nfunction getTerminals(node) {\n  if (node.type === 9 /* ContextKeyExprType.Or */) {\n    return node.expr;\n  }\n  return [node];\n}","map":{"version":3,"names":["isChrome","isEdge","isFirefox","isLinux","isMacintosh","isSafari","isWeb","isWindows","isFalsyOrWhitespace","Scanner","createDecorator","localize","CONSTANT_VALUES","Map","set","hasOwnProperty","Object","prototype","defaultConfig","regexParsingWithErrorRecovery","errorEmptyString","hintEmptyString","errorNoInAfterNot","errorClosingParenthesis","errorUnexpectedToken","hintUnexpectedToken","errorUnexpectedEOF","hintUnexpectedEOF","Parser","constructor","_config","arguments","length","undefined","_scanner","_tokens","_current","_parsingErrors","_flagsGYRe","parse","input","push","message","offset","lexeme","additionalInfo","reset","scan","expr","_expr","_isAtEnd","peek","_peek","type","getLexeme","_parseError","e","_or","_and","_matchOne","right","ContextKeyExpr","or","_term","and","_advance","ContextKeyFalseExpr","INSTANCE","ContextKeyTrueExpr","_consume","negate","ContextKeyNotExpr","create","_errExpectedButGot","_primary","true","false","key","regexLexeme","closingSlashIndex","lastIndexOf","flags","_removeFlagsGY","substring","regexp","RegExp","ContextKeyRegexExpr","lexemeReconstruction","followingToken","parenBalance","i","charCodeAt","join","regex","serializedValue","start","indexOf","end","value","slice","caseIgnoreFlag","_e","_value","notIn","maybeOp","_previous","equals","has","not","notEquals","ContextKeySmallerExpr","ContextKeySmallerEqualsExpr","ContextKeyGreaterExpr","ContextKeyGreaterEqualsExpr","in","token","replaceAll","_check","expected","got","_Parser","Error","ContextKeyDefinedExpr","ContextKeyEqualsExpr","ContextKeyNotEqualsExpr","ContextKeyInExpr","ContextKeyNotInExpr","_len","Array","_key","ContextKeyAndExpr","_len2","_key2","ContextKeyOrExpr","deserialize","serialized","_parser","_ContextKeyExpr","expressionsAreEqualWithConstantSubstitution","a","b","aExpr","substituteConstants","bExpr","cmp","other","evaluate","context","serialize","keys","_ContextKeyFalseExpr","_ContextKeyTrueExpr","negated","constantValue","get","cmp1","getValue","trueValue","cmp2","concat","valueKey","source","item","isArray","includes","call","_negated","falseValue","withFloatOrStr","callback","n","parseFloat","isNaN","thisSource","otherSource","test","ContextKeyNotRegexExpr","actual","_actual","eliminateConstantsInArray","arr","newArr","len","newExpr","j","extraRedundantCheck","_normalizeArr","r","exprArr","hasTrue","sort","splice","lastElement","pop","secondToLastElement","isFinished","resultElement","map","el","result","hasFalse","LEFT","shift","RIGHT","all","left","getTerminals","unshift","RawContextKey","_info","values","defaultValue","metaOrHide","_defaultValue","description","bindTo","target","createKey","getContextKeyValue","toNegated","isEqualTo","_RawContextKey","IContextKeyService","key1","key2","value1","value2","implies","p","q","allElementsIncluded","element","pIndex","qIndex","node"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkey.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isChrome, isEdge, isFirefox, isLinux, isMacintosh, isSafari, isWeb, isWindows } from '../../../base/common/platform.js';\nimport { isFalsyOrWhitespace } from '../../../base/common/strings.js';\nimport { Scanner } from './scanner.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { localize } from '../../../nls.js';\nconst CONSTANT_VALUES = new Map();\nCONSTANT_VALUES.set('false', false);\nCONSTANT_VALUES.set('true', true);\nCONSTANT_VALUES.set('isMac', isMacintosh);\nCONSTANT_VALUES.set('isLinux', isLinux);\nCONSTANT_VALUES.set('isWindows', isWindows);\nCONSTANT_VALUES.set('isWeb', isWeb);\nCONSTANT_VALUES.set('isMacNative', isMacintosh && !isWeb);\nCONSTANT_VALUES.set('isEdge', isEdge);\nCONSTANT_VALUES.set('isFirefox', isFirefox);\nCONSTANT_VALUES.set('isChrome', isChrome);\nCONSTANT_VALUES.set('isSafari', isSafari);\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst defaultConfig = {\n    regexParsingWithErrorRecovery: true\n};\nconst errorEmptyString = localize('contextkey.parser.error.emptyString', \"Empty context key expression\");\nconst hintEmptyString = localize('contextkey.parser.error.emptyString.hint', \"Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively.\");\nconst errorNoInAfterNot = localize('contextkey.parser.error.noInAfterNot', \"'in' after 'not'.\");\nconst errorClosingParenthesis = localize('contextkey.parser.error.closingParenthesis', \"closing parenthesis ')'\");\nconst errorUnexpectedToken = localize('contextkey.parser.error.unexpectedToken', \"Unexpected token\");\nconst hintUnexpectedToken = localize('contextkey.parser.error.unexpectedToken.hint', \"Did you forget to put && or || before the token?\");\nconst errorUnexpectedEOF = localize('contextkey.parser.error.unexpectedEOF', \"Unexpected end of expression\");\nconst hintUnexpectedEOF = localize('contextkey.parser.error.unexpectedEOF.hint', \"Did you forget to put a context key?\");\n/**\n * A parser for context key expressions.\n *\n * Example:\n * ```ts\n * const parser = new Parser();\n * const expr = parser.parse('foo == \"bar\" && baz == true');\n *\n * if (expr === undefined) {\n * \t// there were lexing or parsing errors\n * \t// process lexing errors with `parser.lexingErrors`\n *  // process parsing errors with `parser.parsingErrors`\n * } else {\n * \t// expr is a valid expression\n * }\n * ```\n */\nexport class Parser {\n    // Note: this doesn't produce an exact syntax tree but a normalized one\n    // ContextKeyExpression's that we use as AST nodes do not expose constructors that do not normalize\n    static { this._parseError = new Error(); }\n    constructor(_config = defaultConfig) {\n        this._config = _config;\n        // lifetime note: `_scanner` lives as long as the parser does, i.e., is not reset between calls to `parse`\n        this._scanner = new Scanner();\n        // lifetime note: `_tokens`, `_current`, and `_parsingErrors` must be reset between calls to `parse`\n        this._tokens = [];\n        this._current = 0; // invariant: 0 <= this._current < this._tokens.length ; any incrementation of this value must first call `_isAtEnd`\n        this._parsingErrors = [];\n        this._flagsGYRe = /g|y/g;\n    }\n    /**\n     * Parse a context key expression.\n     *\n     * @param input the expression to parse\n     * @returns the parsed expression or `undefined` if there's an error - call `lexingErrors` and `parsingErrors` to see the errors\n     */\n    parse(input) {\n        if (input === '') {\n            this._parsingErrors.push({ message: errorEmptyString, offset: 0, lexeme: '', additionalInfo: hintEmptyString });\n            return undefined;\n        }\n        this._tokens = this._scanner.reset(input).scan();\n        // @ulugbekna: we do not stop parsing if there are lexing errors to be able to reconstruct regexes with unescaped slashes; TODO@ulugbekna: make this respect config option for recovery\n        this._current = 0;\n        this._parsingErrors = [];\n        try {\n            const expr = this._expr();\n            if (!this._isAtEnd()) {\n                const peek = this._peek();\n                const additionalInfo = peek.type === 17 /* TokenType.Str */ ? hintUnexpectedToken : undefined;\n                this._parsingErrors.push({ message: errorUnexpectedToken, offset: peek.offset, lexeme: Scanner.getLexeme(peek), additionalInfo });\n                throw Parser._parseError;\n            }\n            return expr;\n        }\n        catch (e) {\n            if (!(e === Parser._parseError)) {\n                throw e;\n            }\n            return undefined;\n        }\n    }\n    _expr() {\n        return this._or();\n    }\n    _or() {\n        const expr = [this._and()];\n        while (this._matchOne(16 /* TokenType.Or */)) {\n            const right = this._and();\n            expr.push(right);\n        }\n        return expr.length === 1 ? expr[0] : ContextKeyExpr.or(...expr);\n    }\n    _and() {\n        const expr = [this._term()];\n        while (this._matchOne(15 /* TokenType.And */)) {\n            const right = this._term();\n            expr.push(right);\n        }\n        return expr.length === 1 ? expr[0] : ContextKeyExpr.and(...expr);\n    }\n    _term() {\n        if (this._matchOne(2 /* TokenType.Neg */)) {\n            const peek = this._peek();\n            switch (peek.type) {\n                case 11 /* TokenType.True */:\n                    this._advance();\n                    return ContextKeyFalseExpr.INSTANCE;\n                case 12 /* TokenType.False */:\n                    this._advance();\n                    return ContextKeyTrueExpr.INSTANCE;\n                case 0 /* TokenType.LParen */: {\n                    this._advance();\n                    const expr = this._expr();\n                    this._consume(1 /* TokenType.RParen */, errorClosingParenthesis);\n                    return expr?.negate();\n                }\n                case 17 /* TokenType.Str */:\n                    this._advance();\n                    return ContextKeyNotExpr.create(peek.lexeme);\n                default:\n                    throw this._errExpectedButGot(`KEY | true | false | '(' expression ')'`, peek);\n            }\n        }\n        return this._primary();\n    }\n    _primary() {\n        const peek = this._peek();\n        switch (peek.type) {\n            case 11 /* TokenType.True */:\n                this._advance();\n                return ContextKeyExpr.true();\n            case 12 /* TokenType.False */:\n                this._advance();\n                return ContextKeyExpr.false();\n            case 0 /* TokenType.LParen */: {\n                this._advance();\n                const expr = this._expr();\n                this._consume(1 /* TokenType.RParen */, errorClosingParenthesis);\n                return expr;\n            }\n            case 17 /* TokenType.Str */: {\n                // KEY\n                const key = peek.lexeme;\n                this._advance();\n                // =~ regex\n                if (this._matchOne(9 /* TokenType.RegexOp */)) {\n                    // @ulugbekna: we need to reconstruct the regex from the tokens because some extensions use unescaped slashes in regexes\n                    const expr = this._peek();\n                    if (!this._config.regexParsingWithErrorRecovery) {\n                        this._advance();\n                        if (expr.type !== 10 /* TokenType.RegexStr */) {\n                            throw this._errExpectedButGot(`REGEX`, expr);\n                        }\n                        const regexLexeme = expr.lexeme;\n                        const closingSlashIndex = regexLexeme.lastIndexOf('/');\n                        const flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));\n                        let regexp;\n                        try {\n                            regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);\n                        }\n                        catch (e) {\n                            throw this._errExpectedButGot(`REGEX`, expr);\n                        }\n                        return ContextKeyRegexExpr.create(key, regexp);\n                    }\n                    switch (expr.type) {\n                        case 10 /* TokenType.RegexStr */:\n                        case 19 /* TokenType.Error */: { // also handle an ErrorToken in case of smth such as /(/file)/\n                            const lexemeReconstruction = [expr.lexeme]; // /REGEX/ or /REGEX/FLAGS\n                            this._advance();\n                            let followingToken = this._peek();\n                            let parenBalance = 0;\n                            for (let i = 0; i < expr.lexeme.length; i++) {\n                                if (expr.lexeme.charCodeAt(i) === 40 /* CharCode.OpenParen */) {\n                                    parenBalance++;\n                                }\n                                else if (expr.lexeme.charCodeAt(i) === 41 /* CharCode.CloseParen */) {\n                                    parenBalance--;\n                                }\n                            }\n                            while (!this._isAtEnd() && followingToken.type !== 15 /* TokenType.And */ && followingToken.type !== 16 /* TokenType.Or */) {\n                                switch (followingToken.type) {\n                                    case 0 /* TokenType.LParen */:\n                                        parenBalance++;\n                                        break;\n                                    case 1 /* TokenType.RParen */:\n                                        parenBalance--;\n                                        break;\n                                    case 10 /* TokenType.RegexStr */:\n                                    case 18 /* TokenType.QuotedStr */:\n                                        for (let i = 0; i < followingToken.lexeme.length; i++) {\n                                            if (followingToken.lexeme.charCodeAt(i) === 40 /* CharCode.OpenParen */) {\n                                                parenBalance++;\n                                            }\n                                            else if (expr.lexeme.charCodeAt(i) === 41 /* CharCode.CloseParen */) {\n                                                parenBalance--;\n                                            }\n                                        }\n                                }\n                                if (parenBalance < 0) {\n                                    break;\n                                }\n                                lexemeReconstruction.push(Scanner.getLexeme(followingToken));\n                                this._advance();\n                                followingToken = this._peek();\n                            }\n                            const regexLexeme = lexemeReconstruction.join('');\n                            const closingSlashIndex = regexLexeme.lastIndexOf('/');\n                            const flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));\n                            let regexp;\n                            try {\n                                regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);\n                            }\n                            catch (e) {\n                                throw this._errExpectedButGot(`REGEX`, expr);\n                            }\n                            return ContextKeyExpr.regex(key, regexp);\n                        }\n                        case 18 /* TokenType.QuotedStr */: {\n                            const serializedValue = expr.lexeme;\n                            this._advance();\n                            // replicate old regex parsing behavior\n                            let regex = null;\n                            if (!isFalsyOrWhitespace(serializedValue)) {\n                                const start = serializedValue.indexOf('/');\n                                const end = serializedValue.lastIndexOf('/');\n                                if (start !== end && start >= 0) {\n                                    const value = serializedValue.slice(start + 1, end);\n                                    const caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n                                    try {\n                                        regex = new RegExp(value, caseIgnoreFlag);\n                                    }\n                                    catch (_e) {\n                                        throw this._errExpectedButGot(`REGEX`, expr);\n                                    }\n                                }\n                            }\n                            if (regex === null) {\n                                throw this._errExpectedButGot('REGEX', expr);\n                            }\n                            return ContextKeyRegexExpr.create(key, regex);\n                        }\n                        default:\n                            throw this._errExpectedButGot('REGEX', this._peek());\n                    }\n                }\n                // [ 'not' 'in' value ]\n                if (this._matchOne(14 /* TokenType.Not */)) {\n                    this._consume(13 /* TokenType.In */, errorNoInAfterNot);\n                    const right = this._value();\n                    return ContextKeyExpr.notIn(key, right);\n                }\n                // [ ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in') value ]\n                const maybeOp = this._peek().type;\n                switch (maybeOp) {\n                    case 3 /* TokenType.Eq */: {\n                        this._advance();\n                        const right = this._value();\n                        if (this._previous().type === 18 /* TokenType.QuotedStr */) { // to preserve old parser behavior: \"foo == 'true'\" is preserved as \"foo == 'true'\", but \"foo == true\" is optimized as \"foo\"\n                            return ContextKeyExpr.equals(key, right);\n                        }\n                        switch (right) {\n                            case 'true':\n                                return ContextKeyExpr.has(key);\n                            case 'false':\n                                return ContextKeyExpr.not(key);\n                            default:\n                                return ContextKeyExpr.equals(key, right);\n                        }\n                    }\n                    case 4 /* TokenType.NotEq */: {\n                        this._advance();\n                        const right = this._value();\n                        if (this._previous().type === 18 /* TokenType.QuotedStr */) { // same as above with \"foo != 'true'\"\n                            return ContextKeyExpr.notEquals(key, right);\n                        }\n                        switch (right) {\n                            case 'true':\n                                return ContextKeyExpr.not(key);\n                            case 'false':\n                                return ContextKeyExpr.has(key);\n                            default:\n                                return ContextKeyExpr.notEquals(key, right);\n                        }\n                    }\n                    // TODO: ContextKeyExpr.smaller(key, right) accepts only `number` as `right` AND during eval of this node, we just eval to `false` if `right` is not a number\n                    // consequently, package.json linter should _warn_ the user if they're passing undesired things to ops\n                    case 5 /* TokenType.Lt */:\n                        this._advance();\n                        return ContextKeySmallerExpr.create(key, this._value());\n                    case 6 /* TokenType.LtEq */:\n                        this._advance();\n                        return ContextKeySmallerEqualsExpr.create(key, this._value());\n                    case 7 /* TokenType.Gt */:\n                        this._advance();\n                        return ContextKeyGreaterExpr.create(key, this._value());\n                    case 8 /* TokenType.GtEq */:\n                        this._advance();\n                        return ContextKeyGreaterEqualsExpr.create(key, this._value());\n                    case 13 /* TokenType.In */:\n                        this._advance();\n                        return ContextKeyExpr.in(key, this._value());\n                    default:\n                        return ContextKeyExpr.has(key);\n                }\n            }\n            case 20 /* TokenType.EOF */:\n                this._parsingErrors.push({ message: errorUnexpectedEOF, offset: peek.offset, lexeme: '', additionalInfo: hintUnexpectedEOF });\n                throw Parser._parseError;\n            default:\n                throw this._errExpectedButGot(`true | false | KEY \\n\\t| KEY '=~' REGEX \\n\\t| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`, this._peek());\n        }\n    }\n    _value() {\n        const token = this._peek();\n        switch (token.type) {\n            case 17 /* TokenType.Str */:\n            case 18 /* TokenType.QuotedStr */:\n                this._advance();\n                return token.lexeme;\n            case 11 /* TokenType.True */:\n                this._advance();\n                return 'true';\n            case 12 /* TokenType.False */:\n                this._advance();\n                return 'false';\n            case 13 /* TokenType.In */: // we support `in` as a value, e.g., \"when\": \"languageId == in\" - exists in existing extensions\n                this._advance();\n                return 'in';\n            default:\n                // this allows \"when\": \"foo == \" which's used by existing extensions\n                // we do not call `_advance` on purpose - we don't want to eat unintended tokens\n                return '';\n        }\n    }\n    _removeFlagsGY(flags) {\n        return flags.replaceAll(this._flagsGYRe, '');\n    }\n    // careful: this can throw if current token is the initial one (ie index = 0)\n    _previous() {\n        return this._tokens[this._current - 1];\n    }\n    _matchOne(token) {\n        if (this._check(token)) {\n            this._advance();\n            return true;\n        }\n        return false;\n    }\n    _advance() {\n        if (!this._isAtEnd()) {\n            this._current++;\n        }\n        return this._previous();\n    }\n    _consume(type, message) {\n        if (this._check(type)) {\n            return this._advance();\n        }\n        throw this._errExpectedButGot(message, this._peek());\n    }\n    _errExpectedButGot(expected, got, additionalInfo) {\n        const message = localize('contextkey.parser.error.expectedButGot', \"Expected: {0}\\nReceived: '{1}'.\", expected, Scanner.getLexeme(got));\n        const offset = got.offset;\n        const lexeme = Scanner.getLexeme(got);\n        this._parsingErrors.push({ message, offset, lexeme, additionalInfo });\n        return Parser._parseError;\n    }\n    _check(type) {\n        return this._peek().type === type;\n    }\n    _peek() {\n        return this._tokens[this._current];\n    }\n    _isAtEnd() {\n        return this._peek().type === 20 /* TokenType.EOF */;\n    }\n}\nexport class ContextKeyExpr {\n    static false() {\n        return ContextKeyFalseExpr.INSTANCE;\n    }\n    static true() {\n        return ContextKeyTrueExpr.INSTANCE;\n    }\n    static has(key) {\n        return ContextKeyDefinedExpr.create(key);\n    }\n    static equals(key, value) {\n        return ContextKeyEqualsExpr.create(key, value);\n    }\n    static notEquals(key, value) {\n        return ContextKeyNotEqualsExpr.create(key, value);\n    }\n    static regex(key, value) {\n        return ContextKeyRegexExpr.create(key, value);\n    }\n    static in(key, value) {\n        return ContextKeyInExpr.create(key, value);\n    }\n    static notIn(key, value) {\n        return ContextKeyNotInExpr.create(key, value);\n    }\n    static not(key) {\n        return ContextKeyNotExpr.create(key);\n    }\n    static and(...expr) {\n        return ContextKeyAndExpr.create(expr, null, true);\n    }\n    static or(...expr) {\n        return ContextKeyOrExpr.create(expr, null, true);\n    }\n    static { this._parser = new Parser({ regexParsingWithErrorRecovery: false }); }\n    static deserialize(serialized) {\n        if (serialized === undefined || serialized === null) { // an empty string needs to be handled by the parser to get a corresponding parsing error reported\n            return undefined;\n        }\n        const expr = this._parser.parse(serialized);\n        return expr;\n    }\n}\nexport function expressionsAreEqualWithConstantSubstitution(a, b) {\n    const aExpr = a ? a.substituteConstants() : undefined;\n    const bExpr = b ? b.substituteConstants() : undefined;\n    if (!aExpr && !bExpr) {\n        return true;\n    }\n    if (!aExpr || !bExpr) {\n        return false;\n    }\n    return aExpr.equals(bExpr);\n}\nfunction cmp(a, b) {\n    return a.cmp(b);\n}\nexport class ContextKeyFalseExpr {\n    static { this.INSTANCE = new ContextKeyFalseExpr(); }\n    constructor() {\n        this.type = 0 /* ContextKeyExprType.False */;\n    }\n    cmp(other) {\n        return this.type - other.type;\n    }\n    equals(other) {\n        return (other.type === this.type);\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return false;\n    }\n    serialize() {\n        return 'false';\n    }\n    keys() {\n        return [];\n    }\n    negate() {\n        return ContextKeyTrueExpr.INSTANCE;\n    }\n}\nexport class ContextKeyTrueExpr {\n    static { this.INSTANCE = new ContextKeyTrueExpr(); }\n    constructor() {\n        this.type = 1 /* ContextKeyExprType.True */;\n    }\n    cmp(other) {\n        return this.type - other.type;\n    }\n    equals(other) {\n        return (other.type === this.type);\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return true;\n    }\n    serialize() {\n        return 'true';\n    }\n    keys() {\n        return [];\n    }\n    negate() {\n        return ContextKeyFalseExpr.INSTANCE;\n    }\n}\nexport class ContextKeyDefinedExpr {\n    static create(key, negated = null) {\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n        }\n        return new ContextKeyDefinedExpr(key, negated);\n    }\n    constructor(key, negated) {\n        this.key = key;\n        this.negated = negated;\n        this.type = 2 /* ContextKeyExprType.Defined */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp1(this.key, other.key);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n        }\n        return this;\n    }\n    evaluate(context) {\n        return (!!context.getValue(this.key));\n    }\n    serialize() {\n        return this.key;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotExpr.create(this.key, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyEqualsExpr {\n    static create(key, value, negated = null) {\n        if (typeof value === 'boolean') {\n            return (value ? ContextKeyDefinedExpr.create(key, negated) : ContextKeyNotExpr.create(key, negated));\n        }\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            const trueValue = constantValue ? 'true' : 'false';\n            return (value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n        }\n        return new ContextKeyEqualsExpr(key, value, negated);\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 4 /* ContextKeyExprType.Equals */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            const trueValue = constantValue ? 'true' : 'false';\n            return (this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        // Intentional ==\n        // eslint-disable-next-line eqeqeq\n        return (context.getValue(this.key) == this.value);\n    }\n    serialize() {\n        return `${this.key} == '${this.value}'`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyInExpr {\n    static create(key, valueKey) {\n        return new ContextKeyInExpr(key, valueKey);\n    }\n    constructor(key, valueKey) {\n        this.key = key;\n        this.valueKey = valueKey;\n        this.type = 10 /* ContextKeyExprType.In */;\n        this.negated = null;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.valueKey, other.key, other.valueKey);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.valueKey === other.valueKey);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        const source = context.getValue(this.valueKey);\n        const item = context.getValue(this.key);\n        if (Array.isArray(source)) {\n            return source.includes(item);\n        }\n        if (typeof item === 'string' && typeof source === 'object' && source !== null) {\n            return hasOwnProperty.call(source, item);\n        }\n        return false;\n    }\n    serialize() {\n        return `${this.key} in '${this.valueKey}'`;\n    }\n    keys() {\n        return [this.key, this.valueKey];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotInExpr.create(this.key, this.valueKey);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyNotInExpr {\n    static create(key, valueKey) {\n        return new ContextKeyNotInExpr(key, valueKey);\n    }\n    constructor(key, valueKey) {\n        this.key = key;\n        this.valueKey = valueKey;\n        this.type = 11 /* ContextKeyExprType.NotIn */;\n        this._negated = ContextKeyInExpr.create(key, valueKey);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return this._negated.cmp(other._negated);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return this._negated.equals(other._negated);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return !this._negated.evaluate(context);\n    }\n    serialize() {\n        return `${this.key} not in '${this.valueKey}'`;\n    }\n    keys() {\n        return this._negated.keys();\n    }\n    negate() {\n        return this._negated;\n    }\n}\nexport class ContextKeyNotEqualsExpr {\n    static create(key, value, negated = null) {\n        if (typeof value === 'boolean') {\n            if (value) {\n                return ContextKeyNotExpr.create(key, negated);\n            }\n            return ContextKeyDefinedExpr.create(key, negated);\n        }\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            const falseValue = constantValue ? 'true' : 'false';\n            return (value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return new ContextKeyNotEqualsExpr(key, value, negated);\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 5 /* ContextKeyExprType.NotEquals */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            const falseValue = constantValue ? 'true' : 'false';\n            return (this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        // Intentional !=\n        // eslint-disable-next-line eqeqeq\n        return (context.getValue(this.key) != this.value);\n    }\n    serialize() {\n        return `${this.key} != '${this.value}'`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyNotExpr {\n    static create(key, negated = null) {\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            return (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return new ContextKeyNotExpr(key, negated);\n    }\n    constructor(key, negated) {\n        this.key = key;\n        this.negated = negated;\n        this.type = 3 /* ContextKeyExprType.Not */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp1(this.key, other.key);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            return (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        return (!context.getValue(this.key));\n    }\n    serialize() {\n        return `!${this.key}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyDefinedExpr.create(this.key, this);\n        }\n        return this.negated;\n    }\n}\nfunction withFloatOrStr(value, callback) {\n    if (typeof value === 'string') {\n        const n = parseFloat(value);\n        if (!isNaN(n)) {\n            value = n;\n        }\n    }\n    if (typeof value === 'string' || typeof value === 'number') {\n        return callback(value);\n    }\n    return ContextKeyFalseExpr.INSTANCE;\n}\nexport class ContextKeyGreaterExpr {\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeyGreaterExpr(key, value, negated));\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 12 /* ContextKeyExprType.Greater */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) > this.value);\n    }\n    serialize() {\n        return `${this.key} > ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyGreaterEqualsExpr {\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeyGreaterEqualsExpr(key, value, negated));\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 13 /* ContextKeyExprType.GreaterEquals */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) >= this.value);\n    }\n    serialize() {\n        return `${this.key} >= ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeySmallerExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeySmallerExpr {\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeySmallerExpr(key, value, negated));\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 14 /* ContextKeyExprType.Smaller */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) < this.value);\n    }\n    serialize() {\n        return `${this.key} < ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeySmallerEqualsExpr {\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeySmallerEqualsExpr(key, value, negated));\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 15 /* ContextKeyExprType.SmallerEquals */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) <= this.value);\n    }\n    serialize() {\n        return `${this.key} <= ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyRegexExpr {\n    static create(key, regexp) {\n        return new ContextKeyRegexExpr(key, regexp);\n    }\n    constructor(key, regexp) {\n        this.key = key;\n        this.regexp = regexp;\n        this.type = 7 /* ContextKeyExprType.Regex */;\n        this.negated = null;\n        //\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.key < other.key) {\n            return -1;\n        }\n        if (this.key > other.key) {\n            return 1;\n        }\n        const thisSource = this.regexp ? this.regexp.source : '';\n        const otherSource = other.regexp ? other.regexp.source : '';\n        if (thisSource < otherSource) {\n            return -1;\n        }\n        if (thisSource > otherSource) {\n            return 1;\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            const thisSource = this.regexp ? this.regexp.source : '';\n            const otherSource = other.regexp ? other.regexp.source : '';\n            return (this.key === other.key && thisSource === otherSource);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        const value = context.getValue(this.key);\n        return this.regexp ? this.regexp.test(value) : false;\n    }\n    serialize() {\n        const value = this.regexp\n            ? `/${this.regexp.source}/${this.regexp.flags}`\n            : '/invalid/';\n        return `${this.key} =~ ${value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotRegexExpr.create(this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyNotRegexExpr {\n    static create(actual) {\n        return new ContextKeyNotRegexExpr(actual);\n    }\n    constructor(_actual) {\n        this._actual = _actual;\n        this.type = 8 /* ContextKeyExprType.NotRegex */;\n        //\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return this._actual.cmp(other._actual);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return this._actual.equals(other._actual);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return !this._actual.evaluate(context);\n    }\n    serialize() {\n        return `!(${this._actual.serialize()})`;\n    }\n    keys() {\n        return this._actual.keys();\n    }\n    negate() {\n        return this._actual;\n    }\n}\n/**\n * @returns the same instance if nothing changed.\n */\nfunction eliminateConstantsInArray(arr) {\n    // Allocate array only if there is a difference\n    let newArr = null;\n    for (let i = 0, len = arr.length; i < len; i++) {\n        const newExpr = arr[i].substituteConstants();\n        if (arr[i] !== newExpr) {\n            // something has changed!\n            // allocate array on first difference\n            if (newArr === null) {\n                newArr = [];\n                for (let j = 0; j < i; j++) {\n                    newArr[j] = arr[j];\n                }\n            }\n        }\n        if (newArr !== null) {\n            newArr[i] = newExpr;\n        }\n    }\n    if (newArr === null) {\n        return arr;\n    }\n    return newArr;\n}\nexport class ContextKeyAndExpr {\n    static create(_expr, negated, extraRedundantCheck) {\n        return ContextKeyAndExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n    }\n    constructor(expr, negated) {\n        this.expr = expr;\n        this.negated = negated;\n        this.type = 6 /* ContextKeyExprType.And */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.expr.length < other.expr.length) {\n            return -1;\n        }\n        if (this.expr.length > other.expr.length) {\n            return 1;\n        }\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            const r = cmp(this.expr[i], other.expr[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            if (this.expr.length !== other.expr.length) {\n                return false;\n            }\n            for (let i = 0, len = this.expr.length; i < len; i++) {\n                if (!this.expr[i].equals(other.expr[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    substituteConstants() {\n        const exprArr = eliminateConstantsInArray(this.expr);\n        if (exprArr === this.expr) {\n            // no change\n            return this;\n        }\n        return ContextKeyAndExpr.create(exprArr, this.negated, false);\n    }\n    evaluate(context) {\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            if (!this.expr[i].evaluate(context)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _normalizeArr(arr, negated, extraRedundantCheck) {\n        const expr = [];\n        let hasTrue = false;\n        for (const e of arr) {\n            if (!e) {\n                continue;\n            }\n            if (e.type === 1 /* ContextKeyExprType.True */) {\n                // anything && true ==> anything\n                hasTrue = true;\n                continue;\n            }\n            if (e.type === 0 /* ContextKeyExprType.False */) {\n                // anything && false ==> false\n                return ContextKeyFalseExpr.INSTANCE;\n            }\n            if (e.type === 6 /* ContextKeyExprType.And */) {\n                expr.push(...e.expr);\n                continue;\n            }\n            expr.push(e);\n        }\n        if (expr.length === 0 && hasTrue) {\n            return ContextKeyTrueExpr.INSTANCE;\n        }\n        if (expr.length === 0) {\n            return undefined;\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        expr.sort(cmp);\n        // eliminate duplicate terms\n        for (let i = 1; i < expr.length; i++) {\n            if (expr[i - 1].equals(expr[i])) {\n                expr.splice(i, 1);\n                i--;\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // We must distribute any OR expression because we don't support parens\n        // OR extensions will be at the end (due to sorting rules)\n        while (expr.length > 1) {\n            const lastElement = expr[expr.length - 1];\n            if (lastElement.type !== 9 /* ContextKeyExprType.Or */) {\n                break;\n            }\n            // pop the last element\n            expr.pop();\n            // pop the second to last element\n            const secondToLastElement = expr.pop();\n            const isFinished = (expr.length === 0);\n            // distribute `lastElement` over `secondToLastElement`\n            const resultElement = ContextKeyOrExpr.create(lastElement.expr.map(el => ContextKeyAndExpr.create([el, secondToLastElement], null, extraRedundantCheck)), null, isFinished);\n            if (resultElement) {\n                expr.push(resultElement);\n                expr.sort(cmp);\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // resolve false AND expressions\n        if (extraRedundantCheck) {\n            for (let i = 0; i < expr.length; i++) {\n                for (let j = i + 1; j < expr.length; j++) {\n                    if (expr[i].negate().equals(expr[j])) {\n                        // A && !A case\n                        return ContextKeyFalseExpr.INSTANCE;\n                    }\n                }\n            }\n            if (expr.length === 1) {\n                return expr[0];\n            }\n        }\n        return new ContextKeyAndExpr(expr, negated);\n    }\n    serialize() {\n        return this.expr.map(e => e.serialize()).join(' && ');\n    }\n    keys() {\n        const result = [];\n        for (const expr of this.expr) {\n            result.push(...expr.keys());\n        }\n        return result;\n    }\n    negate() {\n        if (!this.negated) {\n            const result = [];\n            for (const expr of this.expr) {\n                result.push(expr.negate());\n            }\n            this.negated = ContextKeyOrExpr.create(result, this, true);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyOrExpr {\n    static create(_expr, negated, extraRedundantCheck) {\n        return ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n    }\n    constructor(expr, negated) {\n        this.expr = expr;\n        this.negated = negated;\n        this.type = 9 /* ContextKeyExprType.Or */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.expr.length < other.expr.length) {\n            return -1;\n        }\n        if (this.expr.length > other.expr.length) {\n            return 1;\n        }\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            const r = cmp(this.expr[i], other.expr[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            if (this.expr.length !== other.expr.length) {\n                return false;\n            }\n            for (let i = 0, len = this.expr.length; i < len; i++) {\n                if (!this.expr[i].equals(other.expr[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    substituteConstants() {\n        const exprArr = eliminateConstantsInArray(this.expr);\n        if (exprArr === this.expr) {\n            // no change\n            return this;\n        }\n        return ContextKeyOrExpr.create(exprArr, this.negated, false);\n    }\n    evaluate(context) {\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            if (this.expr[i].evaluate(context)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static _normalizeArr(arr, negated, extraRedundantCheck) {\n        let expr = [];\n        let hasFalse = false;\n        if (arr) {\n            for (let i = 0, len = arr.length; i < len; i++) {\n                const e = arr[i];\n                if (!e) {\n                    continue;\n                }\n                if (e.type === 0 /* ContextKeyExprType.False */) {\n                    // anything || false ==> anything\n                    hasFalse = true;\n                    continue;\n                }\n                if (e.type === 1 /* ContextKeyExprType.True */) {\n                    // anything || true ==> true\n                    return ContextKeyTrueExpr.INSTANCE;\n                }\n                if (e.type === 9 /* ContextKeyExprType.Or */) {\n                    expr = expr.concat(e.expr);\n                    continue;\n                }\n                expr.push(e);\n            }\n            if (expr.length === 0 && hasFalse) {\n                return ContextKeyFalseExpr.INSTANCE;\n            }\n            expr.sort(cmp);\n        }\n        if (expr.length === 0) {\n            return undefined;\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // eliminate duplicate terms\n        for (let i = 1; i < expr.length; i++) {\n            if (expr[i - 1].equals(expr[i])) {\n                expr.splice(i, 1);\n                i--;\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // resolve true OR expressions\n        if (extraRedundantCheck) {\n            for (let i = 0; i < expr.length; i++) {\n                for (let j = i + 1; j < expr.length; j++) {\n                    if (expr[i].negate().equals(expr[j])) {\n                        // A || !A case\n                        return ContextKeyTrueExpr.INSTANCE;\n                    }\n                }\n            }\n            if (expr.length === 1) {\n                return expr[0];\n            }\n        }\n        return new ContextKeyOrExpr(expr, negated);\n    }\n    serialize() {\n        return this.expr.map(e => e.serialize()).join(' || ');\n    }\n    keys() {\n        const result = [];\n        for (const expr of this.expr) {\n            result.push(...expr.keys());\n        }\n        return result;\n    }\n    negate() {\n        if (!this.negated) {\n            const result = [];\n            for (const expr of this.expr) {\n                result.push(expr.negate());\n            }\n            // We don't support parens, so here we distribute the AND over the OR terminals\n            // We always take the first 2 AND pairs and distribute them\n            while (result.length > 1) {\n                const LEFT = result.shift();\n                const RIGHT = result.shift();\n                const all = [];\n                for (const left of getTerminals(LEFT)) {\n                    for (const right of getTerminals(RIGHT)) {\n                        all.push(ContextKeyAndExpr.create([left, right], null, false));\n                    }\n                }\n                result.unshift(ContextKeyOrExpr.create(all, null, false));\n            }\n            this.negated = ContextKeyOrExpr.create(result, this, true);\n        }\n        return this.negated;\n    }\n}\nexport class RawContextKey extends ContextKeyDefinedExpr {\n    static { this._info = []; }\n    static all() {\n        return RawContextKey._info.values();\n    }\n    constructor(key, defaultValue, metaOrHide) {\n        super(key, null);\n        this._defaultValue = defaultValue;\n        // collect all context keys into a central place\n        if (typeof metaOrHide === 'object') {\n            RawContextKey._info.push({ ...metaOrHide, key });\n        }\n        else if (metaOrHide !== true) {\n            RawContextKey._info.push({ key, description: metaOrHide, type: defaultValue !== null && defaultValue !== undefined ? typeof defaultValue : undefined });\n        }\n    }\n    bindTo(target) {\n        return target.createKey(this.key, this._defaultValue);\n    }\n    getValue(target) {\n        return target.getContextKeyValue(this.key);\n    }\n    toNegated() {\n        return this.negate();\n    }\n    isEqualTo(value) {\n        return ContextKeyEqualsExpr.create(this.key, value);\n    }\n}\nexport const IContextKeyService = createDecorator('contextKeyService');\nfunction cmp1(key1, key2) {\n    if (key1 < key2) {\n        return -1;\n    }\n    if (key1 > key2) {\n        return 1;\n    }\n    return 0;\n}\nfunction cmp2(key1, value1, key2, value2) {\n    if (key1 < key2) {\n        return -1;\n    }\n    if (key1 > key2) {\n        return 1;\n    }\n    if (value1 < value2) {\n        return -1;\n    }\n    if (value1 > value2) {\n        return 1;\n    }\n    return 0;\n}\n/**\n * Returns true if it is provable `p` implies `q`.\n */\nexport function implies(p, q) {\n    if (p.type === 0 /* ContextKeyExprType.False */ || q.type === 1 /* ContextKeyExprType.True */) {\n        // false implies anything\n        // anything implies true\n        return true;\n    }\n    if (p.type === 9 /* ContextKeyExprType.Or */) {\n        if (q.type === 9 /* ContextKeyExprType.Or */) {\n            // `a || b || c` can only imply something like `a || b || c || d`\n            return allElementsIncluded(p.expr, q.expr);\n        }\n        return false;\n    }\n    if (q.type === 9 /* ContextKeyExprType.Or */) {\n        for (const element of q.expr) {\n            if (implies(p, element)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (p.type === 6 /* ContextKeyExprType.And */) {\n        if (q.type === 6 /* ContextKeyExprType.And */) {\n            // `a && b && c` implies `a && c`\n            return allElementsIncluded(q.expr, p.expr);\n        }\n        for (const element of p.expr) {\n            if (implies(element, q)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    return p.equals(q);\n}\n/**\n * Returns true if all elements in `p` are also present in `q`.\n * The two arrays are assumed to be sorted\n */\nfunction allElementsIncluded(p, q) {\n    let pIndex = 0;\n    let qIndex = 0;\n    while (pIndex < p.length && qIndex < q.length) {\n        const cmp = p[pIndex].cmp(q[qIndex]);\n        if (cmp < 0) {\n            // an element from `p` is missing from `q`\n            return false;\n        }\n        else if (cmp === 0) {\n            pIndex++;\n            qIndex++;\n        }\n        else {\n            qIndex++;\n        }\n    }\n    return (pIndex === p.length);\n}\nfunction getTerminals(node) {\n    if (node.type === 9 /* ContextKeyExprType.Or */) {\n        return node.expr;\n    }\n    return [node];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}