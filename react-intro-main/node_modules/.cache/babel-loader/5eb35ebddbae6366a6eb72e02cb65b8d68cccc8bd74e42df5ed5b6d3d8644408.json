{"ast":null,"code":"import _defineProperty from \"D:/OSPanel/domains/react/react-intro-main/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**\n * marked v14.0.0 - a markdown parser\n * Copyright (c) 2011-2024, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\n// ESM-uncomment-begin\nlet __marked_exports = {};\n(function () {\n  function define(deps, factory) {\n    factory(__marked_exports);\n  }\n  define.amd = true;\n  // ESM-uncomment-end\n\n  (function (global, factory) {\n    typeof define === 'function' && define.amd ? define(['exports'], factory) : typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.marked = {}));\n  })(this, function (exports) {\n    'use strict';\n\n    /**\n     * Gets the original marked default options.\n     */\n    function _getDefaults() {\n      return {\n        async: false,\n        breaks: false,\n        extensions: null,\n        gfm: true,\n        hooks: null,\n        pedantic: false,\n        renderer: null,\n        silent: false,\n        tokenizer: null,\n        walkTokens: null\n      };\n    }\n    exports.defaults = _getDefaults();\n    function changeDefaults(newDefaults) {\n      exports.defaults = newDefaults;\n    }\n\n    /**\n     * Helpers\n     */\n    const escapeTest = /[&<>\"']/;\n    const escapeReplace = new RegExp(escapeTest.source, 'g');\n    const escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\n    const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');\n    const escapeReplacements = {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#39;'\n    };\n    const getEscapeReplacement = ch => escapeReplacements[ch];\n    function escape$1(html, encode) {\n      if (encode) {\n        if (escapeTest.test(html)) {\n          return html.replace(escapeReplace, getEscapeReplacement);\n        }\n      } else {\n        if (escapeTestNoEncode.test(html)) {\n          return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n        }\n      }\n      return html;\n    }\n    const caret = /(^|[^\\[])\\^/g;\n    function edit(regex, opt) {\n      let source = typeof regex === 'string' ? regex : regex.source;\n      opt = opt || '';\n      const obj = {\n        replace: (name, val) => {\n          let valSource = typeof val === 'string' ? val : val.source;\n          valSource = valSource.replace(caret, '$1');\n          source = source.replace(name, valSource);\n          return obj;\n        },\n        getRegex: () => {\n          return new RegExp(source, opt);\n        }\n      };\n      return obj;\n    }\n    function cleanUrl(href) {\n      try {\n        href = encodeURI(href).replace(/%25/g, '%');\n      } catch {\n        return null;\n      }\n      return href;\n    }\n    const noopTest = {\n      exec: () => null\n    };\n    function splitCells(tableRow, count) {\n      // ensure that every cell-delimiting pipe has a space\n      // before it to distinguish it from an escaped pipe\n      const row = tableRow.replace(/\\|/g, (match, offset, str) => {\n          let escaped = false;\n          let curr = offset;\n          while (--curr >= 0 && str[curr] === '\\\\') escaped = !escaped;\n          if (escaped) {\n            // odd number of slashes means | is escaped\n            // so we leave it alone\n            return '|';\n          } else {\n            // add space before unescaped |\n            return ' |';\n          }\n        }),\n        cells = row.split(/ \\|/);\n      let i = 0;\n      // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n      if (!cells[0].trim()) {\n        cells.shift();\n      }\n      if (cells.length > 0 && !cells[cells.length - 1].trim()) {\n        cells.pop();\n      }\n      if (count) {\n        if (cells.length > count) {\n          cells.splice(count);\n        } else {\n          while (cells.length < count) cells.push('');\n        }\n      }\n      for (; i < cells.length; i++) {\n        // leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n      }\n      return cells;\n    }\n    /**\n     * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n     * /c*$/ is vulnerable to REDOS.\n     *\n     * @param str\n     * @param c\n     * @param invert Remove suffix of non-c chars instead. Default falsey.\n     */\n    function rtrim(str, c, invert) {\n      const l = str.length;\n      if (l === 0) {\n        return '';\n      }\n      // Length of suffix matching the invert condition.\n      let suffLen = 0;\n      // Step left until we fail to match the invert condition.\n      while (suffLen < l) {\n        const currChar = str.charAt(l - suffLen - 1);\n        if (currChar === c && !invert) {\n          suffLen++;\n        } else if (currChar !== c && invert) {\n          suffLen++;\n        } else {\n          break;\n        }\n      }\n      return str.slice(0, l - suffLen);\n    }\n    function findClosingBracket(str, b) {\n      if (str.indexOf(b[1]) === -1) {\n        return -1;\n      }\n      let level = 0;\n      for (let i = 0; i < str.length; i++) {\n        if (str[i] === '\\\\') {\n          i++;\n        } else if (str[i] === b[0]) {\n          level++;\n        } else if (str[i] === b[1]) {\n          level--;\n          if (level < 0) {\n            return i;\n          }\n        }\n      }\n      return -1;\n    }\n    function outputLink(cap, link, raw, lexer) {\n      const href = link.href;\n      const title = link.title ? escape$1(link.title) : null;\n      const text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n      if (cap[0].charAt(0) !== '!') {\n        lexer.state.inLink = true;\n        const token = {\n          type: 'link',\n          raw,\n          href,\n          title,\n          text,\n          tokens: lexer.inlineTokens(text)\n        };\n        lexer.state.inLink = false;\n        return token;\n      }\n      return {\n        type: 'image',\n        raw,\n        href,\n        title,\n        text: escape$1(text)\n      };\n    }\n    function indentCodeCompensation(raw, text) {\n      const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n      if (matchIndentToCode === null) {\n        return text;\n      }\n      const indentToCode = matchIndentToCode[1];\n      return text.split('\\n').map(node => {\n        const matchIndentInNode = node.match(/^\\s+/);\n        if (matchIndentInNode === null) {\n          return node;\n        }\n        const [indentInNode] = matchIndentInNode;\n        if (indentInNode.length >= indentToCode.length) {\n          return node.slice(indentToCode.length);\n        }\n        return node;\n      }).join('\\n');\n    }\n    /**\n     * Tokenizer\n     */\n    class _Tokenizer {\n      // set by the lexer\n      constructor(options) {\n        _defineProperty(this, \"options\", void 0);\n        _defineProperty(this, \"rules\", void 0);\n        // set by the lexer\n        _defineProperty(this, \"lexer\", void 0);\n        this.options = options || exports.defaults;\n      }\n      space(src) {\n        const cap = this.rules.block.newline.exec(src);\n        if (cap && cap[0].length > 0) {\n          return {\n            type: 'space',\n            raw: cap[0]\n          };\n        }\n      }\n      code(src) {\n        const cap = this.rules.block.code.exec(src);\n        if (cap) {\n          const text = cap[0].replace(/^ {1,4}/gm, '');\n          return {\n            type: 'code',\n            raw: cap[0],\n            codeBlockStyle: 'indented',\n            text: !this.options.pedantic ? rtrim(text, '\\n') : text\n          };\n        }\n      }\n      fences(src) {\n        const cap = this.rules.block.fences.exec(src);\n        if (cap) {\n          const raw = cap[0];\n          const text = indentCodeCompensation(raw, cap[3] || '');\n          return {\n            type: 'code',\n            raw,\n            lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n            text\n          };\n        }\n      }\n      heading(src) {\n        const cap = this.rules.block.heading.exec(src);\n        if (cap) {\n          let text = cap[2].trim();\n          // remove trailing #s\n          if (/#$/.test(text)) {\n            const trimmed = rtrim(text, '#');\n            if (this.options.pedantic) {\n              text = trimmed.trim();\n            } else if (!trimmed || / $/.test(trimmed)) {\n              // CommonMark requires space before trailing #s\n              text = trimmed.trim();\n            }\n          }\n          return {\n            type: 'heading',\n            raw: cap[0],\n            depth: cap[1].length,\n            text,\n            tokens: this.lexer.inline(text)\n          };\n        }\n      }\n      hr(src) {\n        const cap = this.rules.block.hr.exec(src);\n        if (cap) {\n          return {\n            type: 'hr',\n            raw: rtrim(cap[0], '\\n')\n          };\n        }\n      }\n      blockquote(src) {\n        const cap = this.rules.block.blockquote.exec(src);\n        if (cap) {\n          let lines = rtrim(cap[0], '\\n').split('\\n');\n          let raw = '';\n          let text = '';\n          const tokens = [];\n          while (lines.length > 0) {\n            let inBlockquote = false;\n            const currentLines = [];\n            let i;\n            for (i = 0; i < lines.length; i++) {\n              // get lines up to a continuation\n              if (/^ {0,3}>/.test(lines[i])) {\n                currentLines.push(lines[i]);\n                inBlockquote = true;\n              } else if (!inBlockquote) {\n                currentLines.push(lines[i]);\n              } else {\n                break;\n              }\n            }\n            lines = lines.slice(i);\n            const currentRaw = currentLines.join('\\n');\n            const currentText = currentRaw\n            // precede setext continuation with 4 spaces so it isn't a setext\n            .replace(/\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g, '\\n    $1').replace(/^ {0,3}>[ \\t]?/gm, '');\n            raw = raw ? \"\".concat(raw, \"\\n\").concat(currentRaw) : currentRaw;\n            text = text ? \"\".concat(text, \"\\n\").concat(currentText) : currentText;\n            // parse blockquote lines as top level tokens\n            // merge paragraphs if this is a continuation\n            const top = this.lexer.state.top;\n            this.lexer.state.top = true;\n            this.lexer.blockTokens(currentText, tokens, true);\n            this.lexer.state.top = top;\n            // if there is no continuation then we are done\n            if (lines.length === 0) {\n              break;\n            }\n            const lastToken = tokens[tokens.length - 1];\n            if ((lastToken === null || lastToken === void 0 ? void 0 : lastToken.type) === 'code') {\n              // blockquote continuation cannot be preceded by a code block\n              break;\n            } else if ((lastToken === null || lastToken === void 0 ? void 0 : lastToken.type) === 'blockquote') {\n              // include continuation in nested blockquote\n              const oldToken = lastToken;\n              const newText = oldToken.raw + '\\n' + lines.join('\\n');\n              const newToken = this.blockquote(newText);\n              tokens[tokens.length - 1] = newToken;\n              raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;\n              text = text.substring(0, text.length - oldToken.text.length) + newToken.text;\n              break;\n            } else if ((lastToken === null || lastToken === void 0 ? void 0 : lastToken.type) === 'list') {\n              // include continuation in nested list\n              const oldToken = lastToken;\n              const newText = oldToken.raw + '\\n' + lines.join('\\n');\n              const newToken = this.list(newText);\n              tokens[tokens.length - 1] = newToken;\n              raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;\n              text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;\n              lines = newText.substring(tokens[tokens.length - 1].raw.length).split('\\n');\n              continue;\n            }\n          }\n          return {\n            type: 'blockquote',\n            raw,\n            tokens,\n            text\n          };\n        }\n      }\n      list(src) {\n        let cap = this.rules.block.list.exec(src);\n        if (cap) {\n          let bull = cap[1].trim();\n          const isordered = bull.length > 1;\n          const list = {\n            type: 'list',\n            raw: '',\n            ordered: isordered,\n            start: isordered ? +bull.slice(0, -1) : '',\n            loose: false,\n            items: []\n          };\n          bull = isordered ? \"\\\\d{1,9}\\\\\".concat(bull.slice(-1)) : \"\\\\\".concat(bull);\n          if (this.options.pedantic) {\n            bull = isordered ? bull : '[*+-]';\n          }\n          // Get next list item\n          const itemRegex = new RegExp(\"^( {0,3}\".concat(bull, \")((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))\"));\n          let endsWithBlankLine = false;\n          // Check if current bullet point can start a new List Item\n          while (src) {\n            let endEarly = false;\n            let raw = '';\n            let itemContents = '';\n            if (!(cap = itemRegex.exec(src))) {\n              break;\n            }\n            if (this.rules.block.hr.test(src)) {\n              // End list if bullet was actually HR (possibly move into itemRegex?)\n              break;\n            }\n            raw = cap[0];\n            src = src.substring(raw.length);\n            let line = cap[2].split('\\n', 1)[0].replace(/^\\t+/, t => ' '.repeat(3 * t.length));\n            let nextLine = src.split('\\n', 1)[0];\n            let blankLine = !line.trim();\n            let indent = 0;\n            if (this.options.pedantic) {\n              indent = 2;\n              itemContents = line.trimStart();\n            } else if (blankLine) {\n              indent = cap[1].length + 1;\n            } else {\n              indent = cap[2].search(/[^ ]/); // Find first non-space char\n              indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n              itemContents = line.slice(indent);\n              indent += cap[1].length;\n            }\n            if (blankLine && /^ *$/.test(nextLine)) {\n              // Items begin with at most one blank line\n              raw += nextLine + '\\n';\n              src = src.substring(nextLine.length + 1);\n              endEarly = true;\n            }\n            if (!endEarly) {\n              const nextBulletRegex = new RegExp(\"^ {0,\".concat(Math.min(3, indent - 1), \"}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))\"));\n              const hrRegex = new RegExp(\"^ {0,\".concat(Math.min(3, indent - 1), \"}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)\"));\n              const fencesBeginRegex = new RegExp(\"^ {0,\".concat(Math.min(3, indent - 1), \"}(?:```|~~~)\"));\n              const headingBeginRegex = new RegExp(\"^ {0,\".concat(Math.min(3, indent - 1), \"}#\"));\n              // Check if following lines should be included in List Item\n              while (src) {\n                const rawLine = src.split('\\n', 1)[0];\n                nextLine = rawLine;\n                // Re-align to follow commonmark nesting rules\n                if (this.options.pedantic) {\n                  nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');\n                }\n                // End list item if found code fences\n                if (fencesBeginRegex.test(nextLine)) {\n                  break;\n                }\n                // End list item if found start of new heading\n                if (headingBeginRegex.test(nextLine)) {\n                  break;\n                }\n                // End list item if found start of new bullet\n                if (nextBulletRegex.test(nextLine)) {\n                  break;\n                }\n                // Horizontal rule found\n                if (hrRegex.test(src)) {\n                  break;\n                }\n                if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {\n                  // Dedent if possible\n                  itemContents += '\\n' + nextLine.slice(indent);\n                } else {\n                  // not enough indentation\n                  if (blankLine) {\n                    break;\n                  }\n                  // paragraph continuation unless last line was a different block level element\n                  if (line.search(/[^ ]/) >= 4) {\n                    // indented code block\n                    break;\n                  }\n                  if (fencesBeginRegex.test(line)) {\n                    break;\n                  }\n                  if (headingBeginRegex.test(line)) {\n                    break;\n                  }\n                  if (hrRegex.test(line)) {\n                    break;\n                  }\n                  itemContents += '\\n' + nextLine;\n                }\n                if (!blankLine && !nextLine.trim()) {\n                  // Check if current line is blank\n                  blankLine = true;\n                }\n                raw += rawLine + '\\n';\n                src = src.substring(rawLine.length + 1);\n                line = nextLine.slice(indent);\n              }\n            }\n            if (!list.loose) {\n              // If the previous item ended with a blank line, the list is loose\n              if (endsWithBlankLine) {\n                list.loose = true;\n              } else if (/\\n *\\n *$/.test(raw)) {\n                endsWithBlankLine = true;\n              }\n            }\n            let istask = null;\n            let ischecked;\n            // Check for task list items\n            if (this.options.gfm) {\n              istask = /^\\[[ xX]\\] /.exec(itemContents);\n              if (istask) {\n                ischecked = istask[0] !== '[ ] ';\n                itemContents = itemContents.replace(/^\\[[ xX]\\] +/, '');\n              }\n            }\n            list.items.push({\n              type: 'list_item',\n              raw,\n              task: !!istask,\n              checked: ischecked,\n              loose: false,\n              text: itemContents,\n              tokens: []\n            });\n            list.raw += raw;\n          }\n          // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n          list.items[list.items.length - 1].raw = list.items[list.items.length - 1].raw.trimEnd();\n          list.items[list.items.length - 1].text = list.items[list.items.length - 1].text.trimEnd();\n          list.raw = list.raw.trimEnd();\n          // Item child tokens handled here at end because we needed to have the final item to trim it first\n          for (let i = 0; i < list.items.length; i++) {\n            this.lexer.state.top = false;\n            list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n            if (!list.loose) {\n              // Check if list should be loose\n              const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n              const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\\n.*\\n/.test(t.raw));\n              list.loose = hasMultipleLineBreaks;\n            }\n          }\n          // Set all items to loose if list is loose\n          if (list.loose) {\n            for (let i = 0; i < list.items.length; i++) {\n              list.items[i].loose = true;\n            }\n          }\n          return list;\n        }\n      }\n      html(src) {\n        const cap = this.rules.block.html.exec(src);\n        if (cap) {\n          const token = {\n            type: 'html',\n            block: true,\n            raw: cap[0],\n            pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n            text: cap[0]\n          };\n          return token;\n        }\n      }\n      def(src) {\n        const cap = this.rules.block.def.exec(src);\n        if (cap) {\n          const tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n          const href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n          const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];\n          return {\n            type: 'def',\n            tag,\n            raw: cap[0],\n            href,\n            title\n          };\n        }\n      }\n      table(src) {\n        const cap = this.rules.block.table.exec(src);\n        if (!cap) {\n          return;\n        }\n        if (!/[:|]/.test(cap[2])) {\n          // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n          return;\n        }\n        const headers = splitCells(cap[1]);\n        const aligns = cap[2].replace(/^\\||\\| *$/g, '').split('|');\n        const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, '').split('\\n') : [];\n        const item = {\n          type: 'table',\n          raw: cap[0],\n          header: [],\n          align: [],\n          rows: []\n        };\n        if (headers.length !== aligns.length) {\n          // header and align columns must be equal, rows can be different.\n          return;\n        }\n        for (const align of aligns) {\n          if (/^ *-+: *$/.test(align)) {\n            item.align.push('right');\n          } else if (/^ *:-+: *$/.test(align)) {\n            item.align.push('center');\n          } else if (/^ *:-+ *$/.test(align)) {\n            item.align.push('left');\n          } else {\n            item.align.push(null);\n          }\n        }\n        for (let i = 0; i < headers.length; i++) {\n          item.header.push({\n            text: headers[i],\n            tokens: this.lexer.inline(headers[i]),\n            header: true,\n            align: item.align[i]\n          });\n        }\n        for (const row of rows) {\n          item.rows.push(splitCells(row, item.header.length).map((cell, i) => {\n            return {\n              text: cell,\n              tokens: this.lexer.inline(cell),\n              header: false,\n              align: item.align[i]\n            };\n          }));\n        }\n        return item;\n      }\n      lheading(src) {\n        const cap = this.rules.block.lheading.exec(src);\n        if (cap) {\n          return {\n            type: 'heading',\n            raw: cap[0],\n            depth: cap[2].charAt(0) === '=' ? 1 : 2,\n            text: cap[1],\n            tokens: this.lexer.inline(cap[1])\n          };\n        }\n      }\n      paragraph(src) {\n        const cap = this.rules.block.paragraph.exec(src);\n        if (cap) {\n          const text = cap[1].charAt(cap[1].length - 1) === '\\n' ? cap[1].slice(0, -1) : cap[1];\n          return {\n            type: 'paragraph',\n            raw: cap[0],\n            text,\n            tokens: this.lexer.inline(text)\n          };\n        }\n      }\n      text(src) {\n        const cap = this.rules.block.text.exec(src);\n        if (cap) {\n          return {\n            type: 'text',\n            raw: cap[0],\n            text: cap[0],\n            tokens: this.lexer.inline(cap[0])\n          };\n        }\n      }\n      escape(src) {\n        const cap = this.rules.inline.escape.exec(src);\n        if (cap) {\n          return {\n            type: 'escape',\n            raw: cap[0],\n            text: escape$1(cap[1])\n          };\n        }\n      }\n      tag(src) {\n        const cap = this.rules.inline.tag.exec(src);\n        if (cap) {\n          if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n            this.lexer.state.inLink = true;\n          } else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n            this.lexer.state.inLink = false;\n          }\n          if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n            this.lexer.state.inRawBlock = true;\n          } else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n            this.lexer.state.inRawBlock = false;\n          }\n          return {\n            type: 'html',\n            raw: cap[0],\n            inLink: this.lexer.state.inLink,\n            inRawBlock: this.lexer.state.inRawBlock,\n            block: false,\n            text: cap[0]\n          };\n        }\n      }\n      link(src) {\n        const cap = this.rules.inline.link.exec(src);\n        if (cap) {\n          const trimmedUrl = cap[2].trim();\n          if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n            // commonmark requires matching angle brackets\n            if (!/>$/.test(trimmedUrl)) {\n              return;\n            }\n            // ending angle bracket cannot be escaped\n            const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n            if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n              return;\n            }\n          } else {\n            // find closing parenthesis\n            const lastParenIndex = findClosingBracket(cap[2], '()');\n            if (lastParenIndex > -1) {\n              const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n              const linkLen = start + cap[1].length + lastParenIndex;\n              cap[2] = cap[2].substring(0, lastParenIndex);\n              cap[0] = cap[0].substring(0, linkLen).trim();\n              cap[3] = '';\n            }\n          }\n          let href = cap[2];\n          let title = '';\n          if (this.options.pedantic) {\n            // split pedantic href and title\n            const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n            if (link) {\n              href = link[1];\n              title = link[3];\n            }\n          } else {\n            title = cap[3] ? cap[3].slice(1, -1) : '';\n          }\n          href = href.trim();\n          if (/^</.test(href)) {\n            if (this.options.pedantic && !/>$/.test(trimmedUrl)) {\n              // pedantic allows starting angle bracket without ending angle bracket\n              href = href.slice(1);\n            } else {\n              href = href.slice(1, -1);\n            }\n          }\n          return outputLink(cap, {\n            href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n            title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title\n          }, cap[0], this.lexer);\n        }\n      }\n      reflink(src, links) {\n        let cap;\n        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n          const linkString = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n          const link = links[linkString.toLowerCase()];\n          if (!link) {\n            const text = cap[0].charAt(0);\n            return {\n              type: 'text',\n              raw: text,\n              text\n            };\n          }\n          return outputLink(cap, link, cap[0], this.lexer);\n        }\n      }\n      emStrong(src, maskedSrc) {\n        let prevChar = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n        let match = this.rules.inline.emStrongLDelim.exec(src);\n        if (!match) return;\n        // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n        if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u)) return;\n        const nextChar = match[1] || match[2] || '';\n        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n          // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n          const lLength = [...match[0]].length - 1;\n          let rDelim,\n            rLength,\n            delimTotal = lLength,\n            midDelimTotal = 0;\n          const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n          endReg.lastIndex = 0;\n          // Clip maskedSrc to same section of string as src (move to lexer?)\n          maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n          while ((match = endReg.exec(maskedSrc)) != null) {\n            rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n            if (!rDelim) continue; // skip single * in __abc*abc__\n            rLength = [...rDelim].length;\n            if (match[3] || match[4]) {\n              // found another Left Delim\n              delimTotal += rLength;\n              continue;\n            } else if (match[5] || match[6]) {\n              // either Left or Right Delim\n              if (lLength % 3 && !((lLength + rLength) % 3)) {\n                midDelimTotal += rLength;\n                continue; // CommonMark Emphasis Rules 9-10\n              }\n            }\n            delimTotal -= rLength;\n            if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n            // Remove extra characters. *a*** -> *a*\n            rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n            // char length can be >1 for unicode characters;\n            const lastCharLength = [...match[0]][0].length;\n            const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n            // Create `em` if smallest delimiter has odd char count. *a***\n            if (Math.min(lLength, rLength) % 2) {\n              const text = raw.slice(1, -1);\n              return {\n                type: 'em',\n                raw,\n                text,\n                tokens: this.lexer.inlineTokens(text)\n              };\n            }\n            // Create 'strong' if smallest delimiter has even char count. **a***\n            const text = raw.slice(2, -2);\n            return {\n              type: 'strong',\n              raw,\n              text,\n              tokens: this.lexer.inlineTokens(text)\n            };\n          }\n        }\n      }\n      codespan(src) {\n        const cap = this.rules.inline.code.exec(src);\n        if (cap) {\n          let text = cap[2].replace(/\\n/g, ' ');\n          const hasNonSpaceChars = /[^ ]/.test(text);\n          const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n          if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n            text = text.substring(1, text.length - 1);\n          }\n          text = escape$1(text, true);\n          return {\n            type: 'codespan',\n            raw: cap[0],\n            text\n          };\n        }\n      }\n      br(src) {\n        const cap = this.rules.inline.br.exec(src);\n        if (cap) {\n          return {\n            type: 'br',\n            raw: cap[0]\n          };\n        }\n      }\n      del(src) {\n        const cap = this.rules.inline.del.exec(src);\n        if (cap) {\n          return {\n            type: 'del',\n            raw: cap[0],\n            text: cap[2],\n            tokens: this.lexer.inlineTokens(cap[2])\n          };\n        }\n      }\n      autolink(src) {\n        const cap = this.rules.inline.autolink.exec(src);\n        if (cap) {\n          let text, href;\n          if (cap[2] === '@') {\n            text = escape$1(cap[1]);\n            href = 'mailto:' + text;\n          } else {\n            text = escape$1(cap[1]);\n            href = text;\n          }\n          return {\n            type: 'link',\n            raw: cap[0],\n            text,\n            href,\n            tokens: [{\n              type: 'text',\n              raw: text,\n              text\n            }]\n          };\n        }\n      }\n      url(src) {\n        let cap;\n        if (cap = this.rules.inline.url.exec(src)) {\n          let text, href;\n          if (cap[2] === '@') {\n            text = escape$1(cap[0]);\n            href = 'mailto:' + text;\n          } else {\n            // do extended autolink path validation\n            let prevCapZero;\n            do {\n              var _this$rules$inline$_b, _this$rules$inline$_b2;\n              prevCapZero = cap[0];\n              cap[0] = (_this$rules$inline$_b = (_this$rules$inline$_b2 = this.rules.inline._backpedal.exec(cap[0])) === null || _this$rules$inline$_b2 === void 0 ? void 0 : _this$rules$inline$_b2[0]) !== null && _this$rules$inline$_b !== void 0 ? _this$rules$inline$_b : '';\n            } while (prevCapZero !== cap[0]);\n            text = escape$1(cap[0]);\n            if (cap[1] === 'www.') {\n              href = 'http://' + cap[0];\n            } else {\n              href = cap[0];\n            }\n          }\n          return {\n            type: 'link',\n            raw: cap[0],\n            text,\n            href,\n            tokens: [{\n              type: 'text',\n              raw: text,\n              text\n            }]\n          };\n        }\n      }\n      inlineText(src) {\n        const cap = this.rules.inline.text.exec(src);\n        if (cap) {\n          let text;\n          if (this.lexer.state.inRawBlock) {\n            text = cap[0];\n          } else {\n            text = escape$1(cap[0]);\n          }\n          return {\n            type: 'text',\n            raw: cap[0],\n            text\n          };\n        }\n      }\n    }\n\n    /**\n     * Block-Level Grammar\n     */\n    const newline = /^(?: *(?:\\n|$))+/;\n    const blockCode = /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/;\n    const fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\n    const hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\n    const heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\n    const bullet = /(?:[*+-]|\\d{1,9}[.)])/;\n    const lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/).replace(/bull/g, bullet) // lists can interrupt\n    .replace(/blockCode/g, / {4}/) // indented code blocks can interrupt\n    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n    .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n    .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n    .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n    .getRegex();\n    const _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\n    const blockText = /^[^\\n]+/;\n    const _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\n    const def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n *)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/).replace('label', _blockLabel).replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/).getRegex();\n    const list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/).replace(/bull/g, bullet).getRegex();\n    const _tag = 'address|article|aside|base|basefont|blockquote|body|caption' + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title' + '|tr|track|ul';\n    const _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\n    const html = edit('^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (6)\n    + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) open tag\n    + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) closing tag\n    + ')', 'i').replace('comment', _comment).replace('tag', _tag).replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\n    const paragraph = edit(_paragraph).replace('hr', hr).replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)').replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n    .replace('|table', '').replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex();\n    const blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/).replace('paragraph', paragraph).getRegex();\n    /**\n     * Normal Block Grammar\n     */\n    const blockNormal = {\n      blockquote,\n      code: blockCode,\n      def,\n      fences,\n      heading,\n      hr,\n      html,\n      lheading,\n      list,\n      newline,\n      paragraph,\n      table: noopTest,\n      text: blockText\n    };\n    /**\n     * GFM Block Grammar\n     */\n    const gfmTable = edit('^ *([^\\\\n ].*)\\\\n' // Header\n    + ' {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)' // Align\n    + '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)') // Cells\n    .replace('hr', hr).replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n    .getRegex();\n    const blockGfm = {\n      ...blockNormal,\n      table: gfmTable,\n      paragraph: edit(_paragraph).replace('hr', hr).replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)').replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n      .replace('table', gfmTable) // interrupt paragraphs with table\n      .replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n      .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n      .getRegex()\n    };\n    /**\n     * Pedantic grammar (original John Gruber's loose markdown specification)\n     */\n    const blockPedantic = {\n      ...blockNormal,\n      html: edit('^ *(?:comment *(?:\\\\n|\\\\s*$)' + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n      + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))').replace('comment', _comment).replace(/tag/g, '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b').getRegex(),\n      def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n      heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n      fences: noopTest,\n      // fences not supported\n      lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n      paragraph: edit(_paragraph).replace('hr', hr).replace('heading', ' *#{1,6} *[^\\n]').replace('lheading', lheading).replace('|table', '').replace('blockquote', ' {0,3}>').replace('|fences', '').replace('|list', '').replace('|html', '').replace('|tag', '').getRegex()\n    };\n    /**\n     * Inline-Level Grammar\n     */\n    const escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\n    const inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\n    const br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\n    const inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n    // list of unicode punctuation marks, plus any missing characters from CommonMark spec\n    const _punctuation = '\\\\p{P}\\\\p{S}';\n    const punctuation = edit(/^((?![*_])[\\spunctuation])/, 'u').replace(/punctuation/g, _punctuation).getRegex();\n    // sequences em should skip over [title](link), `code`, <html>\n    const blockSkip = /\\[[^[\\]]*?\\]\\([^\\(\\)]*?\\)|`[^`]*?`|<[^<>]*?>/g;\n    const emStrongLDelim = edit(/^(?:\\*+(?:((?!\\*)[punct])|[^\\s*]))|^_+(?:((?!_)[punct])|([^\\s_]))/, 'u').replace(/punct/g, _punctuation).getRegex();\n    const emStrongRDelimAst = edit('^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)' // Skip orphan inside strong\n    + '|[^*]+(?=[^*])' // Consume to delim\n    + '|(?!\\\\*)[punct](\\\\*+)(?=[\\\\s]|$)' // (1) #*** can only be a Right Delimiter\n    + '|[^punct\\\\s](\\\\*+)(?!\\\\*)(?=[punct\\\\s]|$)' // (2) a***#, a*** can only be a Right Delimiter\n    + '|(?!\\\\*)[punct\\\\s](\\\\*+)(?=[^punct\\\\s])' // (3) #***a, ***a can only be Left Delimiter\n    + '|[\\\\s](\\\\*+)(?!\\\\*)(?=[punct])' // (4) ***# can only be Left Delimiter\n    + '|(?!\\\\*)[punct](\\\\*+)(?!\\\\*)(?=[punct])' // (5) #***# can be either Left or Right Delimiter\n    + '|[^punct\\\\s](\\\\*+)(?=[^punct\\\\s])', 'gu') // (6) a***a can be either Left or Right Delimiter\n    .replace(/punct/g, _punctuation).getRegex();\n    // (6) Not allowed for _\n    const emStrongRDelimUnd = edit('^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)' // Skip orphan inside strong\n    + '|[^_]+(?=[^_])' // Consume to delim\n    + '|(?!_)[punct](_+)(?=[\\\\s]|$)' // (1) #___ can only be a Right Delimiter\n    + '|[^punct\\\\s](_+)(?!_)(?=[punct\\\\s]|$)' // (2) a___#, a___ can only be a Right Delimiter\n    + '|(?!_)[punct\\\\s](_+)(?=[^punct\\\\s])' // (3) #___a, ___a can only be Left Delimiter\n    + '|[\\\\s](_+)(?!_)(?=[punct])' // (4) ___# can only be Left Delimiter\n    + '|(?!_)[punct](_+)(?!_)(?=[punct])', 'gu') // (5) #___# can be either Left or Right Delimiter\n    .replace(/punct/g, _punctuation).getRegex();\n    const anyPunctuation = edit(/\\\\([punct])/, 'gu').replace(/punct/g, _punctuation).getRegex();\n    const autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/).replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();\n    const _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\n    const tag = edit('^comment' + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>') // CDATA section\n    .replace('comment', _inlineComment).replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/).getRegex();\n    const _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n    const link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/).replace('label', _inlineLabel).replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/).replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/).getRegex();\n    const reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/).replace('label', _inlineLabel).replace('ref', _blockLabel).getRegex();\n    const nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/).replace('ref', _blockLabel).getRegex();\n    const reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g').replace('reflink', reflink).replace('nolink', nolink).getRegex();\n    /**\n     * Normal Inline Grammar\n     */\n    const inlineNormal = {\n      _backpedal: noopTest,\n      // only used for GFM url\n      anyPunctuation,\n      autolink,\n      blockSkip,\n      br,\n      code: inlineCode,\n      del: noopTest,\n      emStrongLDelim,\n      emStrongRDelimAst,\n      emStrongRDelimUnd,\n      escape,\n      link,\n      nolink,\n      punctuation,\n      reflink,\n      reflinkSearch,\n      tag,\n      text: inlineText,\n      url: noopTest\n    };\n    /**\n     * Pedantic Inline Grammar\n     */\n    const inlinePedantic = {\n      ...inlineNormal,\n      link: edit(/^!?\\[(label)\\]\\((.*?)\\)/).replace('label', _inlineLabel).getRegex(),\n      reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace('label', _inlineLabel).getRegex()\n    };\n    /**\n     * GFM Inline Grammar\n     */\n    const inlineGfm = {\n      ...inlineNormal,\n      escape: edit(escape).replace('])', '~|])').getRegex(),\n      url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, 'i').replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),\n      _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n      del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n      text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n    };\n    /**\n     * GFM + Line Breaks Inline Grammar\n     */\n    const inlineBreaks = {\n      ...inlineGfm,\n      br: edit(br).replace('{2,}', '*').getRegex(),\n      text: edit(inlineGfm.text).replace('\\\\b_', '\\\\b_| {2,}\\\\n').replace(/\\{2,\\}/g, '*').getRegex()\n    };\n    /**\n     * exports\n     */\n    const block = {\n      normal: blockNormal,\n      gfm: blockGfm,\n      pedantic: blockPedantic\n    };\n    const inline = {\n      normal: inlineNormal,\n      gfm: inlineGfm,\n      breaks: inlineBreaks,\n      pedantic: inlinePedantic\n    };\n\n    /**\n     * Block Lexer\n     */\n    class _Lexer {\n      constructor(options) {\n        _defineProperty(this, \"tokens\", void 0);\n        _defineProperty(this, \"options\", void 0);\n        _defineProperty(this, \"state\", void 0);\n        _defineProperty(this, \"tokenizer\", void 0);\n        _defineProperty(this, \"inlineQueue\", void 0);\n        // TokenList cannot be created in one go\n        this.tokens = [];\n        this.tokens.links = Object.create(null);\n        this.options = options || exports.defaults;\n        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n        this.tokenizer = this.options.tokenizer;\n        this.tokenizer.options = this.options;\n        this.tokenizer.lexer = this;\n        this.inlineQueue = [];\n        this.state = {\n          inLink: false,\n          inRawBlock: false,\n          top: true\n        };\n        const rules = {\n          block: block.normal,\n          inline: inline.normal\n        };\n        if (this.options.pedantic) {\n          rules.block = block.pedantic;\n          rules.inline = inline.pedantic;\n        } else if (this.options.gfm) {\n          rules.block = block.gfm;\n          if (this.options.breaks) {\n            rules.inline = inline.breaks;\n          } else {\n            rules.inline = inline.gfm;\n          }\n        }\n        this.tokenizer.rules = rules;\n      }\n      /**\n       * Expose Rules\n       */\n      static get rules() {\n        return {\n          block,\n          inline\n        };\n      }\n      /**\n       * Static Lex Method\n       */\n      static lex(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.lex(src);\n      }\n      /**\n       * Static Lex Inline Method\n       */\n      static lexInline(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.inlineTokens(src);\n      }\n      /**\n       * Preprocessing\n       */\n      lex(src) {\n        src = src.replace(/\\r\\n|\\r/g, '\\n');\n        this.blockTokens(src, this.tokens);\n        for (let i = 0; i < this.inlineQueue.length; i++) {\n          const next = this.inlineQueue[i];\n          this.inlineTokens(next.src, next.tokens);\n        }\n        this.inlineQueue = [];\n        return this.tokens;\n      }\n      blockTokens(src) {\n        let tokens = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        let lastParagraphClipped = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        if (this.options.pedantic) {\n          src = src.replace(/\\t/g, '    ').replace(/^ +$/gm, '');\n        } else {\n          src = src.replace(/^( *)(\\t+)/gm, (_, leading, tabs) => {\n            return leading + '    '.repeat(tabs.length);\n          });\n        }\n        let token;\n        let lastToken;\n        let cutSrc;\n        while (src) {\n          if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(extTokenizer => {\n            if (token = extTokenizer.call({\n              lexer: this\n            }, src, tokens)) {\n              src = src.substring(token.raw.length);\n              tokens.push(token);\n              return true;\n            }\n            return false;\n          })) {\n            continue;\n          }\n          // newline\n          if (token = this.tokenizer.space(src)) {\n            src = src.substring(token.raw.length);\n            if (token.raw.length === 1 && tokens.length > 0) {\n              // if there's a single \\n as a spacer, it's terminating the last line,\n              // so move it there so that we don't get unnecessary paragraph tags\n              tokens[tokens.length - 1].raw += '\\n';\n            } else {\n              tokens.push(token);\n            }\n            continue;\n          }\n          // code\n          if (token = this.tokenizer.code(src)) {\n            src = src.substring(token.raw.length);\n            lastToken = tokens[tokens.length - 1];\n            // An indented code block cannot interrupt a paragraph.\n            if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n              lastToken.raw += '\\n' + token.raw;\n              lastToken.text += '\\n' + token.text;\n              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n            } else {\n              tokens.push(token);\n            }\n            continue;\n          }\n          // fences\n          if (token = this.tokenizer.fences(src)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            continue;\n          }\n          // heading\n          if (token = this.tokenizer.heading(src)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            continue;\n          }\n          // hr\n          if (token = this.tokenizer.hr(src)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            continue;\n          }\n          // blockquote\n          if (token = this.tokenizer.blockquote(src)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            continue;\n          }\n          // list\n          if (token = this.tokenizer.list(src)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            continue;\n          }\n          // html\n          if (token = this.tokenizer.html(src)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            continue;\n          }\n          // def\n          if (token = this.tokenizer.def(src)) {\n            src = src.substring(token.raw.length);\n            lastToken = tokens[tokens.length - 1];\n            if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n              lastToken.raw += '\\n' + token.raw;\n              lastToken.text += '\\n' + token.raw;\n              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n            } else if (!this.tokens.links[token.tag]) {\n              this.tokens.links[token.tag] = {\n                href: token.href,\n                title: token.title\n              };\n            }\n            continue;\n          }\n          // table (gfm)\n          if (token = this.tokenizer.table(src)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            continue;\n          }\n          // lheading\n          if (token = this.tokenizer.lheading(src)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            continue;\n          }\n          // top-level paragraph\n          // prevent paragraph consuming extensions by clipping 'src' to extension start\n          cutSrc = src;\n          if (this.options.extensions && this.options.extensions.startBlock) {\n            let startIndex = Infinity;\n            const tempSrc = src.slice(1);\n            let tempStart;\n            this.options.extensions.startBlock.forEach(getStartIndex => {\n              tempStart = getStartIndex.call({\n                lexer: this\n              }, tempSrc);\n              if (typeof tempStart === 'number' && tempStart >= 0) {\n                startIndex = Math.min(startIndex, tempStart);\n              }\n            });\n            if (startIndex < Infinity && startIndex >= 0) {\n              cutSrc = src.substring(0, startIndex + 1);\n            }\n          }\n          if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n            var _lastToken;\n            lastToken = tokens[tokens.length - 1];\n            if (lastParagraphClipped && ((_lastToken = lastToken) === null || _lastToken === void 0 ? void 0 : _lastToken.type) === 'paragraph') {\n              lastToken.raw += '\\n' + token.raw;\n              lastToken.text += '\\n' + token.text;\n              this.inlineQueue.pop();\n              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n            } else {\n              tokens.push(token);\n            }\n            lastParagraphClipped = cutSrc.length !== src.length;\n            src = src.substring(token.raw.length);\n            continue;\n          }\n          // text\n          if (token = this.tokenizer.text(src)) {\n            src = src.substring(token.raw.length);\n            lastToken = tokens[tokens.length - 1];\n            if (lastToken && lastToken.type === 'text') {\n              lastToken.raw += '\\n' + token.raw;\n              lastToken.text += '\\n' + token.text;\n              this.inlineQueue.pop();\n              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n            } else {\n              tokens.push(token);\n            }\n            continue;\n          }\n          if (src) {\n            const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n            if (this.options.silent) {\n              console.error(errMsg);\n              break;\n            } else {\n              throw new Error(errMsg);\n            }\n          }\n        }\n        this.state.top = true;\n        return tokens;\n      }\n      inline(src) {\n        let tokens = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        this.inlineQueue.push({\n          src,\n          tokens\n        });\n        return tokens;\n      }\n      /**\n       * Lexing/Compiling\n       */\n      inlineTokens(src) {\n        let tokens = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        let token, lastToken, cutSrc;\n        // String with links masked to avoid interference with em and strong\n        let maskedSrc = src;\n        let match;\n        let keepPrevChar, prevChar;\n        // Mask out reflinks\n        if (this.tokens.links) {\n          const links = Object.keys(this.tokens.links);\n          if (links.length > 0) {\n            while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n              if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n                maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n              }\n            }\n          }\n        }\n        // Mask out other blocks\n        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n          maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n        }\n        // Mask out escaped characters\n        while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n          maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n        }\n        while (src) {\n          if (!keepPrevChar) {\n            prevChar = '';\n          }\n          keepPrevChar = false;\n          // extensions\n          if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(extTokenizer => {\n            if (token = extTokenizer.call({\n              lexer: this\n            }, src, tokens)) {\n              src = src.substring(token.raw.length);\n              tokens.push(token);\n              return true;\n            }\n            return false;\n          })) {\n            continue;\n          }\n          // escape\n          if (token = this.tokenizer.escape(src)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            continue;\n          }\n          // tag\n          if (token = this.tokenizer.tag(src)) {\n            src = src.substring(token.raw.length);\n            lastToken = tokens[tokens.length - 1];\n            if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n              lastToken.raw += token.raw;\n              lastToken.text += token.text;\n            } else {\n              tokens.push(token);\n            }\n            continue;\n          }\n          // link\n          if (token = this.tokenizer.link(src)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            continue;\n          }\n          // reflink, nolink\n          if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n            src = src.substring(token.raw.length);\n            lastToken = tokens[tokens.length - 1];\n            if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n              lastToken.raw += token.raw;\n              lastToken.text += token.text;\n            } else {\n              tokens.push(token);\n            }\n            continue;\n          }\n          // em & strong\n          if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            continue;\n          }\n          // code\n          if (token = this.tokenizer.codespan(src)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            continue;\n          }\n          // br\n          if (token = this.tokenizer.br(src)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            continue;\n          }\n          // del (gfm)\n          if (token = this.tokenizer.del(src)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            continue;\n          }\n          // autolink\n          if (token = this.tokenizer.autolink(src)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            continue;\n          }\n          // url (gfm)\n          if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            continue;\n          }\n          // text\n          // prevent inlineText consuming extensions by clipping 'src' to extension start\n          cutSrc = src;\n          if (this.options.extensions && this.options.extensions.startInline) {\n            let startIndex = Infinity;\n            const tempSrc = src.slice(1);\n            let tempStart;\n            this.options.extensions.startInline.forEach(getStartIndex => {\n              tempStart = getStartIndex.call({\n                lexer: this\n              }, tempSrc);\n              if (typeof tempStart === 'number' && tempStart >= 0) {\n                startIndex = Math.min(startIndex, tempStart);\n              }\n            });\n            if (startIndex < Infinity && startIndex >= 0) {\n              cutSrc = src.substring(0, startIndex + 1);\n            }\n          }\n          if (token = this.tokenizer.inlineText(cutSrc)) {\n            src = src.substring(token.raw.length);\n            if (token.raw.slice(-1) !== '_') {\n              // Track prevChar before string of ____ started\n              prevChar = token.raw.slice(-1);\n            }\n            keepPrevChar = true;\n            lastToken = tokens[tokens.length - 1];\n            if (lastToken && lastToken.type === 'text') {\n              lastToken.raw += token.raw;\n              lastToken.text += token.text;\n            } else {\n              tokens.push(token);\n            }\n            continue;\n          }\n          if (src) {\n            const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n            if (this.options.silent) {\n              console.error(errMsg);\n              break;\n            } else {\n              throw new Error(errMsg);\n            }\n          }\n        }\n        return tokens;\n      }\n    }\n\n    /**\n     * Renderer\n     */\n    class _Renderer {\n      // set by the parser\n      constructor(options) {\n        _defineProperty(this, \"options\", void 0);\n        _defineProperty(this, \"parser\", void 0);\n        this.options = options || exports.defaults;\n      }\n      space(token) {\n        return '';\n      }\n      code(_ref) {\n        var _match;\n        let {\n          text,\n          lang,\n          escaped\n        } = _ref;\n        const langString = (_match = (lang || '').match(/^\\S*/)) === null || _match === void 0 ? void 0 : _match[0];\n        const code = text.replace(/\\n$/, '') + '\\n';\n        if (!langString) {\n          return '<pre><code>' + (escaped ? code : escape$1(code, true)) + '</code></pre>\\n';\n        }\n        return '<pre><code class=\"language-' + escape$1(langString) + '\">' + (escaped ? code : escape$1(code, true)) + '</code></pre>\\n';\n      }\n      blockquote(_ref2) {\n        let {\n          tokens\n        } = _ref2;\n        const body = this.parser.parse(tokens);\n        return \"<blockquote>\\n\".concat(body, \"</blockquote>\\n\");\n      }\n      html(_ref3) {\n        let {\n          text\n        } = _ref3;\n        return text;\n      }\n      heading(_ref4) {\n        let {\n          tokens,\n          depth\n        } = _ref4;\n        return \"<h\".concat(depth, \">\").concat(this.parser.parseInline(tokens), \"</h\").concat(depth, \">\\n\");\n      }\n      hr(token) {\n        return '<hr>\\n';\n      }\n      list(token) {\n        const ordered = token.ordered;\n        const start = token.start;\n        let body = '';\n        for (let j = 0; j < token.items.length; j++) {\n          const item = token.items[j];\n          body += this.listitem(item);\n        }\n        const type = ordered ? 'ol' : 'ul';\n        const startAttr = ordered && start !== 1 ? ' start=\"' + start + '\"' : '';\n        return '<' + type + startAttr + '>\\n' + body + '</' + type + '>\\n';\n      }\n      listitem(item) {\n        let itemBody = '';\n        if (item.task) {\n          const checkbox = this.checkbox({\n            checked: !!item.checked\n          });\n          if (item.loose) {\n            if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {\n              item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n              if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n              }\n            } else {\n              item.tokens.unshift({\n                type: 'text',\n                raw: checkbox + ' ',\n                text: checkbox + ' '\n              });\n            }\n          } else {\n            itemBody += checkbox + ' ';\n          }\n        }\n        itemBody += this.parser.parse(item.tokens, !!item.loose);\n        return \"<li>\".concat(itemBody, \"</li>\\n\");\n      }\n      checkbox(_ref5) {\n        let {\n          checked\n        } = _ref5;\n        return '<input ' + (checked ? 'checked=\"\" ' : '') + 'disabled=\"\" type=\"checkbox\">';\n      }\n      paragraph(_ref6) {\n        let {\n          tokens\n        } = _ref6;\n        return \"<p>\".concat(this.parser.parseInline(tokens), \"</p>\\n\");\n      }\n      table(token) {\n        let header = '';\n        // header\n        let cell = '';\n        for (let j = 0; j < token.header.length; j++) {\n          cell += this.tablecell(token.header[j]);\n        }\n        header += this.tablerow({\n          text: cell\n        });\n        let body = '';\n        for (let j = 0; j < token.rows.length; j++) {\n          const row = token.rows[j];\n          cell = '';\n          for (let k = 0; k < row.length; k++) {\n            cell += this.tablecell(row[k]);\n          }\n          body += this.tablerow({\n            text: cell\n          });\n        }\n        if (body) body = \"<tbody>\".concat(body, \"</tbody>\");\n        return '<table>\\n' + '<thead>\\n' + header + '</thead>\\n' + body + '</table>\\n';\n      }\n      tablerow(_ref7) {\n        let {\n          text\n        } = _ref7;\n        return \"<tr>\\n\".concat(text, \"</tr>\\n\");\n      }\n      tablecell(token) {\n        const content = this.parser.parseInline(token.tokens);\n        const type = token.header ? 'th' : 'td';\n        const tag = token.align ? \"<\".concat(type, \" align=\\\"\").concat(token.align, \"\\\">\") : \"<\".concat(type, \">\");\n        return tag + content + \"</\".concat(type, \">\\n\");\n      }\n      /**\n       * span level renderer\n       */\n      strong(_ref8) {\n        let {\n          tokens\n        } = _ref8;\n        return \"<strong>\".concat(this.parser.parseInline(tokens), \"</strong>\");\n      }\n      em(_ref9) {\n        let {\n          tokens\n        } = _ref9;\n        return \"<em>\".concat(this.parser.parseInline(tokens), \"</em>\");\n      }\n      codespan(_ref10) {\n        let {\n          text\n        } = _ref10;\n        return \"<code>\".concat(text, \"</code>\");\n      }\n      br(token) {\n        return '<br>';\n      }\n      del(_ref11) {\n        let {\n          tokens\n        } = _ref11;\n        return \"<del>\".concat(this.parser.parseInline(tokens), \"</del>\");\n      }\n      link(_ref12) {\n        let {\n          href,\n          title,\n          tokens\n        } = _ref12;\n        const text = this.parser.parseInline(tokens);\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n          return text;\n        }\n        href = cleanHref;\n        let out = '<a href=\"' + href + '\"';\n        if (title) {\n          out += ' title=\"' + title + '\"';\n        }\n        out += '>' + text + '</a>';\n        return out;\n      }\n      image(_ref13) {\n        let {\n          href,\n          title,\n          text\n        } = _ref13;\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n          return text;\n        }\n        href = cleanHref;\n        let out = \"<img src=\\\"\".concat(href, \"\\\" alt=\\\"\").concat(text, \"\\\"\");\n        if (title) {\n          out += \" title=\\\"\".concat(title, \"\\\"\");\n        }\n        out += '>';\n        return out;\n      }\n      text(token) {\n        return 'tokens' in token && token.tokens ? this.parser.parseInline(token.tokens) : token.text;\n      }\n    }\n\n    /**\n     * TextRenderer\n     * returns only the textual part of the token\n     */\n    class _TextRenderer {\n      // no need for block level renderers\n      strong(_ref14) {\n        let {\n          text\n        } = _ref14;\n        return text;\n      }\n      em(_ref15) {\n        let {\n          text\n        } = _ref15;\n        return text;\n      }\n      codespan(_ref16) {\n        let {\n          text\n        } = _ref16;\n        return text;\n      }\n      del(_ref17) {\n        let {\n          text\n        } = _ref17;\n        return text;\n      }\n      html(_ref18) {\n        let {\n          text\n        } = _ref18;\n        return text;\n      }\n      text(_ref19) {\n        let {\n          text\n        } = _ref19;\n        return text;\n      }\n      link(_ref20) {\n        let {\n          text\n        } = _ref20;\n        return '' + text;\n      }\n      image(_ref21) {\n        let {\n          text\n        } = _ref21;\n        return '' + text;\n      }\n      br() {\n        return '';\n      }\n    }\n\n    /**\n     * Parsing & Compiling\n     */\n    class _Parser {\n      constructor(options) {\n        _defineProperty(this, \"options\", void 0);\n        _defineProperty(this, \"renderer\", void 0);\n        _defineProperty(this, \"textRenderer\", void 0);\n        this.options = options || exports.defaults;\n        this.options.renderer = this.options.renderer || new _Renderer();\n        this.renderer = this.options.renderer;\n        this.renderer.options = this.options;\n        this.renderer.parser = this;\n        this.textRenderer = new _TextRenderer();\n      }\n      /**\n       * Static Parse Method\n       */\n      static parse(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parse(tokens);\n      }\n      /**\n       * Static Parse Inline Method\n       */\n      static parseInline(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parseInline(tokens);\n      }\n      /**\n       * Parse Loop\n       */\n      parse(tokens) {\n        let top = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        let out = '';\n        for (let i = 0; i < tokens.length; i++) {\n          const anyToken = tokens[i];\n          // Run any renderer extensions\n          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {\n            const genericToken = anyToken;\n            const ret = this.options.extensions.renderers[genericToken.type].call({\n              parser: this\n            }, genericToken);\n            if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {\n              out += ret || '';\n              continue;\n            }\n          }\n          const token = anyToken;\n          switch (token.type) {\n            case 'space':\n              {\n                out += this.renderer.space(token);\n                continue;\n              }\n            case 'hr':\n              {\n                out += this.renderer.hr(token);\n                continue;\n              }\n            case 'heading':\n              {\n                out += this.renderer.heading(token);\n                continue;\n              }\n            case 'code':\n              {\n                out += this.renderer.code(token);\n                continue;\n              }\n            case 'table':\n              {\n                out += this.renderer.table(token);\n                continue;\n              }\n            case 'blockquote':\n              {\n                out += this.renderer.blockquote(token);\n                continue;\n              }\n            case 'list':\n              {\n                out += this.renderer.list(token);\n                continue;\n              }\n            case 'html':\n              {\n                out += this.renderer.html(token);\n                continue;\n              }\n            case 'paragraph':\n              {\n                out += this.renderer.paragraph(token);\n                continue;\n              }\n            case 'text':\n              {\n                let textToken = token;\n                let body = this.renderer.text(textToken);\n                while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {\n                  textToken = tokens[++i];\n                  body += '\\n' + this.renderer.text(textToken);\n                }\n                if (top) {\n                  out += this.renderer.paragraph({\n                    type: 'paragraph',\n                    raw: body,\n                    text: body,\n                    tokens: [{\n                      type: 'text',\n                      raw: body,\n                      text: body\n                    }]\n                  });\n                } else {\n                  out += body;\n                }\n                continue;\n              }\n            default:\n              {\n                const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                if (this.options.silent) {\n                  console.error(errMsg);\n                  return '';\n                } else {\n                  throw new Error(errMsg);\n                }\n              }\n          }\n        }\n        return out;\n      }\n      /**\n       * Parse Inline Tokens\n       */\n      parseInline(tokens, renderer) {\n        renderer = renderer || this.renderer;\n        let out = '';\n        for (let i = 0; i < tokens.length; i++) {\n          const anyToken = tokens[i];\n          // Run any renderer extensions\n          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {\n            const ret = this.options.extensions.renderers[anyToken.type].call({\n              parser: this\n            }, anyToken);\n            if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(anyToken.type)) {\n              out += ret || '';\n              continue;\n            }\n          }\n          const token = anyToken;\n          switch (token.type) {\n            case 'escape':\n              {\n                out += renderer.text(token);\n                break;\n              }\n            case 'html':\n              {\n                out += renderer.html(token);\n                break;\n              }\n            case 'link':\n              {\n                out += renderer.link(token);\n                break;\n              }\n            case 'image':\n              {\n                out += renderer.image(token);\n                break;\n              }\n            case 'strong':\n              {\n                out += renderer.strong(token);\n                break;\n              }\n            case 'em':\n              {\n                out += renderer.em(token);\n                break;\n              }\n            case 'codespan':\n              {\n                out += renderer.codespan(token);\n                break;\n              }\n            case 'br':\n              {\n                out += renderer.br(token);\n                break;\n              }\n            case 'del':\n              {\n                out += renderer.del(token);\n                break;\n              }\n            case 'text':\n              {\n                out += renderer.text(token);\n                break;\n              }\n            default:\n              {\n                const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                if (this.options.silent) {\n                  console.error(errMsg);\n                  return '';\n                } else {\n                  throw new Error(errMsg);\n                }\n              }\n          }\n        }\n        return out;\n      }\n    }\n    class _Hooks {\n      constructor(options) {\n        _defineProperty(this, \"options\", void 0);\n        this.options = options || exports.defaults;\n      }\n      /**\n       * Process markdown before marked\n       */\n      preprocess(markdown) {\n        return markdown;\n      }\n      /**\n       * Process HTML after marked is finished\n       */\n      postprocess(html) {\n        return html;\n      }\n      /**\n       * Process all tokens before walk tokens\n       */\n      processAllTokens(tokens) {\n        return tokens;\n      }\n    }\n    _defineProperty(_Hooks, \"passThroughHooks\", new Set(['preprocess', 'postprocess', 'processAllTokens']));\n    class Marked {\n      constructor() {\n        _defineProperty(this, \"defaults\", _getDefaults());\n        _defineProperty(this, \"options\", this.setOptions);\n        _defineProperty(this, \"parse\", this.parseMarkdown(_Lexer.lex, _Parser.parse));\n        _defineProperty(this, \"parseInline\", this.parseMarkdown(_Lexer.lexInline, _Parser.parseInline));\n        _defineProperty(this, \"Parser\", _Parser);\n        _defineProperty(this, \"Renderer\", _Renderer);\n        _defineProperty(this, \"TextRenderer\", _TextRenderer);\n        _defineProperty(this, \"Lexer\", _Lexer);\n        _defineProperty(this, \"Tokenizer\", _Tokenizer);\n        _defineProperty(this, \"Hooks\", _Hooks);\n        this.use(...arguments);\n      }\n      /**\n       * Run callback for every token\n       */\n      walkTokens(tokens, callback) {\n        let values = [];\n        for (const token of tokens) {\n          values = values.concat(callback.call(this, token));\n          switch (token.type) {\n            case 'table':\n              {\n                const tableToken = token;\n                for (const cell of tableToken.header) {\n                  values = values.concat(this.walkTokens(cell.tokens, callback));\n                }\n                for (const row of tableToken.rows) {\n                  for (const cell of row) {\n                    values = values.concat(this.walkTokens(cell.tokens, callback));\n                  }\n                }\n                break;\n              }\n            case 'list':\n              {\n                const listToken = token;\n                values = values.concat(this.walkTokens(listToken.items, callback));\n                break;\n              }\n            default:\n              {\n                var _this$defaults$extens;\n                const genericToken = token;\n                if ((_this$defaults$extens = this.defaults.extensions) !== null && _this$defaults$extens !== void 0 && (_this$defaults$extens = _this$defaults$extens.childTokens) !== null && _this$defaults$extens !== void 0 && _this$defaults$extens[genericToken.type]) {\n                  this.defaults.extensions.childTokens[genericToken.type].forEach(childTokens => {\n                    const tokens = genericToken[childTokens].flat(Infinity);\n                    values = values.concat(this.walkTokens(tokens, callback));\n                  });\n                } else if (genericToken.tokens) {\n                  values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                }\n              }\n          }\n        }\n        return values;\n      }\n      use() {\n        const extensions = this.defaults.extensions || {\n          renderers: {},\n          childTokens: {}\n        };\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        args.forEach(pack => {\n          // copy options to new object\n          const opts = {\n            ...pack\n          };\n          // set async to true if it was set to true before\n          opts.async = this.defaults.async || opts.async || false;\n          // ==-- Parse \"addon\" extensions --== //\n          if (pack.extensions) {\n            pack.extensions.forEach(ext => {\n              if (!ext.name) {\n                throw new Error('extension name required');\n              }\n              if ('renderer' in ext) {\n                // Renderer extensions\n                const prevRenderer = extensions.renderers[ext.name];\n                if (prevRenderer) {\n                  // Replace extension with func to run new extension but fall back if false\n                  extensions.renderers[ext.name] = function () {\n                    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                      args[_key2] = arguments[_key2];\n                    }\n                    let ret = ext.renderer.apply(this, args);\n                    if (ret === false) {\n                      ret = prevRenderer.apply(this, args);\n                    }\n                    return ret;\n                  };\n                } else {\n                  extensions.renderers[ext.name] = ext.renderer;\n                }\n              }\n              if ('tokenizer' in ext) {\n                // Tokenizer Extensions\n                if (!ext.level || ext.level !== 'block' && ext.level !== 'inline') {\n                  throw new Error(\"extension level must be 'block' or 'inline'\");\n                }\n                const extLevel = extensions[ext.level];\n                if (extLevel) {\n                  extLevel.unshift(ext.tokenizer);\n                } else {\n                  extensions[ext.level] = [ext.tokenizer];\n                }\n                if (ext.start) {\n                  // Function to check for start of token\n                  if (ext.level === 'block') {\n                    if (extensions.startBlock) {\n                      extensions.startBlock.push(ext.start);\n                    } else {\n                      extensions.startBlock = [ext.start];\n                    }\n                  } else if (ext.level === 'inline') {\n                    if (extensions.startInline) {\n                      extensions.startInline.push(ext.start);\n                    } else {\n                      extensions.startInline = [ext.start];\n                    }\n                  }\n                }\n              }\n              if ('childTokens' in ext && ext.childTokens) {\n                // Child tokens to be visited by walkTokens\n                extensions.childTokens[ext.name] = ext.childTokens;\n              }\n            });\n            opts.extensions = extensions;\n          }\n          // ==-- Parse \"overwrite\" extensions --== //\n          if (pack.renderer) {\n            const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n            for (const prop in pack.renderer) {\n              if (!(prop in renderer)) {\n                throw new Error(\"renderer '\".concat(prop, \"' does not exist\"));\n              }\n              if (['options', 'parser'].includes(prop)) {\n                // ignore options property\n                continue;\n              }\n              const rendererProp = prop;\n              const rendererFunc = pack.renderer[rendererProp];\n              const prevRenderer = renderer[rendererProp];\n              // Replace renderer with func to run extension, but fall back if false\n              renderer[rendererProp] = function () {\n                for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n                  args[_key3] = arguments[_key3];\n                }\n                let ret = rendererFunc.apply(renderer, args);\n                if (ret === false) {\n                  ret = prevRenderer.apply(renderer, args);\n                }\n                return ret || '';\n              };\n            }\n            opts.renderer = renderer;\n          }\n          if (pack.tokenizer) {\n            const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n            for (const prop in pack.tokenizer) {\n              if (!(prop in tokenizer)) {\n                throw new Error(\"tokenizer '\".concat(prop, \"' does not exist\"));\n              }\n              if (['options', 'rules', 'lexer'].includes(prop)) {\n                // ignore options, rules, and lexer properties\n                continue;\n              }\n              const tokenizerProp = prop;\n              const tokenizerFunc = pack.tokenizer[tokenizerProp];\n              const prevTokenizer = tokenizer[tokenizerProp];\n              // Replace tokenizer with func to run extension, but fall back if false\n              // @ts-expect-error cannot type tokenizer function dynamically\n              tokenizer[tokenizerProp] = function () {\n                for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n                  args[_key4] = arguments[_key4];\n                }\n                let ret = tokenizerFunc.apply(tokenizer, args);\n                if (ret === false) {\n                  ret = prevTokenizer.apply(tokenizer, args);\n                }\n                return ret;\n              };\n            }\n            opts.tokenizer = tokenizer;\n          }\n          // ==-- Parse Hooks extensions --== //\n          if (pack.hooks) {\n            const hooks = this.defaults.hooks || new _Hooks();\n            for (const prop in pack.hooks) {\n              if (!(prop in hooks)) {\n                throw new Error(\"hook '\".concat(prop, \"' does not exist\"));\n              }\n              if (prop === 'options') {\n                // ignore options property\n                continue;\n              }\n              const hooksProp = prop;\n              const hooksFunc = pack.hooks[hooksProp];\n              const prevHook = hooks[hooksProp];\n              if (_Hooks.passThroughHooks.has(prop)) {\n                // @ts-expect-error cannot type hook function dynamically\n                hooks[hooksProp] = arg => {\n                  if (this.defaults.async) {\n                    return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {\n                      return prevHook.call(hooks, ret);\n                    });\n                  }\n                  const ret = hooksFunc.call(hooks, arg);\n                  return prevHook.call(hooks, ret);\n                };\n              } else {\n                // @ts-expect-error cannot type hook function dynamically\n                hooks[hooksProp] = function () {\n                  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n                    args[_key5] = arguments[_key5];\n                  }\n                  let ret = hooksFunc.apply(hooks, args);\n                  if (ret === false) {\n                    ret = prevHook.apply(hooks, args);\n                  }\n                  return ret;\n                };\n              }\n            }\n            opts.hooks = hooks;\n          }\n          // ==-- Parse WalkTokens extensions --== //\n          if (pack.walkTokens) {\n            const walkTokens = this.defaults.walkTokens;\n            const packWalktokens = pack.walkTokens;\n            opts.walkTokens = function (token) {\n              let values = [];\n              values.push(packWalktokens.call(this, token));\n              if (walkTokens) {\n                values = values.concat(walkTokens.call(this, token));\n              }\n              return values;\n            };\n          }\n          this.defaults = {\n            ...this.defaults,\n            ...opts\n          };\n        });\n        return this;\n      }\n      setOptions(opt) {\n        this.defaults = {\n          ...this.defaults,\n          ...opt\n        };\n        return this;\n      }\n      lexer(src, options) {\n        return _Lexer.lex(src, options !== null && options !== void 0 ? options : this.defaults);\n      }\n      parser(tokens, options) {\n        return _Parser.parse(tokens, options !== null && options !== void 0 ? options : this.defaults);\n      }\n      parseMarkdown(lexer, parser) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const parse = (src, options) => {\n          const origOpt = {\n            ...options\n          };\n          const opt = {\n            ...this.defaults,\n            ...origOpt\n          };\n          const throwError = this.onError(!!opt.silent, !!opt.async);\n          // throw error if an extension set async to true but parse was called with async: false\n          if (this.defaults.async === true && origOpt.async === false) {\n            return throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));\n          }\n          // throw error in case of non string input\n          if (typeof src === 'undefined' || src === null) {\n            return throwError(new Error('marked(): input parameter is undefined or null'));\n          }\n          if (typeof src !== 'string') {\n            return throwError(new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected'));\n          }\n          if (opt.hooks) {\n            opt.hooks.options = opt;\n          }\n          if (opt.async) {\n            return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then(src => lexer(src, opt)).then(tokens => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then(tokens => parser(tokens, opt)).then(html => opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);\n          }\n          try {\n            if (opt.hooks) {\n              src = opt.hooks.preprocess(src);\n            }\n            let tokens = lexer(src, opt);\n            if (opt.hooks) {\n              tokens = opt.hooks.processAllTokens(tokens);\n            }\n            if (opt.walkTokens) {\n              this.walkTokens(tokens, opt.walkTokens);\n            }\n            let html = parser(tokens, opt);\n            if (opt.hooks) {\n              html = opt.hooks.postprocess(html);\n            }\n            return html;\n          } catch (e) {\n            return throwError(e);\n          }\n        };\n        return parse;\n      }\n      onError(silent, async) {\n        return e => {\n          e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n          if (silent) {\n            const msg = '<p>An error occurred:</p><pre>' + escape$1(e.message + '', true) + '</pre>';\n            if (async) {\n              return Promise.resolve(msg);\n            }\n            return msg;\n          }\n          if (async) {\n            return Promise.reject(e);\n          }\n          throw e;\n        };\n      }\n    }\n    const markedInstance = new Marked();\n    function marked(src, opt) {\n      return markedInstance.parse(src, opt);\n    }\n    /**\n     * Sets the default options.\n     *\n     * @param options Hash of options\n     */\n    marked.options = marked.setOptions = function (options) {\n      markedInstance.setOptions(options);\n      marked.defaults = markedInstance.defaults;\n      changeDefaults(marked.defaults);\n      return marked;\n    };\n    /**\n     * Gets the original marked default options.\n     */\n    marked.getDefaults = _getDefaults;\n    marked.defaults = exports.defaults;\n    /**\n     * Use Extension\n     */\n    marked.use = function () {\n      markedInstance.use(...arguments);\n      marked.defaults = markedInstance.defaults;\n      changeDefaults(marked.defaults);\n      return marked;\n    };\n    /**\n     * Run callback for every token\n     */\n    marked.walkTokens = function (tokens, callback) {\n      return markedInstance.walkTokens(tokens, callback);\n    };\n    /**\n     * Compiles markdown to HTML without enclosing `p` tag.\n     *\n     * @param src String of markdown source to be compiled\n     * @param options Hash of options\n     * @return String of compiled HTML\n     */\n    marked.parseInline = markedInstance.parseInline;\n    /**\n     * Expose\n     */\n    marked.Parser = _Parser;\n    marked.parser = _Parser.parse;\n    marked.Renderer = _Renderer;\n    marked.TextRenderer = _TextRenderer;\n    marked.Lexer = _Lexer;\n    marked.lexer = _Lexer.lex;\n    marked.Tokenizer = _Tokenizer;\n    marked.Hooks = _Hooks;\n    marked.parse = marked;\n    const options = marked.options;\n    const setOptions = marked.setOptions;\n    const use = marked.use;\n    const walkTokens = marked.walkTokens;\n    const parseInline = marked.parseInline;\n    const parse = marked;\n    const parser = _Parser.parse;\n    const lexer = _Lexer.lex;\n    exports.Hooks = _Hooks;\n    exports.Lexer = _Lexer;\n    exports.Marked = Marked;\n    exports.Parser = _Parser;\n    exports.Renderer = _Renderer;\n    exports.TextRenderer = _TextRenderer;\n    exports.Tokenizer = _Tokenizer;\n    exports.getDefaults = _getDefaults;\n    exports.lexer = lexer;\n    exports.marked = marked;\n    exports.options = options;\n    exports.parse = parse;\n    exports.parseInline = parseInline;\n    exports.parser = parser;\n    exports.setOptions = setOptions;\n    exports.use = use;\n    exports.walkTokens = walkTokens;\n  });\n\n  // ESM-uncomment-begin\n})();\nexport var Hooks = __marked_exports.Hooks || exports.Hooks;\nexport var Lexer = __marked_exports.Lexer || exports.Lexer;\nexport var Marked = __marked_exports.Marked || exports.Marked;\nexport var Parser = __marked_exports.Parser || exports.Parser;\nexport var Renderer = __marked_exports.Renderer || exports.Renderer;\nexport var TextRenderer = __marked_exports.TextRenderer || exports.TextRenderer;\nexport var Tokenizer = __marked_exports.Tokenizer || exports.Tokenizer;\nexport var defaults = __marked_exports.defaults || exports.defaults;\nexport var getDefaults = __marked_exports.getDefaults || exports.getDefaults;\nexport var lexer = __marked_exports.lexer || exports.lexer;\nexport var marked = __marked_exports.marked || exports.marked;\nexport var options = __marked_exports.options || exports.options;\nexport var parse = __marked_exports.parse || exports.parse;\nexport var parseInline = __marked_exports.parseInline || exports.parseInline;\nexport var parser = __marked_exports.parser || exports.parser;\nexport var setOptions = __marked_exports.setOptions || exports.setOptions;\nexport var use = __marked_exports.use || exports.use;\nexport var walkTokens = __marked_exports.walkTokens || exports.walkTokens;\n// ESM-uncomment-end","map":{"version":3,"names":["__marked_exports","define","deps","factory","amd","global","exports","module","globalThis","self","marked","_getDefaults","async","breaks","extensions","gfm","hooks","pedantic","renderer","silent","tokenizer","walkTokens","defaults","changeDefaults","newDefaults","escapeTest","escapeReplace","RegExp","source","escapeTestNoEncode","escapeReplaceNoEncode","escapeReplacements","getEscapeReplacement","ch","escape$1","html","encode","test","replace","caret","edit","regex","opt","obj","name","val","valSource","getRegex","cleanUrl","href","encodeURI","noopTest","exec","splitCells","tableRow","count","row","match","offset","str","escaped","curr","cells","split","i","trim","shift","length","pop","splice","push","rtrim","c","invert","l","suffLen","currChar","charAt","slice","findClosingBracket","b","indexOf","level","outputLink","cap","link","raw","lexer","title","text","state","inLink","token","type","tokens","inlineTokens","indentCodeCompensation","matchIndentToCode","indentToCode","map","node","matchIndentInNode","indentInNode","join","_Tokenizer","constructor","options","_defineProperty","space","src","rules","block","newline","code","codeBlockStyle","fences","lang","inline","anyPunctuation","heading","trimmed","depth","hr","blockquote","lines","inBlockquote","currentLines","currentRaw","currentText","concat","top","blockTokens","lastToken","oldToken","newText","newToken","substring","list","bull","isordered","ordered","start","loose","items","itemRegex","endsWithBlankLine","endEarly","itemContents","line","t","repeat","nextLine","blankLine","indent","trimStart","search","nextBulletRegex","Math","min","hrRegex","fencesBeginRegex","headingBeginRegex","rawLine","istask","ischecked","task","checked","trimEnd","spacers","filter","hasMultipleLineBreaks","some","pre","def","tag","toLowerCase","table","headers","aligns","rows","item","header","align","cell","lheading","paragraph","escape","inRawBlock","trimmedUrl","rtrimSlash","lastParenIndex","linkLen","reflink","links","nolink","linkString","emStrong","maskedSrc","prevChar","arguments","undefined","emStrongLDelim","nextChar","punctuation","lLength","rDelim","rLength","delimTotal","midDelimTotal","endReg","emStrongRDelimAst","emStrongRDelimUnd","lastIndex","lastCharLength","index","codespan","hasNonSpaceChars","hasSpaceCharsOnBothEnds","br","del","autolink","url","prevCapZero","_this$rules$inline$_b","_this$rules$inline$_b2","_backpedal","inlineText","blockCode","bullet","_paragraph","blockText","_blockLabel","_tag","_comment","blockNormal","gfmTable","blockGfm","blockPedantic","inlineCode","_punctuation","blockSkip","_inlineComment","_inlineLabel","reflinkSearch","inlineNormal","inlinePedantic","inlineGfm","inlineBreaks","normal","_Lexer","Object","create","inlineQueue","lex","lexInline","next","lastParagraphClipped","_","leading","tabs","cutSrc","extTokenizer","call","startBlock","startIndex","Infinity","tempSrc","tempStart","forEach","getStartIndex","_lastToken","errMsg","charCodeAt","console","error","Error","keepPrevChar","keys","includes","lastIndexOf","startInline","_Renderer","_ref","_match","langString","_ref2","body","parser","parse","_ref3","_ref4","parseInline","j","listitem","startAttr","itemBody","checkbox","unshift","_ref5","_ref6","tablecell","tablerow","k","_ref7","content","strong","_ref8","em","_ref9","_ref10","_ref11","_ref12","cleanHref","out","image","_ref13","_TextRenderer","_ref14","_ref15","_ref16","_ref17","_ref18","_ref19","_ref20","_ref21","_Parser","textRenderer","anyToken","renderers","genericToken","ret","textToken","_Hooks","preprocess","markdown","postprocess","processAllTokens","Set","Marked","setOptions","parseMarkdown","use","callback","values","tableToken","listToken","_this$defaults$extens","childTokens","flat","_len","args","Array","_key","pack","opts","ext","prevRenderer","_len2","_key2","apply","extLevel","prop","rendererProp","rendererFunc","_len3","_key3","tokenizerProp","tokenizerFunc","prevTokenizer","_len4","_key4","hooksProp","hooksFunc","prevHook","passThroughHooks","has","arg","Promise","resolve","then","_len5","_key5","packWalktokens","origOpt","throwError","onError","prototype","toString","all","catch","e","message","msg","reject","markedInstance","getDefaults","Parser","Renderer","TextRenderer","Lexer","Tokenizer","Hooks"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/base/common/marked/marked.js"],"sourcesContent":["/**\n * marked v14.0.0 - a markdown parser\n * Copyright (c) 2011-2024, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\n// ESM-uncomment-begin\nlet __marked_exports = {};\n(function() {\n  function define(deps, factory) {\n    factory(__marked_exports);\n  }\n  define.amd = true;\n// ESM-uncomment-end\n\n(function (global, factory) {\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\t(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.marked = {}));\n  })(this, (function (exports) {\n\t'use strict';\n\n\t/**\n\t * Gets the original marked default options.\n\t */\n\tfunction _getDefaults() {\n\t\treturn {\n\t\t\tasync: false,\n\t\t\tbreaks: false,\n\t\t\textensions: null,\n\t\t\tgfm: true,\n\t\t\thooks: null,\n\t\t\tpedantic: false,\n\t\t\trenderer: null,\n\t\t\tsilent: false,\n\t\t\ttokenizer: null,\n\t\t\twalkTokens: null,\n\t\t};\n\t}\n\texports.defaults = _getDefaults();\n\tfunction changeDefaults(newDefaults) {\n\t\texports.defaults = newDefaults;\n\t}\n\n\t/**\n\t * Helpers\n\t */\n\tconst escapeTest = /[&<>\"']/;\n\tconst escapeReplace = new RegExp(escapeTest.source, 'g');\n\tconst escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\n\tconst escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');\n\tconst escapeReplacements = {\n\t\t'&': '&amp;',\n\t\t'<': '&lt;',\n\t\t'>': '&gt;',\n\t\t'\"': '&quot;',\n\t\t\"'\": '&#39;',\n\t};\n\tconst getEscapeReplacement = (ch) => escapeReplacements[ch];\n\tfunction escape$1(html, encode) {\n\t\tif (encode) {\n\t\t\tif (escapeTest.test(html)) {\n\t\t\t\treturn html.replace(escapeReplace, getEscapeReplacement);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (escapeTestNoEncode.test(html)) {\n\t\t\t\treturn html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n\t\t\t}\n\t\t}\n\t\treturn html;\n\t}\n\tconst caret = /(^|[^\\[])\\^/g;\n\tfunction edit(regex, opt) {\n\t\tlet source = typeof regex === 'string' ? regex : regex.source;\n\t\topt = opt || '';\n\t\tconst obj = {\n\t\t\treplace: (name, val) => {\n\t\t\t\tlet valSource = typeof val === 'string' ? val : val.source;\n\t\t\t\tvalSource = valSource.replace(caret, '$1');\n\t\t\t\tsource = source.replace(name, valSource);\n\t\t\t\treturn obj;\n\t\t\t},\n\t\t\tgetRegex: () => {\n\t\t\t\treturn new RegExp(source, opt);\n\t\t\t},\n\t\t};\n\t\treturn obj;\n\t}\n\tfunction cleanUrl(href) {\n\t\ttry {\n\t\t\thref = encodeURI(href).replace(/%25/g, '%');\n\t\t}\n\t\tcatch {\n\t\t\treturn null;\n\t\t}\n\t\treturn href;\n\t}\n\tconst noopTest = { exec: () => null };\n\tfunction splitCells(tableRow, count) {\n\t\t// ensure that every cell-delimiting pipe has a space\n\t\t// before it to distinguish it from an escaped pipe\n\t\tconst row = tableRow.replace(/\\|/g, (match, offset, str) => {\n\t\t\tlet escaped = false;\n\t\t\tlet curr = offset;\n\t\t\twhile (--curr >= 0 && str[curr] === '\\\\')\n\t\t\t\tescaped = !escaped;\n\t\t\tif (escaped) {\n\t\t\t\t// odd number of slashes means | is escaped\n\t\t\t\t// so we leave it alone\n\t\t\t\treturn '|';\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// add space before unescaped |\n\t\t\t\treturn ' |';\n\t\t\t}\n\t\t}), cells = row.split(/ \\|/);\n\t\tlet i = 0;\n\t\t// First/last cell in a row cannot be empty if it has no leading/trailing pipe\n\t\tif (!cells[0].trim()) {\n\t\t\tcells.shift();\n\t\t}\n\t\tif (cells.length > 0 && !cells[cells.length - 1].trim()) {\n\t\t\tcells.pop();\n\t\t}\n\t\tif (count) {\n\t\t\tif (cells.length > count) {\n\t\t\t\tcells.splice(count);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (cells.length < count)\n\t\t\t\t\tcells.push('');\n\t\t\t}\n\t\t}\n\t\tfor (; i < cells.length; i++) {\n\t\t\t// leading or trailing whitespace is ignored per the gfm spec\n\t\t\tcells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n\t\t}\n\t\treturn cells;\n\t}\n\t/**\n\t * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n\t * /c*$/ is vulnerable to REDOS.\n\t *\n\t * @param str\n\t * @param c\n\t * @param invert Remove suffix of non-c chars instead. Default falsey.\n\t */\n\tfunction rtrim(str, c, invert) {\n\t\tconst l = str.length;\n\t\tif (l === 0) {\n\t\t\treturn '';\n\t\t}\n\t\t// Length of suffix matching the invert condition.\n\t\tlet suffLen = 0;\n\t\t// Step left until we fail to match the invert condition.\n\t\twhile (suffLen < l) {\n\t\t\tconst currChar = str.charAt(l - suffLen - 1);\n\t\t\tif (currChar === c && !invert) {\n\t\t\t\tsuffLen++;\n\t\t\t}\n\t\t\telse if (currChar !== c && invert) {\n\t\t\t\tsuffLen++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn str.slice(0, l - suffLen);\n\t}\n\tfunction findClosingBracket(str, b) {\n\t\tif (str.indexOf(b[1]) === -1) {\n\t\t\treturn -1;\n\t\t}\n\t\tlet level = 0;\n\t\tfor (let i = 0; i < str.length; i++) {\n\t\t\tif (str[i] === '\\\\') {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (str[i] === b[0]) {\n\t\t\t\tlevel++;\n\t\t\t}\n\t\t\telse if (str[i] === b[1]) {\n\t\t\t\tlevel--;\n\t\t\t\tif (level < 0) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tfunction outputLink(cap, link, raw, lexer) {\n\t\tconst href = link.href;\n\t\tconst title = link.title ? escape$1(link.title) : null;\n\t\tconst text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n\t\tif (cap[0].charAt(0) !== '!') {\n\t\t\tlexer.state.inLink = true;\n\t\t\tconst token = {\n\t\t\t\ttype: 'link',\n\t\t\t\traw,\n\t\t\t\thref,\n\t\t\t\ttitle,\n\t\t\t\ttext,\n\t\t\t\ttokens: lexer.inlineTokens(text),\n\t\t\t};\n\t\t\tlexer.state.inLink = false;\n\t\t\treturn token;\n\t\t}\n\t\treturn {\n\t\t\ttype: 'image',\n\t\t\traw,\n\t\t\thref,\n\t\t\ttitle,\n\t\t\ttext: escape$1(text),\n\t\t};\n\t}\n\tfunction indentCodeCompensation(raw, text) {\n\t\tconst matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n\t\tif (matchIndentToCode === null) {\n\t\t\treturn text;\n\t\t}\n\t\tconst indentToCode = matchIndentToCode[1];\n\t\treturn text\n\t\t\t.split('\\n')\n\t\t\t.map(node => {\n\t\t\t\tconst matchIndentInNode = node.match(/^\\s+/);\n\t\t\t\tif (matchIndentInNode === null) {\n\t\t\t\t\treturn node;\n\t\t\t\t}\n\t\t\t\tconst [indentInNode] = matchIndentInNode;\n\t\t\t\tif (indentInNode.length >= indentToCode.length) {\n\t\t\t\t\treturn node.slice(indentToCode.length);\n\t\t\t\t}\n\t\t\t\treturn node;\n\t\t\t})\n\t\t\t.join('\\n');\n\t}\n\t/**\n\t * Tokenizer\n\t */\n\tclass _Tokenizer {\n\t\toptions;\n\t\trules; // set by the lexer\n\t\tlexer; // set by the lexer\n\t\tconstructor(options) {\n\t\t\tthis.options = options || exports.defaults;\n\t\t}\n\t\tspace(src) {\n\t\t\tconst cap = this.rules.block.newline.exec(src);\n\t\t\tif (cap && cap[0].length > 0) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'space',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tcode(src) {\n\t\t\tconst cap = this.rules.block.code.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tconst text = cap[0].replace(/^ {1,4}/gm, '');\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'code',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\tcodeBlockStyle: 'indented',\n\t\t\t\t\ttext: !this.options.pedantic\n\t\t\t\t\t\t? rtrim(text, '\\n')\n\t\t\t\t\t\t: text,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tfences(src) {\n\t\t\tconst cap = this.rules.block.fences.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tconst raw = cap[0];\n\t\t\t\tconst text = indentCodeCompensation(raw, cap[3] || '');\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'code',\n\t\t\t\t\traw,\n\t\t\t\t\tlang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n\t\t\t\t\ttext,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\theading(src) {\n\t\t\tconst cap = this.rules.block.heading.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tlet text = cap[2].trim();\n\t\t\t\t// remove trailing #s\n\t\t\t\tif (/#$/.test(text)) {\n\t\t\t\t\tconst trimmed = rtrim(text, '#');\n\t\t\t\t\tif (this.options.pedantic) {\n\t\t\t\t\t\ttext = trimmed.trim();\n\t\t\t\t\t}\n\t\t\t\t\telse if (!trimmed || / $/.test(trimmed)) {\n\t\t\t\t\t\t// CommonMark requires space before trailing #s\n\t\t\t\t\t\ttext = trimmed.trim();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'heading',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\tdepth: cap[1].length,\n\t\t\t\t\ttext,\n\t\t\t\t\ttokens: this.lexer.inline(text),\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\thr(src) {\n\t\t\tconst cap = this.rules.block.hr.exec(src);\n\t\t\tif (cap) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'hr',\n\t\t\t\t\traw: rtrim(cap[0], '\\n'),\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tblockquote(src) {\n\t\t\tconst cap = this.rules.block.blockquote.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tlet lines = rtrim(cap[0], '\\n').split('\\n');\n\t\t\t\tlet raw = '';\n\t\t\t\tlet text = '';\n\t\t\t\tconst tokens = [];\n\t\t\t\twhile (lines.length > 0) {\n\t\t\t\t\tlet inBlockquote = false;\n\t\t\t\t\tconst currentLines = [];\n\t\t\t\t\tlet i;\n\t\t\t\t\tfor (i = 0; i < lines.length; i++) {\n\t\t\t\t\t\t// get lines up to a continuation\n\t\t\t\t\t\tif (/^ {0,3}>/.test(lines[i])) {\n\t\t\t\t\t\t\tcurrentLines.push(lines[i]);\n\t\t\t\t\t\t\tinBlockquote = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!inBlockquote) {\n\t\t\t\t\t\t\tcurrentLines.push(lines[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlines = lines.slice(i);\n\t\t\t\t\tconst currentRaw = currentLines.join('\\n');\n\t\t\t\t\tconst currentText = currentRaw\n\t\t\t\t\t\t// precede setext continuation with 4 spaces so it isn't a setext\n\t\t\t\t\t\t.replace(/\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g, '\\n    $1')\n\t\t\t\t\t\t.replace(/^ {0,3}>[ \\t]?/gm, '');\n\t\t\t\t\traw = raw ? `${raw}\\n${currentRaw}` : currentRaw;\n\t\t\t\t\ttext = text ? `${text}\\n${currentText}` : currentText;\n\t\t\t\t\t// parse blockquote lines as top level tokens\n\t\t\t\t\t// merge paragraphs if this is a continuation\n\t\t\t\t\tconst top = this.lexer.state.top;\n\t\t\t\t\tthis.lexer.state.top = true;\n\t\t\t\t\tthis.lexer.blockTokens(currentText, tokens, true);\n\t\t\t\t\tthis.lexer.state.top = top;\n\t\t\t\t\t// if there is no continuation then we are done\n\t\t\t\t\tif (lines.length === 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst lastToken = tokens[tokens.length - 1];\n\t\t\t\t\tif (lastToken?.type === 'code') {\n\t\t\t\t\t\t// blockquote continuation cannot be preceded by a code block\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (lastToken?.type === 'blockquote') {\n\t\t\t\t\t\t// include continuation in nested blockquote\n\t\t\t\t\t\tconst oldToken = lastToken;\n\t\t\t\t\t\tconst newText = oldToken.raw + '\\n' + lines.join('\\n');\n\t\t\t\t\t\tconst newToken = this.blockquote(newText);\n\t\t\t\t\t\ttokens[tokens.length - 1] = newToken;\n\t\t\t\t\t\traw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;\n\t\t\t\t\t\ttext = text.substring(0, text.length - oldToken.text.length) + newToken.text;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (lastToken?.type === 'list') {\n\t\t\t\t\t\t// include continuation in nested list\n\t\t\t\t\t\tconst oldToken = lastToken;\n\t\t\t\t\t\tconst newText = oldToken.raw + '\\n' + lines.join('\\n');\n\t\t\t\t\t\tconst newToken = this.list(newText);\n\t\t\t\t\t\ttokens[tokens.length - 1] = newToken;\n\t\t\t\t\t\traw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;\n\t\t\t\t\t\ttext = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;\n\t\t\t\t\t\tlines = newText.substring(tokens[tokens.length - 1].raw.length).split('\\n');\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'blockquote',\n\t\t\t\t\traw,\n\t\t\t\t\ttokens,\n\t\t\t\t\ttext,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tlist(src) {\n\t\t\tlet cap = this.rules.block.list.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tlet bull = cap[1].trim();\n\t\t\t\tconst isordered = bull.length > 1;\n\t\t\t\tconst list = {\n\t\t\t\t\ttype: 'list',\n\t\t\t\t\traw: '',\n\t\t\t\t\tordered: isordered,\n\t\t\t\t\tstart: isordered ? +bull.slice(0, -1) : '',\n\t\t\t\t\tloose: false,\n\t\t\t\t\titems: [],\n\t\t\t\t};\n\t\t\t\tbull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n\t\t\t\tif (this.options.pedantic) {\n\t\t\t\t\tbull = isordered ? bull : '[*+-]';\n\t\t\t\t}\n\t\t\t\t// Get next list item\n\t\t\t\tconst itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n\t\t\t\tlet endsWithBlankLine = false;\n\t\t\t\t// Check if current bullet point can start a new List Item\n\t\t\t\twhile (src) {\n\t\t\t\t\tlet endEarly = false;\n\t\t\t\t\tlet raw = '';\n\t\t\t\t\tlet itemContents = '';\n\t\t\t\t\tif (!(cap = itemRegex.exec(src))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\traw = cap[0];\n\t\t\t\t\tsrc = src.substring(raw.length);\n\t\t\t\t\tlet line = cap[2].split('\\n', 1)[0].replace(/^\\t+/, (t) => ' '.repeat(3 * t.length));\n\t\t\t\t\tlet nextLine = src.split('\\n', 1)[0];\n\t\t\t\t\tlet blankLine = !line.trim();\n\t\t\t\t\tlet indent = 0;\n\t\t\t\t\tif (this.options.pedantic) {\n\t\t\t\t\t\tindent = 2;\n\t\t\t\t\t\titemContents = line.trimStart();\n\t\t\t\t\t}\n\t\t\t\t\telse if (blankLine) {\n\t\t\t\t\t\tindent = cap[1].length + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tindent = cap[2].search(/[^ ]/); // Find first non-space char\n\t\t\t\t\t\tindent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n\t\t\t\t\t\titemContents = line.slice(indent);\n\t\t\t\t\t\tindent += cap[1].length;\n\t\t\t\t\t}\n\t\t\t\t\tif (blankLine && /^ *$/.test(nextLine)) { // Items begin with at most one blank line\n\t\t\t\t\t\traw += nextLine + '\\n';\n\t\t\t\t\t\tsrc = src.substring(nextLine.length + 1);\n\t\t\t\t\t\tendEarly = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (!endEarly) {\n\t\t\t\t\t\tconst nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`);\n\t\t\t\t\t\tconst hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n\t\t\t\t\t\tconst fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n\t\t\t\t\t\tconst headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n\t\t\t\t\t\t// Check if following lines should be included in List Item\n\t\t\t\t\t\twhile (src) {\n\t\t\t\t\t\t\tconst rawLine = src.split('\\n', 1)[0];\n\t\t\t\t\t\t\tnextLine = rawLine;\n\t\t\t\t\t\t\t// Re-align to follow commonmark nesting rules\n\t\t\t\t\t\t\tif (this.options.pedantic) {\n\t\t\t\t\t\t\t\tnextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// End list item if found code fences\n\t\t\t\t\t\t\tif (fencesBeginRegex.test(nextLine)) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// End list item if found start of new heading\n\t\t\t\t\t\t\tif (headingBeginRegex.test(nextLine)) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// End list item if found start of new bullet\n\t\t\t\t\t\t\tif (nextBulletRegex.test(nextLine)) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Horizontal rule found\n\t\t\t\t\t\t\tif (hrRegex.test(src)) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) { // Dedent if possible\n\t\t\t\t\t\t\t\titemContents += '\\n' + nextLine.slice(indent);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// not enough indentation\n\t\t\t\t\t\t\t\tif (blankLine) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// paragraph continuation unless last line was a different block level element\n\t\t\t\t\t\t\t\tif (line.search(/[^ ]/) >= 4) { // indented code block\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (fencesBeginRegex.test(line)) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (headingBeginRegex.test(line)) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (hrRegex.test(line)) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\titemContents += '\\n' + nextLine;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!blankLine && !nextLine.trim()) { // Check if current line is blank\n\t\t\t\t\t\t\t\tblankLine = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\traw += rawLine + '\\n';\n\t\t\t\t\t\t\tsrc = src.substring(rawLine.length + 1);\n\t\t\t\t\t\t\tline = nextLine.slice(indent);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!list.loose) {\n\t\t\t\t\t\t// If the previous item ended with a blank line, the list is loose\n\t\t\t\t\t\tif (endsWithBlankLine) {\n\t\t\t\t\t\t\tlist.loose = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (/\\n *\\n *$/.test(raw)) {\n\t\t\t\t\t\t\tendsWithBlankLine = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlet istask = null;\n\t\t\t\t\tlet ischecked;\n\t\t\t\t\t// Check for task list items\n\t\t\t\t\tif (this.options.gfm) {\n\t\t\t\t\t\tistask = /^\\[[ xX]\\] /.exec(itemContents);\n\t\t\t\t\t\tif (istask) {\n\t\t\t\t\t\t\tischecked = istask[0] !== '[ ] ';\n\t\t\t\t\t\t\titemContents = itemContents.replace(/^\\[[ xX]\\] +/, '');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist.items.push({\n\t\t\t\t\t\ttype: 'list_item',\n\t\t\t\t\t\traw,\n\t\t\t\t\t\ttask: !!istask,\n\t\t\t\t\t\tchecked: ischecked,\n\t\t\t\t\t\tloose: false,\n\t\t\t\t\t\ttext: itemContents,\n\t\t\t\t\t\ttokens: [],\n\t\t\t\t\t});\n\t\t\t\t\tlist.raw += raw;\n\t\t\t\t}\n\t\t\t\t// Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n\t\t\t\tlist.items[list.items.length - 1].raw = list.items[list.items.length - 1].raw.trimEnd();\n\t\t\t\tlist.items[list.items.length - 1].text = list.items[list.items.length - 1].text.trimEnd();\n\t\t\t\tlist.raw = list.raw.trimEnd();\n\t\t\t\t// Item child tokens handled here at end because we needed to have the final item to trim it first\n\t\t\t\tfor (let i = 0; i < list.items.length; i++) {\n\t\t\t\t\tthis.lexer.state.top = false;\n\t\t\t\t\tlist.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n\t\t\t\t\tif (!list.loose) {\n\t\t\t\t\t\t// Check if list should be loose\n\t\t\t\t\t\tconst spacers = list.items[i].tokens.filter(t => t.type === 'space');\n\t\t\t\t\t\tconst hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\\n.*\\n/.test(t.raw));\n\t\t\t\t\t\tlist.loose = hasMultipleLineBreaks;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Set all items to loose if list is loose\n\t\t\t\tif (list.loose) {\n\t\t\t\t\tfor (let i = 0; i < list.items.length; i++) {\n\t\t\t\t\t\tlist.items[i].loose = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn list;\n\t\t\t}\n\t\t}\n\t\thtml(src) {\n\t\t\tconst cap = this.rules.block.html.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tconst token = {\n\t\t\t\t\ttype: 'html',\n\t\t\t\t\tblock: true,\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\tpre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n\t\t\t\t\ttext: cap[0],\n\t\t\t\t};\n\t\t\t\treturn token;\n\t\t\t}\n\t\t}\n\t\tdef(src) {\n\t\t\tconst cap = this.rules.block.def.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tconst tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n\t\t\t\tconst href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n\t\t\t\tconst title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'def',\n\t\t\t\t\ttag,\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\thref,\n\t\t\t\t\ttitle,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\ttable(src) {\n\t\t\tconst cap = this.rules.block.table.exec(src);\n\t\t\tif (!cap) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!/[:|]/.test(cap[2])) {\n\t\t\t\t// delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst headers = splitCells(cap[1]);\n\t\t\tconst aligns = cap[2].replace(/^\\||\\| *$/g, '').split('|');\n\t\t\tconst rows = cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, '').split('\\n') : [];\n\t\t\tconst item = {\n\t\t\t\ttype: 'table',\n\t\t\t\traw: cap[0],\n\t\t\t\theader: [],\n\t\t\t\talign: [],\n\t\t\t\trows: [],\n\t\t\t};\n\t\t\tif (headers.length !== aligns.length) {\n\t\t\t\t// header and align columns must be equal, rows can be different.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (const align of aligns) {\n\t\t\t\tif (/^ *-+: *$/.test(align)) {\n\t\t\t\t\titem.align.push('right');\n\t\t\t\t}\n\t\t\t\telse if (/^ *:-+: *$/.test(align)) {\n\t\t\t\t\titem.align.push('center');\n\t\t\t\t}\n\t\t\t\telse if (/^ *:-+ *$/.test(align)) {\n\t\t\t\t\titem.align.push('left');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\titem.align.push(null);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i = 0; i < headers.length; i++) {\n\t\t\t\titem.header.push({\n\t\t\t\t\ttext: headers[i],\n\t\t\t\t\ttokens: this.lexer.inline(headers[i]),\n\t\t\t\t\theader: true,\n\t\t\t\t\talign: item.align[i],\n\t\t\t\t});\n\t\t\t}\n\t\t\tfor (const row of rows) {\n\t\t\t\titem.rows.push(splitCells(row, item.header.length).map((cell, i) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttext: cell,\n\t\t\t\t\t\ttokens: this.lexer.inline(cell),\n\t\t\t\t\t\theader: false,\n\t\t\t\t\t\talign: item.align[i],\n\t\t\t\t\t};\n\t\t\t\t}));\n\t\t\t}\n\t\t\treturn item;\n\t\t}\n\t\tlheading(src) {\n\t\t\tconst cap = this.rules.block.lheading.exec(src);\n\t\t\tif (cap) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'heading',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\tdepth: cap[2].charAt(0) === '=' ? 1 : 2,\n\t\t\t\t\ttext: cap[1],\n\t\t\t\t\ttokens: this.lexer.inline(cap[1]),\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tparagraph(src) {\n\t\t\tconst cap = this.rules.block.paragraph.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tconst text = cap[1].charAt(cap[1].length - 1) === '\\n'\n\t\t\t\t\t? cap[1].slice(0, -1)\n\t\t\t\t\t: cap[1];\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'paragraph',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\ttext,\n\t\t\t\t\ttokens: this.lexer.inline(text),\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\ttext(src) {\n\t\t\tconst cap = this.rules.block.text.exec(src);\n\t\t\tif (cap) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'text',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\ttext: cap[0],\n\t\t\t\t\ttokens: this.lexer.inline(cap[0]),\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tescape(src) {\n\t\t\tconst cap = this.rules.inline.escape.exec(src);\n\t\t\tif (cap) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'escape',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\ttext: escape$1(cap[1]),\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\ttag(src) {\n\t\t\tconst cap = this.rules.inline.tag.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tif (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n\t\t\t\t\tthis.lexer.state.inLink = true;\n\t\t\t\t}\n\t\t\t\telse if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n\t\t\t\t\tthis.lexer.state.inLink = false;\n\t\t\t\t}\n\t\t\t\tif (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n\t\t\t\t\tthis.lexer.state.inRawBlock = true;\n\t\t\t\t}\n\t\t\t\telse if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n\t\t\t\t\tthis.lexer.state.inRawBlock = false;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'html',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\tinLink: this.lexer.state.inLink,\n\t\t\t\t\tinRawBlock: this.lexer.state.inRawBlock,\n\t\t\t\t\tblock: false,\n\t\t\t\t\ttext: cap[0],\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tlink(src) {\n\t\t\tconst cap = this.rules.inline.link.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tconst trimmedUrl = cap[2].trim();\n\t\t\t\tif (!this.options.pedantic && /^</.test(trimmedUrl)) {\n\t\t\t\t\t// commonmark requires matching angle brackets\n\t\t\t\t\tif (!(/>$/.test(trimmedUrl))) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// ending angle bracket cannot be escaped\n\t\t\t\t\tconst rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n\t\t\t\t\tif ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// find closing parenthesis\n\t\t\t\t\tconst lastParenIndex = findClosingBracket(cap[2], '()');\n\t\t\t\t\tif (lastParenIndex > -1) {\n\t\t\t\t\t\tconst start = cap[0].indexOf('!') === 0 ? 5 : 4;\n\t\t\t\t\t\tconst linkLen = start + cap[1].length + lastParenIndex;\n\t\t\t\t\t\tcap[2] = cap[2].substring(0, lastParenIndex);\n\t\t\t\t\t\tcap[0] = cap[0].substring(0, linkLen).trim();\n\t\t\t\t\t\tcap[3] = '';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet href = cap[2];\n\t\t\t\tlet title = '';\n\t\t\t\tif (this.options.pedantic) {\n\t\t\t\t\t// split pedantic href and title\n\t\t\t\t\tconst link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n\t\t\t\t\tif (link) {\n\t\t\t\t\t\thref = link[1];\n\t\t\t\t\t\ttitle = link[3];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttitle = cap[3] ? cap[3].slice(1, -1) : '';\n\t\t\t\t}\n\t\t\t\thref = href.trim();\n\t\t\t\tif (/^</.test(href)) {\n\t\t\t\t\tif (this.options.pedantic && !(/>$/.test(trimmedUrl))) {\n\t\t\t\t\t\t// pedantic allows starting angle bracket without ending angle bracket\n\t\t\t\t\t\thref = href.slice(1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\thref = href.slice(1, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn outputLink(cap, {\n\t\t\t\t\thref: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n\t\t\t\t\ttitle: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title,\n\t\t\t\t}, cap[0], this.lexer);\n\t\t\t}\n\t\t}\n\t\treflink(src, links) {\n\t\t\tlet cap;\n\t\t\tif ((cap = this.rules.inline.reflink.exec(src))\n\t\t\t\t|| (cap = this.rules.inline.nolink.exec(src))) {\n\t\t\t\tconst linkString = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n\t\t\t\tconst link = links[linkString.toLowerCase()];\n\t\t\t\tif (!link) {\n\t\t\t\t\tconst text = cap[0].charAt(0);\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: 'text',\n\t\t\t\t\t\traw: text,\n\t\t\t\t\t\ttext,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn outputLink(cap, link, cap[0], this.lexer);\n\t\t\t}\n\t\t}\n\t\temStrong(src, maskedSrc, prevChar = '') {\n\t\t\tlet match = this.rules.inline.emStrongLDelim.exec(src);\n\t\t\tif (!match)\n\t\t\t\treturn;\n\t\t\t// _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n\t\t\tif (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u))\n\t\t\t\treturn;\n\t\t\tconst nextChar = match[1] || match[2] || '';\n\t\t\tif (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n\t\t\t\t// unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n\t\t\t\tconst lLength = [...match[0]].length - 1;\n\t\t\t\tlet rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n\t\t\t\tconst endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n\t\t\t\tendReg.lastIndex = 0;\n\t\t\t\t// Clip maskedSrc to same section of string as src (move to lexer?)\n\t\t\t\tmaskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n\t\t\t\twhile ((match = endReg.exec(maskedSrc)) != null) {\n\t\t\t\t\trDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n\t\t\t\t\tif (!rDelim)\n\t\t\t\t\t\tcontinue; // skip single * in __abc*abc__\n\t\t\t\t\trLength = [...rDelim].length;\n\t\t\t\t\tif (match[3] || match[4]) { // found another Left Delim\n\t\t\t\t\t\tdelimTotal += rLength;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (match[5] || match[6]) { // either Left or Right Delim\n\t\t\t\t\t\tif (lLength % 3 && !((lLength + rLength) % 3)) {\n\t\t\t\t\t\t\tmidDelimTotal += rLength;\n\t\t\t\t\t\t\tcontinue; // CommonMark Emphasis Rules 9-10\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdelimTotal -= rLength;\n\t\t\t\t\tif (delimTotal > 0)\n\t\t\t\t\t\tcontinue; // Haven't found enough closing delimiters\n\t\t\t\t\t// Remove extra characters. *a*** -> *a*\n\t\t\t\t\trLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n\t\t\t\t\t// char length can be >1 for unicode characters;\n\t\t\t\t\tconst lastCharLength = [...match[0]][0].length;\n\t\t\t\t\tconst raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n\t\t\t\t\t// Create `em` if smallest delimiter has odd char count. *a***\n\t\t\t\t\tif (Math.min(lLength, rLength) % 2) {\n\t\t\t\t\t\tconst text = raw.slice(1, -1);\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: 'em',\n\t\t\t\t\t\t\traw,\n\t\t\t\t\t\t\ttext,\n\t\t\t\t\t\t\ttokens: this.lexer.inlineTokens(text),\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\t// Create 'strong' if smallest delimiter has even char count. **a***\n\t\t\t\t\tconst text = raw.slice(2, -2);\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: 'strong',\n\t\t\t\t\t\traw,\n\t\t\t\t\t\ttext,\n\t\t\t\t\t\ttokens: this.lexer.inlineTokens(text),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcodespan(src) {\n\t\t\tconst cap = this.rules.inline.code.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tlet text = cap[2].replace(/\\n/g, ' ');\n\t\t\t\tconst hasNonSpaceChars = /[^ ]/.test(text);\n\t\t\t\tconst hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n\t\t\t\tif (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n\t\t\t\t\ttext = text.substring(1, text.length - 1);\n\t\t\t\t}\n\t\t\t\ttext = escape$1(text, true);\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'codespan',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\ttext,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tbr(src) {\n\t\t\tconst cap = this.rules.inline.br.exec(src);\n\t\t\tif (cap) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'br',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tdel(src) {\n\t\t\tconst cap = this.rules.inline.del.exec(src);\n\t\t\tif (cap) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'del',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\ttext: cap[2],\n\t\t\t\t\ttokens: this.lexer.inlineTokens(cap[2]),\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tautolink(src) {\n\t\t\tconst cap = this.rules.inline.autolink.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tlet text, href;\n\t\t\t\tif (cap[2] === '@') {\n\t\t\t\t\ttext = escape$1(cap[1]);\n\t\t\t\t\thref = 'mailto:' + text;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttext = escape$1(cap[1]);\n\t\t\t\t\thref = text;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'link',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\ttext,\n\t\t\t\t\thref,\n\t\t\t\t\ttokens: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype: 'text',\n\t\t\t\t\t\t\traw: text,\n\t\t\t\t\t\t\ttext,\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\turl(src) {\n\t\t\tlet cap;\n\t\t\tif (cap = this.rules.inline.url.exec(src)) {\n\t\t\t\tlet text, href;\n\t\t\t\tif (cap[2] === '@') {\n\t\t\t\t\ttext = escape$1(cap[0]);\n\t\t\t\t\thref = 'mailto:' + text;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// do extended autolink path validation\n\t\t\t\t\tlet prevCapZero;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tprevCapZero = cap[0];\n\t\t\t\t\t\tcap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';\n\t\t\t\t\t} while (prevCapZero !== cap[0]);\n\t\t\t\t\ttext = escape$1(cap[0]);\n\t\t\t\t\tif (cap[1] === 'www.') {\n\t\t\t\t\t\thref = 'http://' + cap[0];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\thref = cap[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'link',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\ttext,\n\t\t\t\t\thref,\n\t\t\t\t\ttokens: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype: 'text',\n\t\t\t\t\t\t\traw: text,\n\t\t\t\t\t\t\ttext,\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tinlineText(src) {\n\t\t\tconst cap = this.rules.inline.text.exec(src);\n\t\t\tif (cap) {\n\t\t\t\tlet text;\n\t\t\t\tif (this.lexer.state.inRawBlock) {\n\t\t\t\t\ttext = cap[0];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttext = escape$1(cap[0]);\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'text',\n\t\t\t\t\traw: cap[0],\n\t\t\t\t\ttext,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Block-Level Grammar\n\t */\n\tconst newline = /^(?: *(?:\\n|$))+/;\n\tconst blockCode = /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/;\n\tconst fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\n\tconst hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\n\tconst heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\n\tconst bullet = /(?:[*+-]|\\d{1,9}[.)])/;\n\tconst lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/)\n\t\t.replace(/bull/g, bullet) // lists can interrupt\n\t\t.replace(/blockCode/g, / {4}/) // indented code blocks can interrupt\n\t\t.replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n\t\t.replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n\t\t.replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n\t\t.replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n\t\t.getRegex();\n\tconst _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\n\tconst blockText = /^[^\\n]+/;\n\tconst _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\n\tconst def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n *)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/)\n\t\t.replace('label', _blockLabel)\n\t\t.replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/)\n\t\t.getRegex();\n\tconst list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/)\n\t\t.replace(/bull/g, bullet)\n\t\t.getRegex();\n\tconst _tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n\t\t+ '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n\t\t+ '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n\t\t+ '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n\t\t+ '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'\n\t\t+ '|tr|track|ul';\n\tconst _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\n\tconst html = edit('^ {0,3}(?:' // optional indentation\n\t\t+ '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n\t\t+ '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n\t\t+ '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n\t\t+ '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n\t\t+ '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n\t\t+ '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (6)\n\t\t+ '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) open tag\n\t\t+ '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) closing tag\n\t\t+ ')', 'i')\n\t\t.replace('comment', _comment)\n\t\t.replace('tag', _tag)\n\t\t.replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n\t\t.getRegex();\n\tconst paragraph = edit(_paragraph)\n\t\t.replace('hr', hr)\n\t\t.replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n\t\t.replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n\t\t.replace('|table', '')\n\t\t.replace('blockquote', ' {0,3}>')\n\t\t.replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n\t\t.replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n\t\t.replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n\t\t.replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n\t\t.getRegex();\n\tconst blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/)\n\t\t.replace('paragraph', paragraph)\n\t\t.getRegex();\n\t/**\n\t * Normal Block Grammar\n\t */\n\tconst blockNormal = {\n\t\tblockquote,\n\t\tcode: blockCode,\n\t\tdef,\n\t\tfences,\n\t\theading,\n\t\thr,\n\t\thtml,\n\t\tlheading,\n\t\tlist,\n\t\tnewline,\n\t\tparagraph,\n\t\ttable: noopTest,\n\t\ttext: blockText,\n\t};\n\t/**\n\t * GFM Block Grammar\n\t */\n\tconst gfmTable = edit('^ *([^\\\\n ].*)\\\\n' // Header\n\t\t+ ' {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)' // Align\n\t\t+ '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)') // Cells\n\t\t.replace('hr', hr)\n\t\t.replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n\t\t.replace('blockquote', ' {0,3}>')\n\t\t.replace('code', ' {4}[^\\\\n]')\n\t\t.replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n\t\t.replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n\t\t.replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n\t\t.replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n\t\t.getRegex();\n\tconst blockGfm = {\n\t\t...blockNormal,\n\t\ttable: gfmTable,\n\t\tparagraph: edit(_paragraph)\n\t\t\t.replace('hr', hr)\n\t\t\t.replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n\t\t\t.replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n\t\t\t.replace('table', gfmTable) // interrupt paragraphs with table\n\t\t\t.replace('blockquote', ' {0,3}>')\n\t\t\t.replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n\t\t\t.replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n\t\t\t.replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n\t\t\t.replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n\t\t\t.getRegex(),\n\t};\n\t/**\n\t * Pedantic grammar (original John Gruber's loose markdown specification)\n\t */\n\tconst blockPedantic = {\n\t\t...blockNormal,\n\t\thtml: edit('^ *(?:comment *(?:\\\\n|\\\\s*$)'\n\t\t\t+ '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n\t\t\t+ '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n\t\t\t.replace('comment', _comment)\n\t\t\t.replace(/tag/g, '(?!(?:'\n\t\t\t\t+ 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n\t\t\t\t+ '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n\t\t\t\t+ '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n\t\t\t.getRegex(),\n\t\tdef: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n\t\theading: /^(#{1,6})(.*)(?:\\n+|$)/,\n\t\tfences: noopTest, // fences not supported\n\t\tlheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n\t\tparagraph: edit(_paragraph)\n\t\t\t.replace('hr', hr)\n\t\t\t.replace('heading', ' *#{1,6} *[^\\n]')\n\t\t\t.replace('lheading', lheading)\n\t\t\t.replace('|table', '')\n\t\t\t.replace('blockquote', ' {0,3}>')\n\t\t\t.replace('|fences', '')\n\t\t\t.replace('|list', '')\n\t\t\t.replace('|html', '')\n\t\t\t.replace('|tag', '')\n\t\t\t.getRegex(),\n\t};\n\t/**\n\t * Inline-Level Grammar\n\t */\n\tconst escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\n\tconst inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\n\tconst br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\n\tconst inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n\t// list of unicode punctuation marks, plus any missing characters from CommonMark spec\n\tconst _punctuation = '\\\\p{P}\\\\p{S}';\n\tconst punctuation = edit(/^((?![*_])[\\spunctuation])/, 'u')\n\t\t.replace(/punctuation/g, _punctuation).getRegex();\n\t// sequences em should skip over [title](link), `code`, <html>\n\tconst blockSkip = /\\[[^[\\]]*?\\]\\([^\\(\\)]*?\\)|`[^`]*?`|<[^<>]*?>/g;\n\tconst emStrongLDelim = edit(/^(?:\\*+(?:((?!\\*)[punct])|[^\\s*]))|^_+(?:((?!_)[punct])|([^\\s_]))/, 'u')\n\t\t.replace(/punct/g, _punctuation)\n\t\t.getRegex();\n\tconst emStrongRDelimAst = edit('^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)' // Skip orphan inside strong\n\t\t+ '|[^*]+(?=[^*])' // Consume to delim\n\t\t+ '|(?!\\\\*)[punct](\\\\*+)(?=[\\\\s]|$)' // (1) #*** can only be a Right Delimiter\n\t\t+ '|[^punct\\\\s](\\\\*+)(?!\\\\*)(?=[punct\\\\s]|$)' // (2) a***#, a*** can only be a Right Delimiter\n\t\t+ '|(?!\\\\*)[punct\\\\s](\\\\*+)(?=[^punct\\\\s])' // (3) #***a, ***a can only be Left Delimiter\n\t\t+ '|[\\\\s](\\\\*+)(?!\\\\*)(?=[punct])' // (4) ***# can only be Left Delimiter\n\t\t+ '|(?!\\\\*)[punct](\\\\*+)(?!\\\\*)(?=[punct])' // (5) #***# can be either Left or Right Delimiter\n\t\t+ '|[^punct\\\\s](\\\\*+)(?=[^punct\\\\s])', 'gu') // (6) a***a can be either Left or Right Delimiter\n\t\t.replace(/punct/g, _punctuation)\n\t\t.getRegex();\n\t// (6) Not allowed for _\n\tconst emStrongRDelimUnd = edit('^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)' // Skip orphan inside strong\n\t\t+ '|[^_]+(?=[^_])' // Consume to delim\n\t\t+ '|(?!_)[punct](_+)(?=[\\\\s]|$)' // (1) #___ can only be a Right Delimiter\n\t\t+ '|[^punct\\\\s](_+)(?!_)(?=[punct\\\\s]|$)' // (2) a___#, a___ can only be a Right Delimiter\n\t\t+ '|(?!_)[punct\\\\s](_+)(?=[^punct\\\\s])' // (3) #___a, ___a can only be Left Delimiter\n\t\t+ '|[\\\\s](_+)(?!_)(?=[punct])' // (4) ___# can only be Left Delimiter\n\t\t+ '|(?!_)[punct](_+)(?!_)(?=[punct])', 'gu') // (5) #___# can be either Left or Right Delimiter\n\t\t.replace(/punct/g, _punctuation)\n\t\t.getRegex();\n\tconst anyPunctuation = edit(/\\\\([punct])/, 'gu')\n\t\t.replace(/punct/g, _punctuation)\n\t\t.getRegex();\n\tconst autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/)\n\t\t.replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)\n\t\t.replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)\n\t\t.getRegex();\n\tconst _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\n\tconst tag = edit('^comment'\n\t\t+ '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n\t\t+ '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n\t\t+ '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n\t\t+ '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n\t\t+ '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>') // CDATA section\n\t\t.replace('comment', _inlineComment)\n\t\t.replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/)\n\t\t.getRegex();\n\tconst _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n\tconst link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/)\n\t\t.replace('label', _inlineLabel)\n\t\t.replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/)\n\t\t.replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/)\n\t\t.getRegex();\n\tconst reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/)\n\t\t.replace('label', _inlineLabel)\n\t\t.replace('ref', _blockLabel)\n\t\t.getRegex();\n\tconst nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/)\n\t\t.replace('ref', _blockLabel)\n\t\t.getRegex();\n\tconst reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g')\n\t\t.replace('reflink', reflink)\n\t\t.replace('nolink', nolink)\n\t\t.getRegex();\n\t/**\n\t * Normal Inline Grammar\n\t */\n\tconst inlineNormal = {\n\t\t_backpedal: noopTest, // only used for GFM url\n\t\tanyPunctuation,\n\t\tautolink,\n\t\tblockSkip,\n\t\tbr,\n\t\tcode: inlineCode,\n\t\tdel: noopTest,\n\t\temStrongLDelim,\n\t\temStrongRDelimAst,\n\t\temStrongRDelimUnd,\n\t\tescape,\n\t\tlink,\n\t\tnolink,\n\t\tpunctuation,\n\t\treflink,\n\t\treflinkSearch,\n\t\ttag,\n\t\ttext: inlineText,\n\t\turl: noopTest,\n\t};\n\t/**\n\t * Pedantic Inline Grammar\n\t */\n\tconst inlinePedantic = {\n\t\t...inlineNormal,\n\t\tlink: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n\t\t\t.replace('label', _inlineLabel)\n\t\t\t.getRegex(),\n\t\treflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n\t\t\t.replace('label', _inlineLabel)\n\t\t\t.getRegex(),\n\t};\n\t/**\n\t * GFM Inline Grammar\n\t */\n\tconst inlineGfm = {\n\t\t...inlineNormal,\n\t\tescape: edit(escape).replace('])', '~|])').getRegex(),\n\t\turl: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, 'i')\n\t\t\t.replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)\n\t\t\t.getRegex(),\n\t\t_backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n\t\tdel: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n\t\ttext: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/,\n\t};\n\t/**\n\t * GFM + Line Breaks Inline Grammar\n\t */\n\tconst inlineBreaks = {\n\t\t...inlineGfm,\n\t\tbr: edit(br).replace('{2,}', '*').getRegex(),\n\t\ttext: edit(inlineGfm.text)\n\t\t\t.replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n\t\t\t.replace(/\\{2,\\}/g, '*')\n\t\t\t.getRegex(),\n\t};\n\t/**\n\t * exports\n\t */\n\tconst block = {\n\t\tnormal: blockNormal,\n\t\tgfm: blockGfm,\n\t\tpedantic: blockPedantic,\n\t};\n\tconst inline = {\n\t\tnormal: inlineNormal,\n\t\tgfm: inlineGfm,\n\t\tbreaks: inlineBreaks,\n\t\tpedantic: inlinePedantic,\n\t};\n\n\t/**\n\t * Block Lexer\n\t */\n\tclass _Lexer {\n\t\ttokens;\n\t\toptions;\n\t\tstate;\n\t\ttokenizer;\n\t\tinlineQueue;\n\t\tconstructor(options) {\n\t\t\t// TokenList cannot be created in one go\n\t\t\tthis.tokens = [];\n\t\t\tthis.tokens.links = Object.create(null);\n\t\t\tthis.options = options || exports.defaults;\n\t\t\tthis.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n\t\t\tthis.tokenizer = this.options.tokenizer;\n\t\t\tthis.tokenizer.options = this.options;\n\t\t\tthis.tokenizer.lexer = this;\n\t\t\tthis.inlineQueue = [];\n\t\t\tthis.state = {\n\t\t\t\tinLink: false,\n\t\t\t\tinRawBlock: false,\n\t\t\t\ttop: true,\n\t\t\t};\n\t\t\tconst rules = {\n\t\t\t\tblock: block.normal,\n\t\t\t\tinline: inline.normal,\n\t\t\t};\n\t\t\tif (this.options.pedantic) {\n\t\t\t\trules.block = block.pedantic;\n\t\t\t\trules.inline = inline.pedantic;\n\t\t\t}\n\t\t\telse if (this.options.gfm) {\n\t\t\t\trules.block = block.gfm;\n\t\t\t\tif (this.options.breaks) {\n\t\t\t\t\trules.inline = inline.breaks;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trules.inline = inline.gfm;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.tokenizer.rules = rules;\n\t\t}\n\t\t/**\n\t\t * Expose Rules\n\t\t */\n\t\tstatic get rules() {\n\t\t\treturn {\n\t\t\t\tblock,\n\t\t\t\tinline,\n\t\t\t};\n\t\t}\n\t\t/**\n\t\t * Static Lex Method\n\t\t */\n\t\tstatic lex(src, options) {\n\t\t\tconst lexer = new _Lexer(options);\n\t\t\treturn lexer.lex(src);\n\t\t}\n\t\t/**\n\t\t * Static Lex Inline Method\n\t\t */\n\t\tstatic lexInline(src, options) {\n\t\t\tconst lexer = new _Lexer(options);\n\t\t\treturn lexer.inlineTokens(src);\n\t\t}\n\t\t/**\n\t\t * Preprocessing\n\t\t */\n\t\tlex(src) {\n\t\t\tsrc = src\n\t\t\t\t.replace(/\\r\\n|\\r/g, '\\n');\n\t\t\tthis.blockTokens(src, this.tokens);\n\t\t\tfor (let i = 0; i < this.inlineQueue.length; i++) {\n\t\t\t\tconst next = this.inlineQueue[i];\n\t\t\t\tthis.inlineTokens(next.src, next.tokens);\n\t\t\t}\n\t\t\tthis.inlineQueue = [];\n\t\t\treturn this.tokens;\n\t\t}\n\t\tblockTokens(src, tokens = [], lastParagraphClipped = false) {\n\t\t\tif (this.options.pedantic) {\n\t\t\t\tsrc = src.replace(/\\t/g, '    ').replace(/^ +$/gm, '');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsrc = src.replace(/^( *)(\\t+)/gm, (_, leading, tabs) => {\n\t\t\t\t\treturn leading + '    '.repeat(tabs.length);\n\t\t\t\t});\n\t\t\t}\n\t\t\tlet token;\n\t\t\tlet lastToken;\n\t\t\tlet cutSrc;\n\t\t\twhile (src) {\n\t\t\t\tif (this.options.extensions\n\t\t\t\t\t&& this.options.extensions.block\n\t\t\t\t\t&& this.options.extensions.block.some((extTokenizer) => {\n\t\t\t\t\t\tif (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n\t\t\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t})) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// newline\n\t\t\t\tif (token = this.tokenizer.space(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\tif (token.raw.length === 1 && tokens.length > 0) {\n\t\t\t\t\t\t// if there's a single \\n as a spacer, it's terminating the last line,\n\t\t\t\t\t\t// so move it there so that we don't get unnecessary paragraph tags\n\t\t\t\t\t\ttokens[tokens.length - 1].raw += '\\n';\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// code\n\t\t\t\tif (token = this.tokenizer.code(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\tlastToken = tokens[tokens.length - 1];\n\t\t\t\t\t// An indented code block cannot interrupt a paragraph.\n\t\t\t\t\tif (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n\t\t\t\t\t\tlastToken.raw += '\\n' + token.raw;\n\t\t\t\t\t\tlastToken.text += '\\n' + token.text;\n\t\t\t\t\t\tthis.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// fences\n\t\t\t\tif (token = this.tokenizer.fences(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// heading\n\t\t\t\tif (token = this.tokenizer.heading(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// hr\n\t\t\t\tif (token = this.tokenizer.hr(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// blockquote\n\t\t\t\tif (token = this.tokenizer.blockquote(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// list\n\t\t\t\tif (token = this.tokenizer.list(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// html\n\t\t\t\tif (token = this.tokenizer.html(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// def\n\t\t\t\tif (token = this.tokenizer.def(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\tlastToken = tokens[tokens.length - 1];\n\t\t\t\t\tif (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n\t\t\t\t\t\tlastToken.raw += '\\n' + token.raw;\n\t\t\t\t\t\tlastToken.text += '\\n' + token.raw;\n\t\t\t\t\t\tthis.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!this.tokens.links[token.tag]) {\n\t\t\t\t\t\tthis.tokens.links[token.tag] = {\n\t\t\t\t\t\t\thref: token.href,\n\t\t\t\t\t\t\ttitle: token.title,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// table (gfm)\n\t\t\t\tif (token = this.tokenizer.table(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// lheading\n\t\t\t\tif (token = this.tokenizer.lheading(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// top-level paragraph\n\t\t\t\t// prevent paragraph consuming extensions by clipping 'src' to extension start\n\t\t\t\tcutSrc = src;\n\t\t\t\tif (this.options.extensions && this.options.extensions.startBlock) {\n\t\t\t\t\tlet startIndex = Infinity;\n\t\t\t\t\tconst tempSrc = src.slice(1);\n\t\t\t\t\tlet tempStart;\n\t\t\t\t\tthis.options.extensions.startBlock.forEach((getStartIndex) => {\n\t\t\t\t\t\ttempStart = getStartIndex.call({ lexer: this }, tempSrc);\n\t\t\t\t\t\tif (typeof tempStart === 'number' && tempStart >= 0) {\n\t\t\t\t\t\t\tstartIndex = Math.min(startIndex, tempStart);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif (startIndex < Infinity && startIndex >= 0) {\n\t\t\t\t\t\tcutSrc = src.substring(0, startIndex + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n\t\t\t\t\tlastToken = tokens[tokens.length - 1];\n\t\t\t\t\tif (lastParagraphClipped && lastToken?.type === 'paragraph') {\n\t\t\t\t\t\tlastToken.raw += '\\n' + token.raw;\n\t\t\t\t\t\tlastToken.text += '\\n' + token.text;\n\t\t\t\t\t\tthis.inlineQueue.pop();\n\t\t\t\t\t\tthis.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t}\n\t\t\t\t\tlastParagraphClipped = (cutSrc.length !== src.length);\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// text\n\t\t\t\tif (token = this.tokenizer.text(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\tlastToken = tokens[tokens.length - 1];\n\t\t\t\t\tif (lastToken && lastToken.type === 'text') {\n\t\t\t\t\t\tlastToken.raw += '\\n' + token.raw;\n\t\t\t\t\t\tlastToken.text += '\\n' + token.text;\n\t\t\t\t\t\tthis.inlineQueue.pop();\n\t\t\t\t\t\tthis.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (src) {\n\t\t\t\t\tconst errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n\t\t\t\t\tif (this.options.silent) {\n\t\t\t\t\t\tconsole.error(errMsg);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new Error(errMsg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.state.top = true;\n\t\t\treturn tokens;\n\t\t}\n\t\tinline(src, tokens = []) {\n\t\t\tthis.inlineQueue.push({ src, tokens });\n\t\t\treturn tokens;\n\t\t}\n\t\t/**\n\t\t * Lexing/Compiling\n\t\t */\n\t\tinlineTokens(src, tokens = []) {\n\t\t\tlet token, lastToken, cutSrc;\n\t\t\t// String with links masked to avoid interference with em and strong\n\t\t\tlet maskedSrc = src;\n\t\t\tlet match;\n\t\t\tlet keepPrevChar, prevChar;\n\t\t\t// Mask out reflinks\n\t\t\tif (this.tokens.links) {\n\t\t\t\tconst links = Object.keys(this.tokens.links);\n\t\t\t\tif (links.length > 0) {\n\t\t\t\t\twhile ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n\t\t\t\t\t\tif (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n\t\t\t\t\t\t\tmaskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Mask out other blocks\n\t\t\twhile ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n\t\t\t\tmaskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n\t\t\t}\n\t\t\t// Mask out escaped characters\n\t\t\twhile ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n\t\t\t\tmaskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n\t\t\t}\n\t\t\twhile (src) {\n\t\t\t\tif (!keepPrevChar) {\n\t\t\t\t\tprevChar = '';\n\t\t\t\t}\n\t\t\t\tkeepPrevChar = false;\n\t\t\t\t// extensions\n\t\t\t\tif (this.options.extensions\n\t\t\t\t\t&& this.options.extensions.inline\n\t\t\t\t\t&& this.options.extensions.inline.some((extTokenizer) => {\n\t\t\t\t\t\tif (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n\t\t\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t})) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// escape\n\t\t\t\tif (token = this.tokenizer.escape(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// tag\n\t\t\t\tif (token = this.tokenizer.tag(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\tlastToken = tokens[tokens.length - 1];\n\t\t\t\t\tif (lastToken && token.type === 'text' && lastToken.type === 'text') {\n\t\t\t\t\t\tlastToken.raw += token.raw;\n\t\t\t\t\t\tlastToken.text += token.text;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// link\n\t\t\t\tif (token = this.tokenizer.link(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// reflink, nolink\n\t\t\t\tif (token = this.tokenizer.reflink(src, this.tokens.links)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\tlastToken = tokens[tokens.length - 1];\n\t\t\t\t\tif (lastToken && token.type === 'text' && lastToken.type === 'text') {\n\t\t\t\t\t\tlastToken.raw += token.raw;\n\t\t\t\t\t\tlastToken.text += token.text;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// em & strong\n\t\t\t\tif (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// code\n\t\t\t\tif (token = this.tokenizer.codespan(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// br\n\t\t\t\tif (token = this.tokenizer.br(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// del (gfm)\n\t\t\t\tif (token = this.tokenizer.del(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// autolink\n\t\t\t\tif (token = this.tokenizer.autolink(src)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// url (gfm)\n\t\t\t\tif (!this.state.inLink && (token = this.tokenizer.url(src))) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\ttokens.push(token);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// text\n\t\t\t\t// prevent inlineText consuming extensions by clipping 'src' to extension start\n\t\t\t\tcutSrc = src;\n\t\t\t\tif (this.options.extensions && this.options.extensions.startInline) {\n\t\t\t\t\tlet startIndex = Infinity;\n\t\t\t\t\tconst tempSrc = src.slice(1);\n\t\t\t\t\tlet tempStart;\n\t\t\t\t\tthis.options.extensions.startInline.forEach((getStartIndex) => {\n\t\t\t\t\t\ttempStart = getStartIndex.call({ lexer: this }, tempSrc);\n\t\t\t\t\t\tif (typeof tempStart === 'number' && tempStart >= 0) {\n\t\t\t\t\t\t\tstartIndex = Math.min(startIndex, tempStart);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif (startIndex < Infinity && startIndex >= 0) {\n\t\t\t\t\t\tcutSrc = src.substring(0, startIndex + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (token = this.tokenizer.inlineText(cutSrc)) {\n\t\t\t\t\tsrc = src.substring(token.raw.length);\n\t\t\t\t\tif (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n\t\t\t\t\t\tprevChar = token.raw.slice(-1);\n\t\t\t\t\t}\n\t\t\t\t\tkeepPrevChar = true;\n\t\t\t\t\tlastToken = tokens[tokens.length - 1];\n\t\t\t\t\tif (lastToken && lastToken.type === 'text') {\n\t\t\t\t\t\tlastToken.raw += token.raw;\n\t\t\t\t\t\tlastToken.text += token.text;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (src) {\n\t\t\t\t\tconst errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n\t\t\t\t\tif (this.options.silent) {\n\t\t\t\t\t\tconsole.error(errMsg);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new Error(errMsg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokens;\n\t\t}\n\t}\n\n\t/**\n\t * Renderer\n\t */\n\tclass _Renderer {\n\t\toptions;\n\t\tparser; // set by the parser\n\t\tconstructor(options) {\n\t\t\tthis.options = options || exports.defaults;\n\t\t}\n\t\tspace(token) {\n\t\t\treturn '';\n\t\t}\n\t\tcode({ text, lang, escaped }) {\n\t\t\tconst langString = (lang || '').match(/^\\S*/)?.[0];\n\t\t\tconst code = text.replace(/\\n$/, '') + '\\n';\n\t\t\tif (!langString) {\n\t\t\t\treturn '<pre><code>'\n\t\t\t\t\t+ (escaped ? code : escape$1(code, true))\n\t\t\t\t\t+ '</code></pre>\\n';\n\t\t\t}\n\t\t\treturn '<pre><code class=\"language-'\n\t\t\t\t+ escape$1(langString)\n\t\t\t\t+ '\">'\n\t\t\t\t+ (escaped ? code : escape$1(code, true))\n\t\t\t\t+ '</code></pre>\\n';\n\t\t}\n\t\tblockquote({ tokens }) {\n\t\t\tconst body = this.parser.parse(tokens);\n\t\t\treturn `<blockquote>\\n${body}</blockquote>\\n`;\n\t\t}\n\t\thtml({ text }) {\n\t\t\treturn text;\n\t\t}\n\t\theading({ tokens, depth }) {\n\t\t\treturn `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\\n`;\n\t\t}\n\t\thr(token) {\n\t\t\treturn '<hr>\\n';\n\t\t}\n\t\tlist(token) {\n\t\t\tconst ordered = token.ordered;\n\t\t\tconst start = token.start;\n\t\t\tlet body = '';\n\t\t\tfor (let j = 0; j < token.items.length; j++) {\n\t\t\t\tconst item = token.items[j];\n\t\t\t\tbody += this.listitem(item);\n\t\t\t}\n\t\t\tconst type = ordered ? 'ol' : 'ul';\n\t\t\tconst startAttr = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n\t\t\treturn '<' + type + startAttr + '>\\n' + body + '</' + type + '>\\n';\n\t\t}\n\t\tlistitem(item) {\n\t\t\tlet itemBody = '';\n\t\t\tif (item.task) {\n\t\t\t\tconst checkbox = this.checkbox({ checked: !!item.checked });\n\t\t\t\tif (item.loose) {\n\t\t\t\t\tif (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {\n\t\t\t\t\t\titem.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n\t\t\t\t\t\tif (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n\t\t\t\t\t\t\titem.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\titem.tokens.unshift({\n\t\t\t\t\t\t\ttype: 'text',\n\t\t\t\t\t\t\traw: checkbox + ' ',\n\t\t\t\t\t\t\ttext: checkbox + ' ',\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\titemBody += checkbox + ' ';\n\t\t\t\t}\n\t\t\t}\n\t\t\titemBody += this.parser.parse(item.tokens, !!item.loose);\n\t\t\treturn `<li>${itemBody}</li>\\n`;\n\t\t}\n\t\tcheckbox({ checked }) {\n\t\t\treturn '<input '\n\t\t\t\t+ (checked ? 'checked=\"\" ' : '')\n\t\t\t\t+ 'disabled=\"\" type=\"checkbox\">';\n\t\t}\n\t\tparagraph({ tokens }) {\n\t\t\treturn `<p>${this.parser.parseInline(tokens)}</p>\\n`;\n\t\t}\n\t\ttable(token) {\n\t\t\tlet header = '';\n\t\t\t// header\n\t\t\tlet cell = '';\n\t\t\tfor (let j = 0; j < token.header.length; j++) {\n\t\t\t\tcell += this.tablecell(token.header[j]);\n\t\t\t}\n\t\t\theader += this.tablerow({ text: cell });\n\t\t\tlet body = '';\n\t\t\tfor (let j = 0; j < token.rows.length; j++) {\n\t\t\t\tconst row = token.rows[j];\n\t\t\t\tcell = '';\n\t\t\t\tfor (let k = 0; k < row.length; k++) {\n\t\t\t\t\tcell += this.tablecell(row[k]);\n\t\t\t\t}\n\t\t\t\tbody += this.tablerow({ text: cell });\n\t\t\t}\n\t\t\tif (body)\n\t\t\t\tbody = `<tbody>${body}</tbody>`;\n\t\t\treturn '<table>\\n'\n\t\t\t\t+ '<thead>\\n'\n\t\t\t\t+ header\n\t\t\t\t+ '</thead>\\n'\n\t\t\t\t+ body\n\t\t\t\t+ '</table>\\n';\n\t\t}\n\t\ttablerow({ text }) {\n\t\t\treturn `<tr>\\n${text}</tr>\\n`;\n\t\t}\n\t\ttablecell(token) {\n\t\t\tconst content = this.parser.parseInline(token.tokens);\n\t\t\tconst type = token.header ? 'th' : 'td';\n\t\t\tconst tag = token.align\n\t\t\t\t? `<${type} align=\"${token.align}\">`\n\t\t\t\t: `<${type}>`;\n\t\t\treturn tag + content + `</${type}>\\n`;\n\t\t}\n\t\t/**\n\t\t * span level renderer\n\t\t */\n\t\tstrong({ tokens }) {\n\t\t\treturn `<strong>${this.parser.parseInline(tokens)}</strong>`;\n\t\t}\n\t\tem({ tokens }) {\n\t\t\treturn `<em>${this.parser.parseInline(tokens)}</em>`;\n\t\t}\n\t\tcodespan({ text }) {\n\t\t\treturn `<code>${text}</code>`;\n\t\t}\n\t\tbr(token) {\n\t\t\treturn '<br>';\n\t\t}\n\t\tdel({ tokens }) {\n\t\t\treturn `<del>${this.parser.parseInline(tokens)}</del>`;\n\t\t}\n\t\tlink({ href, title, tokens }) {\n\t\t\tconst text = this.parser.parseInline(tokens);\n\t\t\tconst cleanHref = cleanUrl(href);\n\t\t\tif (cleanHref === null) {\n\t\t\t\treturn text;\n\t\t\t}\n\t\t\thref = cleanHref;\n\t\t\tlet out = '<a href=\"' + href + '\"';\n\t\t\tif (title) {\n\t\t\t\tout += ' title=\"' + title + '\"';\n\t\t\t}\n\t\t\tout += '>' + text + '</a>';\n\t\t\treturn out;\n\t\t}\n\t\timage({ href, title, text }) {\n\t\t\tconst cleanHref = cleanUrl(href);\n\t\t\tif (cleanHref === null) {\n\t\t\t\treturn text;\n\t\t\t}\n\t\t\thref = cleanHref;\n\t\t\tlet out = `<img src=\"${href}\" alt=\"${text}\"`;\n\t\t\tif (title) {\n\t\t\t\tout += ` title=\"${title}\"`;\n\t\t\t}\n\t\t\tout += '>';\n\t\t\treturn out;\n\t\t}\n\t\ttext(token) {\n\t\t\treturn 'tokens' in token && token.tokens ? this.parser.parseInline(token.tokens) : token.text;\n\t\t}\n\t}\n\n\t/**\n\t * TextRenderer\n\t * returns only the textual part of the token\n\t */\n\tclass _TextRenderer {\n\t\t// no need for block level renderers\n\t\tstrong({ text }) {\n\t\t\treturn text;\n\t\t}\n\t\tem({ text }) {\n\t\t\treturn text;\n\t\t}\n\t\tcodespan({ text }) {\n\t\t\treturn text;\n\t\t}\n\t\tdel({ text }) {\n\t\t\treturn text;\n\t\t}\n\t\thtml({ text }) {\n\t\t\treturn text;\n\t\t}\n\t\ttext({ text }) {\n\t\t\treturn text;\n\t\t}\n\t\tlink({ text }) {\n\t\t\treturn '' + text;\n\t\t}\n\t\timage({ text }) {\n\t\t\treturn '' + text;\n\t\t}\n\t\tbr() {\n\t\t\treturn '';\n\t\t}\n\t}\n\n\t/**\n\t * Parsing & Compiling\n\t */\n\tclass _Parser {\n\t\toptions;\n\t\trenderer;\n\t\ttextRenderer;\n\t\tconstructor(options) {\n\t\t\tthis.options = options || exports.defaults;\n\t\t\tthis.options.renderer = this.options.renderer || new _Renderer();\n\t\t\tthis.renderer = this.options.renderer;\n\t\t\tthis.renderer.options = this.options;\n\t\t\tthis.renderer.parser = this;\n\t\t\tthis.textRenderer = new _TextRenderer();\n\t\t}\n\t\t/**\n\t\t * Static Parse Method\n\t\t */\n\t\tstatic parse(tokens, options) {\n\t\t\tconst parser = new _Parser(options);\n\t\t\treturn parser.parse(tokens);\n\t\t}\n\t\t/**\n\t\t * Static Parse Inline Method\n\t\t */\n\t\tstatic parseInline(tokens, options) {\n\t\t\tconst parser = new _Parser(options);\n\t\t\treturn parser.parseInline(tokens);\n\t\t}\n\t\t/**\n\t\t * Parse Loop\n\t\t */\n\t\tparse(tokens, top = true) {\n\t\t\tlet out = '';\n\t\t\tfor (let i = 0; i < tokens.length; i++) {\n\t\t\t\tconst anyToken = tokens[i];\n\t\t\t\t// Run any renderer extensions\n\t\t\t\tif (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {\n\t\t\t\t\tconst genericToken = anyToken;\n\t\t\t\t\tconst ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);\n\t\t\t\t\tif (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {\n\t\t\t\t\t\tout += ret || '';\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst token = anyToken;\n\t\t\t\tswitch (token.type) {\n\t\t\t\t\tcase 'space': {\n\t\t\t\t\t\tout += this.renderer.space(token);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'hr': {\n\t\t\t\t\t\tout += this.renderer.hr(token);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'heading': {\n\t\t\t\t\t\tout += this.renderer.heading(token);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'code': {\n\t\t\t\t\t\tout += this.renderer.code(token);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'table': {\n\t\t\t\t\t\tout += this.renderer.table(token);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'blockquote': {\n\t\t\t\t\t\tout += this.renderer.blockquote(token);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'list': {\n\t\t\t\t\t\tout += this.renderer.list(token);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'html': {\n\t\t\t\t\t\tout += this.renderer.html(token);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'paragraph': {\n\t\t\t\t\t\tout += this.renderer.paragraph(token);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'text': {\n\t\t\t\t\t\tlet textToken = token;\n\t\t\t\t\t\tlet body = this.renderer.text(textToken);\n\t\t\t\t\t\twhile (i + 1 < tokens.length && tokens[i + 1].type === 'text') {\n\t\t\t\t\t\t\ttextToken = tokens[++i];\n\t\t\t\t\t\t\tbody += '\\n' + this.renderer.text(textToken);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (top) {\n\t\t\t\t\t\t\tout += this.renderer.paragraph({\n\t\t\t\t\t\t\t\ttype: 'paragraph',\n\t\t\t\t\t\t\t\traw: body,\n\t\t\t\t\t\t\t\ttext: body,\n\t\t\t\t\t\t\t\ttokens: [{ type: 'text', raw: body, text: body }],\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tout += body;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tconst errMsg = 'Token with \"' + token.type + '\" type was not found.';\n\t\t\t\t\t\tif (this.options.silent) {\n\t\t\t\t\t\t\tconsole.error(errMsg);\n\t\t\t\t\t\t\treturn '';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new Error(errMsg);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t}\n\t\t/**\n\t\t * Parse Inline Tokens\n\t\t */\n\t\tparseInline(tokens, renderer) {\n\t\t\trenderer = renderer || this.renderer;\n\t\t\tlet out = '';\n\t\t\tfor (let i = 0; i < tokens.length; i++) {\n\t\t\t\tconst anyToken = tokens[i];\n\t\t\t\t// Run any renderer extensions\n\t\t\t\tif (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {\n\t\t\t\t\tconst ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);\n\t\t\t\t\tif (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(anyToken.type)) {\n\t\t\t\t\t\tout += ret || '';\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst token = anyToken;\n\t\t\t\tswitch (token.type) {\n\t\t\t\t\tcase 'escape': {\n\t\t\t\t\t\tout += renderer.text(token);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'html': {\n\t\t\t\t\t\tout += renderer.html(token);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'link': {\n\t\t\t\t\t\tout += renderer.link(token);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'image': {\n\t\t\t\t\t\tout += renderer.image(token);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'strong': {\n\t\t\t\t\t\tout += renderer.strong(token);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'em': {\n\t\t\t\t\t\tout += renderer.em(token);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'codespan': {\n\t\t\t\t\t\tout += renderer.codespan(token);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'br': {\n\t\t\t\t\t\tout += renderer.br(token);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'del': {\n\t\t\t\t\t\tout += renderer.del(token);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'text': {\n\t\t\t\t\t\tout += renderer.text(token);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tconst errMsg = 'Token with \"' + token.type + '\" type was not found.';\n\t\t\t\t\t\tif (this.options.silent) {\n\t\t\t\t\t\t\tconsole.error(errMsg);\n\t\t\t\t\t\t\treturn '';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new Error(errMsg);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t}\n\t}\n\n\tclass _Hooks {\n\t\toptions;\n\t\tconstructor(options) {\n\t\t\tthis.options = options || exports.defaults;\n\t\t}\n\t\tstatic passThroughHooks = new Set([\n\t\t\t'preprocess',\n\t\t\t'postprocess',\n\t\t\t'processAllTokens',\n\t\t]);\n\t\t/**\n\t\t * Process markdown before marked\n\t\t */\n\t\tpreprocess(markdown) {\n\t\t\treturn markdown;\n\t\t}\n\t\t/**\n\t\t * Process HTML after marked is finished\n\t\t */\n\t\tpostprocess(html) {\n\t\t\treturn html;\n\t\t}\n\t\t/**\n\t\t * Process all tokens before walk tokens\n\t\t */\n\t\tprocessAllTokens(tokens) {\n\t\t\treturn tokens;\n\t\t}\n\t}\n\n\tclass Marked {\n\t\tdefaults = _getDefaults();\n\t\toptions = this.setOptions;\n\t\tparse = this.parseMarkdown(_Lexer.lex, _Parser.parse);\n\t\tparseInline = this.parseMarkdown(_Lexer.lexInline, _Parser.parseInline);\n\t\tParser = _Parser;\n\t\tRenderer = _Renderer;\n\t\tTextRenderer = _TextRenderer;\n\t\tLexer = _Lexer;\n\t\tTokenizer = _Tokenizer;\n\t\tHooks = _Hooks;\n\t\tconstructor(...args) {\n\t\t\tthis.use(...args);\n\t\t}\n\t\t/**\n\t\t * Run callback for every token\n\t\t */\n\t\twalkTokens(tokens, callback) {\n\t\t\tlet values = [];\n\t\t\tfor (const token of tokens) {\n\t\t\t\tvalues = values.concat(callback.call(this, token));\n\t\t\t\tswitch (token.type) {\n\t\t\t\t\tcase 'table': {\n\t\t\t\t\t\tconst tableToken = token;\n\t\t\t\t\t\tfor (const cell of tableToken.header) {\n\t\t\t\t\t\t\tvalues = values.concat(this.walkTokens(cell.tokens, callback));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const row of tableToken.rows) {\n\t\t\t\t\t\t\tfor (const cell of row) {\n\t\t\t\t\t\t\t\tvalues = values.concat(this.walkTokens(cell.tokens, callback));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'list': {\n\t\t\t\t\t\tconst listToken = token;\n\t\t\t\t\t\tvalues = values.concat(this.walkTokens(listToken.items, callback));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tconst genericToken = token;\n\t\t\t\t\t\tif (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n\t\t\t\t\t\t\tthis.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {\n\t\t\t\t\t\t\t\tconst tokens = genericToken[childTokens].flat(Infinity);\n\t\t\t\t\t\t\t\tvalues = values.concat(this.walkTokens(tokens, callback));\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (genericToken.tokens) {\n\t\t\t\t\t\t\tvalues = values.concat(this.walkTokens(genericToken.tokens, callback));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn values;\n\t\t}\n\t\tuse(...args) {\n\t\t\tconst extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };\n\t\t\targs.forEach((pack) => {\n\t\t\t\t// copy options to new object\n\t\t\t\tconst opts = { ...pack };\n\t\t\t\t// set async to true if it was set to true before\n\t\t\t\topts.async = this.defaults.async || opts.async || false;\n\t\t\t\t// ==-- Parse \"addon\" extensions --== //\n\t\t\t\tif (pack.extensions) {\n\t\t\t\t\tpack.extensions.forEach((ext) => {\n\t\t\t\t\t\tif (!ext.name) {\n\t\t\t\t\t\t\tthrow new Error('extension name required');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ('renderer' in ext) { // Renderer extensions\n\t\t\t\t\t\t\tconst prevRenderer = extensions.renderers[ext.name];\n\t\t\t\t\t\t\tif (prevRenderer) {\n\t\t\t\t\t\t\t\t// Replace extension with func to run new extension but fall back if false\n\t\t\t\t\t\t\t\textensions.renderers[ext.name] = function (...args) {\n\t\t\t\t\t\t\t\t\tlet ret = ext.renderer.apply(this, args);\n\t\t\t\t\t\t\t\t\tif (ret === false) {\n\t\t\t\t\t\t\t\t\t\tret = prevRenderer.apply(this, args);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\textensions.renderers[ext.name] = ext.renderer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ('tokenizer' in ext) { // Tokenizer Extensions\n\t\t\t\t\t\t\tif (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n\t\t\t\t\t\t\t\tthrow new Error(\"extension level must be 'block' or 'inline'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst extLevel = extensions[ext.level];\n\t\t\t\t\t\t\tif (extLevel) {\n\t\t\t\t\t\t\t\textLevel.unshift(ext.tokenizer);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\textensions[ext.level] = [ext.tokenizer];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (ext.start) { // Function to check for start of token\n\t\t\t\t\t\t\t\tif (ext.level === 'block') {\n\t\t\t\t\t\t\t\t\tif (extensions.startBlock) {\n\t\t\t\t\t\t\t\t\t\textensions.startBlock.push(ext.start);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\textensions.startBlock = [ext.start];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (ext.level === 'inline') {\n\t\t\t\t\t\t\t\t\tif (extensions.startInline) {\n\t\t\t\t\t\t\t\t\t\textensions.startInline.push(ext.start);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\textensions.startInline = [ext.start];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens\n\t\t\t\t\t\t\textensions.childTokens[ext.name] = ext.childTokens;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\topts.extensions = extensions;\n\t\t\t\t}\n\t\t\t\t// ==-- Parse \"overwrite\" extensions --== //\n\t\t\t\tif (pack.renderer) {\n\t\t\t\t\tconst renderer = this.defaults.renderer || new _Renderer(this.defaults);\n\t\t\t\t\tfor (const prop in pack.renderer) {\n\t\t\t\t\t\tif (!(prop in renderer)) {\n\t\t\t\t\t\t\tthrow new Error(`renderer '${prop}' does not exist`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (['options', 'parser'].includes(prop)) {\n\t\t\t\t\t\t\t// ignore options property\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst rendererProp = prop;\n\t\t\t\t\t\tconst rendererFunc = pack.renderer[rendererProp];\n\t\t\t\t\t\tconst prevRenderer = renderer[rendererProp];\n\t\t\t\t\t\t// Replace renderer with func to run extension, but fall back if false\n\t\t\t\t\t\trenderer[rendererProp] = (...args) => {\n\t\t\t\t\t\t\tlet ret = rendererFunc.apply(renderer, args);\n\t\t\t\t\t\t\tif (ret === false) {\n\t\t\t\t\t\t\t\tret = prevRenderer.apply(renderer, args);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn ret || '';\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\topts.renderer = renderer;\n\t\t\t\t}\n\t\t\t\tif (pack.tokenizer) {\n\t\t\t\t\tconst tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n\t\t\t\t\tfor (const prop in pack.tokenizer) {\n\t\t\t\t\t\tif (!(prop in tokenizer)) {\n\t\t\t\t\t\t\tthrow new Error(`tokenizer '${prop}' does not exist`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (['options', 'rules', 'lexer'].includes(prop)) {\n\t\t\t\t\t\t\t// ignore options, rules, and lexer properties\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst tokenizerProp = prop;\n\t\t\t\t\t\tconst tokenizerFunc = pack.tokenizer[tokenizerProp];\n\t\t\t\t\t\tconst prevTokenizer = tokenizer[tokenizerProp];\n\t\t\t\t\t\t// Replace tokenizer with func to run extension, but fall back if false\n\t\t\t\t\t\t// @ts-expect-error cannot type tokenizer function dynamically\n\t\t\t\t\t\ttokenizer[tokenizerProp] = (...args) => {\n\t\t\t\t\t\t\tlet ret = tokenizerFunc.apply(tokenizer, args);\n\t\t\t\t\t\t\tif (ret === false) {\n\t\t\t\t\t\t\t\tret = prevTokenizer.apply(tokenizer, args);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\topts.tokenizer = tokenizer;\n\t\t\t\t}\n\t\t\t\t// ==-- Parse Hooks extensions --== //\n\t\t\t\tif (pack.hooks) {\n\t\t\t\t\tconst hooks = this.defaults.hooks || new _Hooks();\n\t\t\t\t\tfor (const prop in pack.hooks) {\n\t\t\t\t\t\tif (!(prop in hooks)) {\n\t\t\t\t\t\t\tthrow new Error(`hook '${prop}' does not exist`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (prop === 'options') {\n\t\t\t\t\t\t\t// ignore options property\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst hooksProp = prop;\n\t\t\t\t\t\tconst hooksFunc = pack.hooks[hooksProp];\n\t\t\t\t\t\tconst prevHook = hooks[hooksProp];\n\t\t\t\t\t\tif (_Hooks.passThroughHooks.has(prop)) {\n\t\t\t\t\t\t\t// @ts-expect-error cannot type hook function dynamically\n\t\t\t\t\t\t\thooks[hooksProp] = (arg) => {\n\t\t\t\t\t\t\t\tif (this.defaults.async) {\n\t\t\t\t\t\t\t\t\treturn Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {\n\t\t\t\t\t\t\t\t\t\treturn prevHook.call(hooks, ret);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst ret = hooksFunc.call(hooks, arg);\n\t\t\t\t\t\t\t\treturn prevHook.call(hooks, ret);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// @ts-expect-error cannot type hook function dynamically\n\t\t\t\t\t\t\thooks[hooksProp] = (...args) => {\n\t\t\t\t\t\t\t\tlet ret = hooksFunc.apply(hooks, args);\n\t\t\t\t\t\t\t\tif (ret === false) {\n\t\t\t\t\t\t\t\t\tret = prevHook.apply(hooks, args);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\topts.hooks = hooks;\n\t\t\t\t}\n\t\t\t\t// ==-- Parse WalkTokens extensions --== //\n\t\t\t\tif (pack.walkTokens) {\n\t\t\t\t\tconst walkTokens = this.defaults.walkTokens;\n\t\t\t\t\tconst packWalktokens = pack.walkTokens;\n\t\t\t\t\topts.walkTokens = function (token) {\n\t\t\t\t\t\tlet values = [];\n\t\t\t\t\t\tvalues.push(packWalktokens.call(this, token));\n\t\t\t\t\t\tif (walkTokens) {\n\t\t\t\t\t\t\tvalues = values.concat(walkTokens.call(this, token));\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn values;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tthis.defaults = { ...this.defaults, ...opts };\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\t\tsetOptions(opt) {\n\t\t\tthis.defaults = { ...this.defaults, ...opt };\n\t\t\treturn this;\n\t\t}\n\t\tlexer(src, options) {\n\t\t\treturn _Lexer.lex(src, options ?? this.defaults);\n\t\t}\n\t\tparser(tokens, options) {\n\t\t\treturn _Parser.parse(tokens, options ?? this.defaults);\n\t\t}\n\t\tparseMarkdown(lexer, parser) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tconst parse = (src, options) => {\n\t\t\t\tconst origOpt = { ...options };\n\t\t\t\tconst opt = { ...this.defaults, ...origOpt };\n\t\t\t\tconst throwError = this.onError(!!opt.silent, !!opt.async);\n\t\t\t\t// throw error if an extension set async to true but parse was called with async: false\n\t\t\t\tif (this.defaults.async === true && origOpt.async === false) {\n\t\t\t\t\treturn throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));\n\t\t\t\t}\n\t\t\t\t// throw error in case of non string input\n\t\t\t\tif (typeof src === 'undefined' || src === null) {\n\t\t\t\t\treturn throwError(new Error('marked(): input parameter is undefined or null'));\n\t\t\t\t}\n\t\t\t\tif (typeof src !== 'string') {\n\t\t\t\t\treturn throwError(new Error('marked(): input parameter is of type '\n\t\t\t\t\t\t+ Object.prototype.toString.call(src) + ', string expected'));\n\t\t\t\t}\n\t\t\t\tif (opt.hooks) {\n\t\t\t\t\topt.hooks.options = opt;\n\t\t\t\t}\n\t\t\t\tif (opt.async) {\n\t\t\t\t\treturn Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)\n\t\t\t\t\t\t.then(src => lexer(src, opt))\n\t\t\t\t\t\t.then(tokens => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens)\n\t\t\t\t\t\t.then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens)\n\t\t\t\t\t\t.then(tokens => parser(tokens, opt))\n\t\t\t\t\t\t.then(html => opt.hooks ? opt.hooks.postprocess(html) : html)\n\t\t\t\t\t\t.catch(throwError);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tif (opt.hooks) {\n\t\t\t\t\t\tsrc = opt.hooks.preprocess(src);\n\t\t\t\t\t}\n\t\t\t\t\tlet tokens = lexer(src, opt);\n\t\t\t\t\tif (opt.hooks) {\n\t\t\t\t\t\ttokens = opt.hooks.processAllTokens(tokens);\n\t\t\t\t\t}\n\t\t\t\t\tif (opt.walkTokens) {\n\t\t\t\t\t\tthis.walkTokens(tokens, opt.walkTokens);\n\t\t\t\t\t}\n\t\t\t\t\tlet html = parser(tokens, opt);\n\t\t\t\t\tif (opt.hooks) {\n\t\t\t\t\t\thtml = opt.hooks.postprocess(html);\n\t\t\t\t\t}\n\t\t\t\t\treturn html;\n\t\t\t\t}\n\t\t\t\tcatch (e) {\n\t\t\t\t\treturn throwError(e);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn parse;\n\t\t}\n\t\tonError(silent, async) {\n\t\t\treturn (e) => {\n\t\t\t\te.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\t\t\t\tif (silent) {\n\t\t\t\t\tconst msg = '<p>An error occurred:</p><pre>'\n\t\t\t\t\t\t+ escape$1(e.message + '', true)\n\t\t\t\t\t\t+ '</pre>';\n\t\t\t\t\tif (async) {\n\t\t\t\t\t\treturn Promise.resolve(msg);\n\t\t\t\t\t}\n\t\t\t\t\treturn msg;\n\t\t\t\t}\n\t\t\t\tif (async) {\n\t\t\t\t\treturn Promise.reject(e);\n\t\t\t\t}\n\t\t\t\tthrow e;\n\t\t\t};\n\t\t}\n\t}\n\n\tconst markedInstance = new Marked();\n\tfunction marked(src, opt) {\n\t\treturn markedInstance.parse(src, opt);\n\t}\n\t/**\n\t * Sets the default options.\n\t *\n\t * @param options Hash of options\n\t */\n\tmarked.options =\n\t\tmarked.setOptions = function (options) {\n\t\t\tmarkedInstance.setOptions(options);\n\t\t\tmarked.defaults = markedInstance.defaults;\n\t\t\tchangeDefaults(marked.defaults);\n\t\t\treturn marked;\n\t\t};\n\t/**\n\t * Gets the original marked default options.\n\t */\n\tmarked.getDefaults = _getDefaults;\n\tmarked.defaults = exports.defaults;\n\t/**\n\t * Use Extension\n\t */\n\tmarked.use = function (...args) {\n\t\tmarkedInstance.use(...args);\n\t\tmarked.defaults = markedInstance.defaults;\n\t\tchangeDefaults(marked.defaults);\n\t\treturn marked;\n\t};\n\t/**\n\t * Run callback for every token\n\t */\n\tmarked.walkTokens = function (tokens, callback) {\n\t\treturn markedInstance.walkTokens(tokens, callback);\n\t};\n\t/**\n\t * Compiles markdown to HTML without enclosing `p` tag.\n\t *\n\t * @param src String of markdown source to be compiled\n\t * @param options Hash of options\n\t * @return String of compiled HTML\n\t */\n\tmarked.parseInline = markedInstance.parseInline;\n\t/**\n\t * Expose\n\t */\n\tmarked.Parser = _Parser;\n\tmarked.parser = _Parser.parse;\n\tmarked.Renderer = _Renderer;\n\tmarked.TextRenderer = _TextRenderer;\n\tmarked.Lexer = _Lexer;\n\tmarked.lexer = _Lexer.lex;\n\tmarked.Tokenizer = _Tokenizer;\n\tmarked.Hooks = _Hooks;\n\tmarked.parse = marked;\n\tconst options = marked.options;\n\tconst setOptions = marked.setOptions;\n\tconst use = marked.use;\n\tconst walkTokens = marked.walkTokens;\n\tconst parseInline = marked.parseInline;\n\tconst parse = marked;\n\tconst parser = _Parser.parse;\n\tconst lexer = _Lexer.lex;\n\n\texports.Hooks = _Hooks;\n\texports.Lexer = _Lexer;\n\texports.Marked = Marked;\n\texports.Parser = _Parser;\n\texports.Renderer = _Renderer;\n\texports.TextRenderer = _TextRenderer;\n\texports.Tokenizer = _Tokenizer;\n\texports.getDefaults = _getDefaults;\n\texports.lexer = lexer;\n\texports.marked = marked;\n\texports.options = options;\n\texports.parse = parse;\n\texports.parseInline = parseInline;\n\texports.parser = parser;\n\texports.setOptions = setOptions;\n\texports.use = use;\n\texports.walkTokens = walkTokens;\n}));\n\n// ESM-uncomment-begin\n})();\nexport var Hooks = (__marked_exports.Hooks || exports.Hooks);\nexport var Lexer = (__marked_exports.Lexer || exports.Lexer);\nexport var Marked = (__marked_exports.Marked || exports.Marked);\nexport var Parser = (__marked_exports.Parser || exports.Parser);\nexport var Renderer = (__marked_exports.Renderer || exports.Renderer);\nexport var TextRenderer = (__marked_exports.TextRenderer || exports.TextRenderer);\nexport var Tokenizer = (__marked_exports.Tokenizer || exports.Tokenizer);\nexport var defaults = (__marked_exports.defaults || exports.defaults);\nexport var getDefaults = (__marked_exports.getDefaults || exports.getDefaults);\nexport var lexer = (__marked_exports.lexer || exports.lexer);\nexport var marked = (__marked_exports.marked || exports.marked);\nexport var options = (__marked_exports.options || exports.options);\nexport var parse = (__marked_exports.parse || exports.parse);\nexport var parseInline = (__marked_exports.parseInline || exports.parseInline);\nexport var parser = (__marked_exports.parser || exports.parser);\nexport var setOptions = (__marked_exports.setOptions || exports.setOptions);\nexport var use = (__marked_exports.use || exports.use);\nexport var walkTokens = (__marked_exports.walkTokens || exports.walkTokens);\n// ESM-uncomment-end\n\n//# sourceMappingURL=marked.umd.js.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}