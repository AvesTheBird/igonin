{"ast":null,"code":"var _AbstractGotoSymbolQuickAccessProvider;\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar AbstractGotoSymbolQuickAccessProvider_1;\nimport { DeferredPromise } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Codicon } from '../../../../base/common/codicons.js';\nimport { ThemeIcon } from '../../../../base/common/themables.js';\nimport { pieceToQuery, prepareQuery, scoreFuzzy2 } from '../../../../base/common/fuzzyScorer.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { format, trim } from '../../../../base/common/strings.js';\nimport { Range } from '../../../common/core/range.js';\nimport { SymbolKinds, getAriaLabelForSymbol } from '../../../common/languages.js';\nimport { IOutlineModelService } from '../../documentSymbols/browser/outlineModel.js';\nimport { AbstractEditorNavigationQuickAccessProvider } from './editorNavigationQuickAccess.js';\nimport { localize } from '../../../../nls.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { findLast } from '../../../../base/common/arraysFind.js';\nlet AbstractGotoSymbolQuickAccessProvider = (_AbstractGotoSymbolQuickAccessProvider = class AbstractGotoSymbolQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {\n  constructor(_languageFeaturesService, _outlineModelService) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Object.create(null);\n    super(options);\n    this._languageFeaturesService = _languageFeaturesService;\n    this._outlineModelService = _outlineModelService;\n    this.options = options;\n    this.options.canAcceptInBackground = true;\n  }\n  provideWithoutTextEditor(picker) {\n    this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutEditor', \"To go to a symbol, first open a text editor with symbol information.\"));\n    return Disposable.None;\n  }\n  provideWithTextEditor(context, picker, token, runOptions) {\n    const editor = context.editor;\n    const model = this.getModel(editor);\n    if (!model) {\n      return Disposable.None;\n    }\n    // Provide symbols from model if available in registry\n    if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n      return this.doProvideWithEditorSymbols(context, model, picker, token, runOptions);\n    }\n    // Otherwise show an entry for a model without registry\n    // But give a chance to resolve the symbols at a later\n    // point if possible\n    return this.doProvideWithoutEditorSymbols(context, model, picker, token);\n  }\n  doProvideWithoutEditorSymbols(context, model, picker, token) {\n    const disposables = new DisposableStore();\n    // Generic pick for not having any symbol information\n    this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutSymbolProvider', \"The active text editor does not provide symbol information.\"));\n    // Wait for changes to the registry and see if eventually\n    // we do get symbols. This can happen if the picker is opened\n    // very early after the model has loaded but before the\n    // language registry is ready.\n    // https://github.com/microsoft/vscode/issues/70607\n    (async () => {\n      const result = await this.waitForLanguageSymbolRegistry(model, disposables);\n      if (!result || token.isCancellationRequested) {\n        return;\n      }\n      disposables.add(this.doProvideWithEditorSymbols(context, model, picker, token));\n    })();\n    return disposables;\n  }\n  provideLabelPick(picker, label) {\n    picker.items = [{\n      label,\n      index: 0,\n      kind: 14 /* SymbolKind.String */\n    }];\n    picker.ariaLabel = label;\n  }\n  async waitForLanguageSymbolRegistry(model, disposables) {\n    if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n      return true;\n    }\n    const symbolProviderRegistryPromise = new DeferredPromise();\n    // Resolve promise when registry knows model\n    const symbolProviderListener = disposables.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => {\n      if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n        symbolProviderListener.dispose();\n        symbolProviderRegistryPromise.complete(true);\n      }\n    }));\n    // Resolve promise when we get disposed too\n    disposables.add(toDisposable(() => symbolProviderRegistryPromise.complete(false)));\n    return symbolProviderRegistryPromise.p;\n  }\n  doProvideWithEditorSymbols(context, model, picker, token, runOptions) {\n    var _editor$getSelection;\n    const editor = context.editor;\n    const disposables = new DisposableStore();\n    // Goto symbol once picked\n    disposables.add(picker.onDidAccept(event => {\n      const [item] = picker.selectedItems;\n      if (item && item.range) {\n        var _runOptions$handleAcc;\n        this.gotoLocation(context, {\n          range: item.range.selection,\n          keyMods: picker.keyMods,\n          preserveFocus: event.inBackground\n        });\n        runOptions === null || runOptions === void 0 || (_runOptions$handleAcc = runOptions.handleAccept) === null || _runOptions$handleAcc === void 0 || _runOptions$handleAcc.call(runOptions, item);\n        if (!event.inBackground) {\n          picker.hide();\n        }\n      }\n    }));\n    // Goto symbol side by side if enabled\n    disposables.add(picker.onDidTriggerItemButton(_ref => {\n      let {\n        item\n      } = _ref;\n      if (item && item.range) {\n        this.gotoLocation(context, {\n          range: item.range.selection,\n          keyMods: picker.keyMods,\n          forceSideBySide: true\n        });\n        picker.hide();\n      }\n    }));\n    // Resolve symbols from document once and reuse this\n    // request for all filtering and typing then on\n    const symbolsPromise = this.getDocumentSymbols(model, token);\n    // Set initial picks and update on type\n    let picksCts = undefined;\n    const updatePickerItems = async positionToEnclose => {\n      var _picksCts;\n      // Cancel any previous ask for picks and busy\n      (_picksCts = picksCts) === null || _picksCts === void 0 || _picksCts.dispose(true);\n      picker.busy = false;\n      // Create new cancellation source for this run\n      picksCts = new CancellationTokenSource(token);\n      // Collect symbol picks\n      picker.busy = true;\n      try {\n        const query = prepareQuery(picker.value.substr(AbstractGotoSymbolQuickAccessProvider_1.PREFIX.length).trim());\n        const items = await this.doGetSymbolPicks(symbolsPromise, query, undefined, picksCts.token, model);\n        if (token.isCancellationRequested) {\n          return;\n        }\n        if (items.length > 0) {\n          picker.items = items;\n          if (positionToEnclose && query.original.length === 0) {\n            const candidate = findLast(items, item => Boolean(item.type !== 'separator' && item.range && Range.containsPosition(item.range.decoration, positionToEnclose)));\n            if (candidate) {\n              picker.activeItems = [candidate];\n            }\n          }\n        } else {\n          if (query.original.length > 0) {\n            this.provideLabelPick(picker, localize('noMatchingSymbolResults', \"No matching editor symbols\"));\n          } else {\n            this.provideLabelPick(picker, localize('noSymbolResults', \"No editor symbols\"));\n          }\n        }\n      } finally {\n        if (!token.isCancellationRequested) {\n          picker.busy = false;\n        }\n      }\n    };\n    disposables.add(picker.onDidChangeValue(() => updatePickerItems(undefined)));\n    updatePickerItems((_editor$getSelection = editor.getSelection()) === null || _editor$getSelection === void 0 ? void 0 : _editor$getSelection.getPosition());\n    // Reveal and decorate when active item changes\n    disposables.add(picker.onDidChangeActive(() => {\n      const [item] = picker.activeItems;\n      if (item && item.range) {\n        // Reveal\n        editor.revealRangeInCenter(item.range.selection, 0 /* ScrollType.Smooth */);\n        // Decorate\n        this.addDecorations(editor, item.range.decoration);\n      }\n    }));\n    return disposables;\n  }\n  async doGetSymbolPicks(symbolsPromise, query, options, token, model) {\n    var _this$options, _this$options$openSid;\n    const symbols = await symbolsPromise;\n    if (token.isCancellationRequested) {\n      return [];\n    }\n    const filterBySymbolKind = query.original.indexOf(AbstractGotoSymbolQuickAccessProvider_1.SCOPE_PREFIX) === 0;\n    const filterPos = filterBySymbolKind ? 1 : 0;\n    // Split between symbol and container query\n    let symbolQuery;\n    let containerQuery;\n    if (query.values && query.values.length > 1) {\n      symbolQuery = pieceToQuery(query.values[0]); // symbol: only match on first part\n      containerQuery = pieceToQuery(query.values.slice(1)); // container: match on all but first parts\n    } else {\n      symbolQuery = query;\n    }\n    // Convert to symbol picks and apply filtering\n    let buttons;\n    const openSideBySideDirection = (_this$options = this.options) === null || _this$options === void 0 || (_this$options$openSid = _this$options.openSideBySideDirection) === null || _this$options$openSid === void 0 ? void 0 : _this$options$openSid.call(_this$options);\n    if (openSideBySideDirection) {\n      buttons = [{\n        iconClass: openSideBySideDirection === 'right' ? ThemeIcon.asClassName(Codicon.splitHorizontal) : ThemeIcon.asClassName(Codicon.splitVertical),\n        tooltip: openSideBySideDirection === 'right' ? localize('openToSide', \"Open to the Side\") : localize('openToBottom', \"Open to the Bottom\")\n      }];\n    }\n    const filteredSymbolPicks = [];\n    for (let index = 0; index < symbols.length; index++) {\n      const symbol = symbols[index];\n      const symbolLabel = trim(symbol.name);\n      const symbolLabelWithIcon = \"$(\".concat(SymbolKinds.toIcon(symbol.kind).id, \") \").concat(symbolLabel);\n      const symbolLabelIconOffset = symbolLabelWithIcon.length - symbolLabel.length;\n      let containerLabel = symbol.containerName;\n      if (options !== null && options !== void 0 && options.extraContainerLabel) {\n        if (containerLabel) {\n          containerLabel = \"\".concat(options.extraContainerLabel, \" \\u2022 \").concat(containerLabel);\n        } else {\n          containerLabel = options.extraContainerLabel;\n        }\n      }\n      let symbolScore = undefined;\n      let symbolMatches = undefined;\n      let containerScore = undefined;\n      let containerMatches = undefined;\n      if (query.original.length > filterPos) {\n        // First: try to score on the entire query, it is possible that\n        // the symbol matches perfectly (e.g. searching for \"change log\"\n        // can be a match on a markdown symbol \"change log\"). In that\n        // case we want to skip the container query altogether.\n        let skipContainerQuery = false;\n        if (symbolQuery !== query) {\n          [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, {\n            ...query,\n            values: undefined /* disable multi-query support */\n          }, filterPos, symbolLabelIconOffset);\n          if (typeof symbolScore === 'number') {\n            skipContainerQuery = true; // since we consumed the query, skip any container matching\n          }\n        }\n        // Otherwise: score on the symbol query and match on the container later\n        if (typeof symbolScore !== 'number') {\n          [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, symbolQuery, filterPos, symbolLabelIconOffset);\n          if (typeof symbolScore !== 'number') {\n            continue;\n          }\n        }\n        // Score by container if specified\n        if (!skipContainerQuery && containerQuery) {\n          if (containerLabel && containerQuery.original.length > 0) {\n            [containerScore, containerMatches] = scoreFuzzy2(containerLabel, containerQuery);\n          }\n          if (typeof containerScore !== 'number') {\n            continue;\n          }\n          if (typeof symbolScore === 'number') {\n            symbolScore += containerScore; // boost symbolScore by containerScore\n          }\n        }\n      }\n      const deprecated = symbol.tags && symbol.tags.indexOf(1 /* SymbolTag.Deprecated */) >= 0;\n      filteredSymbolPicks.push({\n        index,\n        kind: symbol.kind,\n        score: symbolScore,\n        label: symbolLabelWithIcon,\n        ariaLabel: getAriaLabelForSymbol(symbol.name, symbol.kind),\n        description: containerLabel,\n        highlights: deprecated ? undefined : {\n          label: symbolMatches,\n          description: containerMatches\n        },\n        range: {\n          selection: Range.collapseToStart(symbol.selectionRange),\n          decoration: symbol.range\n        },\n        uri: model.uri,\n        symbolName: symbolLabel,\n        strikethrough: deprecated,\n        buttons\n      });\n    }\n    // Sort by score\n    const sortedFilteredSymbolPicks = filteredSymbolPicks.sort((symbolA, symbolB) => filterBySymbolKind ? this.compareByKindAndScore(symbolA, symbolB) : this.compareByScore(symbolA, symbolB));\n    // Add separator for types\n    // - @  only total number of symbols\n    // - @: grouped by symbol kind\n    let symbolPicks = [];\n    if (filterBySymbolKind) {\n      let lastSymbolKind = undefined;\n      let lastSeparator = undefined;\n      let lastSymbolKindCounter = 0;\n      function updateLastSeparatorLabel() {\n        if (lastSeparator && typeof lastSymbolKind === 'number' && lastSymbolKindCounter > 0) {\n          lastSeparator.label = format(NLS_SYMBOL_KIND_CACHE[lastSymbolKind] || FALLBACK_NLS_SYMBOL_KIND, lastSymbolKindCounter);\n        }\n      }\n      for (const symbolPick of sortedFilteredSymbolPicks) {\n        // Found new kind\n        if (lastSymbolKind !== symbolPick.kind) {\n          // Update last separator with number of symbols we found for kind\n          updateLastSeparatorLabel();\n          lastSymbolKind = symbolPick.kind;\n          lastSymbolKindCounter = 1;\n          // Add new separator for new kind\n          lastSeparator = {\n            type: 'separator'\n          };\n          symbolPicks.push(lastSeparator);\n        }\n        // Existing kind, keep counting\n        else {\n          lastSymbolKindCounter++;\n        }\n        // Add to final result\n        symbolPicks.push(symbolPick);\n      }\n      // Update last separator with number of symbols we found for kind\n      updateLastSeparatorLabel();\n    } else if (sortedFilteredSymbolPicks.length > 0) {\n      symbolPicks = [{\n        label: localize('symbols', \"symbols ({0})\", filteredSymbolPicks.length),\n        type: 'separator'\n      }, ...sortedFilteredSymbolPicks];\n    }\n    return symbolPicks;\n  }\n  compareByScore(symbolA, symbolB) {\n    if (typeof symbolA.score !== 'number' && typeof symbolB.score === 'number') {\n      return 1;\n    } else if (typeof symbolA.score === 'number' && typeof symbolB.score !== 'number') {\n      return -1;\n    }\n    if (typeof symbolA.score === 'number' && typeof symbolB.score === 'number') {\n      if (symbolA.score > symbolB.score) {\n        return -1;\n      } else if (symbolA.score < symbolB.score) {\n        return 1;\n      }\n    }\n    if (symbolA.index < symbolB.index) {\n      return -1;\n    } else if (symbolA.index > symbolB.index) {\n      return 1;\n    }\n    return 0;\n  }\n  compareByKindAndScore(symbolA, symbolB) {\n    const kindA = NLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;\n    const kindB = NLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND;\n    // Sort by type first if scoped search\n    const result = kindA.localeCompare(kindB);\n    if (result === 0) {\n      return this.compareByScore(symbolA, symbolB);\n    }\n    return result;\n  }\n  async getDocumentSymbols(document, token) {\n    const model = await this._outlineModelService.getOrCreate(document, token);\n    return token.isCancellationRequested ? [] : model.asListOfDocumentSymbols();\n  }\n}, AbstractGotoSymbolQuickAccessProvider_1 = _AbstractGotoSymbolQuickAccessProvider, _AbstractGotoSymbolQuickAccessProvider.PREFIX = '@', _AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX = ':', _AbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY = \"\".concat(_AbstractGotoSymbolQuickAccessProvider.PREFIX).concat(_AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX), _AbstractGotoSymbolQuickAccessProvider);\nAbstractGotoSymbolQuickAccessProvider = AbstractGotoSymbolQuickAccessProvider_1 = __decorate([__param(0, ILanguageFeaturesService), __param(1, IOutlineModelService)], AbstractGotoSymbolQuickAccessProvider);\nexport { AbstractGotoSymbolQuickAccessProvider };\n// #region NLS Helpers\nconst FALLBACK_NLS_SYMBOL_KIND = localize('property', \"properties ({0})\");\nconst NLS_SYMBOL_KIND_CACHE = {\n  [5 /* SymbolKind.Method */]: localize('method', \"methods ({0})\"),\n  [11 /* SymbolKind.Function */]: localize('function', \"functions ({0})\"),\n  [8 /* SymbolKind.Constructor */]: localize('_constructor', \"constructors ({0})\"),\n  [12 /* SymbolKind.Variable */]: localize('variable', \"variables ({0})\"),\n  [4 /* SymbolKind.Class */]: localize('class', \"classes ({0})\"),\n  [22 /* SymbolKind.Struct */]: localize('struct', \"structs ({0})\"),\n  [23 /* SymbolKind.Event */]: localize('event', \"events ({0})\"),\n  [24 /* SymbolKind.Operator */]: localize('operator', \"operators ({0})\"),\n  [10 /* SymbolKind.Interface */]: localize('interface', \"interfaces ({0})\"),\n  [2 /* SymbolKind.Namespace */]: localize('namespace', \"namespaces ({0})\"),\n  [3 /* SymbolKind.Package */]: localize('package', \"packages ({0})\"),\n  [25 /* SymbolKind.TypeParameter */]: localize('typeParameter', \"type parameters ({0})\"),\n  [1 /* SymbolKind.Module */]: localize('modules', \"modules ({0})\"),\n  [6 /* SymbolKind.Property */]: localize('property', \"properties ({0})\"),\n  [9 /* SymbolKind.Enum */]: localize('enum', \"enumerations ({0})\"),\n  [21 /* SymbolKind.EnumMember */]: localize('enumMember', \"enumeration members ({0})\"),\n  [14 /* SymbolKind.String */]: localize('string', \"strings ({0})\"),\n  [0 /* SymbolKind.File */]: localize('file', \"files ({0})\"),\n  [17 /* SymbolKind.Array */]: localize('array', \"arrays ({0})\"),\n  [15 /* SymbolKind.Number */]: localize('number', \"numbers ({0})\"),\n  [16 /* SymbolKind.Boolean */]: localize('boolean', \"booleans ({0})\"),\n  [18 /* SymbolKind.Object */]: localize('object', \"objects ({0})\"),\n  [19 /* SymbolKind.Key */]: localize('key', \"keys ({0})\"),\n  [7 /* SymbolKind.Field */]: localize('field', \"fields ({0})\"),\n  [13 /* SymbolKind.Constant */]: localize('constant', \"constants ({0})\")\n};\n//#endregion","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","AbstractGotoSymbolQuickAccessProvider_1","DeferredPromise","CancellationTokenSource","Codicon","ThemeIcon","pieceToQuery","prepareQuery","scoreFuzzy2","Disposable","DisposableStore","toDisposable","format","trim","Range","SymbolKinds","getAriaLabelForSymbol","IOutlineModelService","AbstractEditorNavigationQuickAccessProvider","localize","ILanguageFeaturesService","findLast","AbstractGotoSymbolQuickAccessProvider","_AbstractGotoSymbolQuickAccessProvider","constructor","_languageFeaturesService","_outlineModelService","options","undefined","create","canAcceptInBackground","provideWithoutTextEditor","picker","provideLabelPick","None","provideWithTextEditor","context","token","runOptions","editor","model","getModel","documentSymbolProvider","has","doProvideWithEditorSymbols","doProvideWithoutEditorSymbols","disposables","result","waitForLanguageSymbolRegistry","isCancellationRequested","add","label","items","index","kind","ariaLabel","symbolProviderRegistryPromise","symbolProviderListener","onDidChange","dispose","complete","p","_editor$getSelection","onDidAccept","event","item","selectedItems","range","_runOptions$handleAcc","gotoLocation","selection","keyMods","preserveFocus","inBackground","handleAccept","call","hide","onDidTriggerItemButton","_ref","forceSideBySide","symbolsPromise","getDocumentSymbols","picksCts","updatePickerItems","positionToEnclose","_picksCts","busy","query","value","substr","PREFIX","doGetSymbolPicks","original","candidate","Boolean","type","containsPosition","decoration","activeItems","onDidChangeValue","getSelection","getPosition","onDidChangeActive","revealRangeInCenter","addDecorations","_this$options","_this$options$openSid","symbols","filterBySymbolKind","indexOf","SCOPE_PREFIX","filterPos","symbolQuery","containerQuery","values","slice","buttons","openSideBySideDirection","iconClass","asClassName","splitHorizontal","splitVertical","tooltip","filteredSymbolPicks","symbol","symbolLabel","name","symbolLabelWithIcon","concat","toIcon","id","symbolLabelIconOffset","containerLabel","containerName","extraContainerLabel","symbolScore","symbolMatches","containerScore","containerMatches","skipContainerQuery","deprecated","tags","push","score","description","highlights","collapseToStart","selectionRange","uri","symbolName","strikethrough","sortedFilteredSymbolPicks","sort","symbolA","symbolB","compareByKindAndScore","compareByScore","symbolPicks","lastSymbolKind","lastSeparator","lastSymbolKindCounter","updateLastSeparatorLabel","NLS_SYMBOL_KIND_CACHE","FALLBACK_NLS_SYMBOL_KIND","symbolPick","kindA","kindB","localeCompare","document","getOrCreate","asListOfDocumentSymbols","PREFIX_BY_CATEGORY"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar AbstractGotoSymbolQuickAccessProvider_1;\nimport { DeferredPromise } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Codicon } from '../../../../base/common/codicons.js';\nimport { ThemeIcon } from '../../../../base/common/themables.js';\nimport { pieceToQuery, prepareQuery, scoreFuzzy2 } from '../../../../base/common/fuzzyScorer.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { format, trim } from '../../../../base/common/strings.js';\nimport { Range } from '../../../common/core/range.js';\nimport { SymbolKinds, getAriaLabelForSymbol } from '../../../common/languages.js';\nimport { IOutlineModelService } from '../../documentSymbols/browser/outlineModel.js';\nimport { AbstractEditorNavigationQuickAccessProvider } from './editorNavigationQuickAccess.js';\nimport { localize } from '../../../../nls.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { findLast } from '../../../../base/common/arraysFind.js';\nlet AbstractGotoSymbolQuickAccessProvider = class AbstractGotoSymbolQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {\n    static { AbstractGotoSymbolQuickAccessProvider_1 = this; }\n    static { this.PREFIX = '@'; }\n    static { this.SCOPE_PREFIX = ':'; }\n    static { this.PREFIX_BY_CATEGORY = `${this.PREFIX}${this.SCOPE_PREFIX}`; }\n    constructor(_languageFeaturesService, _outlineModelService, options = Object.create(null)) {\n        super(options);\n        this._languageFeaturesService = _languageFeaturesService;\n        this._outlineModelService = _outlineModelService;\n        this.options = options;\n        this.options.canAcceptInBackground = true;\n    }\n    provideWithoutTextEditor(picker) {\n        this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutEditor', \"To go to a symbol, first open a text editor with symbol information.\"));\n        return Disposable.None;\n    }\n    provideWithTextEditor(context, picker, token, runOptions) {\n        const editor = context.editor;\n        const model = this.getModel(editor);\n        if (!model) {\n            return Disposable.None;\n        }\n        // Provide symbols from model if available in registry\n        if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n            return this.doProvideWithEditorSymbols(context, model, picker, token, runOptions);\n        }\n        // Otherwise show an entry for a model without registry\n        // But give a chance to resolve the symbols at a later\n        // point if possible\n        return this.doProvideWithoutEditorSymbols(context, model, picker, token);\n    }\n    doProvideWithoutEditorSymbols(context, model, picker, token) {\n        const disposables = new DisposableStore();\n        // Generic pick for not having any symbol information\n        this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutSymbolProvider', \"The active text editor does not provide symbol information.\"));\n        // Wait for changes to the registry and see if eventually\n        // we do get symbols. This can happen if the picker is opened\n        // very early after the model has loaded but before the\n        // language registry is ready.\n        // https://github.com/microsoft/vscode/issues/70607\n        (async () => {\n            const result = await this.waitForLanguageSymbolRegistry(model, disposables);\n            if (!result || token.isCancellationRequested) {\n                return;\n            }\n            disposables.add(this.doProvideWithEditorSymbols(context, model, picker, token));\n        })();\n        return disposables;\n    }\n    provideLabelPick(picker, label) {\n        picker.items = [{ label, index: 0, kind: 14 /* SymbolKind.String */ }];\n        picker.ariaLabel = label;\n    }\n    async waitForLanguageSymbolRegistry(model, disposables) {\n        if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n            return true;\n        }\n        const symbolProviderRegistryPromise = new DeferredPromise();\n        // Resolve promise when registry knows model\n        const symbolProviderListener = disposables.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => {\n            if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n                symbolProviderListener.dispose();\n                symbolProviderRegistryPromise.complete(true);\n            }\n        }));\n        // Resolve promise when we get disposed too\n        disposables.add(toDisposable(() => symbolProviderRegistryPromise.complete(false)));\n        return symbolProviderRegistryPromise.p;\n    }\n    doProvideWithEditorSymbols(context, model, picker, token, runOptions) {\n        const editor = context.editor;\n        const disposables = new DisposableStore();\n        // Goto symbol once picked\n        disposables.add(picker.onDidAccept(event => {\n            const [item] = picker.selectedItems;\n            if (item && item.range) {\n                this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, preserveFocus: event.inBackground });\n                runOptions?.handleAccept?.(item);\n                if (!event.inBackground) {\n                    picker.hide();\n                }\n            }\n        }));\n        // Goto symbol side by side if enabled\n        disposables.add(picker.onDidTriggerItemButton(({ item }) => {\n            if (item && item.range) {\n                this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, forceSideBySide: true });\n                picker.hide();\n            }\n        }));\n        // Resolve symbols from document once and reuse this\n        // request for all filtering and typing then on\n        const symbolsPromise = this.getDocumentSymbols(model, token);\n        // Set initial picks and update on type\n        let picksCts = undefined;\n        const updatePickerItems = async (positionToEnclose) => {\n            // Cancel any previous ask for picks and busy\n            picksCts?.dispose(true);\n            picker.busy = false;\n            // Create new cancellation source for this run\n            picksCts = new CancellationTokenSource(token);\n            // Collect symbol picks\n            picker.busy = true;\n            try {\n                const query = prepareQuery(picker.value.substr(AbstractGotoSymbolQuickAccessProvider_1.PREFIX.length).trim());\n                const items = await this.doGetSymbolPicks(symbolsPromise, query, undefined, picksCts.token, model);\n                if (token.isCancellationRequested) {\n                    return;\n                }\n                if (items.length > 0) {\n                    picker.items = items;\n                    if (positionToEnclose && query.original.length === 0) {\n                        const candidate = findLast(items, item => Boolean(item.type !== 'separator' && item.range && Range.containsPosition(item.range.decoration, positionToEnclose)));\n                        if (candidate) {\n                            picker.activeItems = [candidate];\n                        }\n                    }\n                }\n                else {\n                    if (query.original.length > 0) {\n                        this.provideLabelPick(picker, localize('noMatchingSymbolResults', \"No matching editor symbols\"));\n                    }\n                    else {\n                        this.provideLabelPick(picker, localize('noSymbolResults', \"No editor symbols\"));\n                    }\n                }\n            }\n            finally {\n                if (!token.isCancellationRequested) {\n                    picker.busy = false;\n                }\n            }\n        };\n        disposables.add(picker.onDidChangeValue(() => updatePickerItems(undefined)));\n        updatePickerItems(editor.getSelection()?.getPosition());\n        // Reveal and decorate when active item changes\n        disposables.add(picker.onDidChangeActive(() => {\n            const [item] = picker.activeItems;\n            if (item && item.range) {\n                // Reveal\n                editor.revealRangeInCenter(item.range.selection, 0 /* ScrollType.Smooth */);\n                // Decorate\n                this.addDecorations(editor, item.range.decoration);\n            }\n        }));\n        return disposables;\n    }\n    async doGetSymbolPicks(symbolsPromise, query, options, token, model) {\n        const symbols = await symbolsPromise;\n        if (token.isCancellationRequested) {\n            return [];\n        }\n        const filterBySymbolKind = query.original.indexOf(AbstractGotoSymbolQuickAccessProvider_1.SCOPE_PREFIX) === 0;\n        const filterPos = filterBySymbolKind ? 1 : 0;\n        // Split between symbol and container query\n        let symbolQuery;\n        let containerQuery;\n        if (query.values && query.values.length > 1) {\n            symbolQuery = pieceToQuery(query.values[0]); // symbol: only match on first part\n            containerQuery = pieceToQuery(query.values.slice(1)); // container: match on all but first parts\n        }\n        else {\n            symbolQuery = query;\n        }\n        // Convert to symbol picks and apply filtering\n        let buttons;\n        const openSideBySideDirection = this.options?.openSideBySideDirection?.();\n        if (openSideBySideDirection) {\n            buttons = [{\n                    iconClass: openSideBySideDirection === 'right' ? ThemeIcon.asClassName(Codicon.splitHorizontal) : ThemeIcon.asClassName(Codicon.splitVertical),\n                    tooltip: openSideBySideDirection === 'right' ? localize('openToSide', \"Open to the Side\") : localize('openToBottom', \"Open to the Bottom\")\n                }];\n        }\n        const filteredSymbolPicks = [];\n        for (let index = 0; index < symbols.length; index++) {\n            const symbol = symbols[index];\n            const symbolLabel = trim(symbol.name);\n            const symbolLabelWithIcon = `$(${SymbolKinds.toIcon(symbol.kind).id}) ${symbolLabel}`;\n            const symbolLabelIconOffset = symbolLabelWithIcon.length - symbolLabel.length;\n            let containerLabel = symbol.containerName;\n            if (options?.extraContainerLabel) {\n                if (containerLabel) {\n                    containerLabel = `${options.extraContainerLabel} â€¢ ${containerLabel}`;\n                }\n                else {\n                    containerLabel = options.extraContainerLabel;\n                }\n            }\n            let symbolScore = undefined;\n            let symbolMatches = undefined;\n            let containerScore = undefined;\n            let containerMatches = undefined;\n            if (query.original.length > filterPos) {\n                // First: try to score on the entire query, it is possible that\n                // the symbol matches perfectly (e.g. searching for \"change log\"\n                // can be a match on a markdown symbol \"change log\"). In that\n                // case we want to skip the container query altogether.\n                let skipContainerQuery = false;\n                if (symbolQuery !== query) {\n                    [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, { ...query, values: undefined /* disable multi-query support */ }, filterPos, symbolLabelIconOffset);\n                    if (typeof symbolScore === 'number') {\n                        skipContainerQuery = true; // since we consumed the query, skip any container matching\n                    }\n                }\n                // Otherwise: score on the symbol query and match on the container later\n                if (typeof symbolScore !== 'number') {\n                    [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, symbolQuery, filterPos, symbolLabelIconOffset);\n                    if (typeof symbolScore !== 'number') {\n                        continue;\n                    }\n                }\n                // Score by container if specified\n                if (!skipContainerQuery && containerQuery) {\n                    if (containerLabel && containerQuery.original.length > 0) {\n                        [containerScore, containerMatches] = scoreFuzzy2(containerLabel, containerQuery);\n                    }\n                    if (typeof containerScore !== 'number') {\n                        continue;\n                    }\n                    if (typeof symbolScore === 'number') {\n                        symbolScore += containerScore; // boost symbolScore by containerScore\n                    }\n                }\n            }\n            const deprecated = symbol.tags && symbol.tags.indexOf(1 /* SymbolTag.Deprecated */) >= 0;\n            filteredSymbolPicks.push({\n                index,\n                kind: symbol.kind,\n                score: symbolScore,\n                label: symbolLabelWithIcon,\n                ariaLabel: getAriaLabelForSymbol(symbol.name, symbol.kind),\n                description: containerLabel,\n                highlights: deprecated ? undefined : {\n                    label: symbolMatches,\n                    description: containerMatches\n                },\n                range: {\n                    selection: Range.collapseToStart(symbol.selectionRange),\n                    decoration: symbol.range\n                },\n                uri: model.uri,\n                symbolName: symbolLabel,\n                strikethrough: deprecated,\n                buttons\n            });\n        }\n        // Sort by score\n        const sortedFilteredSymbolPicks = filteredSymbolPicks.sort((symbolA, symbolB) => filterBySymbolKind ?\n            this.compareByKindAndScore(symbolA, symbolB) :\n            this.compareByScore(symbolA, symbolB));\n        // Add separator for types\n        // - @  only total number of symbols\n        // - @: grouped by symbol kind\n        let symbolPicks = [];\n        if (filterBySymbolKind) {\n            let lastSymbolKind = undefined;\n            let lastSeparator = undefined;\n            let lastSymbolKindCounter = 0;\n            function updateLastSeparatorLabel() {\n                if (lastSeparator && typeof lastSymbolKind === 'number' && lastSymbolKindCounter > 0) {\n                    lastSeparator.label = format(NLS_SYMBOL_KIND_CACHE[lastSymbolKind] || FALLBACK_NLS_SYMBOL_KIND, lastSymbolKindCounter);\n                }\n            }\n            for (const symbolPick of sortedFilteredSymbolPicks) {\n                // Found new kind\n                if (lastSymbolKind !== symbolPick.kind) {\n                    // Update last separator with number of symbols we found for kind\n                    updateLastSeparatorLabel();\n                    lastSymbolKind = symbolPick.kind;\n                    lastSymbolKindCounter = 1;\n                    // Add new separator for new kind\n                    lastSeparator = { type: 'separator' };\n                    symbolPicks.push(lastSeparator);\n                }\n                // Existing kind, keep counting\n                else {\n                    lastSymbolKindCounter++;\n                }\n                // Add to final result\n                symbolPicks.push(symbolPick);\n            }\n            // Update last separator with number of symbols we found for kind\n            updateLastSeparatorLabel();\n        }\n        else if (sortedFilteredSymbolPicks.length > 0) {\n            symbolPicks = [\n                { label: localize('symbols', \"symbols ({0})\", filteredSymbolPicks.length), type: 'separator' },\n                ...sortedFilteredSymbolPicks\n            ];\n        }\n        return symbolPicks;\n    }\n    compareByScore(symbolA, symbolB) {\n        if (typeof symbolA.score !== 'number' && typeof symbolB.score === 'number') {\n            return 1;\n        }\n        else if (typeof symbolA.score === 'number' && typeof symbolB.score !== 'number') {\n            return -1;\n        }\n        if (typeof symbolA.score === 'number' && typeof symbolB.score === 'number') {\n            if (symbolA.score > symbolB.score) {\n                return -1;\n            }\n            else if (symbolA.score < symbolB.score) {\n                return 1;\n            }\n        }\n        if (symbolA.index < symbolB.index) {\n            return -1;\n        }\n        else if (symbolA.index > symbolB.index) {\n            return 1;\n        }\n        return 0;\n    }\n    compareByKindAndScore(symbolA, symbolB) {\n        const kindA = NLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;\n        const kindB = NLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND;\n        // Sort by type first if scoped search\n        const result = kindA.localeCompare(kindB);\n        if (result === 0) {\n            return this.compareByScore(symbolA, symbolB);\n        }\n        return result;\n    }\n    async getDocumentSymbols(document, token) {\n        const model = await this._outlineModelService.getOrCreate(document, token);\n        return token.isCancellationRequested ? [] : model.asListOfDocumentSymbols();\n    }\n};\nAbstractGotoSymbolQuickAccessProvider = AbstractGotoSymbolQuickAccessProvider_1 = __decorate([\n    __param(0, ILanguageFeaturesService),\n    __param(1, IOutlineModelService)\n], AbstractGotoSymbolQuickAccessProvider);\nexport { AbstractGotoSymbolQuickAccessProvider };\n// #region NLS Helpers\nconst FALLBACK_NLS_SYMBOL_KIND = localize('property', \"properties ({0})\");\nconst NLS_SYMBOL_KIND_CACHE = {\n    [5 /* SymbolKind.Method */]: localize('method', \"methods ({0})\"),\n    [11 /* SymbolKind.Function */]: localize('function', \"functions ({0})\"),\n    [8 /* SymbolKind.Constructor */]: localize('_constructor', \"constructors ({0})\"),\n    [12 /* SymbolKind.Variable */]: localize('variable', \"variables ({0})\"),\n    [4 /* SymbolKind.Class */]: localize('class', \"classes ({0})\"),\n    [22 /* SymbolKind.Struct */]: localize('struct', \"structs ({0})\"),\n    [23 /* SymbolKind.Event */]: localize('event', \"events ({0})\"),\n    [24 /* SymbolKind.Operator */]: localize('operator', \"operators ({0})\"),\n    [10 /* SymbolKind.Interface */]: localize('interface', \"interfaces ({0})\"),\n    [2 /* SymbolKind.Namespace */]: localize('namespace', \"namespaces ({0})\"),\n    [3 /* SymbolKind.Package */]: localize('package', \"packages ({0})\"),\n    [25 /* SymbolKind.TypeParameter */]: localize('typeParameter', \"type parameters ({0})\"),\n    [1 /* SymbolKind.Module */]: localize('modules', \"modules ({0})\"),\n    [6 /* SymbolKind.Property */]: localize('property', \"properties ({0})\"),\n    [9 /* SymbolKind.Enum */]: localize('enum', \"enumerations ({0})\"),\n    [21 /* SymbolKind.EnumMember */]: localize('enumMember', \"enumeration members ({0})\"),\n    [14 /* SymbolKind.String */]: localize('string', \"strings ({0})\"),\n    [0 /* SymbolKind.File */]: localize('file', \"files ({0})\"),\n    [17 /* SymbolKind.Array */]: localize('array', \"arrays ({0})\"),\n    [15 /* SymbolKind.Number */]: localize('number', \"numbers ({0})\"),\n    [16 /* SymbolKind.Boolean */]: localize('boolean', \"booleans ({0})\"),\n    [18 /* SymbolKind.Object */]: localize('object', \"objects ({0})\"),\n    [19 /* SymbolKind.Key */]: localize('key', \"keys ({0})\"),\n    [7 /* SymbolKind.Field */]: localize('field', \"fields ({0})\"),\n    [13 /* SymbolKind.Constant */]: localize('constant', \"constants ({0})\")\n};\n//#endregion\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}