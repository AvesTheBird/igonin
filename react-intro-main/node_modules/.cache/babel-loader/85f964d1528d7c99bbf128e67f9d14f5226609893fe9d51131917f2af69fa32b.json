{"ast":null,"code":"var _FormattingConflicts;\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { asArray, isNonEmptyArray } from '../../../../base/common/arrays.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { LinkedList } from '../../../../base/common/linkedList.js';\nimport { assertType } from '../../../../base/common/types.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { EditorStateCancellationTokenSource, TextModelCancellationTokenSource } from '../../editorState/browser/editorState.js';\nimport { isCodeEditor } from '../../../browser/editorBrowser.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { IEditorWorkerService } from '../../../common/services/editorWorker.js';\nimport { ITextModelService } from '../../../common/services/resolverService.js';\nimport { FormattingEdit } from './formattingEdit.js';\nimport { CommandsRegistry } from '../../../../platform/commands/common/commands.js';\nimport { ExtensionIdentifierSet } from '../../../../platform/extensions/common/extensions.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { AccessibilitySignal, IAccessibilitySignalService } from '../../../../platform/accessibilitySignal/browser/accessibilitySignalService.js';\nexport function getRealAndSyntheticDocumentFormattersOrdered(documentFormattingEditProvider, documentRangeFormattingEditProvider, model) {\n  const result = [];\n  const seen = new ExtensionIdentifierSet();\n  // (1) add all document formatter\n  const docFormatter = documentFormattingEditProvider.ordered(model);\n  for (const formatter of docFormatter) {\n    result.push(formatter);\n    if (formatter.extensionId) {\n      seen.add(formatter.extensionId);\n    }\n  }\n  // (2) add all range formatter as document formatter (unless the same extension already did that)\n  const rangeFormatter = documentRangeFormattingEditProvider.ordered(model);\n  for (const formatter of rangeFormatter) {\n    if (formatter.extensionId) {\n      if (seen.has(formatter.extensionId)) {\n        continue;\n      }\n      seen.add(formatter.extensionId);\n    }\n    result.push({\n      displayName: formatter.displayName,\n      extensionId: formatter.extensionId,\n      provideDocumentFormattingEdits(model, options, token) {\n        return formatter.provideDocumentRangeFormattingEdits(model, model.getFullModelRange(), options, token);\n      }\n    });\n  }\n  return result;\n}\nexport class FormattingConflicts {\n  static setFormatterSelector(selector) {\n    const remove = FormattingConflicts._selectors.unshift(selector);\n    return {\n      dispose: remove\n    };\n  }\n  static async select(formatter, document, mode, kind) {\n    if (formatter.length === 0) {\n      return undefined;\n    }\n    const selector = Iterable.first(FormattingConflicts._selectors);\n    if (selector) {\n      return await selector(formatter, document, mode, kind);\n    }\n    return undefined;\n  }\n}\n_FormattingConflicts = FormattingConflicts;\n_FormattingConflicts._selectors = new LinkedList();\nexport async function formatDocumentRangesWithSelectedProvider(accessor, editorOrModel, rangeOrRanges, mode, progress, token, userGesture) {\n  const instaService = accessor.get(IInstantiationService);\n  const {\n    documentRangeFormattingEditProvider: documentRangeFormattingEditProviderRegistry\n  } = accessor.get(ILanguageFeaturesService);\n  const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n  const provider = documentRangeFormattingEditProviderRegistry.ordered(model);\n  const selected = await FormattingConflicts.select(provider, model, mode, 2 /* FormattingKind.Selection */);\n  if (selected) {\n    progress.report(selected);\n    await instaService.invokeFunction(formatDocumentRangesWithProvider, selected, editorOrModel, rangeOrRanges, token, userGesture);\n  }\n}\nexport async function formatDocumentRangesWithProvider(accessor, provider, editorOrModel, rangeOrRanges, token, userGesture) {\n  const workerService = accessor.get(IEditorWorkerService);\n  const logService = accessor.get(ILogService);\n  const accessibilitySignalService = accessor.get(IAccessibilitySignalService);\n  let model;\n  let cts;\n  if (isCodeEditor(editorOrModel)) {\n    model = editorOrModel.getModel();\n    cts = new EditorStateCancellationTokenSource(editorOrModel, 1 /* CodeEditorStateFlag.Value */ | 4 /* CodeEditorStateFlag.Position */, undefined, token);\n  } else {\n    model = editorOrModel;\n    cts = new TextModelCancellationTokenSource(editorOrModel, token);\n  }\n  // make sure that ranges don't overlap nor touch each other\n  const ranges = [];\n  let len = 0;\n  for (const range of asArray(rangeOrRanges).sort(Range.compareRangesUsingStarts)) {\n    if (len > 0 && Range.areIntersectingOrTouching(ranges[len - 1], range)) {\n      ranges[len - 1] = Range.fromPositions(ranges[len - 1].getStartPosition(), range.getEndPosition());\n    } else {\n      len = ranges.push(range);\n    }\n  }\n  const computeEdits = async range => {\n    var _provider$extensionId, _provider$extensionId2;\n    logService.trace(\"[format][provideDocumentRangeFormattingEdits] (request)\", (_provider$extensionId = provider.extensionId) === null || _provider$extensionId === void 0 ? void 0 : _provider$extensionId.value, range);\n    const result = (await provider.provideDocumentRangeFormattingEdits(model, range, model.getFormattingOptions(), cts.token)) || [];\n    logService.trace(\"[format][provideDocumentRangeFormattingEdits] (response)\", (_provider$extensionId2 = provider.extensionId) === null || _provider$extensionId2 === void 0 ? void 0 : _provider$extensionId2.value, result);\n    return result;\n  };\n  const hasIntersectingEdit = (a, b) => {\n    if (!a.length || !b.length) {\n      return false;\n    }\n    // quick exit if the list of ranges are completely unrelated [O(n)]\n    const mergedA = a.reduce((acc, val) => {\n      return Range.plusRange(acc, val.range);\n    }, a[0].range);\n    if (!b.some(x => {\n      return Range.intersectRanges(mergedA, x.range);\n    })) {\n      return false;\n    }\n    // fallback to a complete check [O(n^2)]\n    for (const edit of a) {\n      for (const otherEdit of b) {\n        if (Range.intersectRanges(edit.range, otherEdit.range)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n  const allEdits = [];\n  const rawEditsList = [];\n  try {\n    if (typeof provider.provideDocumentRangesFormattingEdits === 'function') {\n      var _provider$extensionId3, _provider$extensionId4;\n      logService.trace(\"[format][provideDocumentRangeFormattingEdits] (request)\", (_provider$extensionId3 = provider.extensionId) === null || _provider$extensionId3 === void 0 ? void 0 : _provider$extensionId3.value, ranges);\n      const result = (await provider.provideDocumentRangesFormattingEdits(model, ranges, model.getFormattingOptions(), cts.token)) || [];\n      logService.trace(\"[format][provideDocumentRangeFormattingEdits] (response)\", (_provider$extensionId4 = provider.extensionId) === null || _provider$extensionId4 === void 0 ? void 0 : _provider$extensionId4.value, result);\n      rawEditsList.push(result);\n    } else {\n      for (const range of ranges) {\n        if (cts.token.isCancellationRequested) {\n          return true;\n        }\n        rawEditsList.push(await computeEdits(range));\n      }\n      for (let i = 0; i < ranges.length; ++i) {\n        for (let j = i + 1; j < ranges.length; ++j) {\n          if (cts.token.isCancellationRequested) {\n            return true;\n          }\n          if (hasIntersectingEdit(rawEditsList[i], rawEditsList[j])) {\n            // Merge ranges i and j into a single range, recompute the associated edits\n            const mergedRange = Range.plusRange(ranges[i], ranges[j]);\n            const edits = await computeEdits(mergedRange);\n            ranges.splice(j, 1);\n            ranges.splice(i, 1);\n            ranges.push(mergedRange);\n            rawEditsList.splice(j, 1);\n            rawEditsList.splice(i, 1);\n            rawEditsList.push(edits);\n            // Restart scanning\n            i = 0;\n            j = 0;\n          }\n        }\n      }\n    }\n    for (const rawEdits of rawEditsList) {\n      if (cts.token.isCancellationRequested) {\n        return true;\n      }\n      const minimalEdits = await workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n      if (minimalEdits) {\n        allEdits.push(...minimalEdits);\n      }\n    }\n  } finally {\n    cts.dispose();\n  }\n  if (allEdits.length === 0) {\n    return false;\n  }\n  if (isCodeEditor(editorOrModel)) {\n    // use editor to apply edits\n    FormattingEdit.execute(editorOrModel, allEdits, true);\n    editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* ScrollType.Immediate */);\n  } else {\n    // use model to apply edits\n    const [{\n      range\n    }] = allEdits;\n    const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    model.pushEditOperations([initialSelection], allEdits.map(edit => {\n      return {\n        text: edit.text,\n        range: Range.lift(edit.range),\n        forceMoveMarkers: true\n      };\n    }), undoEdits => {\n      for (const {\n        range\n      } of undoEdits) {\n        if (Range.areIntersectingOrTouching(range, initialSelection)) {\n          return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n        }\n      }\n      return null;\n    });\n  }\n  accessibilitySignalService.playSignal(AccessibilitySignal.format, {\n    userGesture\n  });\n  return true;\n}\nexport async function formatDocumentWithSelectedProvider(accessor, editorOrModel, mode, progress, token, userGesture) {\n  const instaService = accessor.get(IInstantiationService);\n  const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n  const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n  const provider = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, model);\n  const selected = await FormattingConflicts.select(provider, model, mode, 1 /* FormattingKind.File */);\n  if (selected) {\n    progress.report(selected);\n    await instaService.invokeFunction(formatDocumentWithProvider, selected, editorOrModel, mode, token, userGesture);\n  }\n}\nexport async function formatDocumentWithProvider(accessor, provider, editorOrModel, mode, token, userGesture) {\n  const workerService = accessor.get(IEditorWorkerService);\n  const accessibilitySignalService = accessor.get(IAccessibilitySignalService);\n  let model;\n  let cts;\n  if (isCodeEditor(editorOrModel)) {\n    model = editorOrModel.getModel();\n    cts = new EditorStateCancellationTokenSource(editorOrModel, 1 /* CodeEditorStateFlag.Value */ | 4 /* CodeEditorStateFlag.Position */, undefined, token);\n  } else {\n    model = editorOrModel;\n    cts = new TextModelCancellationTokenSource(editorOrModel, token);\n  }\n  let edits;\n  try {\n    const rawEdits = await provider.provideDocumentFormattingEdits(model, model.getFormattingOptions(), cts.token);\n    edits = await workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n    if (cts.token.isCancellationRequested) {\n      return true;\n    }\n  } finally {\n    cts.dispose();\n  }\n  if (!edits || edits.length === 0) {\n    return false;\n  }\n  if (isCodeEditor(editorOrModel)) {\n    // use editor to apply edits\n    FormattingEdit.execute(editorOrModel, edits, mode !== 2 /* FormattingMode.Silent */);\n    if (mode !== 2 /* FormattingMode.Silent */) {\n      editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* ScrollType.Immediate */);\n    }\n  } else {\n    // use model to apply edits\n    const [{\n      range\n    }] = edits;\n    const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    model.pushEditOperations([initialSelection], edits.map(edit => {\n      return {\n        text: edit.text,\n        range: Range.lift(edit.range),\n        forceMoveMarkers: true\n      };\n    }), undoEdits => {\n      for (const {\n        range\n      } of undoEdits) {\n        if (Range.areIntersectingOrTouching(range, initialSelection)) {\n          return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n        }\n      }\n      return null;\n    });\n  }\n  accessibilitySignalService.playSignal(AccessibilitySignal.format, {\n    userGesture\n  });\n  return true;\n}\nexport async function getDocumentRangeFormattingEditsUntilResult(workerService, languageFeaturesService, model, range, options, token) {\n  const providers = languageFeaturesService.documentRangeFormattingEditProvider.ordered(model);\n  for (const provider of providers) {\n    const rawEdits = await Promise.resolve(provider.provideDocumentRangeFormattingEdits(model, range, options, token)).catch(onUnexpectedExternalError);\n    if (isNonEmptyArray(rawEdits)) {\n      return await workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n    }\n  }\n  return undefined;\n}\nexport async function getDocumentFormattingEditsUntilResult(workerService, languageFeaturesService, model, options, token) {\n  const providers = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, model);\n  for (const provider of providers) {\n    const rawEdits = await Promise.resolve(provider.provideDocumentFormattingEdits(model, options, token)).catch(onUnexpectedExternalError);\n    if (isNonEmptyArray(rawEdits)) {\n      return await workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n    }\n  }\n  return undefined;\n}\nexport function getOnTypeFormattingEdits(workerService, languageFeaturesService, model, position, ch, options, token) {\n  const providers = languageFeaturesService.onTypeFormattingEditProvider.ordered(model);\n  if (providers.length === 0) {\n    return Promise.resolve(undefined);\n  }\n  if (providers[0].autoFormatTriggerCharacters.indexOf(ch) < 0) {\n    return Promise.resolve(undefined);\n  }\n  return Promise.resolve(providers[0].provideOnTypeFormattingEdits(model, position, ch, options, token)).catch(onUnexpectedExternalError).then(edits => {\n    return workerService.computeMoreMinimalEdits(model.uri, edits);\n  });\n}\nCommandsRegistry.registerCommand('_executeFormatRangeProvider', async function (accessor) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  const [resource, range, options] = args;\n  assertType(URI.isUri(resource));\n  assertType(Range.isIRange(range));\n  const resolverService = accessor.get(ITextModelService);\n  const workerService = accessor.get(IEditorWorkerService);\n  const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n  const reference = await resolverService.createModelReference(resource);\n  try {\n    return getDocumentRangeFormattingEditsUntilResult(workerService, languageFeaturesService, reference.object.textEditorModel, Range.lift(range), options, CancellationToken.None);\n  } finally {\n    reference.dispose();\n  }\n});\nCommandsRegistry.registerCommand('_executeFormatDocumentProvider', async function (accessor) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n  const [resource, options] = args;\n  assertType(URI.isUri(resource));\n  const resolverService = accessor.get(ITextModelService);\n  const workerService = accessor.get(IEditorWorkerService);\n  const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n  const reference = await resolverService.createModelReference(resource);\n  try {\n    return getDocumentFormattingEditsUntilResult(workerService, languageFeaturesService, reference.object.textEditorModel, options, CancellationToken.None);\n  } finally {\n    reference.dispose();\n  }\n});\nCommandsRegistry.registerCommand('_executeFormatOnTypeProvider', async function (accessor) {\n  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    args[_key3 - 1] = arguments[_key3];\n  }\n  const [resource, position, ch, options] = args;\n  assertType(URI.isUri(resource));\n  assertType(Position.isIPosition(position));\n  assertType(typeof ch === 'string');\n  const resolverService = accessor.get(ITextModelService);\n  const workerService = accessor.get(IEditorWorkerService);\n  const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n  const reference = await resolverService.createModelReference(resource);\n  try {\n    return getOnTypeFormattingEdits(workerService, languageFeaturesService, reference.object.textEditorModel, Position.lift(position), ch, options, CancellationToken.None);\n  } finally {\n    reference.dispose();\n  }\n});","map":{"version":3,"names":["asArray","isNonEmptyArray","CancellationToken","onUnexpectedExternalError","Iterable","LinkedList","assertType","URI","EditorStateCancellationTokenSource","TextModelCancellationTokenSource","isCodeEditor","Position","Range","Selection","IEditorWorkerService","ITextModelService","FormattingEdit","CommandsRegistry","ExtensionIdentifierSet","IInstantiationService","ILanguageFeaturesService","ILogService","AccessibilitySignal","IAccessibilitySignalService","getRealAndSyntheticDocumentFormattersOrdered","documentFormattingEditProvider","documentRangeFormattingEditProvider","model","result","seen","docFormatter","ordered","formatter","push","extensionId","add","rangeFormatter","has","displayName","provideDocumentFormattingEdits","options","token","provideDocumentRangeFormattingEdits","getFullModelRange","FormattingConflicts","setFormatterSelector","selector","remove","_selectors","unshift","dispose","select","document","mode","kind","length","undefined","first","_FormattingConflicts","formatDocumentRangesWithSelectedProvider","accessor","editorOrModel","rangeOrRanges","progress","userGesture","instaService","get","documentRangeFormattingEditProviderRegistry","getModel","provider","selected","report","invokeFunction","formatDocumentRangesWithProvider","workerService","logService","accessibilitySignalService","cts","ranges","len","range","sort","compareRangesUsingStarts","areIntersectingOrTouching","fromPositions","getStartPosition","getEndPosition","computeEdits","_provider$extensionId","_provider$extensionId2","trace","value","getFormattingOptions","hasIntersectingEdit","a","b","mergedA","reduce","acc","val","plusRange","some","x","intersectRanges","edit","otherEdit","allEdits","rawEditsList","provideDocumentRangesFormattingEdits","_provider$extensionId3","_provider$extensionId4","isCancellationRequested","i","j","mergedRange","edits","splice","rawEdits","minimalEdits","computeMoreMinimalEdits","uri","execute","revealPositionInCenterIfOutsideViewport","getPosition","initialSelection","startLineNumber","startColumn","endLineNumber","endColumn","pushEditOperations","map","text","lift","forceMoveMarkers","undoEdits","playSignal","format","formatDocumentWithSelectedProvider","languageFeaturesService","formatDocumentWithProvider","getDocumentRangeFormattingEditsUntilResult","providers","Promise","resolve","catch","getDocumentFormattingEditsUntilResult","getOnTypeFormattingEdits","position","ch","onTypeFormattingEditProvider","autoFormatTriggerCharacters","indexOf","provideOnTypeFormattingEdits","then","registerCommand","_len","arguments","args","Array","_key","resource","isUri","isIRange","resolverService","reference","createModelReference","object","textEditorModel","None","_len2","_key2","_len3","_key3","isIPosition"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/editor/contrib/format/browser/format.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { asArray, isNonEmptyArray } from '../../../../base/common/arrays.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { LinkedList } from '../../../../base/common/linkedList.js';\nimport { assertType } from '../../../../base/common/types.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { EditorStateCancellationTokenSource, TextModelCancellationTokenSource } from '../../editorState/browser/editorState.js';\nimport { isCodeEditor } from '../../../browser/editorBrowser.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { IEditorWorkerService } from '../../../common/services/editorWorker.js';\nimport { ITextModelService } from '../../../common/services/resolverService.js';\nimport { FormattingEdit } from './formattingEdit.js';\nimport { CommandsRegistry } from '../../../../platform/commands/common/commands.js';\nimport { ExtensionIdentifierSet } from '../../../../platform/extensions/common/extensions.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { AccessibilitySignal, IAccessibilitySignalService } from '../../../../platform/accessibilitySignal/browser/accessibilitySignalService.js';\nexport function getRealAndSyntheticDocumentFormattersOrdered(documentFormattingEditProvider, documentRangeFormattingEditProvider, model) {\n    const result = [];\n    const seen = new ExtensionIdentifierSet();\n    // (1) add all document formatter\n    const docFormatter = documentFormattingEditProvider.ordered(model);\n    for (const formatter of docFormatter) {\n        result.push(formatter);\n        if (formatter.extensionId) {\n            seen.add(formatter.extensionId);\n        }\n    }\n    // (2) add all range formatter as document formatter (unless the same extension already did that)\n    const rangeFormatter = documentRangeFormattingEditProvider.ordered(model);\n    for (const formatter of rangeFormatter) {\n        if (formatter.extensionId) {\n            if (seen.has(formatter.extensionId)) {\n                continue;\n            }\n            seen.add(formatter.extensionId);\n        }\n        result.push({\n            displayName: formatter.displayName,\n            extensionId: formatter.extensionId,\n            provideDocumentFormattingEdits(model, options, token) {\n                return formatter.provideDocumentRangeFormattingEdits(model, model.getFullModelRange(), options, token);\n            }\n        });\n    }\n    return result;\n}\nexport class FormattingConflicts {\n    static { this._selectors = new LinkedList(); }\n    static setFormatterSelector(selector) {\n        const remove = FormattingConflicts._selectors.unshift(selector);\n        return { dispose: remove };\n    }\n    static async select(formatter, document, mode, kind) {\n        if (formatter.length === 0) {\n            return undefined;\n        }\n        const selector = Iterable.first(FormattingConflicts._selectors);\n        if (selector) {\n            return await selector(formatter, document, mode, kind);\n        }\n        return undefined;\n    }\n}\nexport async function formatDocumentRangesWithSelectedProvider(accessor, editorOrModel, rangeOrRanges, mode, progress, token, userGesture) {\n    const instaService = accessor.get(IInstantiationService);\n    const { documentRangeFormattingEditProvider: documentRangeFormattingEditProviderRegistry } = accessor.get(ILanguageFeaturesService);\n    const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n    const provider = documentRangeFormattingEditProviderRegistry.ordered(model);\n    const selected = await FormattingConflicts.select(provider, model, mode, 2 /* FormattingKind.Selection */);\n    if (selected) {\n        progress.report(selected);\n        await instaService.invokeFunction(formatDocumentRangesWithProvider, selected, editorOrModel, rangeOrRanges, token, userGesture);\n    }\n}\nexport async function formatDocumentRangesWithProvider(accessor, provider, editorOrModel, rangeOrRanges, token, userGesture) {\n    const workerService = accessor.get(IEditorWorkerService);\n    const logService = accessor.get(ILogService);\n    const accessibilitySignalService = accessor.get(IAccessibilitySignalService);\n    let model;\n    let cts;\n    if (isCodeEditor(editorOrModel)) {\n        model = editorOrModel.getModel();\n        cts = new EditorStateCancellationTokenSource(editorOrModel, 1 /* CodeEditorStateFlag.Value */ | 4 /* CodeEditorStateFlag.Position */, undefined, token);\n    }\n    else {\n        model = editorOrModel;\n        cts = new TextModelCancellationTokenSource(editorOrModel, token);\n    }\n    // make sure that ranges don't overlap nor touch each other\n    const ranges = [];\n    let len = 0;\n    for (const range of asArray(rangeOrRanges).sort(Range.compareRangesUsingStarts)) {\n        if (len > 0 && Range.areIntersectingOrTouching(ranges[len - 1], range)) {\n            ranges[len - 1] = Range.fromPositions(ranges[len - 1].getStartPosition(), range.getEndPosition());\n        }\n        else {\n            len = ranges.push(range);\n        }\n    }\n    const computeEdits = async (range) => {\n        logService.trace(`[format][provideDocumentRangeFormattingEdits] (request)`, provider.extensionId?.value, range);\n        const result = (await provider.provideDocumentRangeFormattingEdits(model, range, model.getFormattingOptions(), cts.token)) || [];\n        logService.trace(`[format][provideDocumentRangeFormattingEdits] (response)`, provider.extensionId?.value, result);\n        return result;\n    };\n    const hasIntersectingEdit = (a, b) => {\n        if (!a.length || !b.length) {\n            return false;\n        }\n        // quick exit if the list of ranges are completely unrelated [O(n)]\n        const mergedA = a.reduce((acc, val) => { return Range.plusRange(acc, val.range); }, a[0].range);\n        if (!b.some(x => { return Range.intersectRanges(mergedA, x.range); })) {\n            return false;\n        }\n        // fallback to a complete check [O(n^2)]\n        for (const edit of a) {\n            for (const otherEdit of b) {\n                if (Range.intersectRanges(edit.range, otherEdit.range)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    const allEdits = [];\n    const rawEditsList = [];\n    try {\n        if (typeof provider.provideDocumentRangesFormattingEdits === 'function') {\n            logService.trace(`[format][provideDocumentRangeFormattingEdits] (request)`, provider.extensionId?.value, ranges);\n            const result = (await provider.provideDocumentRangesFormattingEdits(model, ranges, model.getFormattingOptions(), cts.token)) || [];\n            logService.trace(`[format][provideDocumentRangeFormattingEdits] (response)`, provider.extensionId?.value, result);\n            rawEditsList.push(result);\n        }\n        else {\n            for (const range of ranges) {\n                if (cts.token.isCancellationRequested) {\n                    return true;\n                }\n                rawEditsList.push(await computeEdits(range));\n            }\n            for (let i = 0; i < ranges.length; ++i) {\n                for (let j = i + 1; j < ranges.length; ++j) {\n                    if (cts.token.isCancellationRequested) {\n                        return true;\n                    }\n                    if (hasIntersectingEdit(rawEditsList[i], rawEditsList[j])) {\n                        // Merge ranges i and j into a single range, recompute the associated edits\n                        const mergedRange = Range.plusRange(ranges[i], ranges[j]);\n                        const edits = await computeEdits(mergedRange);\n                        ranges.splice(j, 1);\n                        ranges.splice(i, 1);\n                        ranges.push(mergedRange);\n                        rawEditsList.splice(j, 1);\n                        rawEditsList.splice(i, 1);\n                        rawEditsList.push(edits);\n                        // Restart scanning\n                        i = 0;\n                        j = 0;\n                    }\n                }\n            }\n        }\n        for (const rawEdits of rawEditsList) {\n            if (cts.token.isCancellationRequested) {\n                return true;\n            }\n            const minimalEdits = await workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n            if (minimalEdits) {\n                allEdits.push(...minimalEdits);\n            }\n        }\n    }\n    finally {\n        cts.dispose();\n    }\n    if (allEdits.length === 0) {\n        return false;\n    }\n    if (isCodeEditor(editorOrModel)) {\n        // use editor to apply edits\n        FormattingEdit.execute(editorOrModel, allEdits, true);\n        editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* ScrollType.Immediate */);\n    }\n    else {\n        // use model to apply edits\n        const [{ range }] = allEdits;\n        const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n        model.pushEditOperations([initialSelection], allEdits.map(edit => {\n            return {\n                text: edit.text,\n                range: Range.lift(edit.range),\n                forceMoveMarkers: true\n            };\n        }), undoEdits => {\n            for (const { range } of undoEdits) {\n                if (Range.areIntersectingOrTouching(range, initialSelection)) {\n                    return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n                }\n            }\n            return null;\n        });\n    }\n    accessibilitySignalService.playSignal(AccessibilitySignal.format, { userGesture });\n    return true;\n}\nexport async function formatDocumentWithSelectedProvider(accessor, editorOrModel, mode, progress, token, userGesture) {\n    const instaService = accessor.get(IInstantiationService);\n    const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n    const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n    const provider = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, model);\n    const selected = await FormattingConflicts.select(provider, model, mode, 1 /* FormattingKind.File */);\n    if (selected) {\n        progress.report(selected);\n        await instaService.invokeFunction(formatDocumentWithProvider, selected, editorOrModel, mode, token, userGesture);\n    }\n}\nexport async function formatDocumentWithProvider(accessor, provider, editorOrModel, mode, token, userGesture) {\n    const workerService = accessor.get(IEditorWorkerService);\n    const accessibilitySignalService = accessor.get(IAccessibilitySignalService);\n    let model;\n    let cts;\n    if (isCodeEditor(editorOrModel)) {\n        model = editorOrModel.getModel();\n        cts = new EditorStateCancellationTokenSource(editorOrModel, 1 /* CodeEditorStateFlag.Value */ | 4 /* CodeEditorStateFlag.Position */, undefined, token);\n    }\n    else {\n        model = editorOrModel;\n        cts = new TextModelCancellationTokenSource(editorOrModel, token);\n    }\n    let edits;\n    try {\n        const rawEdits = await provider.provideDocumentFormattingEdits(model, model.getFormattingOptions(), cts.token);\n        edits = await workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n        if (cts.token.isCancellationRequested) {\n            return true;\n        }\n    }\n    finally {\n        cts.dispose();\n    }\n    if (!edits || edits.length === 0) {\n        return false;\n    }\n    if (isCodeEditor(editorOrModel)) {\n        // use editor to apply edits\n        FormattingEdit.execute(editorOrModel, edits, mode !== 2 /* FormattingMode.Silent */);\n        if (mode !== 2 /* FormattingMode.Silent */) {\n            editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* ScrollType.Immediate */);\n        }\n    }\n    else {\n        // use model to apply edits\n        const [{ range }] = edits;\n        const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n        model.pushEditOperations([initialSelection], edits.map(edit => {\n            return {\n                text: edit.text,\n                range: Range.lift(edit.range),\n                forceMoveMarkers: true\n            };\n        }), undoEdits => {\n            for (const { range } of undoEdits) {\n                if (Range.areIntersectingOrTouching(range, initialSelection)) {\n                    return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n                }\n            }\n            return null;\n        });\n    }\n    accessibilitySignalService.playSignal(AccessibilitySignal.format, { userGesture });\n    return true;\n}\nexport async function getDocumentRangeFormattingEditsUntilResult(workerService, languageFeaturesService, model, range, options, token) {\n    const providers = languageFeaturesService.documentRangeFormattingEditProvider.ordered(model);\n    for (const provider of providers) {\n        const rawEdits = await Promise.resolve(provider.provideDocumentRangeFormattingEdits(model, range, options, token)).catch(onUnexpectedExternalError);\n        if (isNonEmptyArray(rawEdits)) {\n            return await workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n        }\n    }\n    return undefined;\n}\nexport async function getDocumentFormattingEditsUntilResult(workerService, languageFeaturesService, model, options, token) {\n    const providers = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, model);\n    for (const provider of providers) {\n        const rawEdits = await Promise.resolve(provider.provideDocumentFormattingEdits(model, options, token)).catch(onUnexpectedExternalError);\n        if (isNonEmptyArray(rawEdits)) {\n            return await workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n        }\n    }\n    return undefined;\n}\nexport function getOnTypeFormattingEdits(workerService, languageFeaturesService, model, position, ch, options, token) {\n    const providers = languageFeaturesService.onTypeFormattingEditProvider.ordered(model);\n    if (providers.length === 0) {\n        return Promise.resolve(undefined);\n    }\n    if (providers[0].autoFormatTriggerCharacters.indexOf(ch) < 0) {\n        return Promise.resolve(undefined);\n    }\n    return Promise.resolve(providers[0].provideOnTypeFormattingEdits(model, position, ch, options, token)).catch(onUnexpectedExternalError).then(edits => {\n        return workerService.computeMoreMinimalEdits(model.uri, edits);\n    });\n}\nCommandsRegistry.registerCommand('_executeFormatRangeProvider', async function (accessor, ...args) {\n    const [resource, range, options] = args;\n    assertType(URI.isUri(resource));\n    assertType(Range.isIRange(range));\n    const resolverService = accessor.get(ITextModelService);\n    const workerService = accessor.get(IEditorWorkerService);\n    const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n    const reference = await resolverService.createModelReference(resource);\n    try {\n        return getDocumentRangeFormattingEditsUntilResult(workerService, languageFeaturesService, reference.object.textEditorModel, Range.lift(range), options, CancellationToken.None);\n    }\n    finally {\n        reference.dispose();\n    }\n});\nCommandsRegistry.registerCommand('_executeFormatDocumentProvider', async function (accessor, ...args) {\n    const [resource, options] = args;\n    assertType(URI.isUri(resource));\n    const resolverService = accessor.get(ITextModelService);\n    const workerService = accessor.get(IEditorWorkerService);\n    const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n    const reference = await resolverService.createModelReference(resource);\n    try {\n        return getDocumentFormattingEditsUntilResult(workerService, languageFeaturesService, reference.object.textEditorModel, options, CancellationToken.None);\n    }\n    finally {\n        reference.dispose();\n    }\n});\nCommandsRegistry.registerCommand('_executeFormatOnTypeProvider', async function (accessor, ...args) {\n    const [resource, position, ch, options] = args;\n    assertType(URI.isUri(resource));\n    assertType(Position.isIPosition(position));\n    assertType(typeof ch === 'string');\n    const resolverService = accessor.get(ITextModelService);\n    const workerService = accessor.get(IEditorWorkerService);\n    const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n    const reference = await resolverService.createModelReference(resource);\n    try {\n        return getOnTypeFormattingEdits(workerService, languageFeaturesService, reference.object.textEditorModel, Position.lift(position), ch, options, CancellationToken.None);\n    }\n    finally {\n        reference.dispose();\n    }\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}