{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport InternalMouseEvent from '../event/InternalMouseEvent';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport { getClientX, getClientY, isAltDown, isConsumed, isControlDown, isLeftMouseButton, isMetaDown, isMouseEvent, isMultiTouchEvent, isPenEvent, isPopupTrigger, isShiftDown, isTouchEvent } from '../../util/EventUtils';\nimport Point from '../geometry/Point';\nimport { mixInto } from '../../util/Utils';\nimport { convertPoint } from '../../util/styleUtils';\nimport { NONE } from '../../util/Constants';\nimport Client from '../../Client';\nimport { Graph } from '../Graph';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst EventsMixin = {\n  // TODO: Document me!\n  lastTouchEvent: null,\n  doubleClickCounter: 0,\n  lastTouchCell: null,\n  fireDoubleClick: null,\n  tapAndHoldThread: null,\n  lastMouseX: null,\n  lastMouseY: null,\n  isMouseTrigger: null,\n  ignoreMouseEvents: null,\n  mouseMoveRedirect: null,\n  mouseUpRedirect: null,\n  lastEvent: null,\n  /**\n   * Specifies if {@link KeyHandler} should invoke {@link escape} when the escape key\n   * is pressed.\n   * @default true\n   */\n  escapeEnabled: true,\n  /**\n   * If `true`, when editing is to be stopped by way of selection changing,\n   * data in diagram changing or other means stopCellEditing is invoked, and\n   * changes are saved. This is implemented in a focus handler in\n   * {@link CellEditorHandler}.\n   * @default true\n   */\n  invokesStopCellEditing: true,\n  /**\n   * If `true`, pressing the enter key without pressing control or shift will stop\n   * editing and accept the new value. This is used in {@link CellEditorHandler} to stop\n   * cell editing. Note: You can always use F2 and escape to stop editing.\n   * @default false\n   */\n  enterStopsCellEditing: false,\n  /**\n   * Holds the state of the mouse button.\n   */\n  isMouseDown: false,\n  /**\n   * Specifies if native double click events should be detected.\n   * @default true\n   */\n  nativeDblClickEnabled: true,\n  /**\n   * Specifies if double taps on touch-based devices should be handled as a\n   * double click.\n   * @default true\n   */\n  doubleTapEnabled: true,\n  /**\n   * Specifies the timeout in milliseconds for double taps and non-native double clicks.\n   * @default 500\n   */\n  doubleTapTimeout: 500,\n  /**\n   * Specifies the tolerance in pixels for double taps and double clicks in quirks mode.\n   * @default 25\n   */\n  doubleTapTolerance: 25,\n  /**\n   * Holds the x-coordinate of the last touch event for double tap detection.\n   */\n  lastTouchX: 0,\n  /**\n   * Holds the x-coordinate of the last touch event for double tap detection.\n   */\n  lastTouchY: 0,\n  /**\n   * Holds the time of the last touch event for double click detection.\n   */\n  lastTouchTime: 0,\n  /**\n   * Specifies if tap and hold should be used for starting connections on touch-based\n   * devices.\n   * @default true\n   */\n  tapAndHoldEnabled: true,\n  /**\n   * Specifies the time in milliseconds for a tap and hold.\n   * @default 500\n   */\n  tapAndHoldDelay: 500,\n  /**\n   * `True` if the timer for tap and hold events is running.\n   */\n  tapAndHoldInProgress: false,\n  /**\n   * `True` as long as the timer is running and the touch events\n   * stay within the given {@link tapAndHoldTolerance}.\n   */\n  tapAndHoldValid: false,\n  /**\n   * Holds the x-coordinate of the initial touch event for tap and hold.\n   */\n  initialTouchX: 0,\n  /**\n   * Holds the y-coordinate of the initial touch event for tap and hold.\n   */\n  initialTouchY: 0,\n  /**\n   * Tolerance in pixels for a move to be handled as a single click.\n   * @default 4\n   */\n  tolerance: 4,\n  isNativeDblClickEnabled() {\n    return this.nativeDblClickEnabled;\n  },\n  getEventTolerance() {\n    return this.tolerance;\n  },\n  setEventTolerance(tolerance) {\n    this.tolerance = tolerance;\n  },\n  /*****************************************************************************\n   * Group: Event processing\n   *****************************************************************************/\n  /**\n   * Processes an escape keystroke.\n   *\n   * @param evt Mouseevent that represents the keystroke.\n   */\n  escape(evt) {\n    this.fireEvent(new EventObject(InternalEvent.ESCAPE, {\n      event: evt\n    }));\n  },\n  /**\n   * Processes a singleclick on an optional cell and fires a {@link click} event.\n   * The click event is fired initially. If the graph is enabled and the\n   * event has not been consumed, then the cell is selected using\n   * {@link selectCellForEvent} or the selection is cleared using\n   * {@link clearSelection}. The events consumed state is set to true if the\n   * corresponding {@link InternalMouseEvent} has been consumed.\n   *\n   * To handle a click event, use the following code.\n   *\n   * ```javascript\n   * graph.addListener(mxEvent.CLICK, function(sender, evt)\n   * {\n   *   var e = evt.getProperty('event'); // mouse event\n   *   var cell = evt.getProperty('cell'); // cell may be null\n   *\n   *   if (cell != null)\n   *   {\n   *     // Do something useful with cell and consume the event\n   *     evt.consume();\n   *   }\n   * });\n   * ```\n   *\n   * @param me {@link mxMouseEvent} that represents the single click.\n   */\n  click(me) {\n    const evt = me.getEvent();\n    let cell = me.getCell();\n    const mxe = new EventObject(InternalEvent.CLICK, {\n      event: evt,\n      cell\n    });\n    if (me.isConsumed()) {\n      mxe.consume();\n    }\n    this.fireEvent(mxe);\n    if (this.isEnabled() && !isConsumed(evt) && !mxe.isConsumed()) {\n      if (cell) {\n        if (this.isTransparentClickEvent(evt)) {\n          let active = false;\n          const tmp = this.getCellAt(me.graphX, me.graphY, null, false, false, state => {\n            const selected = this.isCellSelected(state.cell);\n            active = active || selected;\n            return !active || selected || state.cell !== cell && state.cell.isAncestor(cell);\n          });\n          if (tmp) {\n            cell = tmp;\n          }\n        }\n      } else if (this.isSwimlaneSelectionEnabled()) {\n        cell = this.getSwimlaneAt(me.getGraphX(), me.getGraphY());\n        if (cell != null && (!this.isToggleEvent(evt) || !isAltDown(evt))) {\n          let temp = cell;\n          let swimlanes = [];\n          while (temp != null) {\n            temp = temp.getParent();\n            const state = this.getView().getState(temp);\n            if (this.isSwimlane(temp) && state != null) {\n              swimlanes.push(temp);\n            }\n          }\n          // Selects ancestors for selected swimlanes\n          if (swimlanes.length > 0) {\n            swimlanes = swimlanes.reverse();\n            swimlanes.splice(0, 0, cell);\n            swimlanes.push(cell);\n            for (let i = 0; i < swimlanes.length - 1; i += 1) {\n              if (this.isCellSelected(swimlanes[i])) {\n                cell = swimlanes[this.isToggleEvent(evt) ? i : i + 1];\n              }\n            }\n          }\n        }\n      }\n      if (cell) {\n        this.selectCellForEvent(cell, evt);\n      } else if (!this.isToggleEvent(evt)) {\n        this.clearSelection();\n      }\n    }\n    return false;\n  },\n  /**\n   * Processes a doubleclick on an optional cell and fires a {@link dblclick}\n   * event. The event is fired initially. If the graph is enabled and the\n   * event has not been consumed, then {@link edit} is called with the given\n   * cell. The event is ignored if no cell was specified.\n   *\n   * Example for overriding this method.\n   *\n   * ```javascript\n   * graph.dblClick = function(evt, cell)\n   * {\n   *   var mxe = new mxEventObject(mxEvent.DOUBLE_CLICK, 'event', evt, 'cell', cell);\n   *   this.fireEvent(mxe);\n   *\n   *   if (this.isEnabled() && !mxEvent.isConsumed(evt) && !mxe.isConsumed())\n   *   {\n   * \t   mxUtils.alert('Hello, World!');\n   *     mxe.consume();\n   *   }\n   * }\n   * ```\n   *\n   * Example listener for this event.\n   *\n   * ```javascript\n   * graph.addListener(mxEvent.DOUBLE_CLICK, function(sender, evt)\n   * {\n   *   var cell = evt.getProperty('cell');\n   *   // do something with the cell and consume the\n   *   // event to prevent in-place editing from start\n   * });\n   * ```\n   *\n   * @param evt Mouseevent that represents the doubleclick.\n   * @param cell Optional {@link Cell} under the mousepointer.\n   */\n  dblClick(evt) {\n    let cell = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const mxe = new EventObject(InternalEvent.DOUBLE_CLICK, {\n      event: evt,\n      cell\n    });\n    this.fireEvent(mxe);\n    // Handles the event if it has not been consumed\n    if (this.isEnabled() && !isConsumed(evt) && !mxe.isConsumed() && cell && this.isCellEditable(cell) && !this.isEditing(cell)) {\n      this.startEditingAtCell(cell, evt);\n      InternalEvent.consume(evt);\n    }\n  },\n  /**\n   * Handles the {@link InternalMouseEvent} by highlighting the {@link CellState}.\n   *\n   * @param me {@link mxMouseEvent} that represents the touch event.\n   * @param state Optional {@link CellState} that is associated with the event.\n   */\n  tapAndHold(me) {\n    const evt = me.getEvent();\n    const mxe = new EventObject(InternalEvent.TAP_AND_HOLD, {\n      event: evt,\n      cell: me.getCell()\n    });\n    const panningHandler = this.getPlugin('PanningHandler');\n    const connectionHandler = this.getPlugin('ConnectionHandler');\n    // LATER: Check if event should be consumed if me is consumed\n    this.fireEvent(mxe);\n    if (mxe.isConsumed()) {\n      // Resets the state of the panning handler\n      panningHandler && (panningHandler.panningTrigger = false);\n    }\n    // Handles the event if it has not been consumed\n    if (this.isEnabled() && !isConsumed(evt) && !mxe.isConsumed() && connectionHandler && connectionHandler.isEnabled()) {\n      const cell = connectionHandler.marker.getCell(me);\n      if (cell) {\n        const state = this.getView().getState(cell);\n        if (state) {\n          connectionHandler.marker.currentColor = connectionHandler.marker.validColor;\n          connectionHandler.marker.markedState = state;\n          connectionHandler.marker.mark();\n          connectionHandler.first = new Point(me.getGraphX(), me.getGraphY());\n          connectionHandler.edgeState = connectionHandler.createEdgeState(me);\n          connectionHandler.previous = state;\n          connectionHandler.fireEvent(new EventObject(InternalEvent.START, {\n            state: connectionHandler.previous\n          }));\n        }\n      }\n    }\n  },\n  /*****************************************************************************\n   * Group: Graph events\n   *****************************************************************************/\n  /**\n   * Adds a listener to the graph event dispatch loop. The listener\n   * must implement the mouseDown, mouseMove and mouseUp methods\n   * as shown in the {@link InternalMouseEvent} class.\n   *\n   * @param listener Listener to be added to the graph event listeners.\n   */\n  addMouseListener(listener) {\n    this.mouseListeners.push(listener);\n  },\n  /**\n   * Removes the specified graph listener.\n   *\n   * @param listener Listener to be removed from the graph event listeners.\n   */\n  removeMouseListener(listener) {\n    for (let i = 0; i < this.mouseListeners.length; i += 1) {\n      if (this.mouseListeners[i] === listener) {\n        this.mouseListeners.splice(i, 1);\n        break;\n      }\n    }\n  },\n  /**\n   * Sets the graphX and graphY properties if the given {@link InternalMouseEvent} if\n   * required and returned the event.\n   *\n   * @param me {@link mxMouseEvent} to be updated.\n   * @param evtName Name of the mouse event.\n   */\n  updateMouseEvent(me, evtName) {\n    const pt = convertPoint(this.getContainer(), me.getX(), me.getY());\n    me.graphX = pt.x - this.getPanDx();\n    me.graphY = pt.y - this.getPanDy();\n    // Searches for rectangles using method if native hit detection is disabled on shape\n    if (!me.getCell() && this.isMouseDown && evtName === InternalEvent.MOUSE_MOVE) {\n      const cell = this.getCellAt(pt.x, pt.y, null, true, true, state => {\n        return !state.shape || state.shape.paintBackground !== this.paintBackground || state.style.pointerEvents || state.shape.fill !== NONE;\n      });\n      me.state = cell ? this.getView().getState(cell) : null;\n    }\n    return me;\n  },\n  /**\n   * Returns the state for the given touch event.\n   */\n  getStateForTouchEvent(evt) {\n    const x = getClientX(evt);\n    const y = getClientY(evt);\n    // Dispatches the drop event to the graph which\n    // consumes and executes the source function\n    const pt = convertPoint(this.getContainer(), x, y);\n    const cell = this.getCellAt(pt.x, pt.y);\n    return cell ? this.getView().getState(cell) : null;\n  },\n  /**\n   * Returns true if the event should be ignored in {@link fireMouseEvent}.\n   */\n  isEventIgnored(evtName, me, sender) {\n    const mouseEvent = isMouseEvent(me.getEvent());\n    let result = false;\n    // Drops events that are fired more than once\n    if (me.getEvent() === this.lastEvent) {\n      result = true;\n    } else {\n      this.lastEvent = me.getEvent();\n    }\n    // Installs event listeners to capture the complete gesture from the event source\n    // for non-MS touch events as a workaround for all events for the same geture being\n    // fired from the event source even if that was removed from the DOM.\n    const eventSource = this.getEventSource();\n    if (eventSource && evtName !== InternalEvent.MOUSE_MOVE) {\n      InternalEvent.removeGestureListeners(eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);\n      this.mouseMoveRedirect = null;\n      this.mouseUpRedirect = null;\n      this.setEventSource(null);\n    } else if (!Client.IS_GC && eventSource && me.getSource() !== eventSource) {\n      result = true;\n    } else if (eventSource && Client.IS_TOUCH && evtName === InternalEvent.MOUSE_DOWN && !mouseEvent && !isPenEvent(me.getEvent())) {\n      this.setEventSource(me.getSource());\n      this.mouseMoveRedirect = evt => {\n        this.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, this.getStateForTouchEvent(evt)));\n      }, this.mouseUpRedirect = evt => {\n        this.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt, this.getStateForTouchEvent(evt)));\n      }, InternalEvent.addGestureListeners(eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);\n    }\n    // Factored out the workarounds for FF to make it easier to override/remove\n    // Note this method has side-effects!\n    if (this.isSyntheticEventIgnored(evtName, me, sender)) {\n      result = true;\n    }\n    // Never fires mouseUp/-Down for double clicks\n    if (!isPopupTrigger(this.lastEvent) && evtName !== InternalEvent.MOUSE_MOVE && this.lastEvent.detail === 2) {\n      return true;\n    }\n    // Filters out of sequence events or mixed event types during a gesture\n    if (evtName === InternalEvent.MOUSE_UP && this.isMouseDown) {\n      this.isMouseDown = false;\n    } else if (evtName === InternalEvent.MOUSE_DOWN && !this.isMouseDown) {\n      this.isMouseDown = true;\n      this.isMouseTrigger = mouseEvent;\n    }\n    // Drops mouse events that are fired during touch gestures as a workaround for Webkit\n    // and mouse events that are not in sync with the current internal button state\n    else if (!result && ((!Client.IS_FF || evtName !== InternalEvent.MOUSE_MOVE) && this.isMouseDown && this.isMouseTrigger !== mouseEvent || evtName === InternalEvent.MOUSE_DOWN && this.isMouseDown || evtName === InternalEvent.MOUSE_UP && !this.isMouseDown)) {\n      result = true;\n    }\n    if (!result && evtName === InternalEvent.MOUSE_DOWN) {\n      this.lastMouseX = me.getX();\n      this.lastMouseY = me.getY();\n    }\n    return result;\n  },\n  /**\n   * Hook for ignoring synthetic mouse events after touchend in Firefox.\n   */\n  isSyntheticEventIgnored(evtName, me, sender) {\n    let result = false;\n    const mouseEvent = isMouseEvent(me.getEvent());\n    // LATER: This does not cover all possible cases that can go wrong in FF\n    if (this.ignoreMouseEvents && mouseEvent && evtName !== InternalEvent.MOUSE_MOVE) {\n      this.ignoreMouseEvents = evtName !== InternalEvent.MOUSE_UP;\n      result = true;\n    } else if (Client.IS_FF && !mouseEvent && evtName === InternalEvent.MOUSE_UP) {\n      this.ignoreMouseEvents = true;\n    }\n    return result;\n  },\n  /**\n   * Returns true if the event should be ignored in {@link fireMouseEvent}. This\n   * implementation returns true for select, option and input (if not of type\n   * checkbox, radio, button, submit or file) event sources if the event is not\n   * a mouse event or a left mouse button press event.\n   *\n   * @param evtName The name of the event.\n   * @param me {@link mxMouseEvent} that should be ignored.\n   */\n  isEventSourceIgnored(evtName, me) {\n    const source = me.getSource();\n    if (!source) return true;\n    // @ts-ignore nodeName could exist\n    const name = source.nodeName ? source.nodeName.toLowerCase() : '';\n    const candidate = !isMouseEvent(me.getEvent()) || isLeftMouseButton(me.getEvent());\n    return evtName === InternalEvent.MOUSE_DOWN && candidate && (name === 'select' || name === 'option' || name === 'input' &&\n    // @ts-ignore type could exist\n    source.type !== 'checkbox' &&\n    // @ts-ignore type could exist\n    source.type !== 'radio' &&\n    // @ts-ignore type could exist\n    source.type !== 'button' &&\n    // @ts-ignore type could exist\n    source.type !== 'submit' &&\n    // @ts-ignore type could exist\n    source.type !== 'file');\n  },\n  /**\n   * Returns the {@link CellState} to be used when firing the mouse event for the\n   * given state. This implementation returns the given state.\n   *\n   * {@link CellState} - State whose event source should be returned.\n   */\n  getEventState(state) {\n    return state;\n  },\n  /**\n   * Dispatches the given event in the graph event dispatch loop. Possible\n   * event names are {@link InternalEvent.MOUSE_DOWN}, {@link InternalEvent.MOUSE_MOVE} and\n   * {@link InternalEvent.MOUSE_UP}. All listeners are invoked for all events regardless\n   * of the consumed state of the event.\n   *\n   * @param evtName String that specifies the type of event to be dispatched.\n   * @param me {@link mxMouseEvent} to be fired.\n   * @param sender Optional sender argument. Default is `this`.\n   */\n  fireMouseEvent(evtName, me, sender) {\n    var _sender;\n    sender = (_sender = sender) !== null && _sender !== void 0 ? _sender : this;\n    if (this.isEventSourceIgnored(evtName, me)) {\n      const tooltipHandler = this.getPlugin('TooltipHandler');\n      if (tooltipHandler) {\n        tooltipHandler.hide();\n      }\n      return;\n    }\n    // Updates the graph coordinates in the event\n    me = this.updateMouseEvent(me, evtName);\n    // Detects and processes double taps for touch-based devices which do not have native double click events\n    // or where detection of double click is not always possible (quirks, IE10+). Note that this can only handle\n    // double clicks on cells because the sequence of events in IE prevents detection on the background, it fires\n    // two mouse ups, one of which without a cell but no mousedown for the second click which means we cannot\n    // detect which mouseup(s) are part of the first click, ie we do not know when the first click ends.\n    if (!this.nativeDblClickEnabled && !isPopupTrigger(me.getEvent()) || this.doubleTapEnabled && Client.IS_TOUCH && (isTouchEvent(me.getEvent()) || isPenEvent(me.getEvent()))) {\n      const currentTime = new Date().getTime();\n      if (evtName === InternalEvent.MOUSE_DOWN) {\n        if (this.lastTouchEvent && this.lastTouchEvent !== me.getEvent() && currentTime - this.lastTouchTime < this.doubleTapTimeout && Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance && Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance && this.doubleClickCounter < 2) {\n          this.doubleClickCounter += 1;\n          let doubleClickFired = false;\n          if (evtName === InternalEvent.MOUSE_UP) {\n            if (me.getCell() === this.lastTouchCell && this.lastTouchCell) {\n              this.lastTouchTime = 0;\n              const cell = this.lastTouchCell;\n              this.lastTouchCell = null;\n              this.dblClick(me.getEvent(), cell);\n              doubleClickFired = true;\n            }\n          } else {\n            this.fireDoubleClick = true;\n            this.lastTouchTime = 0;\n          }\n          if (doubleClickFired) {\n            InternalEvent.consume(me.getEvent());\n            return;\n          }\n        } else if (!this.lastTouchEvent || this.lastTouchEvent !== me.getEvent()) {\n          this.lastTouchCell = me.getCell();\n          this.lastTouchX = me.getX();\n          this.lastTouchY = me.getY();\n          this.lastTouchTime = currentTime;\n          this.lastTouchEvent = me.getEvent();\n          this.doubleClickCounter = 0;\n        }\n      } else if ((this.isMouseDown || evtName === InternalEvent.MOUSE_UP) && this.fireDoubleClick) {\n        this.fireDoubleClick = false;\n        const cell = this.lastTouchCell;\n        this.lastTouchCell = null;\n        this.isMouseDown = false;\n        // Workaround for Chrome/Safari not firing native double click events for double touch on background\n        const valid = cell || (isTouchEvent(me.getEvent()) || isPenEvent(me.getEvent())) && (Client.IS_GC || Client.IS_SF);\n        if (valid && Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance && Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance) {\n          this.dblClick(me.getEvent(), cell);\n        } else {\n          InternalEvent.consume(me.getEvent());\n        }\n        return;\n      }\n    }\n    if (!this.isEventIgnored(evtName, me, sender)) {\n      const state = me.getState();\n      // Updates the event state via getEventState\n      me.state = state ? this.getEventState(state) : null;\n      this.fireEvent(new EventObject(InternalEvent.FIRE_MOUSE_EVENT, {\n        eventName: evtName,\n        event: me\n      }));\n      if (Client.IS_SF || Client.IS_GC || me.getEvent().target !== this.getContainer()) {\n        const container = this.getContainer();\n        if (evtName === InternalEvent.MOUSE_MOVE && this.isMouseDown && this.isAutoScroll() && !isMultiTouchEvent(me.getEvent())) {\n          this.scrollPointToVisible(me.getGraphX(), me.getGraphY(), this.isAutoExtend());\n        } else if (evtName === InternalEvent.MOUSE_UP && this.isIgnoreScrollbars() && this.isTranslateToScrollPosition() && (container.scrollLeft !== 0 || container.scrollTop !== 0)) {\n          const s = this.getView().scale;\n          const tr = this.getView().translate;\n          this.getView().setTranslate(tr.x - container.scrollLeft / s, tr.y - container.scrollTop / s);\n          container.scrollLeft = 0;\n          container.scrollTop = 0;\n        }\n        const mouseListeners = this.mouseListeners;\n        // Does not change returnValue in Opera\n        if (!me.getEvent().preventDefault) {\n          me.getEvent().returnValue = true;\n        }\n        for (const l of mouseListeners) {\n          if (evtName === InternalEvent.MOUSE_DOWN) {\n            l.mouseDown(sender, me);\n          } else if (evtName === InternalEvent.MOUSE_MOVE) {\n            l.mouseMove(sender, me);\n          } else if (evtName === InternalEvent.MOUSE_UP) {\n            l.mouseUp(sender, me);\n          }\n        }\n        // Invokes the click handler\n        if (evtName === InternalEvent.MOUSE_UP) {\n          this.click(me);\n        }\n      }\n      // Detects tapAndHold events using a timer\n      if ((isTouchEvent(me.getEvent()) || isPenEvent(me.getEvent())) && evtName === InternalEvent.MOUSE_DOWN && this.tapAndHoldEnabled && !this.tapAndHoldInProgress) {\n        this.tapAndHoldInProgress = true;\n        this.initialTouchX = me.getGraphX();\n        this.initialTouchY = me.getGraphY();\n        const handler = () => {\n          if (this.tapAndHoldValid) {\n            this.tapAndHold(me);\n          }\n          this.tapAndHoldInProgress = false;\n          this.tapAndHoldValid = false;\n        };\n        if (this.tapAndHoldThread) {\n          window.clearTimeout(this.tapAndHoldThread);\n        }\n        this.tapAndHoldThread = window.setTimeout(handler, this.tapAndHoldDelay);\n        this.tapAndHoldValid = true;\n      } else if (evtName === InternalEvent.MOUSE_UP) {\n        this.tapAndHoldInProgress = false;\n        this.tapAndHoldValid = false;\n      } else if (this.tapAndHoldValid) {\n        this.tapAndHoldValid = Math.abs(this.initialTouchX - me.getGraphX()) < this.tolerance && Math.abs(this.initialTouchY - me.getGraphY()) < this.tolerance;\n      }\n      const cellEditorHandler = this.getPlugin('CellEditorHandler');\n      // Stops editing for all events other than from cellEditorHandler\n      if (evtName === InternalEvent.MOUSE_DOWN && this.isEditing() && !(cellEditorHandler !== null && cellEditorHandler !== void 0 && cellEditorHandler.isEventSource(me.getEvent()))) {\n        this.stopEditing(!this.isInvokesStopCellEditing());\n      }\n      this.consumeMouseEvent(evtName, me, sender);\n    }\n  },\n  /**\n   * Consumes the given {@link InternalMouseEvent} if it's a touchStart event.\n   */\n  consumeMouseEvent(evtName, me, sender) {\n    var _sender2;\n    sender = (_sender2 = sender) !== null && _sender2 !== void 0 ? _sender2 : this;\n    // Workaround for duplicate click in Windows 8 with Chrome/FF/Opera with touch\n    if (evtName === InternalEvent.MOUSE_DOWN && isTouchEvent(me.getEvent())) {\n      me.consume(false);\n    }\n  },\n  /**\n   * Dispatches a {@link InternalEvent.GESTURE} event. The following example will resize the\n   * cell under the mouse based on the scale property of the native touch event.\n   *\n   * ```javascript\n   * graph.addListener(mxEvent.GESTURE, function(sender, eo)\n   * {\n   *   var evt = eo.getProperty('event');\n   *   var state = graph.view.getState(eo.getProperty('cell'));\n   *\n   *   if (graph.isEnabled() && graph.isCellResizable(state.cell) && Math.abs(1 - evt.scale) > 0.2)\n   *   {\n   *     var scale = graph.view.scale;\n   *     var tr = graph.view.translate;\n   *\n   *     var w = state.width * evt.scale;\n   *     var h = state.height * evt.scale;\n   *     var x = state.x - (w - state.width) / 2;\n   *     var y = state.y - (h - state.height) / 2;\n   *\n   *     var bounds = new mxRectangle(graph.snap(x / scale) - tr.x,\n   *     \t\tgraph.snap(y / scale) - tr.y, graph.snap(w / scale), graph.snap(h / scale));\n   *     graph.resizeCell(state.cell, bounds);\n   *     eo.consume();\n   *   }\n   * });\n   * ```\n   *\n   * @param evt Gestureend event that represents the gesture.\n   * @param cell Optional {@link Cell} associated with the gesture.\n   */\n  fireGestureEvent(evt) {\n    let cell = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    // Resets double tap event handling when gestures take place\n    this.lastTouchTime = 0;\n    this.fireEvent(new EventObject(InternalEvent.GESTURE, {\n      event: evt,\n      cell\n    }));\n  },\n  /**\n   * Called when the size of the graph has changed. This implementation fires\n   * a {@link size} event after updating the clipping region of the SVG element in\n   * SVG-bases browsers.\n   */\n  sizeDidChange() {\n    const bounds = this.getGraphBounds();\n    const border = this.getBorder();\n    let width = Math.max(0, bounds.x) + bounds.width + 2 * border;\n    let height = Math.max(0, bounds.y) + bounds.height + 2 * border;\n    const minimumContainerSize = this.getMinimumContainerSize();\n    if (minimumContainerSize) {\n      width = Math.max(width, minimumContainerSize.width);\n      height = Math.max(height, minimumContainerSize.height);\n    }\n    if (this.isResizeContainer()) {\n      this.doResizeContainer(width, height);\n    }\n    if (this.isPreferPageSize() || this.isPageVisible()) {\n      const size = this.getPreferredPageSize(bounds, Math.max(1, width), Math.max(1, height));\n      width = size.width * this.getView().scale;\n      height = size.height * this.getView().scale;\n    }\n    const minimumGraphSize = this.getMinimumGraphSize();\n    if (minimumGraphSize) {\n      width = Math.max(width, minimumGraphSize.width * this.getView().scale);\n      height = Math.max(height, minimumGraphSize.height * this.getView().scale);\n    }\n    width = Math.ceil(width);\n    height = Math.ceil(height);\n    // @ts-ignore\n    const root = this.getView().getDrawPane().ownerSVGElement;\n    if (root) {\n      root.style.minWidth = \"\".concat(Math.max(1, width), \"px\");\n      root.style.minHeight = \"\".concat(Math.max(1, height), \"px\");\n      root.style.width = '100%';\n      root.style.height = '100%';\n    }\n    this.updatePageBreaks(this.isPageBreaksVisible(), width, height);\n    this.fireEvent(new EventObject(InternalEvent.SIZE, {\n      bounds\n    }));\n  },\n  /*****************************************************************************\n   * Group: Graph display\n   *****************************************************************************/\n  /**\n   * Returns true if the given event is a clone event. This implementation\n   * returns true if control is pressed.\n   */\n  isCloneEvent(evt) {\n    return isControlDown(evt);\n  },\n  /**\n   * Hook for implementing click-through behaviour on selected cells. If this\n   * returns true the cell behind the selected cell will be selected. This\n   * implementation returns false;\n   */\n  isTransparentClickEvent(evt) {\n    return false;\n  },\n  /**\n   * Returns true if the given event is a toggle event. This implementation\n   * returns true if the meta key (Cmd) is pressed on Macs or if control is\n   * pressed on any other platform.\n   */\n  isToggleEvent(evt) {\n    return Client.IS_MAC ? isMetaDown(evt) : isControlDown(evt);\n  },\n  /**\n   * Returns true if the given mouse event should be aligned to the grid.\n   */\n  isGridEnabledEvent(evt) {\n    return !isAltDown(evt);\n  },\n  /**\n   * Returns true if the given mouse event should be aligned to the grid.\n   */\n  isConstrainedEvent(evt) {\n    return isShiftDown(evt);\n  },\n  /**\n   * Returns true if the given mouse event should not allow any connections to be\n   * made. This implementation returns false.\n   */\n  isIgnoreTerminalEvent(evt) {\n    return false;\n  },\n  /**\n   * Returns an {@link Point} representing the given event in the unscaled,\n   * non-translated coordinate space of {@link container} and applies the grid.\n   *\n   * @param evt Mousevent that contains the mouse pointer location.\n   * @param addOffset Optional boolean that specifies if the position should be\n   * offset by half of the {@link gridSize}. Default is `true`.\n   */\n  getPointForEvent(evt) {\n    let addOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const p = convertPoint(this.getContainer(), getClientX(evt), getClientY(evt));\n    const s = this.getView().scale;\n    const tr = this.getView().translate;\n    const off = addOffset ? this.getGridSize() / 2 : 0;\n    p.x = this.snap(p.x / s - tr.x - off);\n    p.y = this.snap(p.y / s - tr.y - off);\n    return p;\n  },\n  /*****************************************************************************\n   * Group: Graph behaviour\n   *****************************************************************************/\n  /**\n   * Returns {@link escapeEnabled}.\n   */\n  isEscapeEnabled() {\n    return this.escapeEnabled;\n  },\n  /**\n   * Sets {@link escapeEnabled}.\n   *\n   * @param enabled Boolean indicating if escape should be enabled.\n   */\n  setEscapeEnabled(value) {\n    this.escapeEnabled = value;\n  },\n  /**\n   * Returns {@link invokesStopCellEditing}.\n   */\n  isInvokesStopCellEditing() {\n    return this.invokesStopCellEditing;\n  },\n  /**\n   * Sets {@link invokesStopCellEditing}.\n   */\n  setInvokesStopCellEditing(value) {\n    this.invokesStopCellEditing = value;\n  },\n  /**\n   * Returns {@link enterStopsCellEditing}.\n   */\n  isEnterStopsCellEditing() {\n    return this.enterStopsCellEditing;\n  },\n  /**\n   * Sets {@link enterStopsCellEditing}.\n   */\n  setEnterStopsCellEditing(value) {\n    this.enterStopsCellEditing = value;\n  },\n  /*****************************************************************************\n   * Group: Graph appearance\n   *****************************************************************************/\n  /**\n   * Returns the cursor value to be used for the CSS of the shape for the\n   * given event. This implementation calls {@link getCursorForCell}.\n   *\n   * @param me {@link mxMouseEvent} whose cursor should be returned.\n   */\n  getCursorForMouseEvent(me) {\n    const cell = me.getCell();\n    return cell ? this.getCursorForCell(cell) : null;\n  }\n};\nmixInto(Graph)(EventsMixin);","map":{"version":3,"names":["InternalMouseEvent","EventObject","InternalEvent","getClientX","getClientY","isAltDown","isConsumed","isControlDown","isLeftMouseButton","isMetaDown","isMouseEvent","isMultiTouchEvent","isPenEvent","isPopupTrigger","isShiftDown","isTouchEvent","Point","mixInto","convertPoint","NONE","Client","Graph","EventsMixin","lastTouchEvent","doubleClickCounter","lastTouchCell","fireDoubleClick","tapAndHoldThread","lastMouseX","lastMouseY","isMouseTrigger","ignoreMouseEvents","mouseMoveRedirect","mouseUpRedirect","lastEvent","escapeEnabled","invokesStopCellEditing","enterStopsCellEditing","isMouseDown","nativeDblClickEnabled","doubleTapEnabled","doubleTapTimeout","doubleTapTolerance","lastTouchX","lastTouchY","lastTouchTime","tapAndHoldEnabled","tapAndHoldDelay","tapAndHoldInProgress","tapAndHoldValid","initialTouchX","initialTouchY","tolerance","isNativeDblClickEnabled","getEventTolerance","setEventTolerance","escape","evt","fireEvent","ESCAPE","event","click","me","getEvent","cell","getCell","mxe","CLICK","consume","isEnabled","isTransparentClickEvent","active","tmp","getCellAt","graphX","graphY","state","selected","isCellSelected","isAncestor","isSwimlaneSelectionEnabled","getSwimlaneAt","getGraphX","getGraphY","isToggleEvent","temp","swimlanes","getParent","getView","getState","isSwimlane","push","length","reverse","splice","i","selectCellForEvent","clearSelection","dblClick","arguments","undefined","DOUBLE_CLICK","isCellEditable","isEditing","startEditingAtCell","tapAndHold","TAP_AND_HOLD","panningHandler","getPlugin","connectionHandler","panningTrigger","marker","currentColor","validColor","markedState","mark","first","edgeState","createEdgeState","previous","START","addMouseListener","listener","mouseListeners","removeMouseListener","updateMouseEvent","evtName","pt","getContainer","getX","getY","x","getPanDx","y","getPanDy","MOUSE_MOVE","shape","paintBackground","style","pointerEvents","fill","getStateForTouchEvent","isEventIgnored","sender","mouseEvent","result","eventSource","getEventSource","removeGestureListeners","setEventSource","IS_GC","getSource","IS_TOUCH","MOUSE_DOWN","fireMouseEvent","MOUSE_UP","addGestureListeners","isSyntheticEventIgnored","detail","IS_FF","isEventSourceIgnored","source","name","nodeName","toLowerCase","candidate","type","getEventState","_sender","tooltipHandler","hide","currentTime","Date","getTime","Math","abs","doubleClickFired","valid","IS_SF","FIRE_MOUSE_EVENT","eventName","target","container","isAutoScroll","scrollPointToVisible","isAutoExtend","isIgnoreScrollbars","isTranslateToScrollPosition","scrollLeft","scrollTop","s","scale","tr","translate","setTranslate","preventDefault","returnValue","l","mouseDown","mouseMove","mouseUp","handler","window","clearTimeout","setTimeout","cellEditorHandler","isEventSource","stopEditing","isInvokesStopCellEditing","consumeMouseEvent","_sender2","fireGestureEvent","GESTURE","sizeDidChange","bounds","getGraphBounds","border","getBorder","width","max","height","minimumContainerSize","getMinimumContainerSize","isResizeContainer","doResizeContainer","isPreferPageSize","isPageVisible","size","getPreferredPageSize","minimumGraphSize","getMinimumGraphSize","ceil","root","getDrawPane","ownerSVGElement","minWidth","concat","minHeight","updatePageBreaks","isPageBreaksVisible","SIZE","isCloneEvent","IS_MAC","isGridEnabledEvent","isConstrainedEvent","isIgnoreTerminalEvent","getPointForEvent","addOffset","p","off","getGridSize","snap","isEscapeEnabled","setEscapeEnabled","value","setInvokesStopCellEditing","isEnterStopsCellEditing","setEnterStopsCellEditing","getCursorForMouseEvent","getCursorForCell"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/@maxgraph/core/dist/view/mixins/EventsMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport InternalMouseEvent from '../event/InternalMouseEvent';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport { getClientX, getClientY, isAltDown, isConsumed, isControlDown, isLeftMouseButton, isMetaDown, isMouseEvent, isMultiTouchEvent, isPenEvent, isPopupTrigger, isShiftDown, isTouchEvent, } from '../../util/EventUtils';\nimport Point from '../geometry/Point';\nimport { mixInto } from '../../util/Utils';\nimport { convertPoint } from '../../util/styleUtils';\nimport { NONE } from '../../util/Constants';\nimport Client from '../../Client';\nimport { Graph } from '../Graph';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst EventsMixin = {\n    // TODO: Document me!\n    lastTouchEvent: null,\n    doubleClickCounter: 0,\n    lastTouchCell: null,\n    fireDoubleClick: null,\n    tapAndHoldThread: null,\n    lastMouseX: null,\n    lastMouseY: null,\n    isMouseTrigger: null,\n    ignoreMouseEvents: null,\n    mouseMoveRedirect: null,\n    mouseUpRedirect: null,\n    lastEvent: null,\n    /**\n     * Specifies if {@link KeyHandler} should invoke {@link escape} when the escape key\n     * is pressed.\n     * @default true\n     */\n    escapeEnabled: true,\n    /**\n     * If `true`, when editing is to be stopped by way of selection changing,\n     * data in diagram changing or other means stopCellEditing is invoked, and\n     * changes are saved. This is implemented in a focus handler in\n     * {@link CellEditorHandler}.\n     * @default true\n     */\n    invokesStopCellEditing: true,\n    /**\n     * If `true`, pressing the enter key without pressing control or shift will stop\n     * editing and accept the new value. This is used in {@link CellEditorHandler} to stop\n     * cell editing. Note: You can always use F2 and escape to stop editing.\n     * @default false\n     */\n    enterStopsCellEditing: false,\n    /**\n     * Holds the state of the mouse button.\n     */\n    isMouseDown: false,\n    /**\n     * Specifies if native double click events should be detected.\n     * @default true\n     */\n    nativeDblClickEnabled: true,\n    /**\n     * Specifies if double taps on touch-based devices should be handled as a\n     * double click.\n     * @default true\n     */\n    doubleTapEnabled: true,\n    /**\n     * Specifies the timeout in milliseconds for double taps and non-native double clicks.\n     * @default 500\n     */\n    doubleTapTimeout: 500,\n    /**\n     * Specifies the tolerance in pixels for double taps and double clicks in quirks mode.\n     * @default 25\n     */\n    doubleTapTolerance: 25,\n    /**\n     * Holds the x-coordinate of the last touch event for double tap detection.\n     */\n    lastTouchX: 0,\n    /**\n     * Holds the x-coordinate of the last touch event for double tap detection.\n     */\n    lastTouchY: 0,\n    /**\n     * Holds the time of the last touch event for double click detection.\n     */\n    lastTouchTime: 0,\n    /**\n     * Specifies if tap and hold should be used for starting connections on touch-based\n     * devices.\n     * @default true\n     */\n    tapAndHoldEnabled: true,\n    /**\n     * Specifies the time in milliseconds for a tap and hold.\n     * @default 500\n     */\n    tapAndHoldDelay: 500,\n    /**\n     * `True` if the timer for tap and hold events is running.\n     */\n    tapAndHoldInProgress: false,\n    /**\n     * `True` as long as the timer is running and the touch events\n     * stay within the given {@link tapAndHoldTolerance}.\n     */\n    tapAndHoldValid: false,\n    /**\n     * Holds the x-coordinate of the initial touch event for tap and hold.\n     */\n    initialTouchX: 0,\n    /**\n     * Holds the y-coordinate of the initial touch event for tap and hold.\n     */\n    initialTouchY: 0,\n    /**\n     * Tolerance in pixels for a move to be handled as a single click.\n     * @default 4\n     */\n    tolerance: 4,\n    isNativeDblClickEnabled() {\n        return this.nativeDblClickEnabled;\n    },\n    getEventTolerance() {\n        return this.tolerance;\n    },\n    setEventTolerance(tolerance) {\n        this.tolerance = tolerance;\n    },\n    /*****************************************************************************\n     * Group: Event processing\n     *****************************************************************************/\n    /**\n     * Processes an escape keystroke.\n     *\n     * @param evt Mouseevent that represents the keystroke.\n     */\n    escape(evt) {\n        this.fireEvent(new EventObject(InternalEvent.ESCAPE, { event: evt }));\n    },\n    /**\n     * Processes a singleclick on an optional cell and fires a {@link click} event.\n     * The click event is fired initially. If the graph is enabled and the\n     * event has not been consumed, then the cell is selected using\n     * {@link selectCellForEvent} or the selection is cleared using\n     * {@link clearSelection}. The events consumed state is set to true if the\n     * corresponding {@link InternalMouseEvent} has been consumed.\n     *\n     * To handle a click event, use the following code.\n     *\n     * ```javascript\n     * graph.addListener(mxEvent.CLICK, function(sender, evt)\n     * {\n     *   var e = evt.getProperty('event'); // mouse event\n     *   var cell = evt.getProperty('cell'); // cell may be null\n     *\n     *   if (cell != null)\n     *   {\n     *     // Do something useful with cell and consume the event\n     *     evt.consume();\n     *   }\n     * });\n     * ```\n     *\n     * @param me {@link mxMouseEvent} that represents the single click.\n     */\n    click(me) {\n        const evt = me.getEvent();\n        let cell = me.getCell();\n        const mxe = new EventObject(InternalEvent.CLICK, { event: evt, cell });\n        if (me.isConsumed()) {\n            mxe.consume();\n        }\n        this.fireEvent(mxe);\n        if (this.isEnabled() && !isConsumed(evt) && !mxe.isConsumed()) {\n            if (cell) {\n                if (this.isTransparentClickEvent(evt)) {\n                    let active = false;\n                    const tmp = this.getCellAt(me.graphX, me.graphY, null, false, false, (state) => {\n                        const selected = this.isCellSelected(state.cell);\n                        active = active || selected;\n                        return (!active ||\n                            selected ||\n                            (state.cell !== cell && state.cell.isAncestor(cell)));\n                    });\n                    if (tmp) {\n                        cell = tmp;\n                    }\n                }\n            }\n            else if (this.isSwimlaneSelectionEnabled()) {\n                cell = this.getSwimlaneAt(me.getGraphX(), me.getGraphY());\n                if (cell != null && (!this.isToggleEvent(evt) || !isAltDown(evt))) {\n                    let temp = cell;\n                    let swimlanes = [];\n                    while (temp != null) {\n                        temp = temp.getParent();\n                        const state = this.getView().getState(temp);\n                        if (this.isSwimlane(temp) && state != null) {\n                            swimlanes.push(temp);\n                        }\n                    }\n                    // Selects ancestors for selected swimlanes\n                    if (swimlanes.length > 0) {\n                        swimlanes = swimlanes.reverse();\n                        swimlanes.splice(0, 0, cell);\n                        swimlanes.push(cell);\n                        for (let i = 0; i < swimlanes.length - 1; i += 1) {\n                            if (this.isCellSelected(swimlanes[i])) {\n                                cell = swimlanes[this.isToggleEvent(evt) ? i : i + 1];\n                            }\n                        }\n                    }\n                }\n            }\n            if (cell) {\n                this.selectCellForEvent(cell, evt);\n            }\n            else if (!this.isToggleEvent(evt)) {\n                this.clearSelection();\n            }\n        }\n        return false;\n    },\n    /**\n     * Processes a doubleclick on an optional cell and fires a {@link dblclick}\n     * event. The event is fired initially. If the graph is enabled and the\n     * event has not been consumed, then {@link edit} is called with the given\n     * cell. The event is ignored if no cell was specified.\n     *\n     * Example for overriding this method.\n     *\n     * ```javascript\n     * graph.dblClick = function(evt, cell)\n     * {\n     *   var mxe = new mxEventObject(mxEvent.DOUBLE_CLICK, 'event', evt, 'cell', cell);\n     *   this.fireEvent(mxe);\n     *\n     *   if (this.isEnabled() && !mxEvent.isConsumed(evt) && !mxe.isConsumed())\n     *   {\n     * \t   mxUtils.alert('Hello, World!');\n     *     mxe.consume();\n     *   }\n     * }\n     * ```\n     *\n     * Example listener for this event.\n     *\n     * ```javascript\n     * graph.addListener(mxEvent.DOUBLE_CLICK, function(sender, evt)\n     * {\n     *   var cell = evt.getProperty('cell');\n     *   // do something with the cell and consume the\n     *   // event to prevent in-place editing from start\n     * });\n     * ```\n     *\n     * @param evt Mouseevent that represents the doubleclick.\n     * @param cell Optional {@link Cell} under the mousepointer.\n     */\n    dblClick(evt, cell = null) {\n        const mxe = new EventObject(InternalEvent.DOUBLE_CLICK, { event: evt, cell });\n        this.fireEvent(mxe);\n        // Handles the event if it has not been consumed\n        if (this.isEnabled() &&\n            !isConsumed(evt) &&\n            !mxe.isConsumed() &&\n            cell &&\n            this.isCellEditable(cell) &&\n            !this.isEditing(cell)) {\n            this.startEditingAtCell(cell, evt);\n            InternalEvent.consume(evt);\n        }\n    },\n    /**\n     * Handles the {@link InternalMouseEvent} by highlighting the {@link CellState}.\n     *\n     * @param me {@link mxMouseEvent} that represents the touch event.\n     * @param state Optional {@link CellState} that is associated with the event.\n     */\n    tapAndHold(me) {\n        const evt = me.getEvent();\n        const mxe = new EventObject(InternalEvent.TAP_AND_HOLD, {\n            event: evt,\n            cell: me.getCell(),\n        });\n        const panningHandler = this.getPlugin('PanningHandler');\n        const connectionHandler = this.getPlugin('ConnectionHandler');\n        // LATER: Check if event should be consumed if me is consumed\n        this.fireEvent(mxe);\n        if (mxe.isConsumed()) {\n            // Resets the state of the panning handler\n            panningHandler && (panningHandler.panningTrigger = false);\n        }\n        // Handles the event if it has not been consumed\n        if (this.isEnabled() &&\n            !isConsumed(evt) &&\n            !mxe.isConsumed() &&\n            connectionHandler &&\n            connectionHandler.isEnabled()) {\n            const cell = connectionHandler.marker.getCell(me);\n            if (cell) {\n                const state = this.getView().getState(cell);\n                if (state) {\n                    connectionHandler.marker.currentColor = connectionHandler.marker.validColor;\n                    connectionHandler.marker.markedState = state;\n                    connectionHandler.marker.mark();\n                    connectionHandler.first = new Point(me.getGraphX(), me.getGraphY());\n                    connectionHandler.edgeState = connectionHandler.createEdgeState(me);\n                    connectionHandler.previous = state;\n                    connectionHandler.fireEvent(new EventObject(InternalEvent.START, { state: connectionHandler.previous }));\n                }\n            }\n        }\n    },\n    /*****************************************************************************\n     * Group: Graph events\n     *****************************************************************************/\n    /**\n     * Adds a listener to the graph event dispatch loop. The listener\n     * must implement the mouseDown, mouseMove and mouseUp methods\n     * as shown in the {@link InternalMouseEvent} class.\n     *\n     * @param listener Listener to be added to the graph event listeners.\n     */\n    addMouseListener(listener) {\n        this.mouseListeners.push(listener);\n    },\n    /**\n     * Removes the specified graph listener.\n     *\n     * @param listener Listener to be removed from the graph event listeners.\n     */\n    removeMouseListener(listener) {\n        for (let i = 0; i < this.mouseListeners.length; i += 1) {\n            if (this.mouseListeners[i] === listener) {\n                this.mouseListeners.splice(i, 1);\n                break;\n            }\n        }\n    },\n    /**\n     * Sets the graphX and graphY properties if the given {@link InternalMouseEvent} if\n     * required and returned the event.\n     *\n     * @param me {@link mxMouseEvent} to be updated.\n     * @param evtName Name of the mouse event.\n     */\n    updateMouseEvent(me, evtName) {\n        const pt = convertPoint(this.getContainer(), me.getX(), me.getY());\n        me.graphX = pt.x - this.getPanDx();\n        me.graphY = pt.y - this.getPanDy();\n        // Searches for rectangles using method if native hit detection is disabled on shape\n        if (!me.getCell() && this.isMouseDown && evtName === InternalEvent.MOUSE_MOVE) {\n            const cell = this.getCellAt(pt.x, pt.y, null, true, true, (state) => {\n                return (!state.shape ||\n                    state.shape.paintBackground !== this.paintBackground ||\n                    state.style.pointerEvents ||\n                    state.shape.fill !== NONE);\n            });\n            me.state = cell ? this.getView().getState(cell) : null;\n        }\n        return me;\n    },\n    /**\n     * Returns the state for the given touch event.\n     */\n    getStateForTouchEvent(evt) {\n        const x = getClientX(evt);\n        const y = getClientY(evt);\n        // Dispatches the drop event to the graph which\n        // consumes and executes the source function\n        const pt = convertPoint(this.getContainer(), x, y);\n        const cell = this.getCellAt(pt.x, pt.y);\n        return cell ? this.getView().getState(cell) : null;\n    },\n    /**\n     * Returns true if the event should be ignored in {@link fireMouseEvent}.\n     */\n    isEventIgnored(evtName, me, sender) {\n        const mouseEvent = isMouseEvent(me.getEvent());\n        let result = false;\n        // Drops events that are fired more than once\n        if (me.getEvent() === this.lastEvent) {\n            result = true;\n        }\n        else {\n            this.lastEvent = me.getEvent();\n        }\n        // Installs event listeners to capture the complete gesture from the event source\n        // for non-MS touch events as a workaround for all events for the same geture being\n        // fired from the event source even if that was removed from the DOM.\n        const eventSource = this.getEventSource();\n        if (eventSource && evtName !== InternalEvent.MOUSE_MOVE) {\n            InternalEvent.removeGestureListeners(eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);\n            this.mouseMoveRedirect = null;\n            this.mouseUpRedirect = null;\n            this.setEventSource(null);\n        }\n        else if (!Client.IS_GC && eventSource && me.getSource() !== eventSource) {\n            result = true;\n        }\n        else if (eventSource &&\n            Client.IS_TOUCH &&\n            evtName === InternalEvent.MOUSE_DOWN &&\n            !mouseEvent &&\n            !isPenEvent(me.getEvent())) {\n            this.setEventSource(me.getSource());\n            (this.mouseMoveRedirect = (evt) => {\n                this.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, this.getStateForTouchEvent(evt)));\n            }),\n                (this.mouseUpRedirect = (evt) => {\n                    this.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt, this.getStateForTouchEvent(evt)));\n                }),\n                InternalEvent.addGestureListeners(eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);\n        }\n        // Factored out the workarounds for FF to make it easier to override/remove\n        // Note this method has side-effects!\n        if (this.isSyntheticEventIgnored(evtName, me, sender)) {\n            result = true;\n        }\n        // Never fires mouseUp/-Down for double clicks\n        if (!isPopupTrigger(this.lastEvent) &&\n            evtName !== InternalEvent.MOUSE_MOVE &&\n            this.lastEvent.detail === 2) {\n            return true;\n        }\n        // Filters out of sequence events or mixed event types during a gesture\n        if (evtName === InternalEvent.MOUSE_UP && this.isMouseDown) {\n            this.isMouseDown = false;\n        }\n        else if (evtName === InternalEvent.MOUSE_DOWN && !this.isMouseDown) {\n            this.isMouseDown = true;\n            this.isMouseTrigger = mouseEvent;\n        }\n        // Drops mouse events that are fired during touch gestures as a workaround for Webkit\n        // and mouse events that are not in sync with the current internal button state\n        else if (!result &&\n            (((!Client.IS_FF || evtName !== InternalEvent.MOUSE_MOVE) &&\n                this.isMouseDown &&\n                this.isMouseTrigger !== mouseEvent) ||\n                (evtName === InternalEvent.MOUSE_DOWN && this.isMouseDown) ||\n                (evtName === InternalEvent.MOUSE_UP && !this.isMouseDown))) {\n            result = true;\n        }\n        if (!result && evtName === InternalEvent.MOUSE_DOWN) {\n            this.lastMouseX = me.getX();\n            this.lastMouseY = me.getY();\n        }\n        return result;\n    },\n    /**\n     * Hook for ignoring synthetic mouse events after touchend in Firefox.\n     */\n    isSyntheticEventIgnored(evtName, me, sender) {\n        let result = false;\n        const mouseEvent = isMouseEvent(me.getEvent());\n        // LATER: This does not cover all possible cases that can go wrong in FF\n        if (this.ignoreMouseEvents && mouseEvent && evtName !== InternalEvent.MOUSE_MOVE) {\n            this.ignoreMouseEvents = evtName !== InternalEvent.MOUSE_UP;\n            result = true;\n        }\n        else if (Client.IS_FF && !mouseEvent && evtName === InternalEvent.MOUSE_UP) {\n            this.ignoreMouseEvents = true;\n        }\n        return result;\n    },\n    /**\n     * Returns true if the event should be ignored in {@link fireMouseEvent}. This\n     * implementation returns true for select, option and input (if not of type\n     * checkbox, radio, button, submit or file) event sources if the event is not\n     * a mouse event or a left mouse button press event.\n     *\n     * @param evtName The name of the event.\n     * @param me {@link mxMouseEvent} that should be ignored.\n     */\n    isEventSourceIgnored(evtName, me) {\n        const source = me.getSource();\n        if (!source)\n            return true;\n        // @ts-ignore nodeName could exist\n        const name = source.nodeName ? source.nodeName.toLowerCase() : '';\n        const candidate = !isMouseEvent(me.getEvent()) || isLeftMouseButton(me.getEvent());\n        return (evtName === InternalEvent.MOUSE_DOWN &&\n            candidate &&\n            (name === 'select' ||\n                name === 'option' ||\n                (name === 'input' &&\n                    // @ts-ignore type could exist\n                    source.type !== 'checkbox' &&\n                    // @ts-ignore type could exist\n                    source.type !== 'radio' &&\n                    // @ts-ignore type could exist\n                    source.type !== 'button' &&\n                    // @ts-ignore type could exist\n                    source.type !== 'submit' &&\n                    // @ts-ignore type could exist\n                    source.type !== 'file')));\n    },\n    /**\n     * Returns the {@link CellState} to be used when firing the mouse event for the\n     * given state. This implementation returns the given state.\n     *\n     * {@link CellState} - State whose event source should be returned.\n     */\n    getEventState(state) {\n        return state;\n    },\n    /**\n     * Dispatches the given event in the graph event dispatch loop. Possible\n     * event names are {@link InternalEvent.MOUSE_DOWN}, {@link InternalEvent.MOUSE_MOVE} and\n     * {@link InternalEvent.MOUSE_UP}. All listeners are invoked for all events regardless\n     * of the consumed state of the event.\n     *\n     * @param evtName String that specifies the type of event to be dispatched.\n     * @param me {@link mxMouseEvent} to be fired.\n     * @param sender Optional sender argument. Default is `this`.\n     */\n    fireMouseEvent(evtName, me, sender) {\n        sender = sender ?? this;\n        if (this.isEventSourceIgnored(evtName, me)) {\n            const tooltipHandler = this.getPlugin('TooltipHandler');\n            if (tooltipHandler) {\n                tooltipHandler.hide();\n            }\n            return;\n        }\n        // Updates the graph coordinates in the event\n        me = this.updateMouseEvent(me, evtName);\n        // Detects and processes double taps for touch-based devices which do not have native double click events\n        // or where detection of double click is not always possible (quirks, IE10+). Note that this can only handle\n        // double clicks on cells because the sequence of events in IE prevents detection on the background, it fires\n        // two mouse ups, one of which without a cell but no mousedown for the second click which means we cannot\n        // detect which mouseup(s) are part of the first click, ie we do not know when the first click ends.\n        if ((!this.nativeDblClickEnabled && !isPopupTrigger(me.getEvent())) ||\n            (this.doubleTapEnabled &&\n                Client.IS_TOUCH &&\n                (isTouchEvent(me.getEvent()) || isPenEvent(me.getEvent())))) {\n            const currentTime = new Date().getTime();\n            if (evtName === InternalEvent.MOUSE_DOWN) {\n                if (this.lastTouchEvent &&\n                    this.lastTouchEvent !== me.getEvent() &&\n                    currentTime - this.lastTouchTime < this.doubleTapTimeout &&\n                    Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance &&\n                    Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance &&\n                    this.doubleClickCounter < 2) {\n                    this.doubleClickCounter += 1;\n                    let doubleClickFired = false;\n                    if (evtName === InternalEvent.MOUSE_UP) {\n                        if (me.getCell() === this.lastTouchCell && this.lastTouchCell) {\n                            this.lastTouchTime = 0;\n                            const cell = this.lastTouchCell;\n                            this.lastTouchCell = null;\n                            this.dblClick(me.getEvent(), cell);\n                            doubleClickFired = true;\n                        }\n                    }\n                    else {\n                        this.fireDoubleClick = true;\n                        this.lastTouchTime = 0;\n                    }\n                    if (doubleClickFired) {\n                        InternalEvent.consume(me.getEvent());\n                        return;\n                    }\n                }\n                else if (!this.lastTouchEvent || this.lastTouchEvent !== me.getEvent()) {\n                    this.lastTouchCell = me.getCell();\n                    this.lastTouchX = me.getX();\n                    this.lastTouchY = me.getY();\n                    this.lastTouchTime = currentTime;\n                    this.lastTouchEvent = me.getEvent();\n                    this.doubleClickCounter = 0;\n                }\n            }\n            else if ((this.isMouseDown || evtName === InternalEvent.MOUSE_UP) &&\n                this.fireDoubleClick) {\n                this.fireDoubleClick = false;\n                const cell = this.lastTouchCell;\n                this.lastTouchCell = null;\n                this.isMouseDown = false;\n                // Workaround for Chrome/Safari not firing native double click events for double touch on background\n                const valid = cell ||\n                    ((isTouchEvent(me.getEvent()) || isPenEvent(me.getEvent())) &&\n                        (Client.IS_GC || Client.IS_SF));\n                if (valid &&\n                    Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance &&\n                    Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance) {\n                    this.dblClick(me.getEvent(), cell);\n                }\n                else {\n                    InternalEvent.consume(me.getEvent());\n                }\n                return;\n            }\n        }\n        if (!this.isEventIgnored(evtName, me, sender)) {\n            const state = me.getState();\n            // Updates the event state via getEventState\n            me.state = state ? this.getEventState(state) : null;\n            this.fireEvent(new EventObject(InternalEvent.FIRE_MOUSE_EVENT, { eventName: evtName, event: me }));\n            if (Client.IS_SF || Client.IS_GC || me.getEvent().target !== this.getContainer()) {\n                const container = this.getContainer();\n                if (evtName === InternalEvent.MOUSE_MOVE &&\n                    this.isMouseDown &&\n                    this.isAutoScroll() &&\n                    !isMultiTouchEvent(me.getEvent())) {\n                    this.scrollPointToVisible(me.getGraphX(), me.getGraphY(), this.isAutoExtend());\n                }\n                else if (evtName === InternalEvent.MOUSE_UP &&\n                    this.isIgnoreScrollbars() &&\n                    this.isTranslateToScrollPosition() &&\n                    (container.scrollLeft !== 0 || container.scrollTop !== 0)) {\n                    const s = this.getView().scale;\n                    const tr = this.getView().translate;\n                    this.getView().setTranslate(tr.x - container.scrollLeft / s, tr.y - container.scrollTop / s);\n                    container.scrollLeft = 0;\n                    container.scrollTop = 0;\n                }\n                const mouseListeners = this.mouseListeners;\n                // Does not change returnValue in Opera\n                if (!me.getEvent().preventDefault) {\n                    me.getEvent().returnValue = true;\n                }\n                for (const l of mouseListeners) {\n                    if (evtName === InternalEvent.MOUSE_DOWN) {\n                        l.mouseDown(sender, me);\n                    }\n                    else if (evtName === InternalEvent.MOUSE_MOVE) {\n                        l.mouseMove(sender, me);\n                    }\n                    else if (evtName === InternalEvent.MOUSE_UP) {\n                        l.mouseUp(sender, me);\n                    }\n                }\n                // Invokes the click handler\n                if (evtName === InternalEvent.MOUSE_UP) {\n                    this.click(me);\n                }\n            }\n            // Detects tapAndHold events using a timer\n            if ((isTouchEvent(me.getEvent()) || isPenEvent(me.getEvent())) &&\n                evtName === InternalEvent.MOUSE_DOWN &&\n                this.tapAndHoldEnabled &&\n                !this.tapAndHoldInProgress) {\n                this.tapAndHoldInProgress = true;\n                this.initialTouchX = me.getGraphX();\n                this.initialTouchY = me.getGraphY();\n                const handler = () => {\n                    if (this.tapAndHoldValid) {\n                        this.tapAndHold(me);\n                    }\n                    this.tapAndHoldInProgress = false;\n                    this.tapAndHoldValid = false;\n                };\n                if (this.tapAndHoldThread) {\n                    window.clearTimeout(this.tapAndHoldThread);\n                }\n                this.tapAndHoldThread = window.setTimeout(handler, this.tapAndHoldDelay);\n                this.tapAndHoldValid = true;\n            }\n            else if (evtName === InternalEvent.MOUSE_UP) {\n                this.tapAndHoldInProgress = false;\n                this.tapAndHoldValid = false;\n            }\n            else if (this.tapAndHoldValid) {\n                this.tapAndHoldValid =\n                    Math.abs(this.initialTouchX - me.getGraphX()) < this.tolerance &&\n                        Math.abs(this.initialTouchY - me.getGraphY()) < this.tolerance;\n            }\n            const cellEditorHandler = this.getPlugin('CellEditorHandler');\n            // Stops editing for all events other than from cellEditorHandler\n            if (evtName === InternalEvent.MOUSE_DOWN &&\n                this.isEditing() &&\n                !cellEditorHandler?.isEventSource(me.getEvent())) {\n                this.stopEditing(!this.isInvokesStopCellEditing());\n            }\n            this.consumeMouseEvent(evtName, me, sender);\n        }\n    },\n    /**\n     * Consumes the given {@link InternalMouseEvent} if it's a touchStart event.\n     */\n    consumeMouseEvent(evtName, me, sender) {\n        sender = sender ?? this;\n        // Workaround for duplicate click in Windows 8 with Chrome/FF/Opera with touch\n        if (evtName === InternalEvent.MOUSE_DOWN && isTouchEvent(me.getEvent())) {\n            me.consume(false);\n        }\n    },\n    /**\n     * Dispatches a {@link InternalEvent.GESTURE} event. The following example will resize the\n     * cell under the mouse based on the scale property of the native touch event.\n     *\n     * ```javascript\n     * graph.addListener(mxEvent.GESTURE, function(sender, eo)\n     * {\n     *   var evt = eo.getProperty('event');\n     *   var state = graph.view.getState(eo.getProperty('cell'));\n     *\n     *   if (graph.isEnabled() && graph.isCellResizable(state.cell) && Math.abs(1 - evt.scale) > 0.2)\n     *   {\n     *     var scale = graph.view.scale;\n     *     var tr = graph.view.translate;\n     *\n     *     var w = state.width * evt.scale;\n     *     var h = state.height * evt.scale;\n     *     var x = state.x - (w - state.width) / 2;\n     *     var y = state.y - (h - state.height) / 2;\n     *\n     *     var bounds = new mxRectangle(graph.snap(x / scale) - tr.x,\n     *     \t\tgraph.snap(y / scale) - tr.y, graph.snap(w / scale), graph.snap(h / scale));\n     *     graph.resizeCell(state.cell, bounds);\n     *     eo.consume();\n     *   }\n     * });\n     * ```\n     *\n     * @param evt Gestureend event that represents the gesture.\n     * @param cell Optional {@link Cell} associated with the gesture.\n     */\n    fireGestureEvent(evt, cell = null) {\n        // Resets double tap event handling when gestures take place\n        this.lastTouchTime = 0;\n        this.fireEvent(new EventObject(InternalEvent.GESTURE, { event: evt, cell }));\n    },\n    /**\n     * Called when the size of the graph has changed. This implementation fires\n     * a {@link size} event after updating the clipping region of the SVG element in\n     * SVG-bases browsers.\n     */\n    sizeDidChange() {\n        const bounds = this.getGraphBounds();\n        const border = this.getBorder();\n        let width = Math.max(0, bounds.x) + bounds.width + 2 * border;\n        let height = Math.max(0, bounds.y) + bounds.height + 2 * border;\n        const minimumContainerSize = this.getMinimumContainerSize();\n        if (minimumContainerSize) {\n            width = Math.max(width, minimumContainerSize.width);\n            height = Math.max(height, minimumContainerSize.height);\n        }\n        if (this.isResizeContainer()) {\n            this.doResizeContainer(width, height);\n        }\n        if (this.isPreferPageSize() || this.isPageVisible()) {\n            const size = this.getPreferredPageSize(bounds, Math.max(1, width), Math.max(1, height));\n            width = size.width * this.getView().scale;\n            height = size.height * this.getView().scale;\n        }\n        const minimumGraphSize = this.getMinimumGraphSize();\n        if (minimumGraphSize) {\n            width = Math.max(width, minimumGraphSize.width * this.getView().scale);\n            height = Math.max(height, minimumGraphSize.height * this.getView().scale);\n        }\n        width = Math.ceil(width);\n        height = Math.ceil(height);\n        // @ts-ignore\n        const root = this.getView().getDrawPane().ownerSVGElement;\n        if (root) {\n            root.style.minWidth = `${Math.max(1, width)}px`;\n            root.style.minHeight = `${Math.max(1, height)}px`;\n            root.style.width = '100%';\n            root.style.height = '100%';\n        }\n        this.updatePageBreaks(this.isPageBreaksVisible(), width, height);\n        this.fireEvent(new EventObject(InternalEvent.SIZE, { bounds }));\n    },\n    /*****************************************************************************\n     * Group: Graph display\n     *****************************************************************************/\n    /**\n     * Returns true if the given event is a clone event. This implementation\n     * returns true if control is pressed.\n     */\n    isCloneEvent(evt) {\n        return isControlDown(evt);\n    },\n    /**\n     * Hook for implementing click-through behaviour on selected cells. If this\n     * returns true the cell behind the selected cell will be selected. This\n     * implementation returns false;\n     */\n    isTransparentClickEvent(evt) {\n        return false;\n    },\n    /**\n     * Returns true if the given event is a toggle event. This implementation\n     * returns true if the meta key (Cmd) is pressed on Macs or if control is\n     * pressed on any other platform.\n     */\n    isToggleEvent(evt) {\n        return Client.IS_MAC ? isMetaDown(evt) : isControlDown(evt);\n    },\n    /**\n     * Returns true if the given mouse event should be aligned to the grid.\n     */\n    isGridEnabledEvent(evt) {\n        return !isAltDown(evt);\n    },\n    /**\n     * Returns true if the given mouse event should be aligned to the grid.\n     */\n    isConstrainedEvent(evt) {\n        return isShiftDown(evt);\n    },\n    /**\n     * Returns true if the given mouse event should not allow any connections to be\n     * made. This implementation returns false.\n     */\n    isIgnoreTerminalEvent(evt) {\n        return false;\n    },\n    /**\n     * Returns an {@link Point} representing the given event in the unscaled,\n     * non-translated coordinate space of {@link container} and applies the grid.\n     *\n     * @param evt Mousevent that contains the mouse pointer location.\n     * @param addOffset Optional boolean that specifies if the position should be\n     * offset by half of the {@link gridSize}. Default is `true`.\n     */\n    getPointForEvent(evt, addOffset = true) {\n        const p = convertPoint(this.getContainer(), getClientX(evt), getClientY(evt));\n        const s = this.getView().scale;\n        const tr = this.getView().translate;\n        const off = addOffset ? this.getGridSize() / 2 : 0;\n        p.x = this.snap(p.x / s - tr.x - off);\n        p.y = this.snap(p.y / s - tr.y - off);\n        return p;\n    },\n    /*****************************************************************************\n     * Group: Graph behaviour\n     *****************************************************************************/\n    /**\n     * Returns {@link escapeEnabled}.\n     */\n    isEscapeEnabled() {\n        return this.escapeEnabled;\n    },\n    /**\n     * Sets {@link escapeEnabled}.\n     *\n     * @param enabled Boolean indicating if escape should be enabled.\n     */\n    setEscapeEnabled(value) {\n        this.escapeEnabled = value;\n    },\n    /**\n     * Returns {@link invokesStopCellEditing}.\n     */\n    isInvokesStopCellEditing() {\n        return this.invokesStopCellEditing;\n    },\n    /**\n     * Sets {@link invokesStopCellEditing}.\n     */\n    setInvokesStopCellEditing(value) {\n        this.invokesStopCellEditing = value;\n    },\n    /**\n     * Returns {@link enterStopsCellEditing}.\n     */\n    isEnterStopsCellEditing() {\n        return this.enterStopsCellEditing;\n    },\n    /**\n     * Sets {@link enterStopsCellEditing}.\n     */\n    setEnterStopsCellEditing(value) {\n        this.enterStopsCellEditing = value;\n    },\n    /*****************************************************************************\n     * Group: Graph appearance\n     *****************************************************************************/\n    /**\n     * Returns the cursor value to be used for the CSS of the shape for the\n     * given event. This implementation calls {@link getCursorForCell}.\n     *\n     * @param me {@link mxMouseEvent} whose cursor should be returned.\n     */\n    getCursorForMouseEvent(me) {\n        const cell = me.getCell();\n        return cell ? this.getCursorForCell(cell) : null;\n    },\n};\nmixInto(Graph)(EventsMixin);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}