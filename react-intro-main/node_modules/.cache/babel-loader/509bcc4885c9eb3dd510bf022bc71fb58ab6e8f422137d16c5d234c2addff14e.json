{"ast":null,"code":"import Dictionary from './Dictionary';\nimport ObjectIdentity from './ObjectIdentity';\n/**\n * Returns the cells from the given array where the given filter function\n * returns true.\n */\nexport const filterCells = filter => cells => {\n  const result = [];\n  for (let i = 0; i < cells.length; i += 1) {\n    if (filter(cells[i])) {\n      result.push(cells[i]);\n    }\n  }\n  return result;\n};\n/**\n * Returns all opposite vertices wrt terminal for the given edges, only\n * returning sources and/or targets as specified. The result is returned\n * as an array of {@link Cell}.\n *\n * @param {Cell} terminal  that specifies the known end of the edges.\n * @param sources  Boolean that specifies if source terminals should be contained\n * in the result. Default is true.\n * @param targets  Boolean that specifies if target terminals should be contained\n * in the result. Default is true.\n */\nexport const getOpposites = (terminal, sources = true, targets = true) => edges => {\n  const terminals = [];\n  for (let i = 0; i < edges.length; i += 1) {\n    const source = edges[i].getTerminal(true);\n    const target = edges[i].getTerminal(false);\n    // Checks if the terminal is the source of\n    // the edge and if the target should be\n    // stored in the result\n    if (source === terminal && target != null && target !== terminal && targets) {\n      terminals.push(target);\n    }\n    // Checks if the terminal is the taget of\n    // the edge and if the source should be\n    // stored in the result\n    else if (target === terminal && source != null && source !== terminal && sources) {\n      terminals.push(source);\n    }\n  }\n  return terminals;\n};\n/**\n * Returns the topmost cells of the hierarchy in an array that contains no\n * descendants for each {@link Cell} that it contains. Duplicates should be\n * removed in the cells array to improve performance.\n */\nexport const getTopmostCells = cells => {\n  const dict = new Dictionary();\n  const tmp = [];\n  for (let i = 0; i < cells.length; i += 1) {\n    dict.put(cells[i], true);\n  }\n  for (let i = 0; i < cells.length; i += 1) {\n    const cell = cells[i];\n    let topmost = true;\n    let parent = cell.getParent();\n    while (parent != null) {\n      if (dict.get(parent)) {\n        topmost = false;\n        break;\n      }\n      parent = parent.getParent();\n    }\n    if (topmost) {\n      tmp.push(cell);\n    }\n  }\n  return tmp;\n};\n/**\n * Returns an array that represents the set (no duplicates) of all parents\n * for the given array of cells.\n */\nexport const getParents = cells => {\n  const parents = [];\n  const dict = new Dictionary();\n  for (const cell of cells) {\n    const parent = cell.getParent();\n    if (parent != null && !dict.get(parent)) {\n      dict.put(parent, true);\n      parents.push(parent);\n    }\n  }\n  return parents;\n};\n/**\n * Returns an array of clones for the given array of {@link Cell}`.\n * Depending on the value of includeChildren, a deep clone is created for\n * each cell. Connections are restored based if the corresponding\n * cell is contained in the passed in array.\n *\n * @param includeChildren  Boolean indicating if the cells should be cloned\n * with all descendants.\n * @param mapping  Optional mapping for existing clones.\n */\nexport const cloneCells = (includeChildren = true, mapping = {}) => cells => {\n  const clones = [];\n  for (const cell of cells) {\n    clones.push(cloneCellImpl(cell, mapping, includeChildren));\n  }\n  for (let i = 0; i < clones.length; i += 1) {\n    if (clones[i] != null) {\n      restoreClone(clones[i], cells[i], mapping);\n    }\n  }\n  return clones;\n};\n/**\n * Inner helper method for cloning cells recursively.\n *\n * @private\n */\nconst cloneCellImpl = (cell, mapping = {}, includeChildren = false) => {\n  const ident = ObjectIdentity.get(cell);\n  let clone = mapping ? mapping[ident] : null;\n  if (clone == null) {\n    clone = cell.clone();\n    mapping[ident] = clone;\n    if (includeChildren) {\n      const childCount = cell.getChildCount();\n      for (let i = 0; i < childCount; i += 1) {\n        const cloneChild = cloneCellImpl(cell.getChildAt(i), mapping, true);\n        clone.insert(cloneChild);\n      }\n    }\n  }\n  return clone;\n};\n/**\n * Inner helper method for restoring the connections in\n * a network of cloned cells.\n *\n * @private\n */\nexport const restoreClone = (clone, cell, mapping) => cells => {\n  const source = cell.getTerminal(true);\n  if (source != null) {\n    const tmp = mapping[ObjectIdentity.get(source)];\n    if (tmp != null) {\n      tmp.insertEdge(clone, true);\n    }\n  }\n  const target = cell.getTerminal(false);\n  if (target != null) {\n    const tmp = mapping[ObjectIdentity.get(target)];\n    if (tmp != null) {\n      tmp.insertEdge(clone, false);\n    }\n  }\n  const childCount = clone.getChildCount();\n  for (let i = 0; i < childCount; i += 1) {\n    restoreClone(clone.getChildAt(i), cell.getChildAt(i), mapping);\n  }\n};","map":{"version":3,"names":["Dictionary","ObjectIdentity","filterCells","filter","cells","result","i","length","push","getOpposites","terminal","sources","targets","edges","terminals","source","getTerminal","target","getTopmostCells","dict","tmp","put","cell","topmost","parent","getParent","get","getParents","parents","cloneCells","includeChildren","mapping","clones","cloneCellImpl","restoreClone","ident","clone","childCount","getChildCount","cloneChild","getChildAt","insert","insertEdge"],"sources":["D:/OSPanel/domains/react/react-intro-main/node_modules/@maxgraph/core/dist/util/cellArrayUtils.js"],"sourcesContent":["import Dictionary from './Dictionary';\nimport ObjectIdentity from './ObjectIdentity';\n/**\n * Returns the cells from the given array where the given filter function\n * returns true.\n */\nexport const filterCells = (filter) => (cells) => {\n    const result = [];\n    for (let i = 0; i < cells.length; i += 1) {\n        if (filter(cells[i])) {\n            result.push(cells[i]);\n        }\n    }\n    return result;\n};\n/**\n * Returns all opposite vertices wrt terminal for the given edges, only\n * returning sources and/or targets as specified. The result is returned\n * as an array of {@link Cell}.\n *\n * @param {Cell} terminal  that specifies the known end of the edges.\n * @param sources  Boolean that specifies if source terminals should be contained\n * in the result. Default is true.\n * @param targets  Boolean that specifies if target terminals should be contained\n * in the result. Default is true.\n */\nexport const getOpposites = (terminal, sources = true, targets = true) => (edges) => {\n    const terminals = [];\n    for (let i = 0; i < edges.length; i += 1) {\n        const source = edges[i].getTerminal(true);\n        const target = edges[i].getTerminal(false);\n        // Checks if the terminal is the source of\n        // the edge and if the target should be\n        // stored in the result\n        if (source === terminal && target != null && target !== terminal && targets) {\n            terminals.push(target);\n        }\n        // Checks if the terminal is the taget of\n        // the edge and if the source should be\n        // stored in the result\n        else if (target === terminal && source != null && source !== terminal && sources) {\n            terminals.push(source);\n        }\n    }\n    return terminals;\n};\n/**\n * Returns the topmost cells of the hierarchy in an array that contains no\n * descendants for each {@link Cell} that it contains. Duplicates should be\n * removed in the cells array to improve performance.\n */\nexport const getTopmostCells = (cells) => {\n    const dict = new Dictionary();\n    const tmp = [];\n    for (let i = 0; i < cells.length; i += 1) {\n        dict.put(cells[i], true);\n    }\n    for (let i = 0; i < cells.length; i += 1) {\n        const cell = cells[i];\n        let topmost = true;\n        let parent = cell.getParent();\n        while (parent != null) {\n            if (dict.get(parent)) {\n                topmost = false;\n                break;\n            }\n            parent = parent.getParent();\n        }\n        if (topmost) {\n            tmp.push(cell);\n        }\n    }\n    return tmp;\n};\n/**\n * Returns an array that represents the set (no duplicates) of all parents\n * for the given array of cells.\n */\nexport const getParents = (cells) => {\n    const parents = [];\n    const dict = new Dictionary();\n    for (const cell of cells) {\n        const parent = cell.getParent();\n        if (parent != null && !dict.get(parent)) {\n            dict.put(parent, true);\n            parents.push(parent);\n        }\n    }\n    return parents;\n};\n/**\n * Returns an array of clones for the given array of {@link Cell}`.\n * Depending on the value of includeChildren, a deep clone is created for\n * each cell. Connections are restored based if the corresponding\n * cell is contained in the passed in array.\n *\n * @param includeChildren  Boolean indicating if the cells should be cloned\n * with all descendants.\n * @param mapping  Optional mapping for existing clones.\n */\nexport const cloneCells = (includeChildren = true, mapping = {}) => (cells) => {\n    const clones = [];\n    for (const cell of cells) {\n        clones.push(cloneCellImpl(cell, mapping, includeChildren));\n    }\n    for (let i = 0; i < clones.length; i += 1) {\n        if (clones[i] != null) {\n            restoreClone(clones[i], cells[i], mapping);\n        }\n    }\n    return clones;\n};\n/**\n * Inner helper method for cloning cells recursively.\n *\n * @private\n */\nconst cloneCellImpl = (cell, mapping = {}, includeChildren = false) => {\n    const ident = ObjectIdentity.get(cell);\n    let clone = mapping ? mapping[ident] : null;\n    if (clone == null) {\n        clone = cell.clone();\n        mapping[ident] = clone;\n        if (includeChildren) {\n            const childCount = cell.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                const cloneChild = cloneCellImpl(cell.getChildAt(i), mapping, true);\n                clone.insert(cloneChild);\n            }\n        }\n    }\n    return clone;\n};\n/**\n * Inner helper method for restoring the connections in\n * a network of cloned cells.\n *\n * @private\n */\nexport const restoreClone = (clone, cell, mapping) => (cells) => {\n    const source = cell.getTerminal(true);\n    if (source != null) {\n        const tmp = mapping[ObjectIdentity.get(source)];\n        if (tmp != null) {\n            tmp.insertEdge(clone, true);\n        }\n    }\n    const target = cell.getTerminal(false);\n    if (target != null) {\n        const tmp = mapping[ObjectIdentity.get(target)];\n        if (tmp != null) {\n            tmp.insertEdge(clone, false);\n        }\n    }\n    const childCount = clone.getChildCount();\n    for (let i = 0; i < childCount; i += 1) {\n        restoreClone(clone.getChildAt(i), cell.getChildAt(i), mapping);\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}