{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { mixInto } from '../../util/Utils';\nimport { hasScrollbars } from '../../util/styleUtils';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport { Graph } from '../Graph';\nimport Rectangle from '../geometry/Rectangle';\nimport Point from '../geometry/Point';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst PanningMixin = {\n  shiftPreview1: null,\n  shiftPreview2: null,\n  /**\n   * Specifies if scrollbars should be used for panning in {@link panGraph} if\n   * any scrollbars are available. If scrollbars are enabled in CSS, but no\n   * scrollbars appear because the graph is smaller than the container size,\n   * then no panning occurs if this is `true`.\n   * @default true\n   */\n  useScrollbarsForPanning: true,\n  isUseScrollbarsForPanning() {\n    return this.useScrollbarsForPanning;\n  },\n  /**\n   * Specifies if autoscrolling should be carried out via mxPanningManager even\n   * if the container has scrollbars. This disables {@link scrollPointToVisible} and\n   * uses {@link PanningManager} instead. If this is true then {@link autoExtend} is\n   * disabled. It should only be used with a scroll buffer or when scollbars\n   * are visible and scrollable in all directions.\n   * @default false\n   */\n  timerAutoScroll: false,\n  isTimerAutoScroll() {\n    return this.timerAutoScroll;\n  },\n  /**\n   * Specifies if panning via {@link panGraph} should be allowed to implement autoscroll\n   * if no scrollbars are available in {@link scrollPointToVisible}. To enable panning\n   * inside the container, near the edge, set {@link PanningManager.border} to a\n   * positive value.\n   * @default false\n   */\n  allowAutoPanning: false,\n  isAllowAutoPanning() {\n    return this.allowAutoPanning;\n  },\n  /**\n   * Current horizontal panning value.\n   * @default 0\n   */\n  panDx: 0,\n  getPanDx() {\n    return this.panDx;\n  },\n  setPanDx(dx) {\n    this.panDx = dx;\n  },\n  /**\n   * Current vertical panning value.\n   * @default 0\n   */\n  panDy: 0,\n  getPanDy() {\n    return this.panDy;\n  },\n  setPanDy(dy) {\n    this.panDy = dy;\n  },\n  /**\n   * Shifts the graph display by the given amount. This is used to preview\n   * panning operations, use {@link GraphView.setTranslate} to set a persistent\n   * translation of the view. Fires {@link InternalEvent.PAN}.\n   *\n   * @param dx Amount to shift the graph along the x-axis.\n   * @param dy Amount to shift the graph along the y-axis.\n   */\n  panGraph(dx, dy) {\n    const container = this.getContainer();\n    if (this.useScrollbarsForPanning && hasScrollbars(container)) {\n      container.scrollLeft = -dx;\n      container.scrollTop = -dy;\n    } else {\n      const canvas = this.getView().getCanvas();\n      // Puts everything inside the container in a DIV so that it\n      // can be moved without changing the state of the container\n      if (dx === 0 && dy === 0) {\n        canvas.removeAttribute('transform');\n        if (this.shiftPreview1) {\n          let child = this.shiftPreview1.firstChild;\n          while (child) {\n            const next = child.nextSibling;\n            container.appendChild(child);\n            child = next;\n          }\n          if (this.shiftPreview1.parentNode) {\n            this.shiftPreview1.parentNode.removeChild(this.shiftPreview1);\n          }\n          this.shiftPreview1 = null;\n          container.appendChild(canvas.parentNode);\n          const shiftPreview2 = this.shiftPreview2;\n          child = shiftPreview2.firstChild;\n          while (child) {\n            const next = child.nextSibling;\n            container.appendChild(child);\n            child = next;\n          }\n          if (shiftPreview2.parentNode) {\n            shiftPreview2.parentNode.removeChild(shiftPreview2);\n          }\n          this.shiftPreview2 = null;\n        }\n      } else {\n        canvas.setAttribute('transform', `translate(${dx},${dy})`);\n        if (!this.shiftPreview1) {\n          // Needs two divs for stuff before and after the SVG element\n          this.shiftPreview1 = document.createElement('div');\n          this.shiftPreview1.style.position = 'absolute';\n          this.shiftPreview1.style.overflow = 'visible';\n          this.shiftPreview2 = document.createElement('div');\n          this.shiftPreview2.style.position = 'absolute';\n          this.shiftPreview2.style.overflow = 'visible';\n          let current = this.shiftPreview1;\n          let child = container.firstChild;\n          while (child) {\n            const next = child.nextSibling;\n            // SVG element is moved via transform attribute\n            // @ts-ignore\n            if (child !== canvas.parentNode) {\n              current.appendChild(child);\n            } else {\n              current = this.shiftPreview2;\n            }\n            child = next;\n          }\n          // Inserts elements only if not empty\n          if (this.shiftPreview1.firstChild) {\n            container.insertBefore(this.shiftPreview1, canvas.parentNode);\n          }\n          if (this.shiftPreview2.firstChild) {\n            container.appendChild(this.shiftPreview2);\n          }\n        }\n        this.shiftPreview1.style.left = `${dx}px`;\n        this.shiftPreview1.style.top = `${dy}px`;\n        if (this.shiftPreview2) {\n          this.shiftPreview2.style.left = `${dx}px`;\n          this.shiftPreview2.style.top = `${dy}px`;\n        }\n      }\n      this.panDx = dx;\n      this.panDy = dy;\n      this.fireEvent(new EventObject(InternalEvent.PAN));\n    }\n  },\n  /**\n   * Pans the graph so that it shows the given cell. Optionally the cell may\n   * be centered in the container.\n   *\n   * To center a given graph if the {@link container} has no scrollbars, use the following code.\n   *\n   * [code]\n   * var bounds = graph.getGraphBounds();\n   * graph.view.setTranslate(-bounds.x - (bounds.width - container.clientWidth) / 2,\n   * \t\t\t\t\t\t   -bounds.y - (bounds.height - container.clientHeight) / 2);\n   * [/code]\n   *\n   * @param cell {@link mxCell} to be made visible.\n   * @param center Optional boolean flag. Default is `false`.\n   */\n  scrollCellToVisible(cell, center = false) {\n    const x = -this.getView().translate.x;\n    const y = -this.getView().translate.y;\n    const state = this.getView().getState(cell);\n    if (state) {\n      const bounds = new Rectangle(x + state.x, y + state.y, state.width, state.height);\n      if (center && this.getContainer()) {\n        const w = this.getContainer().clientWidth;\n        const h = this.getContainer().clientHeight;\n        bounds.x = bounds.getCenterX() - w / 2;\n        bounds.width = w;\n        bounds.y = bounds.getCenterY() - h / 2;\n        bounds.height = h;\n      }\n      const tr = new Point(this.getView().translate.x, this.getView().translate.y);\n      if (this.scrollRectToVisible(bounds)) {\n        // Triggers an update via the view's event source\n        const tr2 = new Point(this.getView().translate.x, this.getView().translate.y);\n        this.getView().translate.x = tr.x;\n        this.getView().translate.y = tr.y;\n        this.getView().setTranslate(tr2.x, tr2.y);\n      }\n    }\n  },\n  /**\n   * Pans the graph so that it shows the given rectangle.\n   *\n   * @param rect {@link mxRectangle} to be made visible.\n   */\n  scrollRectToVisible(rect) {\n    let isChanged = false;\n    const container = this.getContainer();\n    const w = container.offsetWidth;\n    const h = container.offsetHeight;\n    const widthLimit = Math.min(w, rect.width);\n    const heightLimit = Math.min(h, rect.height);\n    if (hasScrollbars(container)) {\n      rect.x += this.getView().translate.x;\n      rect.y += this.getView().translate.y;\n      let dx = container.scrollLeft - rect.x;\n      const ddx = Math.max(dx - container.scrollLeft, 0);\n      if (dx > 0) {\n        container.scrollLeft -= dx + 2;\n      } else {\n        dx = rect.x + widthLimit - container.scrollLeft - container.clientWidth;\n        if (dx > 0) {\n          container.scrollLeft += dx + 2;\n        }\n      }\n      let dy = container.scrollTop - rect.y;\n      const ddy = Math.max(0, dy - container.scrollTop);\n      if (dy > 0) {\n        container.scrollTop -= dy + 2;\n      } else {\n        dy = rect.y + heightLimit - container.scrollTop - container.clientHeight;\n        if (dy > 0) {\n          container.scrollTop += dy + 2;\n        }\n      }\n      if (!this.useScrollbarsForPanning && (ddx != 0 || ddy != 0)) {\n        this.getView().setTranslate(ddx, ddy);\n      }\n    } else {\n      const x = -this.getView().translate.x;\n      const y = -this.getView().translate.y;\n      const s = this.getView().scale;\n      if (rect.x + widthLimit > x + w) {\n        this.getView().translate.x -= (rect.x + widthLimit - w - x) / s;\n        isChanged = true;\n      }\n      if (rect.y + heightLimit > y + h) {\n        this.getView().translate.y -= (rect.y + heightLimit - h - y) / s;\n        isChanged = true;\n      }\n      if (rect.x < x) {\n        this.getView().translate.x += (x - rect.x) / s;\n        isChanged = true;\n      }\n      if (rect.y < y) {\n        this.getView().translate.y += (y - rect.y) / s;\n        isChanged = true;\n      }\n      if (isChanged) {\n        this.getView().refresh();\n        const selectionCellsHandler = this.getPlugin('SelectionCellsHandler');\n        // Repaints selection marker (ticket 18)\n        if (selectionCellsHandler) {\n          selectionCellsHandler.refresh();\n        }\n      }\n    }\n    return isChanged;\n  },\n  /*****************************************************************************\n   * Group: Graph behaviour\n   *****************************************************************************/\n  /**\n   * Specifies if panning should be enabled. This implementation updates {@link PanningHandler.panningEnabled}.\n   *\n   * @param enabled Boolean indicating if panning should be enabled.\n   */\n  setPanning(enabled) {\n    const panningHandler = this.getPlugin('PanningHandler');\n    panningHandler && (panningHandler.panningEnabled = enabled);\n  }\n};\nmixInto(Graph)(PanningMixin);","map":{"version":3,"names":["mixInto","hasScrollbars","EventObject","InternalEvent","Graph","Rectangle","Point","PanningMixin","shiftPreview1","shiftPreview2","useScrollbarsForPanning","isUseScrollbarsForPanning","timerAutoScroll","isTimerAutoScroll","allowAutoPanning","isAllowAutoPanning","panDx","getPanDx","setPanDx","dx","panDy","getPanDy","setPanDy","dy","panGraph","container","getContainer","scrollLeft","scrollTop","canvas","getView","getCanvas","removeAttribute","child","firstChild","next","nextSibling","appendChild","parentNode","removeChild","setAttribute","document","createElement","style","position","overflow","current","insertBefore","left","top","fireEvent","PAN","scrollCellToVisible","cell","center","x","translate","y","state","getState","bounds","width","height","w","clientWidth","h","clientHeight","getCenterX","getCenterY","tr","scrollRectToVisible","tr2","setTranslate","rect","isChanged","offsetWidth","offsetHeight","widthLimit","Math","min","heightLimit","ddx","max","ddy","s","scale","refresh","selectionCellsHandler","getPlugin","setPanning","enabled","panningHandler","panningEnabled"],"sources":["D:/ospanel/domains/old/react/react-intro/node_modules/@maxgraph/core/dist/view/mixins/PanningMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { mixInto } from '../../util/Utils';\nimport { hasScrollbars } from '../../util/styleUtils';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport { Graph } from '../Graph';\nimport Rectangle from '../geometry/Rectangle';\nimport Point from '../geometry/Point';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst PanningMixin = {\n    shiftPreview1: null,\n    shiftPreview2: null,\n    /**\n     * Specifies if scrollbars should be used for panning in {@link panGraph} if\n     * any scrollbars are available. If scrollbars are enabled in CSS, but no\n     * scrollbars appear because the graph is smaller than the container size,\n     * then no panning occurs if this is `true`.\n     * @default true\n     */\n    useScrollbarsForPanning: true,\n    isUseScrollbarsForPanning() {\n        return this.useScrollbarsForPanning;\n    },\n    /**\n     * Specifies if autoscrolling should be carried out via mxPanningManager even\n     * if the container has scrollbars. This disables {@link scrollPointToVisible} and\n     * uses {@link PanningManager} instead. If this is true then {@link autoExtend} is\n     * disabled. It should only be used with a scroll buffer or when scollbars\n     * are visible and scrollable in all directions.\n     * @default false\n     */\n    timerAutoScroll: false,\n    isTimerAutoScroll() {\n        return this.timerAutoScroll;\n    },\n    /**\n     * Specifies if panning via {@link panGraph} should be allowed to implement autoscroll\n     * if no scrollbars are available in {@link scrollPointToVisible}. To enable panning\n     * inside the container, near the edge, set {@link PanningManager.border} to a\n     * positive value.\n     * @default false\n     */\n    allowAutoPanning: false,\n    isAllowAutoPanning() {\n        return this.allowAutoPanning;\n    },\n    /**\n     * Current horizontal panning value.\n     * @default 0\n     */\n    panDx: 0,\n    getPanDx() {\n        return this.panDx;\n    },\n    setPanDx(dx) {\n        this.panDx = dx;\n    },\n    /**\n     * Current vertical panning value.\n     * @default 0\n     */\n    panDy: 0,\n    getPanDy() {\n        return this.panDy;\n    },\n    setPanDy(dy) {\n        this.panDy = dy;\n    },\n    /**\n     * Shifts the graph display by the given amount. This is used to preview\n     * panning operations, use {@link GraphView.setTranslate} to set a persistent\n     * translation of the view. Fires {@link InternalEvent.PAN}.\n     *\n     * @param dx Amount to shift the graph along the x-axis.\n     * @param dy Amount to shift the graph along the y-axis.\n     */\n    panGraph(dx, dy) {\n        const container = this.getContainer();\n        if (this.useScrollbarsForPanning && hasScrollbars(container)) {\n            container.scrollLeft = -dx;\n            container.scrollTop = -dy;\n        }\n        else {\n            const canvas = this.getView().getCanvas();\n            // Puts everything inside the container in a DIV so that it\n            // can be moved without changing the state of the container\n            if (dx === 0 && dy === 0) {\n                canvas.removeAttribute('transform');\n                if (this.shiftPreview1) {\n                    let child = this.shiftPreview1.firstChild;\n                    while (child) {\n                        const next = child.nextSibling;\n                        container.appendChild(child);\n                        child = next;\n                    }\n                    if (this.shiftPreview1.parentNode) {\n                        this.shiftPreview1.parentNode.removeChild(this.shiftPreview1);\n                    }\n                    this.shiftPreview1 = null;\n                    container.appendChild(canvas.parentNode);\n                    const shiftPreview2 = this.shiftPreview2;\n                    child = shiftPreview2.firstChild;\n                    while (child) {\n                        const next = child.nextSibling;\n                        container.appendChild(child);\n                        child = next;\n                    }\n                    if (shiftPreview2.parentNode) {\n                        shiftPreview2.parentNode.removeChild(shiftPreview2);\n                    }\n                    this.shiftPreview2 = null;\n                }\n            }\n            else {\n                canvas.setAttribute('transform', `translate(${dx},${dy})`);\n                if (!this.shiftPreview1) {\n                    // Needs two divs for stuff before and after the SVG element\n                    this.shiftPreview1 = document.createElement('div');\n                    this.shiftPreview1.style.position = 'absolute';\n                    this.shiftPreview1.style.overflow = 'visible';\n                    this.shiftPreview2 = document.createElement('div');\n                    this.shiftPreview2.style.position = 'absolute';\n                    this.shiftPreview2.style.overflow = 'visible';\n                    let current = this.shiftPreview1;\n                    let child = container.firstChild;\n                    while (child) {\n                        const next = child.nextSibling;\n                        // SVG element is moved via transform attribute\n                        // @ts-ignore\n                        if (child !== canvas.parentNode) {\n                            current.appendChild(child);\n                        }\n                        else {\n                            current = this.shiftPreview2;\n                        }\n                        child = next;\n                    }\n                    // Inserts elements only if not empty\n                    if (this.shiftPreview1.firstChild) {\n                        container.insertBefore(this.shiftPreview1, canvas.parentNode);\n                    }\n                    if (this.shiftPreview2.firstChild) {\n                        container.appendChild(this.shiftPreview2);\n                    }\n                }\n                this.shiftPreview1.style.left = `${dx}px`;\n                this.shiftPreview1.style.top = `${dy}px`;\n                if (this.shiftPreview2) {\n                    this.shiftPreview2.style.left = `${dx}px`;\n                    this.shiftPreview2.style.top = `${dy}px`;\n                }\n            }\n            this.panDx = dx;\n            this.panDy = dy;\n            this.fireEvent(new EventObject(InternalEvent.PAN));\n        }\n    },\n    /**\n     * Pans the graph so that it shows the given cell. Optionally the cell may\n     * be centered in the container.\n     *\n     * To center a given graph if the {@link container} has no scrollbars, use the following code.\n     *\n     * [code]\n     * var bounds = graph.getGraphBounds();\n     * graph.view.setTranslate(-bounds.x - (bounds.width - container.clientWidth) / 2,\n     * \t\t\t\t\t\t   -bounds.y - (bounds.height - container.clientHeight) / 2);\n     * [/code]\n     *\n     * @param cell {@link mxCell} to be made visible.\n     * @param center Optional boolean flag. Default is `false`.\n     */\n    scrollCellToVisible(cell, center = false) {\n        const x = -this.getView().translate.x;\n        const y = -this.getView().translate.y;\n        const state = this.getView().getState(cell);\n        if (state) {\n            const bounds = new Rectangle(x + state.x, y + state.y, state.width, state.height);\n            if (center && this.getContainer()) {\n                const w = this.getContainer().clientWidth;\n                const h = this.getContainer().clientHeight;\n                bounds.x = bounds.getCenterX() - w / 2;\n                bounds.width = w;\n                bounds.y = bounds.getCenterY() - h / 2;\n                bounds.height = h;\n            }\n            const tr = new Point(this.getView().translate.x, this.getView().translate.y);\n            if (this.scrollRectToVisible(bounds)) {\n                // Triggers an update via the view's event source\n                const tr2 = new Point(this.getView().translate.x, this.getView().translate.y);\n                this.getView().translate.x = tr.x;\n                this.getView().translate.y = tr.y;\n                this.getView().setTranslate(tr2.x, tr2.y);\n            }\n        }\n    },\n    /**\n     * Pans the graph so that it shows the given rectangle.\n     *\n     * @param rect {@link mxRectangle} to be made visible.\n     */\n    scrollRectToVisible(rect) {\n        let isChanged = false;\n        const container = this.getContainer();\n        const w = container.offsetWidth;\n        const h = container.offsetHeight;\n        const widthLimit = Math.min(w, rect.width);\n        const heightLimit = Math.min(h, rect.height);\n        if (hasScrollbars(container)) {\n            rect.x += this.getView().translate.x;\n            rect.y += this.getView().translate.y;\n            let dx = container.scrollLeft - rect.x;\n            const ddx = Math.max(dx - container.scrollLeft, 0);\n            if (dx > 0) {\n                container.scrollLeft -= dx + 2;\n            }\n            else {\n                dx = rect.x + widthLimit - container.scrollLeft - container.clientWidth;\n                if (dx > 0) {\n                    container.scrollLeft += dx + 2;\n                }\n            }\n            let dy = container.scrollTop - rect.y;\n            const ddy = Math.max(0, dy - container.scrollTop);\n            if (dy > 0) {\n                container.scrollTop -= dy + 2;\n            }\n            else {\n                dy = rect.y + heightLimit - container.scrollTop - container.clientHeight;\n                if (dy > 0) {\n                    container.scrollTop += dy + 2;\n                }\n            }\n            if (!this.useScrollbarsForPanning && (ddx != 0 || ddy != 0)) {\n                this.getView().setTranslate(ddx, ddy);\n            }\n        }\n        else {\n            const x = -this.getView().translate.x;\n            const y = -this.getView().translate.y;\n            const s = this.getView().scale;\n            if (rect.x + widthLimit > x + w) {\n                this.getView().translate.x -= (rect.x + widthLimit - w - x) / s;\n                isChanged = true;\n            }\n            if (rect.y + heightLimit > y + h) {\n                this.getView().translate.y -= (rect.y + heightLimit - h - y) / s;\n                isChanged = true;\n            }\n            if (rect.x < x) {\n                this.getView().translate.x += (x - rect.x) / s;\n                isChanged = true;\n            }\n            if (rect.y < y) {\n                this.getView().translate.y += (y - rect.y) / s;\n                isChanged = true;\n            }\n            if (isChanged) {\n                this.getView().refresh();\n                const selectionCellsHandler = this.getPlugin('SelectionCellsHandler');\n                // Repaints selection marker (ticket 18)\n                if (selectionCellsHandler) {\n                    selectionCellsHandler.refresh();\n                }\n            }\n        }\n        return isChanged;\n    },\n    /*****************************************************************************\n     * Group: Graph behaviour\n     *****************************************************************************/\n    /**\n     * Specifies if panning should be enabled. This implementation updates {@link PanningHandler.panningEnabled}.\n     *\n     * @param enabled Boolean indicating if panning should be enabled.\n     */\n    setPanning(enabled) {\n        const panningHandler = this.getPlugin('PanningHandler');\n        panningHandler && (panningHandler.panningEnabled = enabled);\n    },\n};\nmixInto(Graph)(PanningMixin);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}