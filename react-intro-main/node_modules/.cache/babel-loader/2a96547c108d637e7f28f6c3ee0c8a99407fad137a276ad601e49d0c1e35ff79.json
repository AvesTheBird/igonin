{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport EventSource from '../event/EventSource';\nimport InternalEvent from '../event/InternalEvent';\nimport { convertPoint, sortCells } from '../../util/styleUtils';\nimport RootChange from '../undoable_changes/RootChange';\nimport ChildChange from '../undoable_changes/ChildChange';\nimport TerminalChange from '../undoable_changes/TerminalChange';\nimport GeometryChange from '../undoable_changes/GeometryChange';\nimport VisibleChange from '../undoable_changes/VisibleChange';\nimport StyleChange from '../undoable_changes/StyleChange';\nimport EventObject from '../event/EventObject';\nimport { getClientX, getClientY } from '../../util/EventUtils';\n/**\n * @class LayoutManager\n * @extends {EventSource}\n *\n * Implements a layout manager that runs a given layout after any changes to the graph:\n *\n * ### Example\n *\n * ```javascript\n * var layoutMgr = new mxLayoutManager(graph);\n * layoutMgr.getLayout(cell, eventName)\n * {\n *   return layout;\n * };\n * ```\n *\n * See {@link getLayout} for a description of the possible eventNames.\n *\n * #### Event: mxEvent.LAYOUT_CELLS\n *\n * Fires between begin- and endUpdate after all cells have been layouted in\n * {@link layoutCells}. The `cells` property contains all cells that have\n * been passed to {@link layoutCells}.\n */\nclass LayoutManager extends EventSource {\n  constructor(graph) {\n    super();\n    /**\n     * Specifies if the layout should bubble along\n     * the cell hierarchy.\n     * @default true\n     */\n    this.bubbling = true;\n    /**\n     * Specifies if event handling is enabled.\n     * @default true\n     */\n    this.enabled = true;\n    // Executes the layout before the changes are dispatched\n    this.undoHandler = (sender, evt) => {\n      if (this.isEnabled()) {\n        this.beforeUndo(evt.getProperty('edit'));\n      }\n    };\n    // Notifies the layout of a move operation inside a parent\n    this.moveHandler = (sender, evt) => {\n      if (this.isEnabled()) {\n        this.cellsMoved(evt.getProperty('cells'), evt.getProperty('event'));\n      }\n    };\n    // Notifies the layout of a move operation inside a parent\n    this.resizeHandler = (sender, evt) => {\n      if (this.isEnabled()) {\n        this.cellsResized(evt.getProperty('cells'), evt.getProperty('bounds'), evt.getProperty('previous'));\n      }\n    };\n    this.setGraph(graph);\n  }\n  /**\n   * Returns true if events are handled. This implementation\n   * returns {@link enabled}.\n   */\n  isEnabled() {\n    return this.enabled;\n  }\n  /**\n   * Enables or disables event handling. This implementation\n   * updates {@link enabled}.\n   *\n   * @param enabled Boolean that specifies the new enabled state.\n   */\n  setEnabled(enabled) {\n    this.enabled = enabled;\n  }\n  /**\n   * Returns true if a layout should bubble, that is, if the parent layout\n   * should be executed whenever a cell layout (layout of the children of\n   * a cell) has been executed. This implementation returns {@link bubbling}.\n   */\n  isBubbling() {\n    return this.bubbling;\n  }\n  /**\n   * Sets {@link bubbling}.\n   */\n  setBubbling(value) {\n    this.bubbling = value;\n  }\n  /**\n   * Returns the graph that this layout operates on.\n   */\n  getGraph() {\n    return this.graph;\n  }\n  /**\n   * Sets the graph that the layouts operate on.\n   */\n  setGraph(graph) {\n    if (this.graph) {\n      const model = this.graph.getDataModel();\n      model.removeListener(this.undoHandler);\n      this.graph.removeListener(this.moveHandler);\n      this.graph.removeListener(this.resizeHandler);\n    }\n    this.graph = graph;\n    if (this.graph) {\n      const model = this.graph.getDataModel();\n      model.addListener(InternalEvent.BEFORE_UNDO, this.undoHandler);\n      this.graph.addListener(InternalEvent.MOVE_CELLS, this.moveHandler);\n      this.graph.addListener(InternalEvent.RESIZE_CELLS, this.resizeHandler);\n    }\n  }\n  /**\n   * Returns true if the given cell has a layout. This implementation invokes\n   * <getLayout> with {@link Event#LAYOUT_CELLS} as the eventName. Override this\n   * if creating layouts in <getLayout> is expensive and return true if\n   * <getLayout> will return a layout for the given cell for\n   * {@link Event#BEGIN_UPDATE} or {@link Event#END_UPDATE}.\n   */\n  hasLayout(cell) {\n    return !!this.getLayout(cell, InternalEvent.LAYOUT_CELLS);\n  }\n  /**\n   * Returns the layout for the given cell and eventName. Possible\n   * event names are {@link InternalEvent.MOVE_CELLS} and {@link InternalEvent.RESIZE_CELLS}\n   * for callbacks on when cells are moved or resized and\n   * {@link InternalEvent.BEGIN_UPDATE} and {@link InternalEvent.END_UPDATE} for the capture\n   * and bubble phase of the layout after any changes of the model.\n   */\n  getLayout(cell, eventName) {\n    return null;\n  }\n  /**\n   * Called from {@link undoHandler}.\n   *\n   * @param cell Array of {@link Cell} that have been moved.\n   * @param evt Mouse event that represents the mousedown.\n   *\n   * TODO: what is undoableEdit type?\n   */\n  beforeUndo(undoableEdit) {\n    this.executeLayoutForCells(this.getCellsForChanges(undoableEdit.changes));\n  }\n  /**\n   * Called from {@link moveHandler}.\n   *\n   * @param cell Array of {@link Cell} that have been moved.\n   * @param evt Mouse event that represents the mousedown.\n   */\n  cellsMoved(cells, evt) {\n    if (cells.length > 0 && evt) {\n      const point = convertPoint(this.getGraph().container, getClientX(evt), getClientY(evt));\n      for (let i = 0; i < cells.length; i += 1) {\n        const layout = this.getLayout(cells[i].getParent(), InternalEvent.MOVE_CELLS);\n        if (layout) {\n          layout.moveCell(cells[i], point.x, point.y);\n        }\n      }\n    }\n  }\n  /**\n   * Called from {@link resizeHandler}.\n   *\n   * @param cell Array of {@link Cell} that have been resized.\n   * @param bounds {@link mxRectangle} taht represents the new bounds.\n   */\n  cellsResized(cells = null, bounds = null, prev = null) {\n    if (cells && bounds) {\n      for (let i = 0; i < cells.length; i += 1) {\n        const layout = this.getLayout(cells[i].getParent(), InternalEvent.RESIZE_CELLS);\n        if (layout) {\n          layout.resizeCell(cells[i], bounds[i], prev?.[i]);\n        }\n      }\n    }\n  }\n  /**\n   * Returns the cells for which a layout should be executed.\n   */\n  getCellsForChanges(changes) {\n    let result = [];\n    for (const change of changes) {\n      if (change instanceof RootChange) {\n        return [];\n      }\n      result = result.concat(this.getCellsForChange(change));\n    }\n    return result;\n  }\n  /**\n   * Executes all layouts which have been scheduled during the\n   * changes.\n   * @param change  mxChildChange|mxTerminalChange|mxVisibleChange|...\n   */\n  getCellsForChange(change) {\n    if (change instanceof ChildChange) {\n      return this.addCellsWithLayout(change.child, this.addCellsWithLayout(change.previous));\n    }\n    if (change instanceof TerminalChange || change instanceof GeometryChange) {\n      return this.addCellsWithLayout(change.cell);\n    }\n    if (change instanceof VisibleChange || change instanceof StyleChange) {\n      return this.addCellsWithLayout(change.cell);\n    }\n    return [];\n  }\n  /**\n   * Adds all ancestors of the given cell that have a layout.\n   */\n  addCellsWithLayout(cell, result = []) {\n    return this.addDescendantsWithLayout(cell, this.addAncestorsWithLayout(cell, result));\n  }\n  /**\n   * Adds all ancestors of the given cell that have a layout.\n   */\n  addAncestorsWithLayout(cell, result = []) {\n    if (cell) {\n      const layout = this.hasLayout(cell);\n      if (layout) {\n        result.push(cell);\n      }\n      if (this.isBubbling()) {\n        this.addAncestorsWithLayout(cell.getParent(), result);\n      }\n    }\n    return result;\n  }\n  /**\n   * Adds all descendants of the given cell that have a layout.\n   */\n  addDescendantsWithLayout(cell, result = []) {\n    if (cell && this.hasLayout(cell)) {\n      for (let i = 0; i < cell.getChildCount(); i += 1) {\n        const child = cell.getChildAt(i);\n        if (this.hasLayout(child)) {\n          result.push(child);\n          this.addDescendantsWithLayout(child, result);\n        }\n      }\n    }\n    return result;\n  }\n  /**\n   * Executes the given layout on the given parent.\n   */\n  executeLayoutForCells(cells) {\n    const sorted = sortCells(cells, false);\n    this.layoutCells(sorted, true);\n    this.layoutCells(sorted.reverse(), false);\n  }\n  /**\n   * Executes all layouts which have been scheduled during the changes.\n   */\n  layoutCells(cells, bubble = false) {\n    if (cells.length > 0) {\n      // Invokes the layouts while removing duplicates\n      const model = this.getGraph().getDataModel();\n      model.batchUpdate(() => {\n        let last = null;\n        for (const cell of cells) {\n          if (cell !== model.getRoot() && cell !== last) {\n            this.executeLayout(cell, bubble);\n            last = cell;\n          }\n        }\n        this.fireEvent(new EventObject(InternalEvent.LAYOUT_CELLS, {\n          cells\n        }));\n      });\n    }\n  }\n  /**\n   * Executes the given layout on the given parent.\n   */\n  executeLayout(cell, bubble = false) {\n    const layout = this.getLayout(cell, bubble ? InternalEvent.BEGIN_UPDATE : InternalEvent.END_UPDATE);\n    if (layout) {\n      layout.execute(cell);\n    }\n  }\n  /**\n   * Removes all handlers from the {@link graph} and deletes the reference to it.\n   */\n  destroy() {\n    this.setGraph(null);\n  }\n}\nexport default LayoutManager;","map":{"version":3,"names":["EventSource","InternalEvent","convertPoint","sortCells","RootChange","ChildChange","TerminalChange","GeometryChange","VisibleChange","StyleChange","EventObject","getClientX","getClientY","LayoutManager","constructor","graph","bubbling","enabled","undoHandler","sender","evt","isEnabled","beforeUndo","getProperty","moveHandler","cellsMoved","resizeHandler","cellsResized","setGraph","setEnabled","isBubbling","setBubbling","value","getGraph","model","getDataModel","removeListener","addListener","BEFORE_UNDO","MOVE_CELLS","RESIZE_CELLS","hasLayout","cell","getLayout","LAYOUT_CELLS","eventName","undoableEdit","executeLayoutForCells","getCellsForChanges","changes","cells","length","point","container","i","layout","getParent","moveCell","x","y","bounds","prev","resizeCell","result","change","concat","getCellsForChange","addCellsWithLayout","child","previous","addDescendantsWithLayout","addAncestorsWithLayout","push","getChildCount","getChildAt","sorted","layoutCells","reverse","bubble","batchUpdate","last","getRoot","executeLayout","fireEvent","BEGIN_UPDATE","END_UPDATE","execute","destroy"],"sources":["D:/ospanel/domains/old/react/react-intro-main/node_modules/@maxgraph/core/dist/view/layout/LayoutManager.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport EventSource from '../event/EventSource';\nimport InternalEvent from '../event/InternalEvent';\nimport { convertPoint, sortCells } from '../../util/styleUtils';\nimport RootChange from '../undoable_changes/RootChange';\nimport ChildChange from '../undoable_changes/ChildChange';\nimport TerminalChange from '../undoable_changes/TerminalChange';\nimport GeometryChange from '../undoable_changes/GeometryChange';\nimport VisibleChange from '../undoable_changes/VisibleChange';\nimport StyleChange from '../undoable_changes/StyleChange';\nimport EventObject from '../event/EventObject';\nimport { getClientX, getClientY } from '../../util/EventUtils';\n/**\n * @class LayoutManager\n * @extends {EventSource}\n *\n * Implements a layout manager that runs a given layout after any changes to the graph:\n *\n * ### Example\n *\n * ```javascript\n * var layoutMgr = new mxLayoutManager(graph);\n * layoutMgr.getLayout(cell, eventName)\n * {\n *   return layout;\n * };\n * ```\n *\n * See {@link getLayout} for a description of the possible eventNames.\n *\n * #### Event: mxEvent.LAYOUT_CELLS\n *\n * Fires between begin- and endUpdate after all cells have been layouted in\n * {@link layoutCells}. The `cells` property contains all cells that have\n * been passed to {@link layoutCells}.\n */\nclass LayoutManager extends EventSource {\n    constructor(graph) {\n        super();\n        /**\n         * Specifies if the layout should bubble along\n         * the cell hierarchy.\n         * @default true\n         */\n        this.bubbling = true;\n        /**\n         * Specifies if event handling is enabled.\n         * @default true\n         */\n        this.enabled = true;\n        // Executes the layout before the changes are dispatched\n        this.undoHandler = (sender, evt) => {\n            if (this.isEnabled()) {\n                this.beforeUndo(evt.getProperty('edit'));\n            }\n        };\n        // Notifies the layout of a move operation inside a parent\n        this.moveHandler = (sender, evt) => {\n            if (this.isEnabled()) {\n                this.cellsMoved(evt.getProperty('cells'), evt.getProperty('event'));\n            }\n        };\n        // Notifies the layout of a move operation inside a parent\n        this.resizeHandler = (sender, evt) => {\n            if (this.isEnabled()) {\n                this.cellsResized(evt.getProperty('cells'), evt.getProperty('bounds'), evt.getProperty('previous'));\n            }\n        };\n        this.setGraph(graph);\n    }\n    /**\n     * Returns true if events are handled. This implementation\n     * returns {@link enabled}.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Enables or disables event handling. This implementation\n     * updates {@link enabled}.\n     *\n     * @param enabled Boolean that specifies the new enabled state.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n    }\n    /**\n     * Returns true if a layout should bubble, that is, if the parent layout\n     * should be executed whenever a cell layout (layout of the children of\n     * a cell) has been executed. This implementation returns {@link bubbling}.\n     */\n    isBubbling() {\n        return this.bubbling;\n    }\n    /**\n     * Sets {@link bubbling}.\n     */\n    setBubbling(value) {\n        this.bubbling = value;\n    }\n    /**\n     * Returns the graph that this layout operates on.\n     */\n    getGraph() {\n        return this.graph;\n    }\n    /**\n     * Sets the graph that the layouts operate on.\n     */\n    setGraph(graph) {\n        if (this.graph) {\n            const model = this.graph.getDataModel();\n            model.removeListener(this.undoHandler);\n            this.graph.removeListener(this.moveHandler);\n            this.graph.removeListener(this.resizeHandler);\n        }\n        this.graph = graph;\n        if (this.graph) {\n            const model = this.graph.getDataModel();\n            model.addListener(InternalEvent.BEFORE_UNDO, this.undoHandler);\n            this.graph.addListener(InternalEvent.MOVE_CELLS, this.moveHandler);\n            this.graph.addListener(InternalEvent.RESIZE_CELLS, this.resizeHandler);\n        }\n    }\n    /**\n     * Returns true if the given cell has a layout. This implementation invokes\n     * <getLayout> with {@link Event#LAYOUT_CELLS} as the eventName. Override this\n     * if creating layouts in <getLayout> is expensive and return true if\n     * <getLayout> will return a layout for the given cell for\n     * {@link Event#BEGIN_UPDATE} or {@link Event#END_UPDATE}.\n     */\n    hasLayout(cell) {\n        return !!this.getLayout(cell, InternalEvent.LAYOUT_CELLS);\n    }\n    /**\n     * Returns the layout for the given cell and eventName. Possible\n     * event names are {@link InternalEvent.MOVE_CELLS} and {@link InternalEvent.RESIZE_CELLS}\n     * for callbacks on when cells are moved or resized and\n     * {@link InternalEvent.BEGIN_UPDATE} and {@link InternalEvent.END_UPDATE} for the capture\n     * and bubble phase of the layout after any changes of the model.\n     */\n    getLayout(cell, eventName) {\n        return null;\n    }\n    /**\n     * Called from {@link undoHandler}.\n     *\n     * @param cell Array of {@link Cell} that have been moved.\n     * @param evt Mouse event that represents the mousedown.\n     *\n     * TODO: what is undoableEdit type?\n     */\n    beforeUndo(undoableEdit) {\n        this.executeLayoutForCells(this.getCellsForChanges(undoableEdit.changes));\n    }\n    /**\n     * Called from {@link moveHandler}.\n     *\n     * @param cell Array of {@link Cell} that have been moved.\n     * @param evt Mouse event that represents the mousedown.\n     */\n    cellsMoved(cells, evt) {\n        if (cells.length > 0 && evt) {\n            const point = convertPoint(this.getGraph().container, getClientX(evt), getClientY(evt));\n            for (let i = 0; i < cells.length; i += 1) {\n                const layout = this.getLayout(cells[i].getParent(), InternalEvent.MOVE_CELLS);\n                if (layout) {\n                    layout.moveCell(cells[i], point.x, point.y);\n                }\n            }\n        }\n    }\n    /**\n     * Called from {@link resizeHandler}.\n     *\n     * @param cell Array of {@link Cell} that have been resized.\n     * @param bounds {@link mxRectangle} taht represents the new bounds.\n     */\n    cellsResized(cells = null, bounds = null, prev = null) {\n        if (cells && bounds) {\n            for (let i = 0; i < cells.length; i += 1) {\n                const layout = this.getLayout(cells[i].getParent(), InternalEvent.RESIZE_CELLS);\n                if (layout) {\n                    layout.resizeCell(cells[i], bounds[i], prev?.[i]);\n                }\n            }\n        }\n    }\n    /**\n     * Returns the cells for which a layout should be executed.\n     */\n    getCellsForChanges(changes) {\n        let result = [];\n        for (const change of changes) {\n            if (change instanceof RootChange) {\n                return [];\n            }\n            result = result.concat(this.getCellsForChange(change));\n        }\n        return result;\n    }\n    /**\n     * Executes all layouts which have been scheduled during the\n     * changes.\n     * @param change  mxChildChange|mxTerminalChange|mxVisibleChange|...\n     */\n    getCellsForChange(change) {\n        if (change instanceof ChildChange) {\n            return this.addCellsWithLayout(change.child, this.addCellsWithLayout(change.previous));\n        }\n        if (change instanceof TerminalChange || change instanceof GeometryChange) {\n            return this.addCellsWithLayout(change.cell);\n        }\n        if (change instanceof VisibleChange || change instanceof StyleChange) {\n            return this.addCellsWithLayout(change.cell);\n        }\n        return [];\n    }\n    /**\n     * Adds all ancestors of the given cell that have a layout.\n     */\n    addCellsWithLayout(cell, result = []) {\n        return this.addDescendantsWithLayout(cell, this.addAncestorsWithLayout(cell, result));\n    }\n    /**\n     * Adds all ancestors of the given cell that have a layout.\n     */\n    addAncestorsWithLayout(cell, result = []) {\n        if (cell) {\n            const layout = this.hasLayout(cell);\n            if (layout) {\n                result.push(cell);\n            }\n            if (this.isBubbling()) {\n                this.addAncestorsWithLayout(cell.getParent(), result);\n            }\n        }\n        return result;\n    }\n    /**\n     * Adds all descendants of the given cell that have a layout.\n     */\n    addDescendantsWithLayout(cell, result = []) {\n        if (cell && this.hasLayout(cell)) {\n            for (let i = 0; i < cell.getChildCount(); i += 1) {\n                const child = cell.getChildAt(i);\n                if (this.hasLayout(child)) {\n                    result.push(child);\n                    this.addDescendantsWithLayout(child, result);\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Executes the given layout on the given parent.\n     */\n    executeLayoutForCells(cells) {\n        const sorted = sortCells(cells, false);\n        this.layoutCells(sorted, true);\n        this.layoutCells(sorted.reverse(), false);\n    }\n    /**\n     * Executes all layouts which have been scheduled during the changes.\n     */\n    layoutCells(cells, bubble = false) {\n        if (cells.length > 0) {\n            // Invokes the layouts while removing duplicates\n            const model = this.getGraph().getDataModel();\n            model.batchUpdate(() => {\n                let last = null;\n                for (const cell of cells) {\n                    if (cell !== model.getRoot() && cell !== last) {\n                        this.executeLayout(cell, bubble);\n                        last = cell;\n                    }\n                }\n                this.fireEvent(new EventObject(InternalEvent.LAYOUT_CELLS, { cells }));\n            });\n        }\n    }\n    /**\n     * Executes the given layout on the given parent.\n     */\n    executeLayout(cell, bubble = false) {\n        const layout = this.getLayout(cell, bubble ? InternalEvent.BEGIN_UPDATE : InternalEvent.END_UPDATE);\n        if (layout) {\n            layout.execute(cell);\n        }\n    }\n    /**\n     * Removes all handlers from the {@link graph} and deletes the reference to it.\n     */\n    destroy() {\n        this.setGraph(null);\n    }\n}\nexport default LayoutManager;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}