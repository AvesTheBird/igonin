{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../geometry/Point';\nimport ConnectionConstraint from '../other/ConnectionConstraint';\nimport { DIRECTION } from '../../util/Constants';\nimport { mixInto } from '../../util/Utils';\nimport { getRotatedPoint, toRadians } from '../../util/mathUtils';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport Dictionary from '../../util/Dictionary';\nimport { Graph } from '../Graph';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst ConnectionsMixin = {\n  /*****************************************************************************\n   * Group: Cell connecting and connection constraints\n   *****************************************************************************/\n  /**\n   * Specifies if a child should be constrained inside the parent bounds after a\n   * move or resize of the child.\n   * @default true\n   */\n  constrainChildren: true,\n  /**\n   * Specifies if child cells with relative geometries should be constrained\n   * inside the parent bounds, if {@link constrainChildren} is `true`, and/or the\n   * {@link maximumGraphBounds}.\n   * @default false\n   */\n  constrainRelativeChildren: false,\n  /**\n   * Specifies if edges should be disconnected from their terminals when they\n   * are moved.\n   * @default true\n   */\n  disconnectOnMove: true,\n  cellsDisconnectable: true,\n  /**\n   * Returns the constraint used to connect to the outline of the given state.\n   */\n  getOutlineConstraint(point, terminalState, me) {\n    if (terminalState.shape) {\n      const bounds = this.getView().getPerimeterBounds(terminalState);\n      const direction = terminalState.style.direction;\n      if (direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH) {\n        bounds.x += bounds.width / 2 - bounds.height / 2;\n        bounds.y += bounds.height / 2 - bounds.width / 2;\n        const tmp = bounds.width;\n        bounds.width = bounds.height;\n        bounds.height = tmp;\n      }\n      const alpha = toRadians(terminalState.shape.getShapeRotation());\n      if (alpha !== 0) {\n        const cos = Math.cos(-alpha);\n        const sin = Math.sin(-alpha);\n        const ct = new Point(bounds.getCenterX(), bounds.getCenterY());\n        point = getRotatedPoint(point, cos, sin, ct);\n      }\n      let sx = 1;\n      let sy = 1;\n      let dx = 0;\n      let dy = 0;\n      // LATER: Add flipping support for image shapes\n      if (terminalState.cell.isVertex()) {\n        let flipH = terminalState.style.flipH;\n        let flipV = terminalState.style.flipV;\n        if (direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH) {\n          const tmp = flipH;\n          flipH = flipV;\n          flipV = tmp;\n        }\n        if (flipH) {\n          sx = -1;\n          dx = -bounds.width;\n        }\n        if (flipV) {\n          sy = -1;\n          dy = -bounds.height;\n        }\n      }\n      point = new Point((point.x - bounds.x) * sx - dx + bounds.x, (point.y - bounds.y) * sy - dy + bounds.y);\n      const x = bounds.width === 0 ? 0 : Math.round((point.x - bounds.x) * 1000 / bounds.width) / 1000;\n      const y = bounds.height === 0 ? 0 : Math.round((point.y - bounds.y) * 1000 / bounds.height) / 1000;\n      return new ConnectionConstraint(new Point(x, y), false);\n    }\n    return null;\n  },\n  /**\n   * Returns an array of all {@link mxConnectionConstraints} for the given terminal. If\n   * the shape of the given terminal is a {@link mxStencilShape} then the constraints\n   * of the corresponding {@link mxStencil} are returned.\n   *\n   * @param terminal {@link CellState} that represents the terminal.\n   * @param source Boolean that specifies if the terminal is the source or target.\n   */\n  getAllConnectionConstraints(terminal, source) {\n    if (terminal && terminal.shape && terminal.shape.stencil) {\n      return terminal.shape.stencil.constraints;\n    }\n    return null;\n  },\n  /**\n   * Returns an {@link ConnectionConstraint} that describes the given connection\n   * point. This result can then be passed to {@link getConnectionPoint}.\n   *\n   * @param edge {@link CellState} that represents the edge.\n   * @param terminal {@link CellState} that represents the terminal.\n   * @param source Boolean indicating if the terminal is the source or target.\n   */\n  getConnectionConstraint(edge, terminal) {\n    let source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let point = null;\n    const x = edge.style[source ? 'exitX' : 'entryX'];\n    if (x !== undefined) {\n      const y = edge.style[source ? 'exitY' : 'entryY'];\n      if (y !== undefined) {\n        point = new Point(x, y);\n      }\n    }\n    let perimeter = false;\n    let dx = 0;\n    let dy = 0;\n    if (point) {\n      perimeter = edge.style[source ? 'exitPerimeter' : 'entryPerimeter'] || false;\n      // Add entry/exit offset\n      dx = edge.style[source ? 'exitDx' : 'entryDx'];\n      dy = edge.style[source ? 'exitDy' : 'entryDy'];\n      dx = Number.isFinite(dx) ? dx : 0;\n      dy = Number.isFinite(dy) ? dy : 0;\n    }\n    return new ConnectionConstraint(point, perimeter, null, dx, dy);\n  },\n  /**\n   * Sets the {@link ConnectionConstraint} that describes the given connection point.\n   * If no constraint is given then nothing is changed. To remove an existing\n   * constraint from the given edge, use an empty constraint instead.\n   *\n   * @param edge {@link mxCell} that represents the edge.\n   * @param terminal {@link mxCell} that represents the terminal.\n   * @param source Boolean indicating if the terminal is the source or target.\n   * @param constraint Optional {@link ConnectionConstraint} to be used for this\n   * connection.\n   */\n  setConnectionConstraint(edge, terminal) {\n    let source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let constraint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    if (constraint) {\n      this.batchUpdate(() => {\n        if (!constraint || !constraint.point) {\n          this.setCellStyles(source ? 'exitX' : 'entryX', null, [edge]);\n          this.setCellStyles(source ? 'exitY' : 'entryY', null, [edge]);\n          this.setCellStyles(source ? 'exitDx' : 'entryDx', null, [edge]);\n          this.setCellStyles(source ? 'exitDy' : 'entryDy', null, [edge]);\n          this.setCellStyles(source ? 'exitPerimeter' : 'entryPerimeter', null, [edge]);\n        } else if (constraint.point) {\n          this.setCellStyles(source ? 'exitX' : 'entryX', constraint.point.x, [edge]);\n          this.setCellStyles(source ? 'exitY' : 'entryY', constraint.point.y, [edge]);\n          this.setCellStyles(source ? 'exitDx' : 'entryDx', constraint.dx, [edge]);\n          this.setCellStyles(source ? 'exitDy' : 'entryDy', constraint.dy, [edge]);\n          // Only writes 0 since 1 is default\n          if (!constraint.perimeter) {\n            this.setCellStyles(source ? 'exitPerimeter' : 'entryPerimeter', '0', [edge]);\n          } else {\n            this.setCellStyles(source ? 'exitPerimeter' : 'entryPerimeter', null, [edge]);\n          }\n        }\n      });\n    }\n  },\n  /**\n   * Returns the nearest point in the list of absolute points or the center\n   * of the opposite terminal.\n   *\n   * @param vertex {@link CellState} that represents the vertex.\n   * @param constraint {@link mxConnectionConstraint} that represents the connection point\n   * constraint as returned by {@link getConnectionConstraint}.\n   */\n  getConnectionPoint(vertex, constraint) {\n    let round = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let point = null;\n    if (constraint.point) {\n      const bounds = this.getView().getPerimeterBounds(vertex);\n      const cx = new Point(bounds.getCenterX(), bounds.getCenterY());\n      const direction = vertex.style.direction;\n      let r1 = 0;\n      // Bounds need to be rotated by 90 degrees for further computation\n      if (vertex.style.anchorPointDirection) {\n        if (direction === DIRECTION.NORTH) {\n          r1 += 270;\n        } else if (direction === DIRECTION.WEST) {\n          r1 += 180;\n        } else if (direction === DIRECTION.SOUTH) {\n          r1 += 90;\n        }\n        // Bounds need to be rotated by 90 degrees for further computation\n        if (direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH) {\n          bounds.rotate90();\n        }\n      }\n      const {\n        scale\n      } = this.getView();\n      point = new Point(bounds.x + constraint.point.x * bounds.width + constraint.dx * scale, bounds.y + constraint.point.y * bounds.height + constraint.dy * scale);\n      // Rotation for direction before projection on perimeter\n      let r2 = vertex.style.rotation || 0;\n      if (constraint.perimeter) {\n        if (r1 !== 0) {\n          // Only 90 degrees steps possible here so no trig needed\n          let cos = 0;\n          let sin = 0;\n          if (r1 === 90) {\n            sin = 1;\n          } else if (r1 === 180) {\n            cos = -1;\n          } else if (r1 === 270) {\n            sin = -1;\n          }\n          point = getRotatedPoint(point, cos, sin, cx);\n        }\n        point = this.getView().getPerimeterPoint(vertex, point, false);\n      } else {\n        r2 += r1;\n        if (vertex.cell.isVertex()) {\n          let flipH = vertex.style.flipH;\n          let flipV = vertex.style.flipV;\n          if (direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH) {\n            const temp = flipH;\n            flipH = flipV;\n            flipV = temp;\n          }\n          if (flipH) {\n            point.x = 2 * bounds.getCenterX() - point.x;\n          }\n          if (flipV) {\n            point.y = 2 * bounds.getCenterY() - point.y;\n          }\n        }\n      }\n      // Generic rotation after projection on perimeter\n      if (r2 !== 0 && point) {\n        const rad = toRadians(r2);\n        const cos = Math.cos(rad);\n        const sin = Math.sin(rad);\n        point = getRotatedPoint(point, cos, sin, cx);\n      }\n    }\n    if (round && point) {\n      point.x = Math.round(point.x);\n      point.y = Math.round(point.y);\n    }\n    return point;\n  },\n  /**\n   * Connects the specified end of the given edge to the given terminal\n   * using {@link cellConnected} and fires {@link InternalEvent.CONNECT_CELL} while the\n   * transaction is in progress. Returns the updated edge.\n   *\n   * @param edge {@link mxCell} whose terminal should be updated.\n   * @param terminal {@link mxCell} that represents the new terminal to be used.\n   * @param source Boolean indicating if the new terminal is the source or target.\n   * @param constraint Optional {@link ConnectionConstraint} to be used for this\n   * connection.\n   */\n  connectCell(edge) {\n    let terminal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let constraint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    this.batchUpdate(() => {\n      const previous = edge.getTerminal(source);\n      this.cellConnected(edge, terminal, source, constraint);\n      this.fireEvent(new EventObject(InternalEvent.CONNECT_CELL, 'edge', edge, 'terminal', terminal, 'source', source, 'previous', previous));\n    });\n    return edge;\n  },\n  /**\n   * Sets the new terminal for the given edge and resets the edge points if\n   * {@link resetEdgesOnConnect} is true. This method fires\n   * {@link InternalEvent.CELL_CONNECTED} while the transaction is in progress.\n   *\n   * @param edge {@link mxCell} whose terminal should be updated.\n   * @param terminal {@link mxCell} that represents the new terminal to be used.\n   * @param source Boolean indicating if the new terminal is the source or target.\n   * @param constraint {@link mxConnectionConstraint} to be used for this connection.\n   */\n  cellConnected(edge, terminal) {\n    let source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let constraint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    this.batchUpdate(() => {\n      const previous = edge.getTerminal(source);\n      // Updates the constraint\n      this.setConnectionConstraint(edge, terminal, source, constraint);\n      // Checks if the new terminal is a port, uses the ID of the port in the\n      // style and the parent of the port as the actual terminal of the edge.\n      if (this.isPortsEnabled()) {\n        let id = null;\n        if (terminal && this.isPort(terminal)) {\n          id = terminal.getId();\n          terminal = this.getTerminalForPort(terminal, source);\n        }\n        // Sets or resets all previous information for connecting to a child port\n        const key = source ? 'sourcePort' : 'targetPort';\n        this.setCellStyles(key, id, [edge]);\n      }\n      this.getDataModel().setTerminal(edge, terminal, source);\n      if (this.isResetEdgesOnConnect()) {\n        this.resetEdge(edge);\n      }\n      this.fireEvent(new EventObject(InternalEvent.CELL_CONNECTED, 'edge', edge, 'terminal', terminal, 'source', source, 'previous', previous));\n    });\n  },\n  /**\n   * Disconnects the given edges from the terminals which are not in the\n   * given array.\n   *\n   * @param cells Array of {@link Cell} to be disconnected.\n   */\n  disconnectGraph(cells) {\n    this.batchUpdate(() => {\n      const {\n        scale,\n        translate: tr\n      } = this.getView();\n      // Fast lookup for finding cells in array\n      const dict = new Dictionary();\n      for (let i = 0; i < cells.length; i += 1) {\n        dict.put(cells[i], true);\n      }\n      for (const cell of cells) {\n        if (cell.isEdge()) {\n          let geo = cell.getGeometry();\n          if (geo) {\n            const state = this.getView().getState(cell);\n            const parent = cell.getParent();\n            const pstate = parent ? this.getView().getState(parent) : null;\n            if (state && pstate) {\n              geo = geo.clone();\n              const dx = -pstate.origin.x;\n              const dy = -pstate.origin.y;\n              const pts = state.absolutePoints;\n              let src = cell.getTerminal(true);\n              if (src && this.isCellDisconnectable(cell, src, true)) {\n                while (src && !dict.get(src)) {\n                  src = src.getParent();\n                }\n                if (!src && pts[0]) {\n                  geo.setTerminalPoint(new Point(pts[0].x / scale - tr.x + dx, pts[0].y / scale - tr.y + dy), true);\n                  this.getDataModel().setTerminal(cell, null, true);\n                }\n              }\n              let trg = cell.getTerminal(false);\n              if (trg && this.isCellDisconnectable(cell, trg, false)) {\n                while (trg && !dict.get(trg)) {\n                  trg = trg.getParent();\n                }\n                if (!trg) {\n                  const n = pts.length - 1;\n                  const p = pts[n];\n                  if (p) {\n                    geo.setTerminalPoint(new Point(p.x / scale - tr.x + dx, p.y / scale - tr.y + dy), false);\n                    this.getDataModel().setTerminal(cell, null, false);\n                  }\n                }\n              }\n              this.getDataModel().setGeometry(cell, geo);\n            }\n          }\n        }\n      }\n    });\n  },\n  /**\n   * Returns all visible edges connected to the given cell without loops.\n   *\n   * @param cell {@link mxCell} whose connections should be returned.\n   * @param parent Optional parent of the opposite end for a connection to be\n   * returned.\n   */\n  getConnections(cell) {\n    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return this.getEdges(cell, parent, true, true, false);\n  },\n  /**\n   * Returns true if the given cell should be kept inside the bounds of its\n   * parent according to the rules defined by {@link getOverlap} and\n   * {@link isAllowOverlapParent}. This implementation returns false for all children\n   * of edges and {@link isConstrainChildren} otherwise.\n   *\n   * @param cell {@link mxCell} that should be constrained.\n   */\n  isConstrainChild(cell) {\n    return this.isConstrainChildren() && !!cell.getParent() && !cell.getParent().isEdge();\n  },\n  /**\n   * Returns {@link constrainChildren}.\n   */\n  isConstrainChildren() {\n    return this.constrainChildren;\n  },\n  /**\n   * Sets {@link constrainChildren}.\n   */\n  setConstrainChildren(value) {\n    this.constrainChildren = value;\n  },\n  /**\n   * Returns {@link constrainRelativeChildren}.\n   */\n  isConstrainRelativeChildren() {\n    return this.constrainRelativeChildren;\n  },\n  /**\n   * Sets {@link constrainRelativeChildren}.\n   */\n  setConstrainRelativeChildren(value) {\n    this.constrainRelativeChildren = value;\n  },\n  /*****************************************************************************\n   * Group: Graph behaviour\n   *****************************************************************************/\n  /**\n   * Returns {@link disconnectOnMove} as a boolean.\n   */\n  isDisconnectOnMove() {\n    return this.disconnectOnMove;\n  },\n  /**\n   * Specifies if edges should be disconnected when moved. (Note: Cloned\n   * edges are always disconnected.)\n   *\n   * @param value Boolean indicating if edges should be disconnected\n   * when moved.\n   */\n  setDisconnectOnMove(value) {\n    this.disconnectOnMove = value;\n  },\n  /**\n   * Returns true if the given cell is disconnectable from the source or\n   * target terminal. This returns {@link isCellsDisconnectable} for all given\n   * cells if {@link isCellLocked} does not return true for the given cell.\n   *\n   * @param cell {@link mxCell} whose disconnectable state should be returned.\n   * @param terminal {@link mxCell} that represents the source or target terminal.\n   * @param source Boolean indicating if the source or target terminal is to be\n   * disconnected.\n   */\n  isCellDisconnectable(cell) {\n    let terminal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    return this.isCellsDisconnectable() && !this.isCellLocked(cell);\n  },\n  /**\n   * Returns {@link cellsDisconnectable}.\n   */\n  isCellsDisconnectable() {\n    return this.cellsDisconnectable;\n  },\n  /**\n   * Sets {@link cellsDisconnectable}.\n   */\n  setCellsDisconnectable(value) {\n    this.cellsDisconnectable = value;\n  },\n  /**\n   * Returns true if the given cell is a valid source for new connections.\n   * This implementation returns true for all non-null values and is\n   * called by is called by {@link isValidConnection}.\n   *\n   * @param cell {@link mxCell} that represents a possible source or null.\n   */\n  isValidSource(cell) {\n    return cell == null && this.isAllowDanglingEdges() || cell != null && (!cell.isEdge() || this.isConnectableEdges()) && cell.isConnectable();\n  },\n  /**\n   * Returns {@link isValidSource} for the given cell. This is called by\n   * {@link isValidConnection}.\n   *\n   * @param cell {@link mxCell} that represents a possible target or null.\n   */\n  isValidTarget(cell) {\n    return this.isValidSource(cell);\n  },\n  /**\n   * Returns true if the given target cell is a valid target for source.\n   * This is a boolean implementation for not allowing connections between\n   * certain pairs of vertices and is called by {@link getEdgeValidationError}.\n   * This implementation returns true if {@link isValidSource} returns true for\n   * the source and {@link isValidTarget} returns true for the target.\n   *\n   * @param source {@link mxCell} that represents the source cell.\n   * @param target {@link mxCell} that represents the target cell.\n   */\n  isValidConnection(source, target) {\n    return this.isValidSource(source) && this.isValidTarget(target);\n  },\n  /**\n   * Specifies if the graph should allow new connections. This implementation\n   * updates {@link ConnectionHandler.enabled} in {@link connectionHandler}.\n   *\n   * @param connectable Boolean indicating if new connections should be allowed.\n   */\n  setConnectable(connectable) {\n    const connectionHandler = this.getPlugin('ConnectionHandler');\n    connectionHandler === null || connectionHandler === void 0 || connectionHandler.setEnabled(connectable);\n  },\n  /**\n   * Returns true if the {@link connectionHandler} is enabled.\n   */\n  isConnectable() {\n    var _connectionHandler$is;\n    const connectionHandler = this.getPlugin('ConnectionHandler');\n    return (_connectionHandler$is = connectionHandler === null || connectionHandler === void 0 ? void 0 : connectionHandler.isEnabled()) !== null && _connectionHandler$is !== void 0 ? _connectionHandler$is : false;\n  }\n};\nmixInto(Graph)(ConnectionsMixin);","map":{"version":3,"names":["Point","ConnectionConstraint","DIRECTION","mixInto","getRotatedPoint","toRadians","EventObject","InternalEvent","Dictionary","Graph","ConnectionsMixin","constrainChildren","constrainRelativeChildren","disconnectOnMove","cellsDisconnectable","getOutlineConstraint","point","terminalState","me","shape","bounds","getView","getPerimeterBounds","direction","style","NORTH","SOUTH","x","width","height","y","tmp","alpha","getShapeRotation","cos","Math","sin","ct","getCenterX","getCenterY","sx","sy","dx","dy","cell","isVertex","flipH","flipV","round","getAllConnectionConstraints","terminal","source","stencil","constraints","getConnectionConstraint","edge","arguments","length","undefined","perimeter","Number","isFinite","setConnectionConstraint","constraint","batchUpdate","setCellStyles","getConnectionPoint","vertex","cx","r1","anchorPointDirection","WEST","rotate90","scale","r2","rotation","getPerimeterPoint","temp","rad","connectCell","previous","getTerminal","cellConnected","fireEvent","CONNECT_CELL","isPortsEnabled","id","isPort","getId","getTerminalForPort","key","getDataModel","setTerminal","isResetEdgesOnConnect","resetEdge","CELL_CONNECTED","disconnectGraph","cells","translate","tr","dict","i","put","isEdge","geo","getGeometry","state","getState","parent","getParent","pstate","clone","origin","pts","absolutePoints","src","isCellDisconnectable","get","setTerminalPoint","trg","n","p","setGeometry","getConnections","getEdges","isConstrainChild","isConstrainChildren","setConstrainChildren","value","isConstrainRelativeChildren","setConstrainRelativeChildren","isDisconnectOnMove","setDisconnectOnMove","isCellsDisconnectable","isCellLocked","setCellsDisconnectable","isValidSource","isAllowDanglingEdges","isConnectableEdges","isConnectable","isValidTarget","isValidConnection","target","setConnectable","connectable","connectionHandler","getPlugin","setEnabled","_connectionHandler$is","isEnabled"],"sources":["D:/ospanel/domains/проекты open server/old/react/react-intro-main/node_modules/@maxgraph/core/dist/view/mixins/ConnectionsMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../geometry/Point';\nimport ConnectionConstraint from '../other/ConnectionConstraint';\nimport { DIRECTION } from '../../util/Constants';\nimport { mixInto } from '../../util/Utils';\nimport { getRotatedPoint, toRadians } from '../../util/mathUtils';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport Dictionary from '../../util/Dictionary';\nimport { Graph } from '../Graph';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst ConnectionsMixin = {\n    /*****************************************************************************\n     * Group: Cell connecting and connection constraints\n     *****************************************************************************/\n    /**\n     * Specifies if a child should be constrained inside the parent bounds after a\n     * move or resize of the child.\n     * @default true\n     */\n    constrainChildren: true,\n    /**\n     * Specifies if child cells with relative geometries should be constrained\n     * inside the parent bounds, if {@link constrainChildren} is `true`, and/or the\n     * {@link maximumGraphBounds}.\n     * @default false\n     */\n    constrainRelativeChildren: false,\n    /**\n     * Specifies if edges should be disconnected from their terminals when they\n     * are moved.\n     * @default true\n     */\n    disconnectOnMove: true,\n    cellsDisconnectable: true,\n    /**\n     * Returns the constraint used to connect to the outline of the given state.\n     */\n    getOutlineConstraint(point, terminalState, me) {\n        if (terminalState.shape) {\n            const bounds = this.getView().getPerimeterBounds(terminalState);\n            const direction = terminalState.style.direction;\n            if (direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH) {\n                bounds.x += bounds.width / 2 - bounds.height / 2;\n                bounds.y += bounds.height / 2 - bounds.width / 2;\n                const tmp = bounds.width;\n                bounds.width = bounds.height;\n                bounds.height = tmp;\n            }\n            const alpha = toRadians(terminalState.shape.getShapeRotation());\n            if (alpha !== 0) {\n                const cos = Math.cos(-alpha);\n                const sin = Math.sin(-alpha);\n                const ct = new Point(bounds.getCenterX(), bounds.getCenterY());\n                point = getRotatedPoint(point, cos, sin, ct);\n            }\n            let sx = 1;\n            let sy = 1;\n            let dx = 0;\n            let dy = 0;\n            // LATER: Add flipping support for image shapes\n            if (terminalState.cell.isVertex()) {\n                let flipH = terminalState.style.flipH;\n                let flipV = terminalState.style.flipV;\n                if (direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH) {\n                    const tmp = flipH;\n                    flipH = flipV;\n                    flipV = tmp;\n                }\n                if (flipH) {\n                    sx = -1;\n                    dx = -bounds.width;\n                }\n                if (flipV) {\n                    sy = -1;\n                    dy = -bounds.height;\n                }\n            }\n            point = new Point((point.x - bounds.x) * sx - dx + bounds.x, (point.y - bounds.y) * sy - dy + bounds.y);\n            const x = bounds.width === 0\n                ? 0\n                : Math.round(((point.x - bounds.x) * 1000) / bounds.width) / 1000;\n            const y = bounds.height === 0\n                ? 0\n                : Math.round(((point.y - bounds.y) * 1000) / bounds.height) / 1000;\n            return new ConnectionConstraint(new Point(x, y), false);\n        }\n        return null;\n    },\n    /**\n     * Returns an array of all {@link mxConnectionConstraints} for the given terminal. If\n     * the shape of the given terminal is a {@link mxStencilShape} then the constraints\n     * of the corresponding {@link mxStencil} are returned.\n     *\n     * @param terminal {@link CellState} that represents the terminal.\n     * @param source Boolean that specifies if the terminal is the source or target.\n     */\n    getAllConnectionConstraints(terminal, source) {\n        if (terminal && terminal.shape && terminal.shape.stencil) {\n            return terminal.shape.stencil.constraints;\n        }\n        return null;\n    },\n    /**\n     * Returns an {@link ConnectionConstraint} that describes the given connection\n     * point. This result can then be passed to {@link getConnectionPoint}.\n     *\n     * @param edge {@link CellState} that represents the edge.\n     * @param terminal {@link CellState} that represents the terminal.\n     * @param source Boolean indicating if the terminal is the source or target.\n     */\n    getConnectionConstraint(edge, terminal, source = false) {\n        let point = null;\n        const x = edge.style[source ? 'exitX' : 'entryX'];\n        if (x !== undefined) {\n            const y = edge.style[source ? 'exitY' : 'entryY'];\n            if (y !== undefined) {\n                point = new Point(x, y);\n            }\n        }\n        let perimeter = false;\n        let dx = 0;\n        let dy = 0;\n        if (point) {\n            perimeter = edge.style[source ? 'exitPerimeter' : 'entryPerimeter'] || false;\n            // Add entry/exit offset\n            dx = edge.style[source ? 'exitDx' : 'entryDx'];\n            dy = edge.style[source ? 'exitDy' : 'entryDy'];\n            dx = Number.isFinite(dx) ? dx : 0;\n            dy = Number.isFinite(dy) ? dy : 0;\n        }\n        return new ConnectionConstraint(point, perimeter, null, dx, dy);\n    },\n    /**\n     * Sets the {@link ConnectionConstraint} that describes the given connection point.\n     * If no constraint is given then nothing is changed. To remove an existing\n     * constraint from the given edge, use an empty constraint instead.\n     *\n     * @param edge {@link mxCell} that represents the edge.\n     * @param terminal {@link mxCell} that represents the terminal.\n     * @param source Boolean indicating if the terminal is the source or target.\n     * @param constraint Optional {@link ConnectionConstraint} to be used for this\n     * connection.\n     */\n    setConnectionConstraint(edge, terminal, source = false, constraint = null) {\n        if (constraint) {\n            this.batchUpdate(() => {\n                if (!constraint || !constraint.point) {\n                    this.setCellStyles(source ? 'exitX' : 'entryX', null, [edge]);\n                    this.setCellStyles(source ? 'exitY' : 'entryY', null, [edge]);\n                    this.setCellStyles(source ? 'exitDx' : 'entryDx', null, [edge]);\n                    this.setCellStyles(source ? 'exitDy' : 'entryDy', null, [edge]);\n                    this.setCellStyles(source ? 'exitPerimeter' : 'entryPerimeter', null, [edge]);\n                }\n                else if (constraint.point) {\n                    this.setCellStyles(source ? 'exitX' : 'entryX', constraint.point.x, [edge]);\n                    this.setCellStyles(source ? 'exitY' : 'entryY', constraint.point.y, [edge]);\n                    this.setCellStyles(source ? 'exitDx' : 'entryDx', constraint.dx, [edge]);\n                    this.setCellStyles(source ? 'exitDy' : 'entryDy', constraint.dy, [edge]);\n                    // Only writes 0 since 1 is default\n                    if (!constraint.perimeter) {\n                        this.setCellStyles(source ? 'exitPerimeter' : 'entryPerimeter', '0', [edge]);\n                    }\n                    else {\n                        this.setCellStyles(source ? 'exitPerimeter' : 'entryPerimeter', null, [edge]);\n                    }\n                }\n            });\n        }\n    },\n    /**\n     * Returns the nearest point in the list of absolute points or the center\n     * of the opposite terminal.\n     *\n     * @param vertex {@link CellState} that represents the vertex.\n     * @param constraint {@link mxConnectionConstraint} that represents the connection point\n     * constraint as returned by {@link getConnectionConstraint}.\n     */\n    getConnectionPoint(vertex, constraint, round = true) {\n        let point = null;\n        if (constraint.point) {\n            const bounds = this.getView().getPerimeterBounds(vertex);\n            const cx = new Point(bounds.getCenterX(), bounds.getCenterY());\n            const direction = vertex.style.direction;\n            let r1 = 0;\n            // Bounds need to be rotated by 90 degrees for further computation\n            if (vertex.style.anchorPointDirection) {\n                if (direction === DIRECTION.NORTH) {\n                    r1 += 270;\n                }\n                else if (direction === DIRECTION.WEST) {\n                    r1 += 180;\n                }\n                else if (direction === DIRECTION.SOUTH) {\n                    r1 += 90;\n                }\n                // Bounds need to be rotated by 90 degrees for further computation\n                if (direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH) {\n                    bounds.rotate90();\n                }\n            }\n            const { scale } = this.getView();\n            point = new Point(bounds.x + constraint.point.x * bounds.width + constraint.dx * scale, bounds.y + constraint.point.y * bounds.height + constraint.dy * scale);\n            // Rotation for direction before projection on perimeter\n            let r2 = vertex.style.rotation || 0;\n            if (constraint.perimeter) {\n                if (r1 !== 0) {\n                    // Only 90 degrees steps possible here so no trig needed\n                    let cos = 0;\n                    let sin = 0;\n                    if (r1 === 90) {\n                        sin = 1;\n                    }\n                    else if (r1 === 180) {\n                        cos = -1;\n                    }\n                    else if (r1 === 270) {\n                        sin = -1;\n                    }\n                    point = getRotatedPoint(point, cos, sin, cx);\n                }\n                point = this.getView().getPerimeterPoint(vertex, point, false);\n            }\n            else {\n                r2 += r1;\n                if (vertex.cell.isVertex()) {\n                    let flipH = vertex.style.flipH;\n                    let flipV = vertex.style.flipV;\n                    if (direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH) {\n                        const temp = flipH;\n                        flipH = flipV;\n                        flipV = temp;\n                    }\n                    if (flipH) {\n                        point.x = 2 * bounds.getCenterX() - point.x;\n                    }\n                    if (flipV) {\n                        point.y = 2 * bounds.getCenterY() - point.y;\n                    }\n                }\n            }\n            // Generic rotation after projection on perimeter\n            if (r2 !== 0 && point) {\n                const rad = toRadians(r2);\n                const cos = Math.cos(rad);\n                const sin = Math.sin(rad);\n                point = getRotatedPoint(point, cos, sin, cx);\n            }\n        }\n        if (round && point) {\n            point.x = Math.round(point.x);\n            point.y = Math.round(point.y);\n        }\n        return point;\n    },\n    /**\n     * Connects the specified end of the given edge to the given terminal\n     * using {@link cellConnected} and fires {@link InternalEvent.CONNECT_CELL} while the\n     * transaction is in progress. Returns the updated edge.\n     *\n     * @param edge {@link mxCell} whose terminal should be updated.\n     * @param terminal {@link mxCell} that represents the new terminal to be used.\n     * @param source Boolean indicating if the new terminal is the source or target.\n     * @param constraint Optional {@link ConnectionConstraint} to be used for this\n     * connection.\n     */\n    connectCell(edge, terminal = null, source = false, constraint = null) {\n        this.batchUpdate(() => {\n            const previous = edge.getTerminal(source);\n            this.cellConnected(edge, terminal, source, constraint);\n            this.fireEvent(new EventObject(InternalEvent.CONNECT_CELL, 'edge', edge, 'terminal', terminal, 'source', source, 'previous', previous));\n        });\n        return edge;\n    },\n    /**\n     * Sets the new terminal for the given edge and resets the edge points if\n     * {@link resetEdgesOnConnect} is true. This method fires\n     * {@link InternalEvent.CELL_CONNECTED} while the transaction is in progress.\n     *\n     * @param edge {@link mxCell} whose terminal should be updated.\n     * @param terminal {@link mxCell} that represents the new terminal to be used.\n     * @param source Boolean indicating if the new terminal is the source or target.\n     * @param constraint {@link mxConnectionConstraint} to be used for this connection.\n     */\n    cellConnected(edge, terminal, source = false, constraint = null) {\n        this.batchUpdate(() => {\n            const previous = edge.getTerminal(source);\n            // Updates the constraint\n            this.setConnectionConstraint(edge, terminal, source, constraint);\n            // Checks if the new terminal is a port, uses the ID of the port in the\n            // style and the parent of the port as the actual terminal of the edge.\n            if (this.isPortsEnabled()) {\n                let id = null;\n                if (terminal && this.isPort(terminal)) {\n                    id = terminal.getId();\n                    terminal = this.getTerminalForPort(terminal, source);\n                }\n                // Sets or resets all previous information for connecting to a child port\n                const key = source ? 'sourcePort' : 'targetPort';\n                this.setCellStyles(key, id, [edge]);\n            }\n            this.getDataModel().setTerminal(edge, terminal, source);\n            if (this.isResetEdgesOnConnect()) {\n                this.resetEdge(edge);\n            }\n            this.fireEvent(new EventObject(InternalEvent.CELL_CONNECTED, 'edge', edge, 'terminal', terminal, 'source', source, 'previous', previous));\n        });\n    },\n    /**\n     * Disconnects the given edges from the terminals which are not in the\n     * given array.\n     *\n     * @param cells Array of {@link Cell} to be disconnected.\n     */\n    disconnectGraph(cells) {\n        this.batchUpdate(() => {\n            const { scale, translate: tr } = this.getView();\n            // Fast lookup for finding cells in array\n            const dict = new Dictionary();\n            for (let i = 0; i < cells.length; i += 1) {\n                dict.put(cells[i], true);\n            }\n            for (const cell of cells) {\n                if (cell.isEdge()) {\n                    let geo = cell.getGeometry();\n                    if (geo) {\n                        const state = this.getView().getState(cell);\n                        const parent = cell.getParent();\n                        const pstate = parent ? this.getView().getState(parent) : null;\n                        if (state && pstate) {\n                            geo = geo.clone();\n                            const dx = -pstate.origin.x;\n                            const dy = -pstate.origin.y;\n                            const pts = state.absolutePoints;\n                            let src = cell.getTerminal(true);\n                            if (src && this.isCellDisconnectable(cell, src, true)) {\n                                while (src && !dict.get(src)) {\n                                    src = src.getParent();\n                                }\n                                if (!src && pts[0]) {\n                                    geo.setTerminalPoint(new Point(pts[0].x / scale - tr.x + dx, pts[0].y / scale - tr.y + dy), true);\n                                    this.getDataModel().setTerminal(cell, null, true);\n                                }\n                            }\n                            let trg = cell.getTerminal(false);\n                            if (trg && this.isCellDisconnectable(cell, trg, false)) {\n                                while (trg && !dict.get(trg)) {\n                                    trg = trg.getParent();\n                                }\n                                if (!trg) {\n                                    const n = pts.length - 1;\n                                    const p = pts[n];\n                                    if (p) {\n                                        geo.setTerminalPoint(new Point(p.x / scale - tr.x + dx, p.y / scale - tr.y + dy), false);\n                                        this.getDataModel().setTerminal(cell, null, false);\n                                    }\n                                }\n                            }\n                            this.getDataModel().setGeometry(cell, geo);\n                        }\n                    }\n                }\n            }\n        });\n    },\n    /**\n     * Returns all visible edges connected to the given cell without loops.\n     *\n     * @param cell {@link mxCell} whose connections should be returned.\n     * @param parent Optional parent of the opposite end for a connection to be\n     * returned.\n     */\n    getConnections(cell, parent = null) {\n        return this.getEdges(cell, parent, true, true, false);\n    },\n    /**\n     * Returns true if the given cell should be kept inside the bounds of its\n     * parent according to the rules defined by {@link getOverlap} and\n     * {@link isAllowOverlapParent}. This implementation returns false for all children\n     * of edges and {@link isConstrainChildren} otherwise.\n     *\n     * @param cell {@link mxCell} that should be constrained.\n     */\n    isConstrainChild(cell) {\n        return (this.isConstrainChildren() &&\n            !!cell.getParent() &&\n            !cell.getParent().isEdge());\n    },\n    /**\n     * Returns {@link constrainChildren}.\n     */\n    isConstrainChildren() {\n        return this.constrainChildren;\n    },\n    /**\n     * Sets {@link constrainChildren}.\n     */\n    setConstrainChildren(value) {\n        this.constrainChildren = value;\n    },\n    /**\n     * Returns {@link constrainRelativeChildren}.\n     */\n    isConstrainRelativeChildren() {\n        return this.constrainRelativeChildren;\n    },\n    /**\n     * Sets {@link constrainRelativeChildren}.\n     */\n    setConstrainRelativeChildren(value) {\n        this.constrainRelativeChildren = value;\n    },\n    /*****************************************************************************\n     * Group: Graph behaviour\n     *****************************************************************************/\n    /**\n     * Returns {@link disconnectOnMove} as a boolean.\n     */\n    isDisconnectOnMove() {\n        return this.disconnectOnMove;\n    },\n    /**\n     * Specifies if edges should be disconnected when moved. (Note: Cloned\n     * edges are always disconnected.)\n     *\n     * @param value Boolean indicating if edges should be disconnected\n     * when moved.\n     */\n    setDisconnectOnMove(value) {\n        this.disconnectOnMove = value;\n    },\n    /**\n     * Returns true if the given cell is disconnectable from the source or\n     * target terminal. This returns {@link isCellsDisconnectable} for all given\n     * cells if {@link isCellLocked} does not return true for the given cell.\n     *\n     * @param cell {@link mxCell} whose disconnectable state should be returned.\n     * @param terminal {@link mxCell} that represents the source or target terminal.\n     * @param source Boolean indicating if the source or target terminal is to be\n     * disconnected.\n     */\n    isCellDisconnectable(cell, terminal = null, source = false) {\n        return this.isCellsDisconnectable() && !this.isCellLocked(cell);\n    },\n    /**\n     * Returns {@link cellsDisconnectable}.\n     */\n    isCellsDisconnectable() {\n        return this.cellsDisconnectable;\n    },\n    /**\n     * Sets {@link cellsDisconnectable}.\n     */\n    setCellsDisconnectable(value) {\n        this.cellsDisconnectable = value;\n    },\n    /**\n     * Returns true if the given cell is a valid source for new connections.\n     * This implementation returns true for all non-null values and is\n     * called by is called by {@link isValidConnection}.\n     *\n     * @param cell {@link mxCell} that represents a possible source or null.\n     */\n    isValidSource(cell) {\n        return ((cell == null && this.isAllowDanglingEdges()) ||\n            (cell != null &&\n                (!cell.isEdge() || this.isConnectableEdges()) &&\n                cell.isConnectable()));\n    },\n    /**\n     * Returns {@link isValidSource} for the given cell. This is called by\n     * {@link isValidConnection}.\n     *\n     * @param cell {@link mxCell} that represents a possible target or null.\n     */\n    isValidTarget(cell) {\n        return this.isValidSource(cell);\n    },\n    /**\n     * Returns true if the given target cell is a valid target for source.\n     * This is a boolean implementation for not allowing connections between\n     * certain pairs of vertices and is called by {@link getEdgeValidationError}.\n     * This implementation returns true if {@link isValidSource} returns true for\n     * the source and {@link isValidTarget} returns true for the target.\n     *\n     * @param source {@link mxCell} that represents the source cell.\n     * @param target {@link mxCell} that represents the target cell.\n     */\n    isValidConnection(source, target) {\n        return this.isValidSource(source) && this.isValidTarget(target);\n    },\n    /**\n     * Specifies if the graph should allow new connections. This implementation\n     * updates {@link ConnectionHandler.enabled} in {@link connectionHandler}.\n     *\n     * @param connectable Boolean indicating if new connections should be allowed.\n     */\n    setConnectable(connectable) {\n        const connectionHandler = this.getPlugin('ConnectionHandler');\n        connectionHandler?.setEnabled(connectable);\n    },\n    /**\n     * Returns true if the {@link connectionHandler} is enabled.\n     */\n    isConnectable() {\n        const connectionHandler = this.getPlugin('ConnectionHandler');\n        return connectionHandler?.isEnabled() ?? false;\n    },\n};\nmixInto(Graph)(ConnectionsMixin);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}