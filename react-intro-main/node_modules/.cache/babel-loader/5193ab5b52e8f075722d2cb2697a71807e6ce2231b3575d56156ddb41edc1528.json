{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { getValue } from '../../util/Utils';\nimport { getAlignmentAsPoint, setPrefixedStyle } from '../../util/styleUtils';\nimport Rectangle from '../geometry/Rectangle';\nimport InternalEvent from '../event/InternalEvent';\nimport Client from '../../Client';\nimport { ABSOLUTE_LINE_HEIGHT, ALIGN, DEFAULT_FONTFAMILY, DEFAULT_FONTSIZE, DEFAULT_TEXT_DIRECTION, DIALECT, FONT, LINE_HEIGHT, NONE, WORD_WRAP } from '../../util/Constants';\nimport TextShape from '../geometry/node/TextShape';\nimport { clearSelection, extractTextWithWhitespace, isNode } from '../../util/domUtils';\nimport { getStringValue, htmlEntities, replaceTrailingNewlines } from '../../util/StringUtils';\nimport { getSource, isConsumed, isControlDown, isMetaDown, isShiftDown } from '../../util/EventUtils';\n/**\n * In-place editor for the graph. To control this editor, use\n * {@link Graph#invokesStopCellEditing}, {@link Graph#enterStopsCellEditing} and\n * {@link Graph#escapeEnabled}. If {@link Graph#enterStopsCellEditing} is true then\n * ctrl-enter or shift-enter can be used to create a linefeed. The F2 and\n * escape keys can always be used to stop editing.\n *\n * To customize the location of the textbox in the graph, override\n * <getEditorBounds> as follows:\n *\n * ```javascript\n * graph.cellEditor.getEditorBounds = (state)=>\n * {\n *   let result = getEditorBounds.apply(this, arguments);\n *\n *   if (this.graph.getDataModel().isEdge(state.cell))\n *   {\n *     result.x = state.getCenterX() - result.width / 2;\n *     result.y = state.getCenterY() - result.height / 2;\n *   }\n *\n *   return result;\n * };\n * ```\n *\n * Note that this hook is only called if <autoSize> is false. If <autoSize> is true,\n * then {@link Shape#getLabelBounds} is used to compute the current bounds of the textbox.\n *\n * The textarea uses the mxCellEditor CSS class. You can modify this class in\n * your custom CSS. Note: You should modify the CSS after loading the client\n * in the page.\n *\n * Example:\n *\n * To only allow numeric input in the in-place editor, use the following code.\n *\n * ```javascript\n * let text = graph.cellEditor.textarea;\n *\n * mxEvent.addListener(text, 'keydown', function (evt)\n * {\n *   if (!(evt.keyCode >= 48 && evt.keyCode <= 57) &&\n *       !(evt.keyCode >= 96 && evt.keyCode <= 105))\n *   {\n *     mxEvent.consume(evt);\n *   }\n * });\n * ```\n *\n * Placeholder:\n *\n * To implement a placeholder for cells without a label, use the\n * <emptyLabelText> variable.\n *\n * Resize in Chrome:\n *\n * Resize of the textarea is disabled by default. If you want to enable\n * this feature extend <init> and set this.textarea.style.resize = ''.\n *\n * To start editing on a key press event, the container of the graph\n * should have focus or a focusable parent should be used to add the\n * key press handler as follows.\n *\n * ```javascript\n * mxEvent.addListener(graph.container, 'keypress', mxUtils.bind(this, (evt)=>\n * {\n *   if (!graph.isEditing() && !graph.isSelectionEmpty() && evt.which !== 0 &&\n *       !mxEvent.isAltDown(evt) && !mxEvent.isControlDown(evt) && !mxEvent.isMetaDown(evt))\n *   {\n *     graph.startEditing();\n *\n *     if (Client.IS_FF)\n *     {\n *       graph.cellEditor.textarea.value = String.fromCharCode(evt.which);\n *     }\n *   }\n * }));\n * ```\n *\n * To allow focus for a DIV, and hence to receive key press events, some browsers\n * require it to have a valid tabindex attribute. In this case the following\n * code may be used to keep the container focused.\n *\n * ```javascript\n * let graphFireMouseEvent = graph.fireMouseEvent;\n * graph.fireMouseEvent = (evtName, me, sender)=>\n * {\n *   if (evtName == mxEvent.MOUSE_DOWN)\n *   {\n *     this.container.focus();\n *   }\n *\n *   graphFireMouseEvent.apply(this, arguments);\n * };\n * ```\n *\n * Constructor: mxCellEditor\n *\n * Constructs a new in-place editor for the specified graph.\n *\n * @param graph Reference to the enclosing {@link Graph}.\n */\nclass CellEditorHandler {\n  constructor(graph) {\n    this.clearOnChange = false;\n    this.bounds = null;\n    this.resizeThread = null;\n    this.textDirection = null;\n    /**\n     * Holds the DIV that is used for text editing. Note that this may be null before the first\n     * edit. Instantiated in <init>.\n     */\n    this.textarea = null;\n    /**\n     * Reference to the <Cell> that is currently being edited.\n     */\n    // editingCell: mxCell;\n    this.editingCell = null;\n    /**\n     * Reference to the event that was used to start editing.\n     */\n    // trigger: MouseEvent;\n    this.trigger = null;\n    /**\n     * Specifies if the label has been modified.\n     */\n    // modified: boolean;\n    this.modified = false;\n    /**\n     * Specifies if the textarea should be resized while the text is being edited.\n     * Default is true.\n     */\n    // autoSize: boolean;\n    this.autoSize = true;\n    /**\n     * Specifies if the text should be selected when editing starts. Default is\n     * true.\n     */\n    // selectText: boolean;\n    this.selectText = true;\n    /**\n     * Text to be displayed for empty labels. Default is '' or '<br>' in Firefox as\n     * a workaround for the missing cursor bug for empty content editable. This can\n     * be set to eg. \"[Type Here]\" to easier visualize editing of empty labels. The\n     * value is only displayed before the first keystroke and is never used as the\n     * actual editing value.\n     */\n    // emptyLabelText: '<br>' | '';\n    this.emptyLabelText = Client.IS_FF ? '<br>' : '';\n    /**\n     * If true, pressing the escape key will stop editing and not accept the new\n     * value. Change this to false to accept the new value on escape, and cancel\n     * editing on Shift+Escape instead. Default is true.\n     */\n    // escapeCancelsEditing: boolean;\n    this.escapeCancelsEditing = true;\n    /**\n     * Reference to the label DOM node that has been hidden.\n     */\n    // textNode: string;\n    this.textNode = null;\n    /**\n     * Specifies the zIndex for the textarea. Default is 5.\n     */\n    // zIndex: number;\n    this.zIndex = 5;\n    /**\n     * Defines the minimum width and height to be used in <resize>. Default is 0x20px.\n     */\n    // minResize: mxRectangle;\n    this.minResize = new Rectangle(0, 20);\n    /**\n     * Correction factor for word wrapping width. Default is 2 in quirks, 0 in IE\n     * 11 and 1 in all other browsers and modes.\n     */\n    // wordWrapPadding: 2 | 1 | 0;\n    this.wordWrapPadding = 0;\n    /**\n     * If <focusLost> should be called if <textarea> loses the focus. Default is false.\n     */\n    // blurEnabled: boolean;\n    this.blurEnabled = false;\n    /**\n     * Holds the initial editing value to check if the current value was modified.\n     */\n    // initialValue: string;\n    this.initialValue = null;\n    /**\n     * Holds the current temporary horizontal alignment for the cell style. If this\n     * is modified then the current text alignment is changed and the cell style is\n     * updated when the value is applied.\n     */\n    this.align = null;\n    this.graph = graph;\n    // Stops editing after zoom changes\n    this.zoomHandler = () => {\n      if (this.graph.isEditing()) {\n        this.resize();\n      }\n    };\n    // Handling of deleted cells while editing\n    this.changeHandler = sender => {\n      if (this.editingCell && !this.graph.getView().getState(this.editingCell, false)) {\n        this.stopEditing(true);\n      }\n    };\n    this.graph.getView().addListener(InternalEvent.SCALE, this.zoomHandler);\n    this.graph.getView().addListener(InternalEvent.SCALE_AND_TRANSLATE, this.zoomHandler);\n    this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.changeHandler);\n  }\n  /**\n   * Creates the <textarea> and installs the event listeners. The key handler\n   * updates the {@link odified} state.\n   */\n  init() {\n    this.textarea = document.createElement('div');\n    this.textarea.className = 'mxCellEditor mxPlainTextEditor';\n    this.textarea.contentEditable = String(true);\n    // Workaround for selection outside of DIV if height is 0\n    if (Client.IS_GC) {\n      this.textarea.style.minHeight = '1em';\n    }\n    this.textarea.style.position = 'relative';\n    this.installListeners(this.textarea);\n  }\n  /**\n   * Called in <stopEditing> if cancel is false to invoke {@link Graph#labelChanged}.\n   */\n  // applyValue(state: CellState, value: string): void;\n  applyValue(state, value) {\n    this.graph.labelChanged(state.cell, value, this.trigger);\n  }\n  /**\n   * Sets the temporary horizontal alignment for the current editing session.\n   */\n  setAlign(align) {\n    if (this.textarea) {\n      this.textarea.style.textAlign = align;\n    }\n    this.align = align;\n    this.resize();\n  }\n  /**\n   * Gets the initial editing value for the given cell.\n   */\n  getInitialValue(state, trigger) {\n    let result = htmlEntities(this.graph.getEditingValue(state.cell, trigger), false);\n    result = replaceTrailingNewlines(result, '<div><br></div>');\n    return result.replace(/\\n/g, '<br>');\n  }\n  /**\n   * Returns the current editing value.\n   */\n  getCurrentValue(state) {\n    if (!this.textarea) return null;\n    return extractTextWithWhitespace(Array.from(this.textarea.childNodes));\n  }\n  /**\n   * Returns true if <escapeCancelsEditing> is true and shift, control and meta\n   * are not pressed.\n   */\n  // isCancelEditingKeyEvent(evt: Event): boolean;\n  isCancelEditingKeyEvent(evt) {\n    return this.escapeCancelsEditing || isShiftDown(evt) || isControlDown(evt) || isMetaDown(evt);\n  }\n  /**\n   * Installs listeners for focus, change and standard key event handling.\n   */\n  // installListeners(elt: Element): void;\n  installListeners(elt) {\n    // Applies value if text is dragged\n    // LATER: Gesture mouse events ignored for starting move\n    InternalEvent.addListener(elt, 'dragstart', evt => {\n      this.graph.stopEditing(false);\n      InternalEvent.consume(evt);\n    });\n    // Applies value if focus is lost\n    InternalEvent.addListener(elt, 'blur', evt => {\n      if (this.blurEnabled) {\n        this.focusLost();\n      }\n    });\n    // Updates modified state and handles placeholder text\n    InternalEvent.addListener(elt, 'keydown', evt => {\n      if (!isConsumed(evt)) {\n        if (this.isStopEditingEvent(evt)) {\n          this.graph.stopEditing(false);\n          InternalEvent.consume(evt);\n        } else if (evt.keyCode === 27 /* Escape */) {\n          this.graph.stopEditing(this.isCancelEditingKeyEvent(evt));\n          InternalEvent.consume(evt);\n        }\n      }\n    });\n    // Keypress only fires if printable key was pressed and handles removing the empty placeholder\n    const keypressHandler = evt => {\n      if (this.editingCell != null) {\n        // Clears the initial empty label on the first keystroke\n        // and workaround for FF which fires keypress for delete and backspace\n        if (this.clearOnChange && elt.innerHTML === this.getEmptyLabelText() && (!Client.IS_FF || evt.keyCode !== 8 /* Backspace */ && evt.keyCode !== 46) /* Delete */) {\n          this.clearOnChange = false;\n          elt.innerHTML = '';\n        }\n      }\n    };\n    InternalEvent.addListener(elt, 'keypress', keypressHandler);\n    InternalEvent.addListener(elt, 'paste', keypressHandler);\n    // Handler for updating the empty label text value after a change\n    const keyupHandler = evt => {\n      if (this.editingCell != null) {\n        // Uses an optional text value for sempty labels which is cleared\n        // when the first keystroke appears. This makes it easier to see\n        // that a label is being edited even if the label is empty.\n        // In Safari and FF, an empty text is represented by <BR> which isn't enough to force a valid size\n        const textarea = this.textarea;\n        if (textarea.innerHTML.length === 0 || textarea.innerHTML === '<br>') {\n          textarea.innerHTML = this.getEmptyLabelText();\n          this.clearOnChange = textarea.innerHTML.length > 0;\n        } else {\n          this.clearOnChange = false;\n        }\n      }\n    };\n    InternalEvent.addListener(elt, 'input', keyupHandler);\n    InternalEvent.addListener(elt, 'cut', keyupHandler);\n    InternalEvent.addListener(elt, 'paste', keyupHandler);\n    // Adds automatic resizing of the textbox while typing using input, keyup and/or DOM change events\n    const evtName = 'input';\n    const resizeHandler = evt => {\n      if (this.editingCell != null && this.autoSize && !isConsumed(evt)) {\n        // Asynchronous is needed for keydown and shows better results for input events overall\n        // (ie non-blocking and cases where the offsetWidth/-Height was wrong at this time)\n        if (this.resizeThread != null) {\n          window.clearTimeout(this.resizeThread);\n        }\n        this.resizeThread = window.setTimeout(() => {\n          this.resizeThread = null;\n          this.resize();\n        }, 0);\n      }\n    };\n    InternalEvent.addListener(elt, evtName, resizeHandler);\n    InternalEvent.addListener(window, 'resize', resizeHandler);\n    InternalEvent.addListener(elt, 'cut', resizeHandler);\n    InternalEvent.addListener(elt, 'paste', resizeHandler);\n  }\n  /**\n   * Returns true if the given keydown event should stop cell editing. This\n   * returns true if F2 is pressed of if {@link Graph#enterStopsCellEditing} is true\n   * and enter is pressed without control or shift.\n   */\n  isStopEditingEvent(evt) {\n    return evt.keyCode === 113 /* F2 */ || this.graph.isEnterStopsCellEditing() && evt.keyCode === 13 /* Enter */ && !isControlDown(evt) && !isShiftDown(evt);\n  }\n  /**\n   * Returns true if this editor is the source for the given native event.\n   */\n  isEventSource(evt) {\n    return getSource(evt) === this.textarea;\n  }\n  /**\n   * Returns {@link odified}.\n   */\n  resize() {\n    const state = this.editingCell ? this.graph.getView().getState(this.editingCell) : null;\n    if (!state) {\n      this.stopEditing(true);\n    } else if (this.textarea != null) {\n      const isEdge = state.cell.isEdge();\n      const {\n        scale\n      } = this.graph.getView();\n      let m = null;\n      if (!this.autoSize || state.style.overflow === 'fill') {\n        // Specifies the bounds of the editor box\n        this.bounds = this.getEditorBounds(state);\n        this.textarea.style.width = `${Math.round(this.bounds.width / scale)}px`;\n        this.textarea.style.height = `${Math.round(this.bounds.height / scale)}px`;\n        // FIXME: Offset when scaled\n        this.textarea.style.left = `${Math.max(0, Math.round(this.bounds.x + 1))}px`;\n        this.textarea.style.top = `${Math.max(0, Math.round(this.bounds.y + 1))}px`;\n        // Installs native word wrapping and avoids word wrap for empty label placeholder\n        if (this.graph.isWrapping(state.cell) && (this.bounds.width >= 2 || this.bounds.height >= 2) && this.textarea.innerHTML !== this.getEmptyLabelText()) {\n          this.textarea.style.wordWrap = WORD_WRAP;\n          this.textarea.style.whiteSpace = 'normal';\n          if (state.style.overflow !== 'fill') {\n            this.textarea.style.width = `${Math.round(this.bounds.width / scale) + this.wordWrapPadding}px`;\n          }\n        } else {\n          this.textarea.style.whiteSpace = 'nowrap';\n          if (state.style.overflow !== 'fill') {\n            this.textarea.style.width = '';\n          }\n        }\n      } else {\n        const lw = getValue(state.style, 'labelWidth', null);\n        m = state.text != null && this.align == null ? state.text.margin : null;\n        if (m == null) {\n          m = getAlignmentAsPoint(this.align || getValue(state.style, 'align', ALIGN.CENTER), getValue(state.style, 'verticalAlign', ALIGN.MIDDLE));\n        }\n        if (isEdge) {\n          this.bounds = new Rectangle(state.absoluteOffset.x, state.absoluteOffset.y, 0, 0);\n          if (lw != null) {\n            const tmp = (parseFloat(lw) + 2) * scale;\n            this.bounds.width = tmp;\n            this.bounds.x += m.x * tmp;\n          }\n        } else {\n          let bounds = Rectangle.fromRectangle(state);\n          let hpos = getValue(state.style, 'labelPosition', ALIGN.CENTER);\n          let vpos = getValue(state.style, 'verticalLabelPosition', ALIGN.MIDDLE);\n          bounds = state.shape != null && hpos === 'center' && vpos === 'middle' ? state.shape.getLabelBounds(bounds) : bounds;\n          if (lw != null) {\n            bounds.width = parseFloat(lw) * scale;\n          }\n          if (!state.view.graph.cellRenderer.legacySpacing || state.style.overflow !== 'width') {\n            // @ts-ignore\n            const dummy = new TextShape(); // FIXME!!!! ===================================================================================================\n            const spacing = (state.style.spacing ?? 2) * scale;\n            const spacingTop = ((state.style.spacingTop ?? 0) + dummy.baseSpacingTop) * scale + spacing;\n            const spacingRight = ((state.style.spacingRight ?? 0) + dummy.baseSpacingRight) * scale + spacing;\n            const spacingBottom = ((state.style.spacingBottom ?? 0) + dummy.baseSpacingBottom) * scale + spacing;\n            const spacingLeft = ((state.style.spacingLeft ?? 0) + dummy.baseSpacingLeft) * scale + spacing;\n            hpos = state.style.labelPosition != null ? state.style.labelPosition : 'center';\n            vpos = state.style.verticalLabelPosition != null ? state.style.verticalLabelPosition : 'middle';\n            bounds = new Rectangle(bounds.x + spacingLeft, bounds.y + spacingTop, bounds.width - (hpos === ALIGN.CENTER && lw == null ? spacingLeft + spacingRight : 0), bounds.height - (vpos === ALIGN.MIDDLE ? spacingTop + spacingBottom : 0));\n          }\n          this.bounds = new Rectangle(bounds.x + state.absoluteOffset.x, bounds.y + state.absoluteOffset.y, bounds.width, bounds.height);\n        }\n        // Needed for word wrap inside text blocks with oversize lines to match the final result where\n        // the width of the longest line is used as the reference for text alignment in the cell\n        // TODO: Fix word wrapping preview for edge labels in helloworld.html\n        if (this.graph.isWrapping(state.cell) && (this.bounds.width >= 2 || this.bounds.height >= 2) && this.textarea.innerHTML !== this.getEmptyLabelText()) {\n          this.textarea.style.wordWrap = WORD_WRAP;\n          this.textarea.style.whiteSpace = 'normal';\n          // Forces automatic reflow if text is removed from an oversize label and normal word wrap\n          const tmp = Math.round(this.bounds.width / scale) + this.wordWrapPadding;\n          if (this.textarea.style.position !== 'relative') {\n            this.textarea.style.width = `${tmp}px`;\n            if (this.textarea.scrollWidth > tmp) {\n              this.textarea.style.width = `${this.textarea.scrollWidth}px`;\n            }\n          } else {\n            this.textarea.style.maxWidth = `${tmp}px`;\n          }\n        } else {\n          // KNOWN: Trailing cursor in IE9 quirks mode is not visible\n          this.textarea.style.whiteSpace = 'nowrap';\n          this.textarea.style.width = '';\n        }\n        const ow = this.textarea.scrollWidth;\n        const oh = this.textarea.scrollHeight;\n        // TODO: Update CSS width and height if smaller than minResize or remove minResize\n        // if (this.minResize != null)\n        // {\n        //  ow = Math.max(ow, this.minResize.width);\n        //  oh = Math.max(oh, this.minResize.height);\n        // }\n        // LATER: Keep in visible area, add fine tuning for pixel precision\n        this.textarea.style.left = `${Math.max(0, Math.round(this.bounds.x - m.x * (this.bounds.width - 2)) + 1)}px`;\n        this.textarea.style.top = `${Math.max(0, Math.round(this.bounds.y - m.y * (this.bounds.height - 4) + (m.y === -1 ? 3 : 0)) + 1)}px`;\n      }\n      setPrefixedStyle(this.textarea.style, 'transformOrigin', '0px 0px');\n      setPrefixedStyle(this.textarea.style, 'transform', `scale(${scale},${scale})${m == null ? '' : ` translate(${m.x * 100}%,${m.y * 100}%)`}`);\n    }\n  }\n  /**\n   * Called if the textarea has lost focus.\n   */\n  focusLost() {\n    this.stopEditing(!this.graph.isInvokesStopCellEditing());\n  }\n  /**\n   * Returns the background color for the in-place editor. This implementation\n   * always returns NONE.\n   */\n  getBackgroundColor(state) {\n    return NONE;\n  }\n  /**\n   * Starts the editor for the given cell.\n   *\n   * @param cell <Cell> to start editing.\n   * @param trigger Optional mouse event that triggered the editor.\n   */\n  startEditing(cell, trigger = null) {\n    this.stopEditing(true);\n    this.align = null;\n    // Creates new textarea instance\n    if (this.textarea == null) {\n      this.init();\n    }\n    const tooltipHandler = this.graph.getPlugin('TooltipHandler');\n    tooltipHandler?.hideTooltip();\n    const state = this.graph.getView().getState(cell);\n    if (state) {\n      // Configures the style of the in-place editor\n      const {\n        scale\n      } = this.graph.getView();\n      const size = state.style.fontSize ?? DEFAULT_FONTSIZE;\n      const family = state.style.fontFamily ?? DEFAULT_FONTFAMILY;\n      const color = state.style.fontColor ?? 'black';\n      const align = state.style.align ?? ALIGN.LEFT;\n      const bold = (state.style.fontStyle || 0) & FONT.BOLD;\n      const italic = (state.style.fontStyle || 0) & FONT.ITALIC;\n      const txtDecor = [];\n      if ((state.style.fontStyle || 0) & FONT.UNDERLINE) {\n        txtDecor.push('underline');\n      }\n      if ((state.style.fontStyle || 0) & FONT.STRIKETHROUGH) {\n        txtDecor.push('line-through');\n      }\n      const textarea = this.textarea;\n      textarea.style.lineHeight = ABSOLUTE_LINE_HEIGHT ? `${Math.round(size * LINE_HEIGHT)}px` : String(LINE_HEIGHT);\n      textarea.style.backgroundColor = this.getBackgroundColor(state) || 'transparent';\n      textarea.style.textDecoration = txtDecor.join(' ');\n      textarea.style.fontWeight = bold ? 'bold' : 'normal';\n      textarea.style.fontStyle = italic ? 'italic' : '';\n      textarea.style.fontSize = `${Math.round(size)}px`;\n      textarea.style.zIndex = String(this.zIndex);\n      textarea.style.fontFamily = family;\n      textarea.style.textAlign = align;\n      textarea.style.outline = 'none';\n      textarea.style.color = color;\n      let dir = this.textDirection = state.style.textDirection ?? DEFAULT_TEXT_DIRECTION;\n      if (dir === 'auto') {\n        if (state.text !== null && state.text.dialect !== DIALECT.STRICTHTML && !isNode(state.text.value)) {\n          dir = state.text.getAutoDirection();\n        }\n      }\n      if (dir === 'ltr' || dir === 'rtl') {\n        textarea.setAttribute('dir', dir);\n      } else {\n        textarea.removeAttribute('dir');\n      }\n      // Sets the initial editing value\n      textarea.innerHTML = this.getInitialValue(state, trigger) || '';\n      this.initialValue = textarea.innerHTML;\n      // Uses an optional text value for empty labels which is cleared\n      // when the first keystroke appears. This makes it easier to see\n      // that a label is being edited even if the label is empty.\n      if (textarea.innerHTML.length === 0 || textarea.innerHTML === '<br>') {\n        textarea.innerHTML = this.getEmptyLabelText();\n        this.clearOnChange = true;\n      } else {\n        this.clearOnChange = textarea.innerHTML === this.getEmptyLabelText();\n      }\n      // @ts-ignore\n      this.graph.container.appendChild(textarea);\n      // Update this after firing all potential events that could update the cleanOnChange flag\n      this.editingCell = cell;\n      this.trigger = trigger;\n      this.textNode = null;\n      if (state.text !== null && this.isHideLabel(state)) {\n        this.textNode = state.text.node;\n        this.textNode.style.visibility = 'hidden';\n      }\n      // Workaround for initial offsetHeight not ready for heading in markup\n      if (this.autoSize && (state.cell.isEdge() || state.style.overflow !== 'fill')) {\n        window.setTimeout(() => {\n          this.resize();\n        }, 0);\n      }\n      this.resize();\n      // Workaround for NS_ERROR_FAILURE in FF\n      try {\n        // Prefers blinking cursor over no selected text if empty\n        textarea.focus();\n        if (this.isSelectText() && textarea.innerHTML.length > 0 && (textarea.innerHTML !== this.getEmptyLabelText() || !this.clearOnChange)) {\n          document.execCommand('selectAll', false);\n        }\n      } catch (e) {\n        // ignore\n      }\n    }\n  }\n  /**\n   * Returns <selectText>.\n   */\n  isSelectText() {\n    return this.selectText;\n  }\n  /**\n  clearSelection() {\n    const selection = window.getSelection();\n       if (selection) {\n      if (selection.empty) {\n        selection.empty();\n      } else if (selection.removeAllRanges) {\n        selection.removeAllRanges();\n      }\n    }\n  }\n     /**\n   * Stops the editor and applies the value if cancel is false.\n   */\n  stopEditing(cancel = false) {\n    if (this.editingCell) {\n      if (this.textNode) {\n        this.textNode.style.visibility = 'visible';\n        this.textNode = null;\n      }\n      const state = !cancel ? this.graph.view.getState(this.editingCell) : null;\n      const textarea = this.textarea;\n      const initial = this.initialValue;\n      this.initialValue = null;\n      this.editingCell = null;\n      this.trigger = null;\n      this.bounds = null;\n      textarea.blur();\n      clearSelection();\n      if (textarea.parentNode) {\n        textarea.parentNode.removeChild(textarea);\n      }\n      if (this.clearOnChange && textarea.innerHTML === this.getEmptyLabelText()) {\n        textarea.innerHTML = '';\n        this.clearOnChange = false;\n      }\n      if (state && (textarea.innerHTML !== initial || this.align !== null)) {\n        this.prepareTextarea();\n        const value = this.getCurrentValue(state);\n        this.graph.batchUpdate(() => {\n          if (value !== null) {\n            this.applyValue(state, value);\n          }\n          if (this.align !== null) {\n            this.graph.setCellStyles('align', this.align, [state.cell]);\n          }\n        });\n      }\n      // Forces new instance on next edit for undo history reset\n      if (this.textarea) InternalEvent.release(this.textarea);\n      this.textarea = null;\n      this.align = null;\n    }\n  }\n  /**\n   * Prepares the textarea for getting its value in <stopEditing>.\n   * This implementation removes the extra trailing linefeed in Firefox.\n   */\n  prepareTextarea() {\n    const textarea = this.textarea;\n    if (textarea.lastChild && textarea.lastChild.nodeName === 'BR') {\n      textarea.removeChild(textarea.lastChild);\n    }\n  }\n  /**\n   * Returns true if the label should be hidden while the cell is being\n   * edited.\n   */\n  isHideLabel(state = null) {\n    return true;\n  }\n  /**\n   * Returns the minimum width and height for editing the given state.\n   */\n  getMinimumSize(state) {\n    const {\n      scale\n    } = this.graph.getView();\n    const textarea = this.textarea;\n    return new Rectangle(0, 0, state.text === null ? 30 : state.text.size * scale + 20, textarea.style.textAlign === 'left' ? 120 : 40);\n  }\n  /**\n   * Returns the {@link Rectangle} that defines the bounds of the editor.\n   */\n  getEditorBounds(state) {\n    const isEdge = state.cell.isEdge();\n    const {\n      scale\n    } = this.graph.getView();\n    const minSize = this.getMinimumSize(state);\n    const minWidth = minSize.width;\n    const minHeight = minSize.height;\n    let result = null;\n    if (!isEdge && state.view.graph.cellRenderer.legacySpacing && state.style.overflow === 'fill') {\n      result = state.shape.getLabelBounds(Rectangle.fromRectangle(state));\n    } else {\n      // @ts-ignore\n      const dummy = new TextShape(); // FIXME!!!! ===================================================================================================\n      const spacing = (state.style.spacing ?? 0) * scale;\n      const spacingTop = ((state.style.spacingTop ?? 0) + dummy.baseSpacingTop) * scale + spacing;\n      const spacingRight = ((state.style.spacingRight ?? 0) + dummy.baseSpacingRight) * scale + spacing;\n      const spacingBottom = ((state.style.spacingBottom ?? 0) + dummy.baseSpacingBottom) * scale + spacing;\n      const spacingLeft = ((state.style.spacingLeft ?? 0) + dummy.baseSpacingLeft) * scale + spacing;\n      result = new Rectangle(state.x, state.y, Math.max(minWidth, state.width - spacingLeft - spacingRight), Math.max(minHeight, state.height - spacingTop - spacingBottom));\n      const hpos = state.style.labelPosition != null ? state.style.labelPosition : 'center';\n      const vpos = state.style.verticalLabelPosition != null ? state.style.verticalLabelPosition : 'middle';\n      result = state.shape != null && hpos === 'center' && vpos === 'middle' ? state.shape.getLabelBounds(result) : result;\n      if (isEdge) {\n        result.x = state.absoluteOffset.x;\n        result.y = state.absoluteOffset.y;\n        if (state.text != null && state.text.boundingBox != null) {\n          // Workaround for label containing just spaces in which case\n          // the bounding box location contains negative numbers\n          if (state.text.boundingBox.x > 0) {\n            result.x = state.text.boundingBox.x;\n          }\n          if (state.text.boundingBox.y > 0) {\n            result.y = state.text.boundingBox.y;\n          }\n        }\n      } else if (state.text != null && state.text.boundingBox != null) {\n        result.x = Math.min(result.x, state.text.boundingBox.x);\n        result.y = Math.min(result.y, state.text.boundingBox.y);\n      }\n      result.x += spacingLeft;\n      result.y += spacingTop;\n      if (state.text != null && state.text.boundingBox != null) {\n        if (!isEdge) {\n          result.width = Math.max(result.width, state.text.boundingBox.width);\n          result.height = Math.max(result.height, state.text.boundingBox.height);\n        } else {\n          result.width = Math.max(minWidth, state.text.boundingBox.width);\n          result.height = Math.max(minHeight, state.text.boundingBox.height);\n        }\n      }\n      // Applies the horizontal and vertical label positions\n      if (state.cell.isVertex()) {\n        const horizontal = getStringValue(state.style, 'labelPosition', ALIGN.CENTER);\n        if (horizontal === 'left') {\n          result.x -= state.width;\n        } else if (horizontal === 'right') {\n          result.x += state.width;\n        }\n        const vertical = state.style.verticalLabelPosition != null ? state.style.verticalLabelPosition : 'middle';\n        if (vertical === 'top') {\n          result.y -= state.height;\n        } else if (vertical === 'bottom') {\n          result.y += state.height;\n        }\n      }\n    }\n    return new Rectangle(Math.round(result.x), Math.round(result.y), Math.round(result.width), Math.round(result.height));\n  }\n  /**\n   * Returns the initial label value to be used of the label of the given\n   * cell is empty. This label is displayed and cleared on the first keystroke.\n   * This implementation returns <emptyLabelText>.\n   *\n   * @param cell <Cell> for which a text for an empty editing box should be\n   * returned.\n   */\n  getEmptyLabelText(cell = null) {\n    return this.emptyLabelText ?? '';\n  }\n  /**\n   * Returns the cell that is currently being edited or null if no cell is\n   * being edited.\n   */\n  getEditingCell() {\n    return this.editingCell;\n  }\n  /**\n   * Destroys the editor and removes all associated resources.\n   */\n  onDestroy() {\n    if (this.textarea) {\n      InternalEvent.release(this.textarea);\n      if (this.textarea.parentNode) {\n        this.textarea.parentNode.removeChild(this.textarea);\n      }\n      this.textarea = null;\n    }\n    this.graph.getDataModel().removeListener(this.changeHandler);\n    this.graph.getView().removeListener(this.zoomHandler);\n  }\n}\nCellEditorHandler.pluginId = 'CellEditorHandler';\nexport default CellEditorHandler;","map":{"version":3,"names":["getValue","getAlignmentAsPoint","setPrefixedStyle","Rectangle","InternalEvent","Client","ABSOLUTE_LINE_HEIGHT","ALIGN","DEFAULT_FONTFAMILY","DEFAULT_FONTSIZE","DEFAULT_TEXT_DIRECTION","DIALECT","FONT","LINE_HEIGHT","NONE","WORD_WRAP","TextShape","clearSelection","extractTextWithWhitespace","isNode","getStringValue","htmlEntities","replaceTrailingNewlines","getSource","isConsumed","isControlDown","isMetaDown","isShiftDown","CellEditorHandler","constructor","graph","clearOnChange","bounds","resizeThread","textDirection","textarea","editingCell","trigger","modified","autoSize","selectText","emptyLabelText","IS_FF","escapeCancelsEditing","textNode","zIndex","minResize","wordWrapPadding","blurEnabled","initialValue","align","zoomHandler","isEditing","resize","changeHandler","sender","getView","getState","stopEditing","addListener","SCALE","SCALE_AND_TRANSLATE","getDataModel","CHANGE","init","document","createElement","className","contentEditable","String","IS_GC","style","minHeight","position","installListeners","applyValue","state","value","labelChanged","cell","setAlign","textAlign","getInitialValue","result","getEditingValue","replace","getCurrentValue","Array","from","childNodes","isCancelEditingKeyEvent","evt","elt","consume","focusLost","isStopEditingEvent","keyCode","keypressHandler","innerHTML","getEmptyLabelText","keyupHandler","length","evtName","resizeHandler","window","clearTimeout","setTimeout","isEnterStopsCellEditing","isEventSource","isEdge","scale","m","overflow","getEditorBounds","width","Math","round","height","left","max","x","top","y","isWrapping","wordWrap","whiteSpace","lw","text","margin","CENTER","MIDDLE","absoluteOffset","tmp","parseFloat","fromRectangle","hpos","vpos","shape","getLabelBounds","view","cellRenderer","legacySpacing","dummy","spacing","spacingTop","baseSpacingTop","spacingRight","baseSpacingRight","spacingBottom","baseSpacingBottom","spacingLeft","baseSpacingLeft","labelPosition","verticalLabelPosition","scrollWidth","maxWidth","ow","oh","scrollHeight","isInvokesStopCellEditing","getBackgroundColor","startEditing","tooltipHandler","getPlugin","hideTooltip","size","fontSize","family","fontFamily","color","fontColor","LEFT","bold","fontStyle","BOLD","italic","ITALIC","txtDecor","UNDERLINE","push","STRIKETHROUGH","lineHeight","backgroundColor","textDecoration","join","fontWeight","outline","dir","dialect","STRICTHTML","getAutoDirection","setAttribute","removeAttribute","container","appendChild","isHideLabel","node","visibility","focus","isSelectText","execCommand","e","cancel","initial","blur","parentNode","removeChild","prepareTextarea","batchUpdate","setCellStyles","release","lastChild","nodeName","getMinimumSize","minSize","minWidth","boundingBox","min","isVertex","horizontal","vertical","getEditingCell","onDestroy","removeListener","pluginId"],"sources":["D:/OSPanel/domains/old/react/react-intro-main/node_modules/@maxgraph/core/dist/view/handler/CellEditorHandler.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { getValue } from '../../util/Utils';\nimport { getAlignmentAsPoint, setPrefixedStyle } from '../../util/styleUtils';\nimport Rectangle from '../geometry/Rectangle';\nimport InternalEvent from '../event/InternalEvent';\nimport Client from '../../Client';\nimport { ABSOLUTE_LINE_HEIGHT, ALIGN, DEFAULT_FONTFAMILY, DEFAULT_FONTSIZE, DEFAULT_TEXT_DIRECTION, DIALECT, FONT, LINE_HEIGHT, NONE, WORD_WRAP, } from '../../util/Constants';\nimport TextShape from '../geometry/node/TextShape';\nimport { clearSelection, extractTextWithWhitespace, isNode } from '../../util/domUtils';\nimport { getStringValue, htmlEntities, replaceTrailingNewlines, } from '../../util/StringUtils';\nimport { getSource, isConsumed, isControlDown, isMetaDown, isShiftDown, } from '../../util/EventUtils';\n/**\n * In-place editor for the graph. To control this editor, use\n * {@link Graph#invokesStopCellEditing}, {@link Graph#enterStopsCellEditing} and\n * {@link Graph#escapeEnabled}. If {@link Graph#enterStopsCellEditing} is true then\n * ctrl-enter or shift-enter can be used to create a linefeed. The F2 and\n * escape keys can always be used to stop editing.\n *\n * To customize the location of the textbox in the graph, override\n * <getEditorBounds> as follows:\n *\n * ```javascript\n * graph.cellEditor.getEditorBounds = (state)=>\n * {\n *   let result = getEditorBounds.apply(this, arguments);\n *\n *   if (this.graph.getDataModel().isEdge(state.cell))\n *   {\n *     result.x = state.getCenterX() - result.width / 2;\n *     result.y = state.getCenterY() - result.height / 2;\n *   }\n *\n *   return result;\n * };\n * ```\n *\n * Note that this hook is only called if <autoSize> is false. If <autoSize> is true,\n * then {@link Shape#getLabelBounds} is used to compute the current bounds of the textbox.\n *\n * The textarea uses the mxCellEditor CSS class. You can modify this class in\n * your custom CSS. Note: You should modify the CSS after loading the client\n * in the page.\n *\n * Example:\n *\n * To only allow numeric input in the in-place editor, use the following code.\n *\n * ```javascript\n * let text = graph.cellEditor.textarea;\n *\n * mxEvent.addListener(text, 'keydown', function (evt)\n * {\n *   if (!(evt.keyCode >= 48 && evt.keyCode <= 57) &&\n *       !(evt.keyCode >= 96 && evt.keyCode <= 105))\n *   {\n *     mxEvent.consume(evt);\n *   }\n * });\n * ```\n *\n * Placeholder:\n *\n * To implement a placeholder for cells without a label, use the\n * <emptyLabelText> variable.\n *\n * Resize in Chrome:\n *\n * Resize of the textarea is disabled by default. If you want to enable\n * this feature extend <init> and set this.textarea.style.resize = ''.\n *\n * To start editing on a key press event, the container of the graph\n * should have focus or a focusable parent should be used to add the\n * key press handler as follows.\n *\n * ```javascript\n * mxEvent.addListener(graph.container, 'keypress', mxUtils.bind(this, (evt)=>\n * {\n *   if (!graph.isEditing() && !graph.isSelectionEmpty() && evt.which !== 0 &&\n *       !mxEvent.isAltDown(evt) && !mxEvent.isControlDown(evt) && !mxEvent.isMetaDown(evt))\n *   {\n *     graph.startEditing();\n *\n *     if (Client.IS_FF)\n *     {\n *       graph.cellEditor.textarea.value = String.fromCharCode(evt.which);\n *     }\n *   }\n * }));\n * ```\n *\n * To allow focus for a DIV, and hence to receive key press events, some browsers\n * require it to have a valid tabindex attribute. In this case the following\n * code may be used to keep the container focused.\n *\n * ```javascript\n * let graphFireMouseEvent = graph.fireMouseEvent;\n * graph.fireMouseEvent = (evtName, me, sender)=>\n * {\n *   if (evtName == mxEvent.MOUSE_DOWN)\n *   {\n *     this.container.focus();\n *   }\n *\n *   graphFireMouseEvent.apply(this, arguments);\n * };\n * ```\n *\n * Constructor: mxCellEditor\n *\n * Constructs a new in-place editor for the specified graph.\n *\n * @param graph Reference to the enclosing {@link Graph}.\n */\nclass CellEditorHandler {\n    constructor(graph) {\n        this.clearOnChange = false;\n        this.bounds = null;\n        this.resizeThread = null;\n        this.textDirection = null;\n        /**\n         * Holds the DIV that is used for text editing. Note that this may be null before the first\n         * edit. Instantiated in <init>.\n         */\n        this.textarea = null;\n        /**\n         * Reference to the <Cell> that is currently being edited.\n         */\n        // editingCell: mxCell;\n        this.editingCell = null;\n        /**\n         * Reference to the event that was used to start editing.\n         */\n        // trigger: MouseEvent;\n        this.trigger = null;\n        /**\n         * Specifies if the label has been modified.\n         */\n        // modified: boolean;\n        this.modified = false;\n        /**\n         * Specifies if the textarea should be resized while the text is being edited.\n         * Default is true.\n         */\n        // autoSize: boolean;\n        this.autoSize = true;\n        /**\n         * Specifies if the text should be selected when editing starts. Default is\n         * true.\n         */\n        // selectText: boolean;\n        this.selectText = true;\n        /**\n         * Text to be displayed for empty labels. Default is '' or '<br>' in Firefox as\n         * a workaround for the missing cursor bug for empty content editable. This can\n         * be set to eg. \"[Type Here]\" to easier visualize editing of empty labels. The\n         * value is only displayed before the first keystroke and is never used as the\n         * actual editing value.\n         */\n        // emptyLabelText: '<br>' | '';\n        this.emptyLabelText = Client.IS_FF ? '<br>' : '';\n        /**\n         * If true, pressing the escape key will stop editing and not accept the new\n         * value. Change this to false to accept the new value on escape, and cancel\n         * editing on Shift+Escape instead. Default is true.\n         */\n        // escapeCancelsEditing: boolean;\n        this.escapeCancelsEditing = true;\n        /**\n         * Reference to the label DOM node that has been hidden.\n         */\n        // textNode: string;\n        this.textNode = null;\n        /**\n         * Specifies the zIndex for the textarea. Default is 5.\n         */\n        // zIndex: number;\n        this.zIndex = 5;\n        /**\n         * Defines the minimum width and height to be used in <resize>. Default is 0x20px.\n         */\n        // minResize: mxRectangle;\n        this.minResize = new Rectangle(0, 20);\n        /**\n         * Correction factor for word wrapping width. Default is 2 in quirks, 0 in IE\n         * 11 and 1 in all other browsers and modes.\n         */\n        // wordWrapPadding: 2 | 1 | 0;\n        this.wordWrapPadding = 0;\n        /**\n         * If <focusLost> should be called if <textarea> loses the focus. Default is false.\n         */\n        // blurEnabled: boolean;\n        this.blurEnabled = false;\n        /**\n         * Holds the initial editing value to check if the current value was modified.\n         */\n        // initialValue: string;\n        this.initialValue = null;\n        /**\n         * Holds the current temporary horizontal alignment for the cell style. If this\n         * is modified then the current text alignment is changed and the cell style is\n         * updated when the value is applied.\n         */\n        this.align = null;\n        this.graph = graph;\n        // Stops editing after zoom changes\n        this.zoomHandler = () => {\n            if (this.graph.isEditing()) {\n                this.resize();\n            }\n        };\n        // Handling of deleted cells while editing\n        this.changeHandler = (sender) => {\n            if (this.editingCell && !this.graph.getView().getState(this.editingCell, false)) {\n                this.stopEditing(true);\n            }\n        };\n        this.graph.getView().addListener(InternalEvent.SCALE, this.zoomHandler);\n        this.graph.getView().addListener(InternalEvent.SCALE_AND_TRANSLATE, this.zoomHandler);\n        this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.changeHandler);\n    }\n    /**\n     * Creates the <textarea> and installs the event listeners. The key handler\n     * updates the {@link odified} state.\n     */\n    init() {\n        this.textarea = document.createElement('div');\n        this.textarea.className = 'mxCellEditor mxPlainTextEditor';\n        this.textarea.contentEditable = String(true);\n        // Workaround for selection outside of DIV if height is 0\n        if (Client.IS_GC) {\n            this.textarea.style.minHeight = '1em';\n        }\n        this.textarea.style.position = 'relative';\n        this.installListeners(this.textarea);\n    }\n    /**\n     * Called in <stopEditing> if cancel is false to invoke {@link Graph#labelChanged}.\n     */\n    // applyValue(state: CellState, value: string): void;\n    applyValue(state, value) {\n        this.graph.labelChanged(state.cell, value, this.trigger);\n    }\n    /**\n     * Sets the temporary horizontal alignment for the current editing session.\n     */\n    setAlign(align) {\n        if (this.textarea) {\n            this.textarea.style.textAlign = align;\n        }\n        this.align = align;\n        this.resize();\n    }\n    /**\n     * Gets the initial editing value for the given cell.\n     */\n    getInitialValue(state, trigger) {\n        let result = htmlEntities(this.graph.getEditingValue(state.cell, trigger), false);\n        result = replaceTrailingNewlines(result, '<div><br></div>');\n        return result.replace(/\\n/g, '<br>');\n    }\n    /**\n     * Returns the current editing value.\n     */\n    getCurrentValue(state) {\n        if (!this.textarea)\n            return null;\n        return extractTextWithWhitespace(Array.from(this.textarea.childNodes));\n    }\n    /**\n     * Returns true if <escapeCancelsEditing> is true and shift, control and meta\n     * are not pressed.\n     */\n    // isCancelEditingKeyEvent(evt: Event): boolean;\n    isCancelEditingKeyEvent(evt) {\n        return (this.escapeCancelsEditing ||\n            isShiftDown(evt) ||\n            isControlDown(evt) ||\n            isMetaDown(evt));\n    }\n    /**\n     * Installs listeners for focus, change and standard key event handling.\n     */\n    // installListeners(elt: Element): void;\n    installListeners(elt) {\n        // Applies value if text is dragged\n        // LATER: Gesture mouse events ignored for starting move\n        InternalEvent.addListener(elt, 'dragstart', (evt) => {\n            this.graph.stopEditing(false);\n            InternalEvent.consume(evt);\n        });\n        // Applies value if focus is lost\n        InternalEvent.addListener(elt, 'blur', (evt) => {\n            if (this.blurEnabled) {\n                this.focusLost();\n            }\n        });\n        // Updates modified state and handles placeholder text\n        InternalEvent.addListener(elt, 'keydown', (evt) => {\n            if (!isConsumed(evt)) {\n                if (this.isStopEditingEvent(evt)) {\n                    this.graph.stopEditing(false);\n                    InternalEvent.consume(evt);\n                }\n                else if (evt.keyCode === 27 /* Escape */) {\n                    this.graph.stopEditing(this.isCancelEditingKeyEvent(evt));\n                    InternalEvent.consume(evt);\n                }\n            }\n        });\n        // Keypress only fires if printable key was pressed and handles removing the empty placeholder\n        const keypressHandler = (evt) => {\n            if (this.editingCell != null) {\n                // Clears the initial empty label on the first keystroke\n                // and workaround for FF which fires keypress for delete and backspace\n                if (this.clearOnChange &&\n                    elt.innerHTML === this.getEmptyLabelText() &&\n                    (!Client.IS_FF ||\n                        (evt.keyCode !== 8 /* Backspace */ && evt.keyCode !== 46)) /* Delete */) {\n                    this.clearOnChange = false;\n                    elt.innerHTML = '';\n                }\n            }\n        };\n        InternalEvent.addListener(elt, 'keypress', keypressHandler);\n        InternalEvent.addListener(elt, 'paste', keypressHandler);\n        // Handler for updating the empty label text value after a change\n        const keyupHandler = (evt) => {\n            if (this.editingCell != null) {\n                // Uses an optional text value for sempty labels which is cleared\n                // when the first keystroke appears. This makes it easier to see\n                // that a label is being edited even if the label is empty.\n                // In Safari and FF, an empty text is represented by <BR> which isn't enough to force a valid size\n                const textarea = this.textarea;\n                if (textarea.innerHTML.length === 0 || textarea.innerHTML === '<br>') {\n                    textarea.innerHTML = this.getEmptyLabelText();\n                    this.clearOnChange = textarea.innerHTML.length > 0;\n                }\n                else {\n                    this.clearOnChange = false;\n                }\n            }\n        };\n        InternalEvent.addListener(elt, 'input', keyupHandler);\n        InternalEvent.addListener(elt, 'cut', keyupHandler);\n        InternalEvent.addListener(elt, 'paste', keyupHandler);\n        // Adds automatic resizing of the textbox while typing using input, keyup and/or DOM change events\n        const evtName = 'input';\n        const resizeHandler = (evt) => {\n            if (this.editingCell != null && this.autoSize && !isConsumed(evt)) {\n                // Asynchronous is needed for keydown and shows better results for input events overall\n                // (ie non-blocking and cases where the offsetWidth/-Height was wrong at this time)\n                if (this.resizeThread != null) {\n                    window.clearTimeout(this.resizeThread);\n                }\n                this.resizeThread = window.setTimeout(() => {\n                    this.resizeThread = null;\n                    this.resize();\n                }, 0);\n            }\n        };\n        InternalEvent.addListener(elt, evtName, resizeHandler);\n        InternalEvent.addListener(window, 'resize', resizeHandler);\n        InternalEvent.addListener(elt, 'cut', resizeHandler);\n        InternalEvent.addListener(elt, 'paste', resizeHandler);\n    }\n    /**\n     * Returns true if the given keydown event should stop cell editing. This\n     * returns true if F2 is pressed of if {@link Graph#enterStopsCellEditing} is true\n     * and enter is pressed without control or shift.\n     */\n    isStopEditingEvent(evt) {\n        return (evt.keyCode === 113 /* F2 */ ||\n            (this.graph.isEnterStopsCellEditing() &&\n                evt.keyCode === 13 /* Enter */ &&\n                !isControlDown(evt) &&\n                !isShiftDown(evt)));\n    }\n    /**\n     * Returns true if this editor is the source for the given native event.\n     */\n    isEventSource(evt) {\n        return getSource(evt) === this.textarea;\n    }\n    /**\n     * Returns {@link odified}.\n     */\n    resize() {\n        const state = this.editingCell\n            ? this.graph.getView().getState(this.editingCell)\n            : null;\n        if (!state) {\n            this.stopEditing(true);\n        }\n        else if (this.textarea != null) {\n            const isEdge = state.cell.isEdge();\n            const { scale } = this.graph.getView();\n            let m = null;\n            if (!this.autoSize || state.style.overflow === 'fill') {\n                // Specifies the bounds of the editor box\n                this.bounds = this.getEditorBounds(state);\n                this.textarea.style.width = `${Math.round(this.bounds.width / scale)}px`;\n                this.textarea.style.height = `${Math.round(this.bounds.height / scale)}px`;\n                // FIXME: Offset when scaled\n                this.textarea.style.left = `${Math.max(0, Math.round(this.bounds.x + 1))}px`;\n                this.textarea.style.top = `${Math.max(0, Math.round(this.bounds.y + 1))}px`;\n                // Installs native word wrapping and avoids word wrap for empty label placeholder\n                if (this.graph.isWrapping(state.cell) &&\n                    (this.bounds.width >= 2 || this.bounds.height >= 2) &&\n                    this.textarea.innerHTML !== this.getEmptyLabelText()) {\n                    this.textarea.style.wordWrap = WORD_WRAP;\n                    this.textarea.style.whiteSpace = 'normal';\n                    if (state.style.overflow !== 'fill') {\n                        this.textarea.style.width = `${Math.round(this.bounds.width / scale) + this.wordWrapPadding}px`;\n                    }\n                }\n                else {\n                    this.textarea.style.whiteSpace = 'nowrap';\n                    if (state.style.overflow !== 'fill') {\n                        this.textarea.style.width = '';\n                    }\n                }\n            }\n            else {\n                const lw = getValue(state.style, 'labelWidth', null);\n                m = state.text != null && this.align == null ? state.text.margin : null;\n                if (m == null) {\n                    m = getAlignmentAsPoint(this.align || getValue(state.style, 'align', ALIGN.CENTER), getValue(state.style, 'verticalAlign', ALIGN.MIDDLE));\n                }\n                if (isEdge) {\n                    this.bounds = new Rectangle(state.absoluteOffset.x, state.absoluteOffset.y, 0, 0);\n                    if (lw != null) {\n                        const tmp = (parseFloat(lw) + 2) * scale;\n                        this.bounds.width = tmp;\n                        this.bounds.x += m.x * tmp;\n                    }\n                }\n                else {\n                    let bounds = Rectangle.fromRectangle(state);\n                    let hpos = getValue(state.style, 'labelPosition', ALIGN.CENTER);\n                    let vpos = getValue(state.style, 'verticalLabelPosition', ALIGN.MIDDLE);\n                    bounds =\n                        state.shape != null && hpos === 'center' && vpos === 'middle'\n                            ? state.shape.getLabelBounds(bounds)\n                            : bounds;\n                    if (lw != null) {\n                        bounds.width = parseFloat(lw) * scale;\n                    }\n                    if (!state.view.graph.cellRenderer.legacySpacing ||\n                        state.style.overflow !== 'width') {\n                        // @ts-ignore\n                        const dummy = new TextShape(); // FIXME!!!! ===================================================================================================\n                        const spacing = (state.style.spacing ?? 2) * scale;\n                        const spacingTop = ((state.style.spacingTop ?? 0) + dummy.baseSpacingTop) * scale + spacing;\n                        const spacingRight = ((state.style.spacingRight ?? 0) + dummy.baseSpacingRight) * scale +\n                            spacing;\n                        const spacingBottom = ((state.style.spacingBottom ?? 0) + dummy.baseSpacingBottom) * scale +\n                            spacing;\n                        const spacingLeft = ((state.style.spacingLeft ?? 0) + dummy.baseSpacingLeft) * scale + spacing;\n                        hpos =\n                            state.style.labelPosition != null ? state.style.labelPosition : 'center';\n                        vpos =\n                            state.style.verticalLabelPosition != null\n                                ? state.style.verticalLabelPosition\n                                : 'middle';\n                        bounds = new Rectangle(bounds.x + spacingLeft, bounds.y + spacingTop, bounds.width -\n                            (hpos === ALIGN.CENTER && lw == null ? spacingLeft + spacingRight : 0), bounds.height - (vpos === ALIGN.MIDDLE ? spacingTop + spacingBottom : 0));\n                    }\n                    this.bounds = new Rectangle(bounds.x + state.absoluteOffset.x, bounds.y + state.absoluteOffset.y, bounds.width, bounds.height);\n                }\n                // Needed for word wrap inside text blocks with oversize lines to match the final result where\n                // the width of the longest line is used as the reference for text alignment in the cell\n                // TODO: Fix word wrapping preview for edge labels in helloworld.html\n                if (this.graph.isWrapping(state.cell) &&\n                    (this.bounds.width >= 2 || this.bounds.height >= 2) &&\n                    this.textarea.innerHTML !== this.getEmptyLabelText()) {\n                    this.textarea.style.wordWrap = WORD_WRAP;\n                    this.textarea.style.whiteSpace = 'normal';\n                    // Forces automatic reflow if text is removed from an oversize label and normal word wrap\n                    const tmp = Math.round(this.bounds.width / scale) + this.wordWrapPadding;\n                    if (this.textarea.style.position !== 'relative') {\n                        this.textarea.style.width = `${tmp}px`;\n                        if (this.textarea.scrollWidth > tmp) {\n                            this.textarea.style.width = `${this.textarea.scrollWidth}px`;\n                        }\n                    }\n                    else {\n                        this.textarea.style.maxWidth = `${tmp}px`;\n                    }\n                }\n                else {\n                    // KNOWN: Trailing cursor in IE9 quirks mode is not visible\n                    this.textarea.style.whiteSpace = 'nowrap';\n                    this.textarea.style.width = '';\n                }\n                const ow = this.textarea.scrollWidth;\n                const oh = this.textarea.scrollHeight;\n                // TODO: Update CSS width and height if smaller than minResize or remove minResize\n                // if (this.minResize != null)\n                // {\n                //  ow = Math.max(ow, this.minResize.width);\n                //  oh = Math.max(oh, this.minResize.height);\n                // }\n                // LATER: Keep in visible area, add fine tuning for pixel precision\n                this.textarea.style.left = `${Math.max(0, Math.round(this.bounds.x - m.x * (this.bounds.width - 2)) + 1)}px`;\n                this.textarea.style.top = `${Math.max(0, Math.round(this.bounds.y - m.y * (this.bounds.height - 4) + (m.y === -1 ? 3 : 0)) + 1)}px`;\n            }\n            setPrefixedStyle(this.textarea.style, 'transformOrigin', '0px 0px');\n            setPrefixedStyle(this.textarea.style, 'transform', `scale(${scale},${scale})${m == null ? '' : ` translate(${m.x * 100}%,${m.y * 100}%)`}`);\n        }\n    }\n    /**\n     * Called if the textarea has lost focus.\n     */\n    focusLost() {\n        this.stopEditing(!this.graph.isInvokesStopCellEditing());\n    }\n    /**\n     * Returns the background color for the in-place editor. This implementation\n     * always returns NONE.\n     */\n    getBackgroundColor(state) {\n        return NONE;\n    }\n    /**\n     * Starts the editor for the given cell.\n     *\n     * @param cell <Cell> to start editing.\n     * @param trigger Optional mouse event that triggered the editor.\n     */\n    startEditing(cell, trigger = null) {\n        this.stopEditing(true);\n        this.align = null;\n        // Creates new textarea instance\n        if (this.textarea == null) {\n            this.init();\n        }\n        const tooltipHandler = this.graph.getPlugin('TooltipHandler');\n        tooltipHandler?.hideTooltip();\n        const state = this.graph.getView().getState(cell);\n        if (state) {\n            // Configures the style of the in-place editor\n            const { scale } = this.graph.getView();\n            const size = state.style.fontSize ?? DEFAULT_FONTSIZE;\n            const family = state.style.fontFamily ?? DEFAULT_FONTFAMILY;\n            const color = state.style.fontColor ?? 'black';\n            const align = state.style.align ?? ALIGN.LEFT;\n            const bold = (state.style.fontStyle || 0) & FONT.BOLD;\n            const italic = (state.style.fontStyle || 0) & FONT.ITALIC;\n            const txtDecor = [];\n            if ((state.style.fontStyle || 0) & FONT.UNDERLINE) {\n                txtDecor.push('underline');\n            }\n            if ((state.style.fontStyle || 0) & FONT.STRIKETHROUGH) {\n                txtDecor.push('line-through');\n            }\n            const textarea = this.textarea;\n            textarea.style.lineHeight = ABSOLUTE_LINE_HEIGHT\n                ? `${Math.round(size * LINE_HEIGHT)}px`\n                : String(LINE_HEIGHT);\n            textarea.style.backgroundColor = this.getBackgroundColor(state) || 'transparent';\n            textarea.style.textDecoration = txtDecor.join(' ');\n            textarea.style.fontWeight = bold ? 'bold' : 'normal';\n            textarea.style.fontStyle = italic ? 'italic' : '';\n            textarea.style.fontSize = `${Math.round(size)}px`;\n            textarea.style.zIndex = String(this.zIndex);\n            textarea.style.fontFamily = family;\n            textarea.style.textAlign = align;\n            textarea.style.outline = 'none';\n            textarea.style.color = color;\n            let dir = (this.textDirection =\n                state.style.textDirection ?? DEFAULT_TEXT_DIRECTION);\n            if (dir === 'auto') {\n                if (state.text !== null &&\n                    state.text.dialect !== DIALECT.STRICTHTML &&\n                    !isNode(state.text.value)) {\n                    dir = state.text.getAutoDirection();\n                }\n            }\n            if (dir === 'ltr' || dir === 'rtl') {\n                textarea.setAttribute('dir', dir);\n            }\n            else {\n                textarea.removeAttribute('dir');\n            }\n            // Sets the initial editing value\n            textarea.innerHTML = this.getInitialValue(state, trigger) || '';\n            this.initialValue = textarea.innerHTML;\n            // Uses an optional text value for empty labels which is cleared\n            // when the first keystroke appears. This makes it easier to see\n            // that a label is being edited even if the label is empty.\n            if (textarea.innerHTML.length === 0 || textarea.innerHTML === '<br>') {\n                textarea.innerHTML = this.getEmptyLabelText();\n                this.clearOnChange = true;\n            }\n            else {\n                this.clearOnChange = textarea.innerHTML === this.getEmptyLabelText();\n            }\n            // @ts-ignore\n            this.graph.container.appendChild(textarea);\n            // Update this after firing all potential events that could update the cleanOnChange flag\n            this.editingCell = cell;\n            this.trigger = trigger;\n            this.textNode = null;\n            if (state.text !== null && this.isHideLabel(state)) {\n                this.textNode = state.text.node;\n                this.textNode.style.visibility = 'hidden';\n            }\n            // Workaround for initial offsetHeight not ready for heading in markup\n            if (this.autoSize &&\n                (state.cell.isEdge() || state.style.overflow !== 'fill')) {\n                window.setTimeout(() => {\n                    this.resize();\n                }, 0);\n            }\n            this.resize();\n            // Workaround for NS_ERROR_FAILURE in FF\n            try {\n                // Prefers blinking cursor over no selected text if empty\n                textarea.focus();\n                if (this.isSelectText() &&\n                    textarea.innerHTML.length > 0 &&\n                    (textarea.innerHTML !== this.getEmptyLabelText() || !this.clearOnChange)) {\n                    document.execCommand('selectAll', false);\n                }\n            }\n            catch (e) {\n                // ignore\n            }\n        }\n    }\n    /**\n     * Returns <selectText>.\n     */\n    isSelectText() {\n        return this.selectText;\n    }\n    /**\n    clearSelection() {\n      const selection = window.getSelection();\n  \n      if (selection) {\n        if (selection.empty) {\n          selection.empty();\n        } else if (selection.removeAllRanges) {\n          selection.removeAllRanges();\n        }\n      }\n    }\n  \n    /**\n     * Stops the editor and applies the value if cancel is false.\n     */\n    stopEditing(cancel = false) {\n        if (this.editingCell) {\n            if (this.textNode) {\n                this.textNode.style.visibility = 'visible';\n                this.textNode = null;\n            }\n            const state = !cancel ? this.graph.view.getState(this.editingCell) : null;\n            const textarea = this.textarea;\n            const initial = this.initialValue;\n            this.initialValue = null;\n            this.editingCell = null;\n            this.trigger = null;\n            this.bounds = null;\n            textarea.blur();\n            clearSelection();\n            if (textarea.parentNode) {\n                textarea.parentNode.removeChild(textarea);\n            }\n            if (this.clearOnChange && textarea.innerHTML === this.getEmptyLabelText()) {\n                textarea.innerHTML = '';\n                this.clearOnChange = false;\n            }\n            if (state && (textarea.innerHTML !== initial || this.align !== null)) {\n                this.prepareTextarea();\n                const value = this.getCurrentValue(state);\n                this.graph.batchUpdate(() => {\n                    if (value !== null) {\n                        this.applyValue(state, value);\n                    }\n                    if (this.align !== null) {\n                        this.graph.setCellStyles('align', this.align, [state.cell]);\n                    }\n                });\n            }\n            // Forces new instance on next edit for undo history reset\n            if (this.textarea)\n                InternalEvent.release(this.textarea);\n            this.textarea = null;\n            this.align = null;\n        }\n    }\n    /**\n     * Prepares the textarea for getting its value in <stopEditing>.\n     * This implementation removes the extra trailing linefeed in Firefox.\n     */\n    prepareTextarea() {\n        const textarea = this.textarea;\n        if (textarea.lastChild && textarea.lastChild.nodeName === 'BR') {\n            textarea.removeChild(textarea.lastChild);\n        }\n    }\n    /**\n     * Returns true if the label should be hidden while the cell is being\n     * edited.\n     */\n    isHideLabel(state = null) {\n        return true;\n    }\n    /**\n     * Returns the minimum width and height for editing the given state.\n     */\n    getMinimumSize(state) {\n        const { scale } = this.graph.getView();\n        const textarea = this.textarea;\n        return new Rectangle(0, 0, state.text === null ? 30 : state.text.size * scale + 20, textarea.style.textAlign === 'left' ? 120 : 40);\n    }\n    /**\n     * Returns the {@link Rectangle} that defines the bounds of the editor.\n     */\n    getEditorBounds(state) {\n        const isEdge = state.cell.isEdge();\n        const { scale } = this.graph.getView();\n        const minSize = this.getMinimumSize(state);\n        const minWidth = minSize.width;\n        const minHeight = minSize.height;\n        let result = null;\n        if (!isEdge &&\n            state.view.graph.cellRenderer.legacySpacing &&\n            state.style.overflow === 'fill') {\n            result = state.shape.getLabelBounds(Rectangle.fromRectangle(state));\n        }\n        else {\n            // @ts-ignore\n            const dummy = new TextShape(); // FIXME!!!! ===================================================================================================\n            const spacing = (state.style.spacing ?? 0) * scale;\n            const spacingTop = ((state.style.spacingTop ?? 0) + dummy.baseSpacingTop) * scale + spacing;\n            const spacingRight = ((state.style.spacingRight ?? 0) + dummy.baseSpacingRight) * scale + spacing;\n            const spacingBottom = ((state.style.spacingBottom ?? 0) + dummy.baseSpacingBottom) * scale + spacing;\n            const spacingLeft = ((state.style.spacingLeft ?? 0) + dummy.baseSpacingLeft) * scale + spacing;\n            result = new Rectangle(state.x, state.y, Math.max(minWidth, state.width - spacingLeft - spacingRight), Math.max(minHeight, state.height - spacingTop - spacingBottom));\n            const hpos = state.style.labelPosition != null ? state.style.labelPosition : 'center';\n            const vpos = state.style.verticalLabelPosition != null\n                ? state.style.verticalLabelPosition\n                : 'middle';\n            result =\n                state.shape != null && hpos === 'center' && vpos === 'middle'\n                    ? state.shape.getLabelBounds(result)\n                    : result;\n            if (isEdge) {\n                result.x = state.absoluteOffset.x;\n                result.y = state.absoluteOffset.y;\n                if (state.text != null && state.text.boundingBox != null) {\n                    // Workaround for label containing just spaces in which case\n                    // the bounding box location contains negative numbers\n                    if (state.text.boundingBox.x > 0) {\n                        result.x = state.text.boundingBox.x;\n                    }\n                    if (state.text.boundingBox.y > 0) {\n                        result.y = state.text.boundingBox.y;\n                    }\n                }\n            }\n            else if (state.text != null && state.text.boundingBox != null) {\n                result.x = Math.min(result.x, state.text.boundingBox.x);\n                result.y = Math.min(result.y, state.text.boundingBox.y);\n            }\n            result.x += spacingLeft;\n            result.y += spacingTop;\n            if (state.text != null && state.text.boundingBox != null) {\n                if (!isEdge) {\n                    result.width = Math.max(result.width, state.text.boundingBox.width);\n                    result.height = Math.max(result.height, state.text.boundingBox.height);\n                }\n                else {\n                    result.width = Math.max(minWidth, state.text.boundingBox.width);\n                    result.height = Math.max(minHeight, state.text.boundingBox.height);\n                }\n            }\n            // Applies the horizontal and vertical label positions\n            if (state.cell.isVertex()) {\n                const horizontal = (getStringValue(state.style, 'labelPosition', ALIGN.CENTER));\n                if (horizontal === 'left') {\n                    result.x -= state.width;\n                }\n                else if (horizontal === 'right') {\n                    result.x += state.width;\n                }\n                const vertical = state.style.verticalLabelPosition != null\n                    ? state.style.verticalLabelPosition\n                    : 'middle';\n                if (vertical === 'top') {\n                    result.y -= state.height;\n                }\n                else if (vertical === 'bottom') {\n                    result.y += state.height;\n                }\n            }\n        }\n        return new Rectangle(Math.round(result.x), Math.round(result.y), Math.round(result.width), Math.round(result.height));\n    }\n    /**\n     * Returns the initial label value to be used of the label of the given\n     * cell is empty. This label is displayed and cleared on the first keystroke.\n     * This implementation returns <emptyLabelText>.\n     *\n     * @param cell <Cell> for which a text for an empty editing box should be\n     * returned.\n     */\n    getEmptyLabelText(cell = null) {\n        return this.emptyLabelText ?? '';\n    }\n    /**\n     * Returns the cell that is currently being edited or null if no cell is\n     * being edited.\n     */\n    getEditingCell() {\n        return this.editingCell;\n    }\n    /**\n     * Destroys the editor and removes all associated resources.\n     */\n    onDestroy() {\n        if (this.textarea) {\n            InternalEvent.release(this.textarea);\n            if (this.textarea.parentNode) {\n                this.textarea.parentNode.removeChild(this.textarea);\n            }\n            this.textarea = null;\n        }\n        this.graph.getDataModel().removeListener(this.changeHandler);\n        this.graph.getView().removeListener(this.zoomHandler);\n    }\n}\nCellEditorHandler.pluginId = 'CellEditorHandler';\nexport default CellEditorHandler;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,QAAQ,QAAQ,kBAAkB;AAC3C,SAASC,mBAAmB,EAAEC,gBAAgB,QAAQ,uBAAuB;AAC7E,OAAOC,SAAS,MAAM,uBAAuB;AAC7C,OAAOC,aAAa,MAAM,wBAAwB;AAClD,OAAOC,MAAM,MAAM,cAAc;AACjC,SAASC,oBAAoB,EAAEC,KAAK,EAAEC,kBAAkB,EAAEC,gBAAgB,EAAEC,sBAAsB,EAAEC,OAAO,EAAEC,IAAI,EAAEC,WAAW,EAAEC,IAAI,EAAEC,SAAS,QAAS,sBAAsB;AAC9K,OAAOC,SAAS,MAAM,4BAA4B;AAClD,SAASC,cAAc,EAAEC,yBAAyB,EAAEC,MAAM,QAAQ,qBAAqB;AACvF,SAASC,cAAc,EAAEC,YAAY,EAAEC,uBAAuB,QAAS,wBAAwB;AAC/F,SAASC,SAAS,EAAEC,UAAU,EAAEC,aAAa,EAAEC,UAAU,EAAEC,WAAW,QAAS,uBAAuB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,iBAAiB,CAAC;EACpBC,WAAWA,CAACC,KAAK,EAAE;IACf,IAAI,CAACC,aAAa,GAAG,KAAK;IAC1B,IAAI,CAACC,MAA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}