{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Translations from '../../util/Translations';\nimport { isNode } from '../../util/domUtils';\n/**\n * @class Multiplicity\n *\n * Defines invalid connections along with the error messages that they produce.\n * To add or remove rules on a graph, you must add/remove instances of this\n * class to {@link graph.multiplicities}.\n *\n * ### Example\n *\n * ```javascript\n * graph.multiplicities.push(new mxMultiplicity(\n *   true, 'rectangle', null, null, 0, 2, ['circle'],\n *   'Only 2 targets allowed',\n *   'Only circle targets allowed'));\n * ```\n *\n * Defines a rule where each rectangle must be connected to no more than 2\n * circles and no other types of targets are allowed.\n */\nclass Multiplicity {\n  constructor(source, type, attr, value, min, max, validNeighbors, countError, typeError, validNeighborsAllowed = true) {\n    /**\n     * Boolean indicating if the list of validNeighbors are those that are allowed\n     * for this rule or those that are not allowed for this rule.\n     */\n    this.validNeighborsAllowed = true;\n    this.source = source;\n    this.type = type;\n    this.attr = attr;\n    this.value = value;\n    this.min = min != null ? min : 0;\n    this.max = max != null ? max : 'n';\n    this.validNeighbors = validNeighbors;\n    this.countError = Translations.get(countError) || countError;\n    this.typeError = Translations.get(typeError) || typeError;\n    this.validNeighborsAllowed = validNeighborsAllowed;\n  }\n  /**\n   * Checks the multiplicity for the given arguments and returns the error\n   * for the given connection or null if the multiplicity does not apply.\n   *\n   * @param graph Reference to the enclosing {@link graph} instance.\n   * @param edge {@link mxCell} that represents the edge to validate.\n   * @param source {@link mxCell} that represents the source terminal.\n   * @param target {@link mxCell} that represents the target terminal.\n   * @param sourceOut Number of outgoing edges from the source terminal.\n   * @param targetIn Number of incoming edges for the target terminal.\n   */\n  check(graph, edge, source, target, sourceOut, targetIn) {\n    let error = '';\n    if (this.source && this.checkTerminal(graph, source, edge) || !this.source && this.checkTerminal(graph, target, edge)) {\n      if (this.countError != null && (this.source && (this.max === 0 || sourceOut >= this.max) || !this.source && (this.max === 0 || targetIn >= this.max))) {\n        error += `${this.countError}\\n`;\n      }\n      if (this.validNeighbors != null && this.typeError != null && this.validNeighbors.length > 0) {\n        const isValid = this.checkNeighbors(graph, edge, source, target);\n        if (!isValid) {\n          error += `${this.typeError}\\n`;\n        }\n      }\n    }\n    return error.length > 0 ? error : null;\n  }\n  /**\n   * Checks if there are any valid neighbours in {@link validNeighbors}. This is only\n   * called if {@link validNeighbors} is a non-empty array.\n   */\n  checkNeighbors(graph, edge, source, target) {\n    const sourceValue = source.getValue();\n    const targetValue = target.getValue();\n    let isValid = !this.validNeighborsAllowed;\n    const valid = this.validNeighbors;\n    for (let j = 0; j < valid.length; j++) {\n      if (this.source && this.checkType(graph, targetValue, valid[j])) {\n        isValid = this.validNeighborsAllowed;\n        break;\n      } else if (!this.source && this.checkType(graph, sourceValue, valid[j])) {\n        isValid = this.validNeighborsAllowed;\n        break;\n      }\n    }\n    return isValid;\n  }\n  /**\n   * Checks the given terminal cell and returns true if this rule applies. The\n   * given cell is the source or target of the given edge, depending on\n   * {@link source}. This implementation uses {@link checkType} on the terminal's value.\n   */\n  checkTerminal(graph, edge, terminal) {\n    const value = terminal.getValue();\n    return this.checkType(graph, value, this.type, this.attr, this.value);\n  }\n  /**\n   * Checks the type of the given value.\n   */\n  checkType(graph, value, type, attr, attrValue) {\n    if (value != null) {\n      if (typeof value !== 'string' && 'nodeType' in value && !Number.isNaN(value.nodeType)) {\n        // Checks if value is a DOM node\n        return isNode(value, type, attr, attrValue);\n      }\n      return value === type;\n    }\n    return false;\n  }\n}\nexport default Multiplicity;","map":{"version":3,"names":["Translations","isNode","Multiplicity","constructor","source","type","attr","value","min","max","validNeighbors","countError","typeError","validNeighborsAllowed","get","check","graph","edge","target","sourceOut","targetIn","error","checkTerminal","length","isValid","checkNeighbors","sourceValue","getValue","targetValue","valid","j","checkType","terminal","attrValue","Number","isNaN","nodeType"],"sources":["D:/OSPanel/domains/react/react-intro-main/node_modules/@maxgraph/core/dist/view/other/Multiplicity.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Translations from '../../util/Translations';\nimport { isNode } from '../../util/domUtils';\n/**\n * @class Multiplicity\n *\n * Defines invalid connections along with the error messages that they produce.\n * To add or remove rules on a graph, you must add/remove instances of this\n * class to {@link graph.multiplicities}.\n *\n * ### Example\n *\n * ```javascript\n * graph.multiplicities.push(new mxMultiplicity(\n *   true, 'rectangle', null, null, 0, 2, ['circle'],\n *   'Only 2 targets allowed',\n *   'Only circle targets allowed'));\n * ```\n *\n * Defines a rule where each rectangle must be connected to no more than 2\n * circles and no other types of targets are allowed.\n */\nclass Multiplicity {\n    constructor(source, type, attr, value, min, max, validNeighbors, countError, typeError, validNeighborsAllowed = true) {\n        /**\n         * Boolean indicating if the list of validNeighbors are those that are allowed\n         * for this rule or those that are not allowed for this rule.\n         */\n        this.validNeighborsAllowed = true;\n        this.source = source;\n        this.type = type;\n        this.attr = attr;\n        this.value = value;\n        this.min = min != null ? min : 0;\n        this.max = max != null ? max : 'n';\n        this.validNeighbors = validNeighbors;\n        this.countError = Translations.get(countError) || countError;\n        this.typeError = Translations.get(typeError) || typeError;\n        this.validNeighborsAllowed = validNeighborsAllowed;\n    }\n    /**\n     * Checks the multiplicity for the given arguments and returns the error\n     * for the given connection or null if the multiplicity does not apply.\n     *\n     * @param graph Reference to the enclosing {@link graph} instance.\n     * @param edge {@link mxCell} that represents the edge to validate.\n     * @param source {@link mxCell} that represents the source terminal.\n     * @param target {@link mxCell} that represents the target terminal.\n     * @param sourceOut Number of outgoing edges from the source terminal.\n     * @param targetIn Number of incoming edges for the target terminal.\n     */\n    check(graph, edge, source, target, sourceOut, targetIn) {\n        let error = '';\n        if ((this.source && this.checkTerminal(graph, source, edge)) ||\n            (!this.source && this.checkTerminal(graph, target, edge))) {\n            if (this.countError != null &&\n                ((this.source && (this.max === 0 || sourceOut >= this.max)) ||\n                    (!this.source && (this.max === 0 || targetIn >= this.max)))) {\n                error += `${this.countError}\\n`;\n            }\n            if (this.validNeighbors != null &&\n                this.typeError != null &&\n                this.validNeighbors.length > 0) {\n                const isValid = this.checkNeighbors(graph, edge, source, target);\n                if (!isValid) {\n                    error += `${this.typeError}\\n`;\n                }\n            }\n        }\n        return error.length > 0 ? error : null;\n    }\n    /**\n     * Checks if there are any valid neighbours in {@link validNeighbors}. This is only\n     * called if {@link validNeighbors} is a non-empty array.\n     */\n    checkNeighbors(graph, edge, source, target) {\n        const sourceValue = source.getValue();\n        const targetValue = target.getValue();\n        let isValid = !this.validNeighborsAllowed;\n        const valid = this.validNeighbors;\n        for (let j = 0; j < valid.length; j++) {\n            if (this.source && this.checkType(graph, targetValue, valid[j])) {\n                isValid = this.validNeighborsAllowed;\n                break;\n            }\n            else if (!this.source && this.checkType(graph, sourceValue, valid[j])) {\n                isValid = this.validNeighborsAllowed;\n                break;\n            }\n        }\n        return isValid;\n    }\n    /**\n     * Checks the given terminal cell and returns true if this rule applies. The\n     * given cell is the source or target of the given edge, depending on\n     * {@link source}. This implementation uses {@link checkType} on the terminal's value.\n     */\n    checkTerminal(graph, edge, terminal) {\n        const value = terminal.getValue();\n        return this.checkType(graph, value, this.type, this.attr, this.value);\n    }\n    /**\n     * Checks the type of the given value.\n     */\n    checkType(graph, value, type, attr, attrValue) {\n        if (value != null) {\n            if (typeof value !== 'string' &&\n                'nodeType' in value &&\n                !Number.isNaN(value.nodeType)) {\n                // Checks if value is a DOM node\n                return isNode(value, type, attr, attrValue);\n            }\n            return value === type;\n        }\n        return false;\n    }\n}\nexport default Multiplicity;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}