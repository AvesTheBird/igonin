{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Dictionary from '../../util/Dictionary';\nimport { mixInto } from '../../util/Utils';\nimport { removeDuplicates } from '../../util/arrayUtils';\nimport { findNearestSegment } from '../../util/mathUtils';\nimport { Graph } from '../Graph';\nimport Cell from '../cell/Cell';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport Geometry from '../geometry/Geometry';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst EdgeMixin = {\n  resetEdgesOnResize: false,\n  isResetEdgesOnResize() {\n    return this.resetEdgesOnResize;\n  },\n  resetEdgesOnMove: false,\n  isResetEdgesOnMove() {\n    return this.resetEdgesOnMove;\n  },\n  resetEdgesOnConnect: true,\n  isResetEdgesOnConnect() {\n    return this.resetEdgesOnConnect;\n  },\n  connectableEdges: false,\n  allowDanglingEdges: true,\n  cloneInvalidEdges: false,\n  alternateEdgeStyle: {},\n  edgeLabelsMovable: true,\n  // ***************************************************************************\n  // Group: Graph Behaviour\n  // ***************************************************************************\n  isEdgeLabelsMovable() {\n    return this.edgeLabelsMovable;\n  },\n  setEdgeLabelsMovable(value) {\n    this.edgeLabelsMovable = value;\n  },\n  setAllowDanglingEdges(value) {\n    this.allowDanglingEdges = value;\n  },\n  isAllowDanglingEdges() {\n    return this.allowDanglingEdges;\n  },\n  setConnectableEdges(value) {\n    this.connectableEdges = value;\n  },\n  isConnectableEdges() {\n    return this.connectableEdges;\n  },\n  setCloneInvalidEdges(value) {\n    this.cloneInvalidEdges = value;\n  },\n  isCloneInvalidEdges() {\n    return this.cloneInvalidEdges;\n  },\n  // ***************************************************************************\n  // Group: Cell alignment and orientation\n  // ***************************************************************************\n  flipEdge(edge) {\n    if (this.alternateEdgeStyle) {\n      this.batchUpdate(() => {\n        const style = edge.getStyle();\n        if (Object.keys(style).length) {\n          this.getDataModel().setStyle(edge, this.alternateEdgeStyle);\n        } else {\n          this.getDataModel().setStyle(edge, {});\n        }\n        // Removes all existing control points\n        this.resetEdge(edge);\n        this.fireEvent(new EventObject(InternalEvent.FLIP_EDGE, {\n          edge\n        }));\n      });\n    }\n    return edge;\n  },\n  splitEdge(edge, cells, newEdge, dx = 0, dy = 0, x, y, parent = null) {\n    parent = parent ?? edge.getParent();\n    const source = edge.getTerminal(true);\n    this.batchUpdate(() => {\n      if (!newEdge) {\n        newEdge = this.cloneCell(edge);\n        // Removes waypoints before/after new cell\n        const state = this.getView().getState(edge);\n        let geo = newEdge.getGeometry();\n        if (geo && state) {\n          const t = this.getView().translate;\n          const s = this.getView().scale;\n          const idx = findNearestSegment(state, (dx + t.x) * s, (dy + t.y) * s);\n          geo.points = geo.points.slice(0, idx);\n          geo = edge.getGeometry();\n          if (geo) {\n            geo = geo.clone();\n            geo.points = geo.points.slice(idx);\n            this.getDataModel().setGeometry(edge, geo);\n          }\n        }\n      }\n      this.cellsMoved(cells, dx, dy, false, false);\n      this.cellsAdded(cells, parent, parent ? parent.getChildCount() : 0, null, null, true);\n      this.cellsAdded([newEdge], parent, parent ? parent.getChildCount() : 0, source, cells[0], false);\n      this.cellConnected(edge, cells[0], true);\n      this.fireEvent(new EventObject(InternalEvent.SPLIT_EDGE, {\n        edge,\n        cells,\n        newEdge,\n        dx,\n        dy\n      }));\n    });\n    return newEdge;\n  },\n  insertEdge(...args) {\n    let parent;\n    let id;\n    let value;\n    let source;\n    let target;\n    let style;\n    if (args.length === 1 && typeof args[0] === 'object') {\n      const params = args[0];\n      parent = params.parent;\n      id = params.id;\n      value = params.value;\n      source = params.source;\n      target = params.target;\n      style = params.style;\n    } else {\n      // otherwise treat as individual arguments\n      [parent, id, value, source, target, style] = args;\n    }\n    const edge = this.createEdge(parent, id, value, source, target, style);\n    return this.addEdge(edge, parent, source, target);\n  },\n  createEdge(parent = null, id, value, source = null, target = null, style = {}) {\n    // Creates the edge\n    const edge = new Cell(value, new Geometry(), style);\n    edge.setId(id);\n    edge.setEdge(true);\n    edge.geometry.relative = true;\n    return edge;\n  },\n  addEdge(edge, parent = null, source = null, target = null, index = null) {\n    return this.addCell(edge, parent, index, source, target);\n  },\n  // ***************************************************************************\n  // Group: Folding\n  // ***************************************************************************\n  addAllEdges(cells) {\n    const allCells = cells.slice();\n    return removeDuplicates(allCells.concat(this.getAllEdges(cells)));\n  },\n  getAllEdges(cells) {\n    let edges = [];\n    if (cells) {\n      for (let i = 0; i < cells.length; i += 1) {\n        const edgeCount = cells[i].getEdgeCount();\n        for (let j = 0; j < edgeCount; j++) {\n          edges.push(cells[i].getEdgeAt(j));\n        }\n        // Recurses\n        const children = cells[i].getChildren();\n        edges = edges.concat(this.getAllEdges(children));\n      }\n    }\n    return edges;\n  },\n  getIncomingEdges(cell, parent = null) {\n    return this.getEdges(cell, parent, true, false, false);\n  },\n  getOutgoingEdges(cell, parent = null) {\n    return this.getEdges(cell, parent, false, true, false);\n  },\n  getEdges(cell, parent = null, incoming = true, outgoing = true, includeLoops = true, recurse = false) {\n    let edges = [];\n    const isCollapsed = cell.isCollapsed();\n    const childCount = cell.getChildCount();\n    for (let i = 0; i < childCount; i += 1) {\n      const child = cell.getChildAt(i);\n      if (isCollapsed || !child.isVisible()) {\n        edges = edges.concat(child.getEdges(incoming, outgoing));\n      }\n    }\n    edges = edges.concat(cell.getEdges(incoming, outgoing));\n    const result = [];\n    for (let i = 0; i < edges.length; i += 1) {\n      const state = this.getView().getState(edges[i]);\n      const source = state ? state.getVisibleTerminal(true) : this.getView().getVisibleTerminal(edges[i], true);\n      const target = state ? state.getVisibleTerminal(false) : this.getView().getVisibleTerminal(edges[i], false);\n      if (includeLoops && source === target || source !== target && (incoming && target === cell && (!parent || this.isValidAncestor(source, parent, recurse)) || outgoing && source === cell && (!parent || this.isValidAncestor(target, parent, recurse)))) {\n        result.push(edges[i]);\n      }\n    }\n    return result;\n  },\n  // ***************************************************************************\n  // Group: Cell retrieval\n  // ***************************************************************************\n  getChildEdges(parent) {\n    return this.getChildCells(parent, false, true);\n  },\n  getEdgesBetween(source, target, directed = false) {\n    const edges = this.getEdges(source);\n    const result = [];\n    // Checks if the edge is connected to the correct\n    // cell and returns the first match\n    for (let i = 0; i < edges.length; i += 1) {\n      const state = this.getView().getState(edges[i]);\n      const src = state ? state.getVisibleTerminal(true) : this.getView().getVisibleTerminal(edges[i], true);\n      const trg = state ? state.getVisibleTerminal(false) : this.getView().getVisibleTerminal(edges[i], false);\n      if (src === source && trg === target || !directed && src === target && trg === source) {\n        result.push(edges[i]);\n      }\n    }\n    return result;\n  },\n  // ***************************************************************************\n  // Group: Cell moving\n  // ***************************************************************************\n  resetEdges(cells) {\n    // Prepares faster cells lookup\n    const dict = new Dictionary();\n    for (let i = 0; i < cells.length; i += 1) {\n      dict.put(cells[i], true);\n    }\n    this.batchUpdate(() => {\n      for (let i = 0; i < cells.length; i += 1) {\n        const edges = cells[i].getEdges();\n        for (let j = 0; j < edges.length; j++) {\n          const state = this.getView().getState(edges[j]);\n          const source = state ? state.getVisibleTerminal(true) : this.getView().getVisibleTerminal(edges[j], true);\n          const target = state ? state.getVisibleTerminal(false) : this.getView().getVisibleTerminal(edges[j], false);\n          // Checks if one of the terminals is not in the given array\n          if (!dict.get(source) || !dict.get(target)) {\n            this.resetEdge(edges[j]);\n          }\n        }\n        this.resetEdges(cells[i].getChildren());\n      }\n    });\n  },\n  resetEdge(edge) {\n    let geo = edge.getGeometry();\n    // Resets the control points\n    if (geo && geo.points && geo.points.length > 0) {\n      geo = geo.clone();\n      geo.points = [];\n      this.getDataModel().setGeometry(edge, geo);\n    }\n    return edge;\n  }\n};\nmixInto(Graph)(EdgeMixin);","map":{"version":3,"names":["Dictionary","mixInto","removeDuplicates","findNearestSegment","Graph","Cell","EventObject","InternalEvent","Geometry","EdgeMixin","resetEdgesOnResize","isResetEdgesOnResize","resetEdgesOnMove","isResetEdgesOnMove","resetEdgesOnConnect","isResetEdgesOnConnect","connectableEdges","allowDanglingEdges","cloneInvalidEdges","alternateEdgeStyle","edgeLabelsMovable","isEdgeLabelsMovable","setEdgeLabelsMovable","value","setAllowDanglingEdges","isAllowDanglingEdges","setConnectableEdges","isConnectableEdges","setCloneInvalidEdges","isCloneInvalidEdges","flipEdge","edge","batchUpdate","style","getStyle","Object","keys","length","getDataModel","setStyle","resetEdge","fireEvent","FLIP_EDGE","splitEdge","cells","newEdge","dx","dy","x","y","parent","getParent","source","getTerminal","cloneCell","state","getView","getState","geo","getGeometry","t","translate","s","scale","idx","points","slice","clone","setGeometry","cellsMoved","cellsAdded","getChildCount","cellConnected","SPLIT_EDGE","insertEdge","args","id","target","params","createEdge","addEdge","setId","setEdge","geometry","relative","index","addCell","addAllEdges","allCells","concat","getAllEdges","edges","i","edgeCount","getEdgeCount","j","push","getEdgeAt","children","getChildren","getIncomingEdges","cell","getEdges","getOutgoingEdges","incoming","outgoing","includeLoops","recurse","isCollapsed","childCount","child","getChildAt","isVisible","result","getVisibleTerminal","isValidAncestor","getChildEdges","getChildCells","getEdgesBetween","directed","src","trg","resetEdges","dict","put","get"],"sources":["D:/ospanel/domains/old/react/react-intro-main/node_modules/@maxgraph/core/dist/view/mixins/EdgeMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Dictionary from '../../util/Dictionary';\nimport { mixInto } from '../../util/Utils';\nimport { removeDuplicates } from '../../util/arrayUtils';\nimport { findNearestSegment } from '../../util/mathUtils';\nimport { Graph } from '../Graph';\nimport Cell from '../cell/Cell';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport Geometry from '../geometry/Geometry';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst EdgeMixin = {\n    resetEdgesOnResize: false,\n    isResetEdgesOnResize() {\n        return this.resetEdgesOnResize;\n    },\n    resetEdgesOnMove: false,\n    isResetEdgesOnMove() {\n        return this.resetEdgesOnMove;\n    },\n    resetEdgesOnConnect: true,\n    isResetEdgesOnConnect() {\n        return this.resetEdgesOnConnect;\n    },\n    connectableEdges: false,\n    allowDanglingEdges: true,\n    cloneInvalidEdges: false,\n    alternateEdgeStyle: {},\n    edgeLabelsMovable: true,\n    // ***************************************************************************\n    // Group: Graph Behaviour\n    // ***************************************************************************\n    isEdgeLabelsMovable() {\n        return this.edgeLabelsMovable;\n    },\n    setEdgeLabelsMovable(value) {\n        this.edgeLabelsMovable = value;\n    },\n    setAllowDanglingEdges(value) {\n        this.allowDanglingEdges = value;\n    },\n    isAllowDanglingEdges() {\n        return this.allowDanglingEdges;\n    },\n    setConnectableEdges(value) {\n        this.connectableEdges = value;\n    },\n    isConnectableEdges() {\n        return this.connectableEdges;\n    },\n    setCloneInvalidEdges(value) {\n        this.cloneInvalidEdges = value;\n    },\n    isCloneInvalidEdges() {\n        return this.cloneInvalidEdges;\n    },\n    // ***************************************************************************\n    // Group: Cell alignment and orientation\n    // ***************************************************************************\n    flipEdge(edge) {\n        if (this.alternateEdgeStyle) {\n            this.batchUpdate(() => {\n                const style = edge.getStyle();\n                if (Object.keys(style).length) {\n                    this.getDataModel().setStyle(edge, this.alternateEdgeStyle);\n                }\n                else {\n                    this.getDataModel().setStyle(edge, {});\n                }\n                // Removes all existing control points\n                this.resetEdge(edge);\n                this.fireEvent(new EventObject(InternalEvent.FLIP_EDGE, { edge }));\n            });\n        }\n        return edge;\n    },\n    splitEdge(edge, cells, newEdge, dx = 0, dy = 0, x, y, parent = null) {\n        parent = parent ?? edge.getParent();\n        const source = edge.getTerminal(true);\n        this.batchUpdate(() => {\n            if (!newEdge) {\n                newEdge = this.cloneCell(edge);\n                // Removes waypoints before/after new cell\n                const state = this.getView().getState(edge);\n                let geo = newEdge.getGeometry();\n                if (geo && state) {\n                    const t = this.getView().translate;\n                    const s = this.getView().scale;\n                    const idx = findNearestSegment(state, (dx + t.x) * s, (dy + t.y) * s);\n                    geo.points = geo.points.slice(0, idx);\n                    geo = edge.getGeometry();\n                    if (geo) {\n                        geo = geo.clone();\n                        geo.points = geo.points.slice(idx);\n                        this.getDataModel().setGeometry(edge, geo);\n                    }\n                }\n            }\n            this.cellsMoved(cells, dx, dy, false, false);\n            this.cellsAdded(cells, parent, parent ? parent.getChildCount() : 0, null, null, true);\n            this.cellsAdded([newEdge], parent, parent ? parent.getChildCount() : 0, source, cells[0], false);\n            this.cellConnected(edge, cells[0], true);\n            this.fireEvent(new EventObject(InternalEvent.SPLIT_EDGE, { edge, cells, newEdge, dx, dy }));\n        });\n        return newEdge;\n    },\n    insertEdge(...args) {\n        let parent;\n        let id;\n        let value;\n        let source;\n        let target;\n        let style;\n        if (args.length === 1 && typeof args[0] === 'object') {\n            const params = args[0];\n            parent = params.parent;\n            id = params.id;\n            value = params.value;\n            source = params.source;\n            target = params.target;\n            style = params.style;\n        }\n        else {\n            // otherwise treat as individual arguments\n            [parent, id, value, source, target, style] = args;\n        }\n        const edge = this.createEdge(parent, id, value, source, target, style);\n        return this.addEdge(edge, parent, source, target);\n    },\n    createEdge(parent = null, id, value, source = null, target = null, style = {}) {\n        // Creates the edge\n        const edge = new Cell(value, new Geometry(), style);\n        edge.setId(id);\n        edge.setEdge(true);\n        edge.geometry.relative = true;\n        return edge;\n    },\n    addEdge(edge, parent = null, source = null, target = null, index = null) {\n        return this.addCell(edge, parent, index, source, target);\n    },\n    // ***************************************************************************\n    // Group: Folding\n    // ***************************************************************************\n    addAllEdges(cells) {\n        const allCells = cells.slice();\n        return removeDuplicates(allCells.concat(this.getAllEdges(cells)));\n    },\n    getAllEdges(cells) {\n        let edges = [];\n        if (cells) {\n            for (let i = 0; i < cells.length; i += 1) {\n                const edgeCount = cells[i].getEdgeCount();\n                for (let j = 0; j < edgeCount; j++) {\n                    edges.push(cells[i].getEdgeAt(j));\n                }\n                // Recurses\n                const children = cells[i].getChildren();\n                edges = edges.concat(this.getAllEdges(children));\n            }\n        }\n        return edges;\n    },\n    getIncomingEdges(cell, parent = null) {\n        return this.getEdges(cell, parent, true, false, false);\n    },\n    getOutgoingEdges(cell, parent = null) {\n        return this.getEdges(cell, parent, false, true, false);\n    },\n    getEdges(cell, parent = null, incoming = true, outgoing = true, includeLoops = true, recurse = false) {\n        let edges = [];\n        const isCollapsed = cell.isCollapsed();\n        const childCount = cell.getChildCount();\n        for (let i = 0; i < childCount; i += 1) {\n            const child = cell.getChildAt(i);\n            if (isCollapsed || !child.isVisible()) {\n                edges = edges.concat(child.getEdges(incoming, outgoing));\n            }\n        }\n        edges = edges.concat(cell.getEdges(incoming, outgoing));\n        const result = [];\n        for (let i = 0; i < edges.length; i += 1) {\n            const state = this.getView().getState(edges[i]);\n            const source = state\n                ? state.getVisibleTerminal(true)\n                : this.getView().getVisibleTerminal(edges[i], true);\n            const target = state\n                ? state.getVisibleTerminal(false)\n                : this.getView().getVisibleTerminal(edges[i], false);\n            if ((includeLoops && source === target) ||\n                (source !== target &&\n                    ((incoming &&\n                        target === cell &&\n                        (!parent || this.isValidAncestor(source, parent, recurse))) ||\n                        (outgoing &&\n                            source === cell &&\n                            (!parent || this.isValidAncestor(target, parent, recurse)))))) {\n                result.push(edges[i]);\n            }\n        }\n        return result;\n    },\n    // ***************************************************************************\n    // Group: Cell retrieval\n    // ***************************************************************************\n    getChildEdges(parent) {\n        return this.getChildCells(parent, false, true);\n    },\n    getEdgesBetween(source, target, directed = false) {\n        const edges = this.getEdges(source);\n        const result = [];\n        // Checks if the edge is connected to the correct\n        // cell and returns the first match\n        for (let i = 0; i < edges.length; i += 1) {\n            const state = this.getView().getState(edges[i]);\n            const src = state\n                ? state.getVisibleTerminal(true)\n                : this.getView().getVisibleTerminal(edges[i], true);\n            const trg = state\n                ? state.getVisibleTerminal(false)\n                : this.getView().getVisibleTerminal(edges[i], false);\n            if ((src === source && trg === target) ||\n                (!directed && src === target && trg === source)) {\n                result.push(edges[i]);\n            }\n        }\n        return result;\n    },\n    // ***************************************************************************\n    // Group: Cell moving\n    // ***************************************************************************\n    resetEdges(cells) {\n        // Prepares faster cells lookup\n        const dict = new Dictionary();\n        for (let i = 0; i < cells.length; i += 1) {\n            dict.put(cells[i], true);\n        }\n        this.batchUpdate(() => {\n            for (let i = 0; i < cells.length; i += 1) {\n                const edges = cells[i].getEdges();\n                for (let j = 0; j < edges.length; j++) {\n                    const state = this.getView().getState(edges[j]);\n                    const source = state\n                        ? state.getVisibleTerminal(true)\n                        : this.getView().getVisibleTerminal(edges[j], true);\n                    const target = state\n                        ? state.getVisibleTerminal(false)\n                        : this.getView().getVisibleTerminal(edges[j], false);\n                    // Checks if one of the terminals is not in the given array\n                    if (!dict.get(source) || !dict.get(target)) {\n                        this.resetEdge(edges[j]);\n                    }\n                }\n                this.resetEdges(cells[i].getChildren());\n            }\n        });\n    },\n    resetEdge(edge) {\n        let geo = edge.getGeometry();\n        // Resets the control points\n        if (geo && geo.points && geo.points.length > 0) {\n            geo = geo.clone();\n            geo.points = [];\n            this.getDataModel().setGeometry(edge, geo);\n        }\n        return edge;\n    },\n};\nmixInto(Graph)(EdgeMixin);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}