{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from './geometry/Point';\nimport Rectangle from './geometry/Rectangle';\nimport Dictionary from '../util/Dictionary';\nimport EventSource from './event/EventSource';\nimport EventObject from './event/EventObject';\nimport RectangleShape from './geometry/node/RectangleShape';\nimport { ALIGN } from '../util/Constants';\nimport Client from '../Client';\nimport InternalEvent from './event/InternalEvent';\nimport { convertPoint, getCurrentStyle, getOffset } from '../util/styleUtils';\nimport { getRotatedPoint, ptSegDistSq, relativeCcw, toRadians } from '../util/mathUtils';\nimport MaxLog from '../gui/MaxLog';\nimport Translations from '../util/Translations';\nimport CellState from './cell/CellState';\nimport UndoableEdit from './undoable_changes/UndoableEdit';\nimport ImageShape from './geometry/node/ImageShape';\nimport InternalMouseEvent from './event/InternalMouseEvent';\nimport CurrentRootChange from './undoable_changes/CurrentRootChange';\nimport { getClientX, getClientY, getSource, isConsumed } from '../util/EventUtils';\nimport { clone } from '../util/cloneUtils';\nimport StyleRegistry from './style/StyleRegistry';\n/**\n * @class GraphView\n * @extends {EventSource}\n *\n * Extends {@link EventSource} to implement a view for a graph. This class is in\n * charge of computing the absolute coordinates for the relative child\n * geometries, the points for perimeters and edge styles and keeping them\n * cached in {@link CellState}s for faster retrieval. The states are updated\n * whenever the model or the view state (translate, scale) changes. The scale\n * and translate are honoured in the bounds.\n *\n * #### Event: mxEvent.UNDO\n *\n * Fires after the root was changed in {@link setCurrentRoot}. The `edit`\n * property contains the {@link UndoableEdit} which contains the\n * {@link CurrentRootChange}.\n *\n * #### Event: mxEvent.SCALE_AND_TRANSLATE\n *\n * Fires after the scale and translate have been changed in {@link scaleAndTranslate}.\n * The `scale`, `previousScale`, `translate`\n * and `previousTranslate` properties contain the new and previous\n * scale and translate, respectively.\n *\n * #### Event: mxEvent.SCALE\n *\n * Fires after the scale was changed in {@link setScale}. The `scale` and\n * `previousScale` properties contain the new and previous scale.\n *\n * #### Event: mxEvent.TRANSLATE\n *\n * Fires after the translate was changed in {@link setTranslate}. The\n * `translate` and `previousTranslate` properties contain\n * the new and previous value for translate.\n *\n * #### Event: mxEvent.DOWN and mxEvent.UP\n *\n * Fire if the current root is changed by executing an {@link CurrentRootChange}.\n * The event name depends on the location of the root in the cell hierarchy\n * with respect to the current root. The `root` and\n * `previous` properties contain the new and previous root,\n * respectively.\n */\nexport class GraphView extends EventSource {\n  constructor(graph) {\n    super();\n    // TODO: Document me!\n    this.backgroundImage = null;\n    this.backgroundPageShape = null;\n    this.EMPTY_POINT = new Point();\n    /**\n     * Specifies the resource key for the status message after a long operation.\n     * If the resource for this key does not exist then the value is used as\n     * the status message. Default is 'done'.\n     */\n    this.doneResource = Client.language !== 'none' ? 'done' : '';\n    /**\n     * Specifies the resource key for the status message while the document is\n     * being updated. If the resource for this key does not exist then the\n     * value is used as the status message. Default is 'updatingDocument'.\n     */\n    this.updatingDocumentResource = Client.language !== 'none' ? 'updatingDocument' : '';\n    /**\n     * Specifies if string values in cell styles should be evaluated using\n     * {@link eval}. This will only be used if the string values can't be mapped\n     * to objects using {@link StyleRegistry}. Default is false. NOTE: Enabling this\n     * switch carries a possible security risk.\n     */\n    this.allowEval = false;\n    /**\n     * Specifies if a gesture should be captured when it goes outside of the\n     * graph container. Default is true.\n     */\n    this.captureDocumentGesture = true;\n    /**\n     * Specifies if shapes should be created, updated and destroyed using the\n     * methods of {@link cellRenderer} in {@link graph}. Default is true.\n     */\n    this.rendering = true;\n    /**\n     * {@link Cell} that acts as the root of the displayed cell hierarchy.\n     */\n    this.currentRoot = null;\n    this.graphBounds = new Rectangle();\n    this.scale = 1;\n    /**\n     * {@link Point} that specifies the current translation. Default is a new\n     * empty {@link Point}.\n     */\n    this.translate = new Point();\n    this.states = new Dictionary();\n    /**\n     * Specifies if the style should be updated in each validation step. If this\n     * is false then the style is only updated if the state is created or if the\n     * style of the cell was changed. Default is false.\n     */\n    this.updateStyle = false;\n    /**\n     * During validation, this contains the last DOM node that was processed.\n     */\n    this.lastNode = null;\n    /**\n     * During validation, this contains the last HTML DOM node that was processed.\n     */\n    this.lastHtmlNode = null;\n    /**\n     * During validation, this contains the last edge's DOM node that was processed.\n     */\n    this.lastForegroundNode = null;\n    /**\n     * During validation, this contains the last edge HTML DOM node that was processed.\n     */\n    this.lastForegroundHtmlNode = null;\n    this.endHandler = null;\n    this.moveHandler = null;\n    this.graph = graph;\n  }\n  /**\n   * Returns {@link graphBounds}.\n   */\n  getGraphBounds() {\n    return this.graphBounds;\n  }\n  /**\n   * Sets {@link graphBounds}.\n   */\n  setGraphBounds(value) {\n    this.graphBounds = value;\n  }\n  /**\n   * Returns the {@link scale}.\n   */\n  getScale() {\n    return this.scale;\n  }\n  /**\n   * Sets the scale and fires a {@link scale} event before calling {@link revalidate} followed\n   * by {@link graph.sizeDidChange}.\n   *\n   * @param value Decimal value that specifies the new scale (1 is 100%).\n   */\n  setScale(value) {\n    const previousScale = this.scale;\n    if (previousScale !== value) {\n      this.scale = value;\n      if (this.isEventsEnabled()) {\n        this.viewStateChanged();\n      }\n    }\n    this.fireEvent(new EventObject(InternalEvent.SCALE, {\n      scale: value,\n      previousScale\n    }));\n  }\n  /**\n   * Returns the {@link translate}.\n   */\n  getTranslate() {\n    return this.translate;\n  }\n  isRendering() {\n    return this.rendering;\n  }\n  setRendering(value) {\n    this.rendering = value;\n  }\n  /**\n   * Sets the translation and fires a {@link translate} event before calling\n   * {@link revalidate} followed by {@link graph.sizeDidChange}. The translation is the\n   * negative of the origin.\n   *\n   * @param dx X-coordinate of the translation.\n   * @param dy Y-coordinate of the translation.\n   */\n  setTranslate(dx, dy) {\n    const previousTranslate = new Point(this.translate.x, this.translate.y);\n    if (this.translate.x !== dx || this.translate.y !== dy) {\n      this.translate.x = dx;\n      this.translate.y = dy;\n      if (this.isEventsEnabled()) {\n        this.viewStateChanged();\n      }\n    }\n    this.fireEvent(new EventObject(InternalEvent.TRANSLATE, {\n      translate: this.translate,\n      previousTranslate: previousTranslate\n    }));\n  }\n  isAllowEval() {\n    return this.allowEval;\n  }\n  setAllowEval(value) {\n    this.allowEval = value;\n  }\n  /**\n   * Returns {@link states}.\n   */\n  getStates() {\n    return this.states;\n  }\n  /**\n   * Sets {@link states}.\n   */\n  setStates(value) {\n    this.states = value;\n  }\n  /**\n   * Returns the DOM node that contains the background-, draw- and\n   * overlay- and decoratorpanes.\n   */\n  getCanvas() {\n    return this.canvas;\n  }\n  /**\n   * Returns the DOM node that represents the background layer.\n   */\n  getBackgroundPane() {\n    return this.backgroundPane;\n  }\n  /**\n   * Returns the DOM node that represents the main drawing layer.\n   */\n  getDrawPane() {\n    return this.drawPane;\n  }\n  /**\n   * Returns the DOM node that represents the layer above the drawing layer.\n   */\n  getOverlayPane() {\n    return this.overlayPane;\n  }\n  /**\n   * Returns the DOM node that represents the topmost drawing layer.\n   */\n  getDecoratorPane() {\n    return this.decoratorPane;\n  }\n  /**\n   * Returns the union of all {@link mxCellStates} for the given array of {@link Cell}.\n   *\n   * @param cells Array of {@link Cell} whose bounds should be returned.\n   */\n  getBounds(cells) {\n    let result = null;\n    if (cells.length > 0) {\n      for (let i = 0; i < cells.length; i += 1) {\n        if (cells[i].isVertex() || cells[i].isEdge()) {\n          const state = this.getState(cells[i]);\n          if (state) {\n            if (!result) {\n              result = Rectangle.fromRectangle(state);\n            } else {\n              result.add(state);\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n  /**\n   * Sets and returns the current root and fires an {@link undo} event before\n   * calling {@link graph.sizeDidChange}.\n   *\n   * @param root {@link mxCell} that specifies the root of the displayed cell hierarchy.\n   */\n  setCurrentRoot(root) {\n    if (this.currentRoot !== root) {\n      const change = new CurrentRootChange(this, root);\n      change.execute();\n      const edit = new UndoableEdit(this, true);\n      edit.add(change);\n      this.fireEvent(new EventObject(InternalEvent.UNDO, {\n        edit\n      }));\n      this.graph.sizeDidChange();\n      this.currentRoot = root;\n    }\n    return root;\n  }\n  /**\n   * Sets the scale and translation and fires a {@link scale} and {@link translate} event\n   * before calling {@link revalidate} followed by {@link graph.sizeDidChange}.\n   *\n   * @param scale Decimal value that specifies the new scale (1 is 100%).\n   * @param dx X-coordinate of the translation.\n   * @param dy Y-coordinate of the translation.\n   */\n  scaleAndTranslate(scale, dx, dy) {\n    const previousScale = this.scale;\n    const previousTranslate = new Point(this.translate.x, this.translate.y);\n    if (this.scale !== scale || this.translate.x !== dx || this.translate.y !== dy) {\n      this.scale = scale;\n      this.translate.x = dx;\n      this.translate.y = dy;\n      if (this.isEventsEnabled()) {\n        this.viewStateChanged();\n      }\n    }\n    this.fireEvent(new EventObject(InternalEvent.SCALE_AND_TRANSLATE, {\n      scale,\n      previousScale,\n      translate: this.translate,\n      previousTranslate: previousTranslate\n    }));\n  }\n  /**\n   * Invoked after {@link scale} and/or {@link translate} has changed.\n   */\n  viewStateChanged() {\n    this.revalidate();\n    this.graph.sizeDidChange();\n  }\n  /**\n   * Clears the view if {@link currentRoot} is not null and revalidates.\n   */\n  refresh() {\n    if (this.currentRoot) {\n      this.clear();\n    }\n    this.revalidate();\n  }\n  /**\n   * Revalidates the complete view with all cell states.\n   */\n  revalidate() {\n    this.invalidate();\n    this.validate();\n  }\n  /**\n   * Removes the state of the given cell and all descendants if the given\n   * cell is not the current root.\n   *\n   * @param cell Optional {@link Cell} for which the state should be removed. Default\n   * is the root of the model.\n   * @param force Boolean indicating if the current root should be ignored for\n   * recursion.\n   */\n  clear(cell, force = false, recurse = true) {\n    if (!cell) {\n      cell = this.graph.getDataModel().getRoot();\n    }\n    if (cell) {\n      this.removeState(cell);\n      if (recurse && (force || cell !== this.currentRoot)) {\n        const childCount = cell.getChildCount();\n        for (let i = 0; i < childCount; i += 1) {\n          this.clear(cell.getChildAt(i), force);\n        }\n      } else {\n        this.invalidate(cell);\n      }\n    }\n  }\n  /**\n   * Invalidates the state of the given cell, all its descendants and\n   * connected edges.\n   *\n   * @param cell Optional {@link Cell} to be invalidated. Default is the root of the\n   * model.\n   */\n  invalidate(cell = null, recurse = true, includeEdges = true) {\n    const model = this.graph.getDataModel();\n    cell = cell ?? model.getRoot();\n    if (cell) {\n      const state = this.getState(cell);\n      if (state) {\n        state.invalid = true;\n      }\n      // Avoids infinite loops for invalid graphs\n      if (!cell.invalidating) {\n        cell.invalidating = true;\n        // Recursively invalidates all descendants\n        if (recurse) {\n          const childCount = cell.getChildCount();\n          for (let i = 0; i < childCount; i += 1) {\n            const child = cell.getChildAt(i);\n            this.invalidate(child, recurse, includeEdges);\n          }\n        }\n        // Propagates invalidation to all connected edges\n        if (includeEdges) {\n          const edgeCount = cell.getEdgeCount();\n          for (let i = 0; i < edgeCount; i += 1) {\n            this.invalidate(cell.getEdgeAt(i), recurse, includeEdges);\n          }\n        }\n        cell.invalidating = false;\n      }\n    }\n  }\n  /**\n   * Calls {@link validateCell} and {@link validateCellState} and updates the {@link graphBounds}\n   * using {@link getBoundingBox}. Finally the background is validated using\n   * {@link validateBackground}.\n   *\n   * @param cell Optional {@link Cell} to be used as the root of the validation.\n   * Default is {@link currentRoot} or the root of the model.\n   */\n  validate(cell = null) {\n    const t0 = MaxLog.enter('mxGraphView.validate');\n    window.status = Translations.get(this.updatingDocumentResource) || this.updatingDocumentResource;\n    this.resetValidationState();\n    const c = cell || (this.currentRoot ?? this.graph.getDataModel().getRoot());\n    if (c) {\n      const graphBounds = this.getBoundingBox(this.validateCellState(c ? this.validateCell(c) : null));\n      this.setGraphBounds(graphBounds ?? this.getEmptyBounds());\n      this.validateBackground();\n      this.resetValidationState();\n    }\n    window.status = Translations.get(this.doneResource) || this.doneResource;\n    MaxLog.leave('mxGraphView.validate', t0);\n  }\n  /**\n   * Returns the bounds for an empty graph. This returns a rectangle at\n   * {@link translate} with the size of 0 x 0.\n   */\n  getEmptyBounds() {\n    return new Rectangle(this.translate.x * this.scale, this.translate.y * this.scale);\n  }\n  /**\n   * Returns the bounding box of the shape and the label for the given\n   * {@link CellState} and its children if recurse is true.\n   *\n   * @param state {@link CellState} whose bounding box should be returned.\n   * @param recurse Optional boolean indicating if the children should be included.\n   * Default is true.\n   */\n  getBoundingBox(state = null, recurse = true) {\n    let bbox = null;\n    if (state) {\n      if (state.shape && state.shape.boundingBox) {\n        bbox = state.shape.boundingBox.clone();\n      }\n      // Adds label bounding box to graph bounds\n      if (state.text && state.text.boundingBox) {\n        if (bbox) {\n          bbox.add(state.text.boundingBox);\n        } else {\n          bbox = state.text.boundingBox.clone();\n        }\n      }\n      if (recurse) {\n        const childCount = state.cell.getChildCount();\n        for (let i = 0; i < childCount; i += 1) {\n          const bounds = this.getBoundingBox(this.getState(state.cell.getChildAt(i)));\n          if (bounds) {\n            if (!bbox) {\n              bbox = bounds;\n            } else {\n              bbox.add(bounds);\n            }\n          }\n        }\n      }\n    }\n    return bbox;\n  }\n  /**\n   * Creates and returns the shape used as the background page.\n   *\n   * @param bounds {@link mxRectangle} that represents the bounds of the shape.\n   */\n  createBackgroundPageShape(bounds) {\n    return new RectangleShape(bounds, 'white', 'black');\n  }\n  /**\n   * Calls {@link validateBackgroundImage} and {@link validateBackgroundPage}.\n   */\n  validateBackground() {\n    this.validateBackgroundImage();\n    this.validateBackgroundPage();\n  }\n  /**\n   * Validates the background image.\n   */\n  validateBackgroundImage() {\n    const bg = this.graph.getBackgroundImage();\n    if (bg) {\n      if (!this.backgroundImage || this.backgroundImage.imageSrc !== bg.src) {\n        if (this.backgroundImage) {\n          this.backgroundImage.destroy();\n        }\n        const bounds = new Rectangle(0, 0, 1, 1);\n        this.backgroundImage = new ImageShape(bounds, bg.src);\n        this.backgroundImage.dialect = this.graph.dialect;\n        this.backgroundImage.init(this.backgroundPane);\n        this.backgroundImage.redraw();\n      }\n      this.redrawBackgroundImage(this.backgroundImage, bg);\n    } else if (this.backgroundImage) {\n      this.backgroundImage.destroy();\n      this.backgroundImage = null;\n    }\n  }\n  /**\n   * Validates the background page.\n   */\n  validateBackgroundPage() {\n    const graph = this.graph;\n    if (graph.pageVisible) {\n      const bounds = this.getBackgroundPageBounds();\n      if (this.backgroundPageShape == null) {\n        this.backgroundPageShape = this.createBackgroundPageShape(bounds);\n        this.backgroundPageShape.scale = this.scale;\n        this.backgroundPageShape.isShadow = true;\n        this.backgroundPageShape.dialect = this.graph.dialect;\n        this.backgroundPageShape.init(this.backgroundPane);\n        this.backgroundPageShape.redraw();\n        if (this.backgroundPageShape.node) {\n          // Adds listener for double click handling on background\n          if (graph.isNativeDblClickEnabled()) {\n            InternalEvent.addListener(this.backgroundPageShape.node, 'dblclick', evt => {\n              graph.dblClick(evt);\n            });\n          }\n          // Adds basic listeners for graph event dispatching outside of the\n          // container and finishing the handling of a single gesture\n          InternalEvent.addGestureListeners(this.backgroundPageShape.node, evt => {\n            graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt));\n          }, evt => {\n            const tooltipHandler = graph.getPlugin('TooltipHandler');\n            // Hides the tooltip if mouse is outside container\n            if (tooltipHandler && tooltipHandler.isHideOnHover()) {\n              tooltipHandler.hide();\n            }\n            if (graph.isMouseDown && !isConsumed(evt)) {\n              graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt));\n            }\n          }, evt => {\n            graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt));\n          });\n        }\n      } else {\n        this.backgroundPageShape.scale = this.scale;\n        this.backgroundPageShape.bounds = bounds;\n        this.backgroundPageShape.redraw();\n      }\n    } else if (this.backgroundPageShape) {\n      this.backgroundPageShape.destroy();\n      this.backgroundPageShape = null;\n    }\n  }\n  /**\n   * Returns the bounds for the background page.\n   */\n  getBackgroundPageBounds() {\n    const fmt = this.graph.pageFormat;\n    const ps = this.scale * this.graph.pageScale;\n    return new Rectangle(this.scale * this.translate.x, this.scale * this.translate.y, fmt.width * ps, fmt.height * ps);\n  }\n  /**\n   * Updates the bounds and redraws the background image.\n   *\n   * Example:\n   *\n   * If the background image should not be scaled, this can be replaced with\n   * the following.\n   *\n   * @example\n   * ```javascript\n   * redrawBackground(backgroundImage, bg)\n   * {\n   *   backgroundImage.bounds.x = this.translate.x;\n   *   backgroundImage.bounds.y = this.translate.y;\n   *   backgroundImage.bounds.width = bg.width;\n   *   backgroundImage.bounds.height = bg.height;\n   *\n   *   backgroundImage.redraw();\n   * };\n   * ```\n   *\n   * @param backgroundImage {@link mxImageShape} that represents the background image.\n   * @param bg {@link mxImage} that specifies the image and its dimensions.\n   */\n  redrawBackgroundImage(backgroundImage, bg) {\n    backgroundImage.scale = this.scale;\n    if (backgroundImage.bounds) {\n      const bounds = backgroundImage.bounds;\n      bounds.x = this.scale * this.translate.x;\n      bounds.y = this.scale * this.translate.y;\n      bounds.width = this.scale * bg.width;\n      bounds.height = this.scale * bg.height;\n    }\n    backgroundImage.redraw();\n  }\n  /**\n   * Recursively creates the cell state for the given cell if visible is true and\n   * the given cell is visible. If the cell is not visible but the state exists\n   * then it is removed using {@link removeState}.\n   *\n   * @param cell {@link mxCell} whose {@link CellState} should be created.\n   * @param visible Optional boolean indicating if the cell should be visible. Default\n   * is true.\n   */\n  validateCell(cell, visible = true) {\n    visible = visible && cell.isVisible();\n    const state = this.getState(cell, visible);\n    if (state && !visible) {\n      this.removeState(cell);\n    } else {\n      const childCount = cell.getChildCount();\n      for (let i = 0; i < childCount; i += 1) {\n        this.validateCell(cell.getChildAt(i), visible && (!cell.isCollapsed() || cell === this.currentRoot));\n      }\n    }\n    return cell;\n  }\n  /**\n   * Validates and repaints the {@link CellState} for the given {@link Cell}.\n   *\n   * @param cell {@link mxCell} whose {@link CellState} should be validated.\n   * @param recurse Optional boolean indicating if the children of the cell should be\n   * validated. Default is true.\n   */\n  validateCellState(cell, recurse = true) {\n    let state = null;\n    if (cell) {\n      state = this.getState(cell);\n      if (state) {\n        if (state.invalid) {\n          state.invalid = false;\n          if (!state.style || state.invalidStyle) {\n            state.style = this.graph.getCellStyle(state.cell);\n            state.invalidStyle = false;\n          }\n          if (cell !== this.currentRoot) {\n            this.validateCellState(cell.getParent(), false);\n          }\n          state.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(cell, true), false), true);\n          state.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(cell, false), false), false);\n          this.updateCellState(state);\n          // Repaint happens immediately after the cell is validated\n          if (cell !== this.currentRoot && !state.invalid) {\n            this.graph.cellRenderer.redraw(state, false, this.isRendering());\n            // Handles changes to invertex paintbounds after update of rendering shape\n            state.updateCachedBounds();\n          }\n        }\n        if (recurse && !state.invalid) {\n          // Updates order in DOM if recursively traversing\n          if (state.shape) {\n            this.stateValidated(state);\n          }\n          const childCount = cell.getChildCount();\n          for (let i = 0; i < childCount; i += 1) {\n            this.validateCellState(cell.getChildAt(i));\n          }\n        }\n      }\n    }\n    return state;\n  }\n  /**\n   * Updates the given {@link CellState}.\n   *\n   * @param state {@link CellState} to be updated.\n   */\n  updateCellState(state) {\n    const absoluteOffset = state.absoluteOffset;\n    const origin = state.origin;\n    absoluteOffset.x = 0;\n    absoluteOffset.y = 0;\n    origin.x = 0;\n    origin.y = 0;\n    state.length = 0;\n    if (state.cell !== this.currentRoot) {\n      const parent = state.cell.getParent();\n      const pState = parent ? this.getState(parent) : null;\n      if (pState && pState.cell !== this.currentRoot) {\n        origin.x += pState.origin.x;\n        origin.y += pState.origin.y;\n      }\n      let offset = this.graph.getChildOffsetForCell(state.cell);\n      if (offset) {\n        origin.x += offset.x;\n        origin.y += offset.y;\n      }\n      const geo = state.cell.getGeometry();\n      if (geo) {\n        if (!state.cell.isEdge()) {\n          offset = geo.offset ? geo.offset : this.EMPTY_POINT;\n          if (geo.relative && pState) {\n            if (pState.cell.isEdge()) {\n              const point = this.getPoint(pState, geo);\n              if (point) {\n                origin.x += point.x / this.scale - pState.origin.x - this.translate.x;\n                origin.y += point.y / this.scale - pState.origin.y - this.translate.y;\n              }\n            } else {\n              origin.x += geo.x * pState.unscaledWidth + offset.x;\n              origin.y += geo.y * pState.unscaledHeight + offset.y;\n            }\n          } else {\n            absoluteOffset.x = this.scale * offset.x;\n            absoluteOffset.y = this.scale * offset.y;\n            origin.x += geo.x;\n            origin.y += geo.y;\n          }\n        }\n        state.x = this.scale * (this.translate.x + origin.x);\n        state.y = this.scale * (this.translate.y + origin.y);\n        state.width = this.scale * geo.width;\n        state.unscaledWidth = geo.width;\n        state.height = this.scale * geo.height;\n        state.unscaledHeight = geo.height;\n        if (state.cell.isVertex()) {\n          this.updateVertexState(state, geo);\n        }\n        if (state.cell.isEdge()) {\n          this.updateEdgeState(state, geo);\n        }\n      }\n    }\n    state.updateCachedBounds();\n  }\n  /**\n   * Validates the given cell state.\n   */\n  updateVertexState(state, geo) {\n    const parent = state.cell.getParent();\n    const pState = parent ? this.getState(parent) : null;\n    if (geo.relative && pState && !pState.cell.isEdge()) {\n      const alpha = toRadians(pState.style.rotation ?? 0);\n      if (alpha !== 0) {\n        const cos = Math.cos(alpha);\n        const sin = Math.sin(alpha);\n        const ct = new Point(state.getCenterX(), state.getCenterY());\n        const cx = new Point(pState.getCenterX(), pState.getCenterY());\n        const pt = getRotatedPoint(ct, cos, sin, cx);\n        state.x = pt.x - state.width / 2;\n        state.y = pt.y - state.height / 2;\n      }\n    }\n    this.updateVertexLabelOffset(state);\n  }\n  /**\n   * Validates the given cell state.\n   */\n  updateEdgeState(state, geo) {\n    const source = state.getVisibleTerminalState(true);\n    const target = state.getVisibleTerminalState(false);\n    // This will remove edges with no terminals and no terminal points\n    // as such edges are invalid and produce NPEs in the edge styles.\n    // Also removes connected edges that have no visible terminals.\n    if (state.cell.getTerminal(true) && !source || !source && !geo.getTerminalPoint(true) || state.cell.getTerminal(false) && !target || !target && !geo.getTerminalPoint(false)) {\n      this.clear(state.cell, true);\n    } else {\n      this.updateFixedTerminalPoints(state, source, target);\n      this.updatePoints(state, geo.points, source, target);\n      this.updateFloatingTerminalPoints(state, source, target);\n      const pts = state.absolutePoints;\n      if (state.cell !== this.currentRoot && (pts == null || pts.length < 2 || pts[0] == null || pts[pts.length - 1] == null)) {\n        // This will remove edges with invalid points from the list of states in the view.\n        // Happens if the one of the terminals and the corresponding terminal point is null.\n        this.clear(state.cell, true);\n      } else {\n        this.updateEdgeBounds(state);\n        this.updateEdgeLabelOffset(state);\n      }\n    }\n  }\n  /**\n   * Updates the absoluteOffset of the given vertex cell state. This takes\n   * into account the label position styles.\n   *\n   * @param state {@link CellState} whose absolute offset should be updated.\n   */\n  updateVertexLabelOffset(state) {\n    const h = state.style.labelPosition ?? ALIGN.CENTER;\n    if (h === ALIGN.LEFT) {\n      let lw = state.style.labelWidth ?? null;\n      if (lw != null) {\n        lw *= this.scale;\n      } else {\n        lw = state.width;\n      }\n      // @ts-ignore\n      state.absoluteOffset.x -= lw;\n    } else if (h === ALIGN.RIGHT) {\n      // @ts-ignore\n      state.absoluteOffset.x += state.width;\n    } else if (h === ALIGN.CENTER) {\n      const lw = state.style.labelWidth ?? null;\n      if (lw != null) {\n        // Aligns text block with given width inside the vertex width\n        const align = state.style.align ?? ALIGN.CENTER;\n        let dx = 0;\n        if (align === ALIGN.CENTER) {\n          dx = 0.5;\n        } else if (align === ALIGN.RIGHT) {\n          dx = 1;\n        }\n        if (dx !== 0) {\n          // @ts-ignore\n          state.absoluteOffset.x -= (lw * this.scale - state.width) * dx;\n        }\n      }\n    }\n    const v = state.style.verticalLabelPosition ?? ALIGN.MIDDLE;\n    if (v === ALIGN.TOP) {\n      // @ts-ignore\n      state.absoluteOffset.y -= state.height;\n    } else if (v === ALIGN.BOTTOM) {\n      // @ts-ignore\n      state.absoluteOffset.y += state.height;\n    }\n  }\n  /**\n   * Resets the current validation state.\n   */\n  resetValidationState() {\n    this.lastNode = null;\n    this.lastHtmlNode = null;\n    this.lastForegroundNode = null;\n    this.lastForegroundHtmlNode = null;\n  }\n  /**\n   * Invoked when a state has been processed in {@link validatePoints}. This is used\n   * to update the order of the DOM nodes of the shape.\n   *\n   * @param state {@link CellState} that represents the cell state.\n   */\n  stateValidated(state) {\n    const graph = this.graph;\n    const fg = state.cell.isEdge() && graph.keepEdgesInForeground || state.cell.isVertex() && graph.keepEdgesInBackground;\n    const htmlNode = fg ? this.lastForegroundHtmlNode || this.lastHtmlNode : this.lastHtmlNode;\n    const node = fg ? this.lastForegroundNode || this.lastNode : this.lastNode;\n    const result = graph.cellRenderer.insertStateAfter(state, node, htmlNode);\n    if (fg) {\n      this.lastForegroundHtmlNode = result[1];\n      this.lastForegroundNode = result[0];\n    } else {\n      this.lastHtmlNode = result[1];\n      this.lastNode = result[0];\n    }\n  }\n  /**\n   * Sets the initial absolute terminal points in the given state before the edge\n   * style is computed.\n   *\n   * @param edge {@link CellState} whose initial terminal points should be updated.\n   * @param source {@link CellState} which represents the source terminal.\n   * @param target {@link CellState} which represents the target terminal.\n   */\n  updateFixedTerminalPoints(edge, source, target) {\n    this.updateFixedTerminalPoint(edge, source, true, this.graph.getConnectionConstraint(edge, source, true));\n    this.updateFixedTerminalPoint(edge, target, false, this.graph.getConnectionConstraint(edge, target, false));\n  }\n  /**\n   * Sets the fixed source or target terminal point on the given edge.\n   *\n   * @param edge <CellState> whose terminal point should be updated.\n   * @param terminal <CellState> which represents the actual terminal.\n   * @param source Boolean that specifies if the terminal is the source.\n   * @param constraint {@link ConnectionConstraint} that specifies the connection.\n   */\n  updateFixedTerminalPoint(edge, terminal, source, constraint) {\n    edge.setAbsoluteTerminalPoint(this.getFixedTerminalPoint(edge, terminal, source, constraint), source);\n  }\n  /**\n   * Returns the fixed source or target terminal point for the given edge.\n   *\n   * @param edge <CellState> whose terminal point should be returned.\n   * @param terminal <CellState> which represents the actual terminal.\n   * @param source Boolean that specifies if the terminal is the source.\n   * @param constraint {@link ConnectionConstraint} that specifies the connection.\n   */\n  getFixedTerminalPoint(edge, terminal, source, constraint) {\n    let pt = null;\n    if (constraint && terminal) {\n      pt = this.graph.getConnectionPoint(terminal, constraint, false); // FIXME Rounding introduced bugs when calculating label positions -> , this.graph.isOrthogonal(edge));\n    }\n    if (!pt && !terminal) {\n      const s = this.scale;\n      const tr = this.translate;\n      const orig = edge.origin;\n      const geo = edge.cell.getGeometry();\n      pt = geo.getTerminalPoint(source);\n      if (pt) {\n        pt = new Point(s * (tr.x + pt.x + orig.x), s * (tr.y + pt.y + orig.y));\n      }\n    }\n    return pt;\n  }\n  /**\n   * Updates the bounds of the given cell state to reflect the bounds of the stencil\n   * if it has a fixed aspect and returns the previous bounds as an {@link Rectangle} if\n   * the bounds have been modified or null otherwise.\n   *\n   * @param edge {@link CellState} whose bounds should be updated.\n   */\n  updateBoundsFromStencil(state) {\n    let previous = null;\n    if (state && state.shape && state.shape.stencil && state.shape.stencil.aspect === 'fixed') {\n      previous = Rectangle.fromRectangle(state);\n      const asp = state.shape.stencil.computeAspect(null,\n      // this argument is not used\n      state.x, state.y, state.width, state.height);\n      state.setRect(asp.x, asp.y, state.shape.stencil.w0 * asp.width, state.shape.stencil.h0 * asp.height);\n    }\n    return previous;\n  }\n  /**\n   * Updates the absolute points in the given state using the specified array\n   * of {@link Point} as the relative points.\n   *\n   * @param edge {@link CellState} whose absolute points should be updated.\n   * @param points Array of {@link Point} that constitute the relative points.\n   * @param source {@link CellState} that represents the source terminal.\n   * @param target {@link CellState} that represents the target terminal.\n   */\n  updatePoints(edge, points, source, target) {\n    const pts = [];\n    pts.push(edge.absolutePoints[0]);\n    const edgeStyle = this.getEdgeStyle(edge, points, source, target);\n    if (edgeStyle && source) {\n      // target can be null\n      const src = this.getTerminalPort(edge, source, true);\n      const trg = target ? this.getTerminalPort(edge, target, false) : null;\n      // Uses the stencil bounds for routing and restores after routing\n      const srcBounds = this.updateBoundsFromStencil(src);\n      const trgBounds = this.updateBoundsFromStencil(trg);\n      edgeStyle(edge, src, trg, points, pts);\n      // Restores previous bounds\n      if (src && srcBounds) {\n        src.setRect(srcBounds.x, srcBounds.y, srcBounds.width, srcBounds.height);\n      }\n      if (trg && trgBounds) {\n        trg.setRect(trgBounds.x, trgBounds.y, trgBounds.width, trgBounds.height);\n      }\n    } else if (points) {\n      for (let i = 0; i < points.length; i += 1) {\n        if (points[i]) {\n          const pt = clone(points[i]);\n          pts.push(this.transformControlPoint(edge, pt));\n        }\n      }\n    }\n    const tmp = edge.absolutePoints;\n    pts.push(tmp[tmp.length - 1]);\n    edge.absolutePoints = pts;\n  }\n  /**\n   * Transforms the given control point to an absolute point.\n   */\n  transformControlPoint(state, pt, ignoreScale = false) {\n    if (state && pt) {\n      const orig = state.origin;\n      const scale = ignoreScale ? 1 : this.scale;\n      return new Point(scale * (pt.x + this.translate.x + orig.x), scale * (pt.y + this.translate.y + orig.y));\n    }\n    return null;\n  }\n  /**\n   * Returns true if the given edge should be routed with {@link graph.defaultLoopStyle}\n   * or the {@link CellStateStyle.STYLE_LOOP} defined for the given edge.\n   * This implementation returns `true` if the given edge is a loop and does not\n   */\n  isLoopStyleEnabled(edge, points = [], source = null, target = null) {\n    const sc = this.graph.getConnectionConstraint(edge, source, true);\n    const tc = this.graph.getConnectionConstraint(edge, target, false);\n    if ((points == null || points.length < 2) && !((edge.style.orthogonalLoop ?? false) || (sc == null || sc.point == null) && (tc == null || tc.point == null))) {\n      return source != null && source === target;\n    }\n    return false;\n  }\n  /**\n   * Returns the edge style function to be used to render the given edge state.\n   */\n  getEdgeStyle(edge, points = [], source = null, target = null) {\n    let edgeStyle = this.isLoopStyleEnabled(edge, points, source, target) ? edge.style.loopStyle ?? this.graph.defaultLoopStyle : !edge.style.noEdgeStyle ?? false ? edge.style.edgeStyle : null;\n    // Converts string values to objects\n    if (typeof edgeStyle === 'string') {\n      let tmp = StyleRegistry.getValue(edgeStyle);\n      if (!tmp && this.isAllowEval()) {\n        tmp = eval(edgeStyle);\n      }\n      edgeStyle = tmp;\n    }\n    if (typeof edgeStyle === 'function') {\n      return edgeStyle;\n    }\n    return null;\n  }\n  /**\n   * Updates the terminal points in the given state after the edge style was\n   * computed for the edge.\n   *\n   * @param state {@link CellState} whose terminal points should be updated.\n   * @param source {@link CellState} that represents the source terminal.\n   * @param target {@link CellState} that represents the target terminal.\n   */\n  updateFloatingTerminalPoints(state, source, target) {\n    const pts = state.absolutePoints;\n    const p0 = pts[0];\n    const pe = pts[pts.length - 1];\n    if (!pe && target) {\n      this.updateFloatingTerminalPoint(state, target, source, false);\n    }\n    if (!p0 && source) {\n      this.updateFloatingTerminalPoint(state, source, target, true);\n    }\n  }\n  /**\n   * Updates the absolute terminal point in the given state for the given\n   * start and end state, where start is the source if source is true.\n   *\n   * @param edge {@link CellState} whose terminal point should be updated.\n   * @param start {@link CellState} for the terminal on \"this\" side of the edge.\n   * @param end {@link CellState} for the terminal on the other side of the edge.\n   * @param source Boolean indicating if start is the source terminal state.\n   */\n  updateFloatingTerminalPoint(edge, start, end, source) {\n    edge.setAbsoluteTerminalPoint(this.getFloatingTerminalPoint(edge, start, end, source), source);\n  }\n  /**\n   * Returns the floating terminal point for the given edge, start and end\n   * state, where start is the source if source is true.\n   *\n   * @param edge {@link CellState} whose terminal point should be returned.\n   * @param start {@link CellState} for the terminal on \"this\" side of the edge.\n   * @param end {@link CellState} for the terminal on the other side of the edge.\n   * @param source Boolean indicating if start is the source terminal state.\n   */\n  getFloatingTerminalPoint(edge, start, end, source) {\n    start = this.getTerminalPort(edge, start, source);\n    let next = this.getNextPoint(edge, end, source);\n    const orth = this.graph.isOrthogonal(edge);\n    const alpha = toRadians(start.style.rotation ?? 0);\n    const center = new Point(start.getCenterX(), start.getCenterY());\n    if (alpha !== 0) {\n      const cos = Math.cos(-alpha);\n      const sin = Math.sin(-alpha);\n      next = getRotatedPoint(next, cos, sin, center);\n    }\n    let border = edge.style.perimeterSpacing ?? 0;\n    border += edge.style[source ? 'sourcePerimeterSpacing' : 'targetPerimeterSpacing'] ?? 0;\n    let pt = this.getPerimeterPoint(start, next, alpha === 0 && orth, border);\n    if (pt && alpha !== 0) {\n      const cos = Math.cos(alpha);\n      const sin = Math.sin(alpha);\n      pt = getRotatedPoint(pt, cos, sin, center);\n    }\n    return pt;\n  }\n  /**\n   * Returns an {@link CellState} that represents the source or target terminal or\n   * port for the given edge.\n   *\n   * @param state {@link CellState} that represents the state of the edge.\n   * @param terminal {@link CellState} that represents the terminal.\n   * @param source Boolean indicating if the given terminal is the source terminal.\n   */\n  getTerminalPort(state, terminal, source = false) {\n    const key = source ? 'sourcePort' : 'targetPort';\n    const id = state.style[key];\n    if (id) {\n      const cell = this.graph.getDataModel().getCell(id);\n      if (cell) {\n        const tmp = this.getState(cell, false);\n        // Only uses ports where a cell state exists\n        if (tmp) {\n          terminal = tmp;\n        }\n      }\n    }\n    return terminal;\n  }\n  /**\n   * Returns an {@link Point} that defines the location of the intersection point between\n   * the perimeter and the line between the center of the shape and the given point.\n   *\n   * @param terminal {@link CellState} for the source or target terminal.\n   * @param next {@link Point} that lies outside the given terminal.\n   * @param orthogonal Boolean that specifies if the orthogonal projection onto\n   * the perimeter should be returned. If this is false then the intersection\n   * of the perimeter and the line between the next and the center point is\n   * returned.\n   * @param border Optional border between the perimeter and the shape.\n   */\n  getPerimeterPoint(terminal, next, orthogonal, border = 0) {\n    let point = null;\n    if (terminal != null) {\n      const perimeter = this.getPerimeterFunction(terminal);\n      if (perimeter != null && next != null) {\n        const bounds = this.getPerimeterBounds(terminal, border);\n        if (bounds.width > 0 || bounds.height > 0) {\n          point = new Point(next.x, next.y);\n          let flipH = false;\n          let flipV = false;\n          if (terminal.cell.isVertex()) {\n            flipH = !!terminal.style.flipH;\n            flipV = !!terminal.style.flipV;\n            if (flipH) {\n              point.x = 2 * bounds.getCenterX() - point.x;\n            }\n            if (flipV) {\n              point.y = 2 * bounds.getCenterY() - point.y;\n            }\n          }\n          point = perimeter(bounds, terminal, point, orthogonal);\n          if (point != null) {\n            if (flipH) {\n              point.x = 2 * bounds.getCenterX() - point.x;\n            }\n            if (flipV) {\n              point.y = 2 * bounds.getCenterY() - point.y;\n            }\n          }\n        }\n      }\n      if (point == null) {\n        point = this.getPoint(terminal);\n      }\n    }\n    return point;\n  }\n  /**\n   * Returns the x-coordinate of the center point for automatic routing.\n   */\n  getRoutingCenterX(state) {\n    const f = state.style ? state.style.routingCenterX ?? 0 : 0;\n    return state.getCenterX() + f * state.width;\n  }\n  /**\n   * Returns the y-coordinate of the center point for automatic routing.\n   */\n  getRoutingCenterY(state) {\n    const f = state.style ? state.style.routingCenterY ?? 0 : 0;\n    return state.getCenterY() + f * state.height;\n  }\n  /**\n   * Returns the perimeter bounds for the given terminal, edge pair as an\n   * {@link Rectangle}.\n   *\n   * If you have a model where each terminal has a relative child that should\n   * act as the graphical endpoint for a connection from/to the terminal, then\n   * this method can be replaced as follows:\n   *\n   * @example\n   * ```javascript\n   * var oldGetPerimeterBounds = getPerimeterBounds;\n   * getPerimeterBounds(terminal, edge, isSource)\n   * {\n   *   var model = this.graph.getDataModel();\n   *   var childCount = model.getChildCount(terminal.cell);\n   *\n   *   if (childCount > 0)\n   *   {\n   *     var child = model.getChildAt(terminal.cell, 0);\n   *     var geo = model.getGeometry(child);\n   *\n   *     if (geo != null &&\n   *         geo.relative)\n   *     {\n   *       var state = this.getState(child);\n   *\n   *       if (state != null)\n   *       {\n   *         terminal = state;\n   *       }\n   *     }\n   *   }\n   *\n   *   return oldGetPerimeterBounds.apply(this, arguments);\n   * };\n   * ```\n   *\n   * @param terminal CellState that represents the terminal.\n   * @param border Number that adds a border between the shape and the perimeter.\n   */\n  getPerimeterBounds(terminal, border = 0) {\n    border += terminal.style.perimeterSpacing ?? 0;\n    return terminal.getPerimeterBounds(border * this.scale);\n  }\n  /**\n   * Returns the perimeter function for the given state.\n   */\n  getPerimeterFunction(state) {\n    let perimeter = state.style.perimeter;\n    // Converts string values to objects\n    if (typeof perimeter === 'string') {\n      let tmp = StyleRegistry.getValue(perimeter);\n      if (tmp == null && this.isAllowEval()) {\n        tmp = eval(perimeter);\n      }\n      perimeter = tmp;\n    }\n    if (typeof perimeter === 'function') {\n      return perimeter;\n    }\n    return null;\n  }\n  /**\n   * Returns the nearest point in the list of absolute points or the center\n   * of the opposite terminal.\n   *\n   * @param edge {@link CellState} that represents the edge.\n   * @param opposite {@link CellState} that represents the opposite terminal.\n   * @param source Boolean indicating if the next point for the source or target\n   * should be returned.\n   */\n  getNextPoint(edge, opposite, source = false) {\n    const pts = edge.absolutePoints;\n    let point = null;\n    if (pts.length >= 2) {\n      const count = pts.length;\n      point = pts[source ? Math.min(1, count - 1) : Math.max(0, count - 2)];\n    }\n    if (!point && opposite) {\n      point = new Point(opposite.getCenterX(), opposite.getCenterY());\n    }\n    return point; // shouldn't return null, but really?\n  }\n  /**\n   * Returns the nearest ancestor terminal that is visible. The edge appears\n   * to be connected to this terminal on the display. The result of this method\n   * is cached in {@link CellState.getVisibleTerminalState}.\n   *\n   * @param edge {@link mxCell} whose visible terminal should be returned.\n   * @param source Boolean that specifies if the source or target terminal\n   * should be returned.\n   */\n  getVisibleTerminal(edge, source) {\n    const model = this.graph.getDataModel();\n    let result = edge.getTerminal(source);\n    let best = result;\n    while (result && result !== this.currentRoot) {\n      if (best && !best.isVisible() || result.isCollapsed()) {\n        best = result;\n      }\n      result = result.getParent();\n    }\n    // Checks if the result is valid for the current view state\n    if (best && (!model.contains(best) || best.getParent() === model.getRoot() || best === this.currentRoot)) {\n      best = null;\n    }\n    return best;\n  }\n  /**\n   * Updates the given state using the bounding box of t\n   * he absolute points.\n   * Also updates {@link CellState.terminalDistance}, {@link CellState.length} and\n   * {@link CellState.segments}.\n   *\n   * @param state {@link CellState} whose bounds should be updated.\n   */\n  updateEdgeBounds(state) {\n    const points = state.absolutePoints;\n    const p0 = points[0];\n    const pe = points[points.length - 1];\n    if (p0 && pe && (p0.x !== pe.x || p0.y !== pe.y)) {\n      const dx = pe.x - p0.x;\n      const dy = pe.y - p0.y;\n      state.terminalDistance = Math.sqrt(dx * dx + dy * dy);\n    } else {\n      state.terminalDistance = 0;\n    }\n    let length = 0;\n    const segments = [];\n    let pt = p0;\n    if (pt) {\n      let minX = pt.x;\n      let minY = pt.y;\n      let maxX = minX;\n      let maxY = minY;\n      for (let i = 1; i < points.length; i += 1) {\n        const tmp = points[i];\n        if (tmp) {\n          const dx = pt.x - tmp.x;\n          const dy = pt.y - tmp.y;\n          const segment = Math.sqrt(dx * dx + dy * dy);\n          segments.push(segment);\n          length += segment;\n          pt = tmp;\n          minX = Math.min(pt.x, minX);\n          minY = Math.min(pt.y, minY);\n          maxX = Math.max(pt.x, maxX);\n          maxY = Math.max(pt.y, maxY);\n        }\n      }\n      state.length = length;\n      state.segments = segments;\n      const markerSize = 1; // TODO: include marker size\n      state.x = minX;\n      state.y = minY;\n      state.width = Math.max(markerSize, maxX - minX);\n      state.height = Math.max(markerSize, maxY - minY);\n    }\n  }\n  /**\n   * Returns the absolute point on the edge for the given relative\n   * {@link Geometry} as an {@link Point}. The edge is represented by the given\n   * {@link CellState}.\n   *\n   * @param state {@link CellState} that represents the state of the parent edge.\n   * @param geometry {@link mxGeometry} that represents the relative location.\n   */\n  getPoint(state, geometry = null) {\n    let x = state.getCenterX();\n    let y = state.getCenterY();\n    if (state.segments != null && (geometry == null || geometry.relative)) {\n      const gx = geometry != null ? geometry.x / 2 : 0;\n      const pointCount = state.absolutePoints.length;\n      const dist = Math.round((gx + 0.5) * state.length);\n      let segment = state.segments[0];\n      let length = 0;\n      let index = 1;\n      while (dist >= Math.round(length + segment) && index < pointCount - 1) {\n        length += segment;\n        segment = state.segments[index++];\n      }\n      const factor = segment === 0 ? 0 : (dist - length) / segment;\n      const p0 = state.absolutePoints[index - 1];\n      const pe = state.absolutePoints[index];\n      if (p0 != null && pe != null) {\n        let gy = 0;\n        let offsetX = 0;\n        let offsetY = 0;\n        if (geometry != null) {\n          gy = geometry.y;\n          const {\n            offset\n          } = geometry;\n          if (offset != null) {\n            offsetX = offset.x;\n            offsetY = offset.y;\n          }\n        }\n        const dx = pe.x - p0.x;\n        const dy = pe.y - p0.y;\n        const nx = segment === 0 ? 0 : dy / segment;\n        const ny = segment === 0 ? 0 : dx / segment;\n        x = p0.x + dx * factor + (nx * gy + offsetX) * this.scale;\n        y = p0.y + dy * factor - (ny * gy - offsetY) * this.scale;\n      }\n    } else if (geometry != null) {\n      const {\n        offset\n      } = geometry;\n      if (offset != null) {\n        x += offset.x;\n        y += offset.y;\n      }\n    }\n    return new Point(x, y);\n  }\n  /**\n   * Gets the relative point that describes the given, absolute label\n   * position for the given edge state.\n   *\n   * @param state {@link CellState} that represents the state of the parent edge.\n   * @param x Specifies the x-coordinate of the absolute label location.\n   * @param y Specifies the y-coordinate of the absolute label location.\n   */\n  getRelativePoint(edgeState, x, y) {\n    const geometry = edgeState.cell.getGeometry();\n    if (geometry) {\n      const absolutePoints = edgeState.absolutePoints;\n      const pointCount = absolutePoints.length;\n      if (geometry.relative && pointCount > 1) {\n        const totalLength = edgeState.length;\n        const {\n          segments\n        } = edgeState;\n        // Works out which line segment the point of the label is closest to\n        let p0 = absolutePoints[0];\n        let pe = absolutePoints[1];\n        let minDist = ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y);\n        let length = 0;\n        let index = 0;\n        let tmp = 0;\n        for (let i = 2; i < pointCount; i += 1) {\n          p0 = pe;\n          pe = absolutePoints[i];\n          const dist = ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y);\n          tmp += segments[i - 2];\n          if (dist <= minDist) {\n            minDist = dist;\n            index = i - 1;\n            length = tmp;\n          }\n        }\n        const seg = segments[index];\n        p0 = absolutePoints[index];\n        pe = absolutePoints[index + 1];\n        const x2 = p0.x;\n        const y2 = p0.y;\n        const x1 = pe.x;\n        const y1 = pe.y;\n        let px = x;\n        let py = y;\n        const xSegment = x2 - x1;\n        const ySegment = y2 - y1;\n        px -= x1;\n        py -= y1;\n        let projlenSq = 0;\n        px = xSegment - px;\n        py = ySegment - py;\n        const dotprod = px * xSegment + py * ySegment;\n        if (dotprod <= 0.0) {\n          projlenSq = 0;\n        } else {\n          projlenSq = dotprod * dotprod / (xSegment * xSegment + ySegment * ySegment);\n        }\n        let projlen = Math.sqrt(projlenSq);\n        if (projlen > seg) {\n          projlen = seg;\n        }\n        let yDistance = Math.sqrt(ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y));\n        const direction = relativeCcw(p0.x, p0.y, pe.x, pe.y, x, y);\n        if (direction === -1) {\n          yDistance = -yDistance;\n        }\n        // Constructs the relative point for the label\n        return new Point((totalLength / 2 - length - projlen) / totalLength * -2, yDistance / this.scale);\n      }\n    }\n    return new Point();\n  }\n  /**\n   * Updates {@link CellState.absoluteOffset} for the given state. The absolute\n   * offset is normally used for the position of the edge label. Is is\n   * calculated from the geometry as an absolute offset from the center\n   * between the two endpoints if the geometry is absolute, or as the\n   * relative distance between the center along the line and the absolute\n   * orthogonal distance if the geometry is relative.\n   *\n   * @param state {@link CellState} whose absolute offset should be updated.\n   */\n  updateEdgeLabelOffset(state) {\n    const points = state.absolutePoints;\n    const absoluteOffset = state.absoluteOffset;\n    absoluteOffset.x = state.getCenterX();\n    absoluteOffset.y = state.getCenterY();\n    if (points.length > 0 && state.segments) {\n      const geometry = state.cell.getGeometry();\n      if (geometry) {\n        if (geometry.relative) {\n          const offset = this.getPoint(state, geometry);\n          state.absoluteOffset = offset;\n        } else {\n          const p0 = points[0];\n          const pe = points[points.length - 1];\n          if (p0 && pe) {\n            const dx = pe.x - p0.x;\n            const dy = pe.y - p0.y;\n            let x0 = 0;\n            let y0 = 0;\n            const off = geometry.offset;\n            if (off) {\n              x0 = off.x;\n              y0 = off.y;\n            }\n            const x = p0.x + dx / 2 + x0 * this.scale;\n            const y = p0.y + dy / 2 + y0 * this.scale;\n            absoluteOffset.x = x;\n            absoluteOffset.y = y;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Returns the {@link CellState} for the given cell. If create is true, then\n   * the state is created if it does not yet exist.\n   *\n   * @param cell {@link mxCell} for which the {@link CellState} should be returned.\n   * @param create Optional boolean indicating if a new state should be created\n   * if it does not yet exist. Default is false.\n   */\n  getState(cell, create = false) {\n    let state = this.states.get(cell);\n    if (create && (!state || this.updateStyle) && cell.isVisible()) {\n      if (!state) {\n        state = this.createState(cell);\n        this.states.put(cell, state);\n      } else {\n        state.style = this.graph.getCellStyle(cell);\n      }\n    }\n    return state;\n  }\n  /**\n   * Returns the {@link mxCellStates} for the given array of {@link Cell}. The array\n   * contains all states that are not null, that is, the returned array may\n   * have less elements than the given array. If no argument is given, then\n   * this returns {@link states}.\n   */\n  getCellStates(cells = null) {\n    if (!cells) {\n      return this.states.getValues();\n    }\n    const result = [];\n    for (const cell of cells) {\n      const state = this.getState(cell);\n      if (state) {\n        result.push(state);\n      }\n    }\n    return result;\n  }\n  /**\n   * Removes and returns the {@link CellState} for the given cell.\n   *\n   * @param cell {@link mxCell} for which the {@link CellState} should be removed.\n   */\n  removeState(cell) {\n    const state = this.states.remove(cell);\n    if (state) {\n      this.graph.cellRenderer.destroy(state);\n      state.invalid = true;\n      state.destroy();\n    }\n    return state;\n  }\n  /**\n   * Creates and returns an {@link CellState} for the given cell and initializes\n   * it using {@link cellRenderer.initialize}.\n   *\n   * @param cell {@link mxCell} for which a new {@link CellState} should be created.\n   */\n  createState(cell) {\n    return new CellState(this, cell, this.graph.getCellStyle(cell));\n  }\n  /**\n   * Returns true if the event origin is one of the drawing panes or\n   * containers of the view.\n   */\n  isContainerEvent(evt) {\n    const source = getSource(evt);\n    return source && (source === this.graph.container ||\n    // @ts-ignore parentNode may exist\n    source.parentNode === this.backgroundPane ||\n    // @ts-ignore parentNode may exist\n    source.parentNode && source.parentNode.parentNode === this.backgroundPane || source === this.canvas.parentNode || source === this.canvas || source === this.backgroundPane || source === this.drawPane || source === this.overlayPane || source === this.decoratorPane);\n  }\n  /**\n   * Returns true if the event origin is one of the scrollbars of the\n   * container in IE. Such events are ignored.\n   */\n  isScrollEvent(evt) {\n    const graph = this.graph;\n    const offset = getOffset(graph.container);\n    const pt = new Point(evt.clientX - offset.x, evt.clientY - offset.y);\n    const container = graph.container;\n    const outWidth = container.offsetWidth;\n    const inWidth = container.clientWidth;\n    if (outWidth > inWidth && pt.x > inWidth + 2 && pt.x <= outWidth) {\n      return true;\n    }\n    const outHeight = container.offsetHeight;\n    const inHeight = container.clientHeight;\n    return outHeight > inHeight && pt.y > inHeight + 2 && pt.y <= outHeight;\n  }\n  /**\n   * Initializes the graph event dispatch loop for the specified container\n   * and invokes {@link create} to create the required DOM nodes for the display.\n   */\n  init() {\n    this.installListeners();\n    this.createSvg();\n  }\n  /**\n   * Installs the required listeners in the container.\n   */\n  installListeners() {\n    const graph = this.graph;\n    const {\n      container\n    } = graph;\n    // Support for touch device gestures (eg. pinch to zoom)\n    // Double-tap handling is implemented in mxGraph.fireMouseEvent\n    if (Client.IS_TOUCH) {\n      InternalEvent.addListener(container, 'gesturestart', evt => {\n        graph.fireGestureEvent(evt);\n        InternalEvent.consume(evt);\n      });\n      InternalEvent.addListener(container, 'gesturechange', evt => {\n        graph.fireGestureEvent(evt);\n        InternalEvent.consume(evt);\n      });\n      InternalEvent.addListener(container, 'gestureend', evt => {\n        graph.fireGestureEvent(evt);\n        InternalEvent.consume(evt);\n      });\n    }\n    // Fires event only for one pointer per gesture\n    let pointerId = null;\n    // Adds basic listeners for graph event dispatching\n    InternalEvent.addGestureListeners(container, evt => {\n      // Condition to avoid scrollbar events starting a rubberband selection\n      if (this.isContainerEvent(evt) && (!Client.IS_GC && !Client.IS_SF || !this.isScrollEvent(evt))) {\n        graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt));\n        // @ts-ignore\n        pointerId = evt.pointerId;\n      }\n    }, evt => {\n      if (this.isContainerEvent(evt) && (\n      // @ts-ignore\n      pointerId === null || evt.pointerId === pointerId)) {\n        graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt));\n      }\n    }, evt => {\n      if (this.isContainerEvent(evt)) {\n        graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt));\n      }\n      pointerId = null;\n    });\n    // Adds listener for double click handling on background, this does always\n    // use native event handler, we assume that the DOM of the background\n    // does not change during the double click\n    InternalEvent.addListener(container, 'dblclick', evt => {\n      if (this.isContainerEvent(evt)) {\n        graph.dblClick(evt);\n      }\n    });\n    // Workaround for touch events which started on some DOM node\n    // on top of the container, in which case the cells under the\n    // mouse for the move and up events are not detected.\n    const getState = evt => {\n      let state = null;\n      // Workaround for touch events which started on some DOM node\n      // on top of the container, in which case the cells under the\n      // mouse for the move and up events are not detected.\n      if (Client.IS_TOUCH) {\n        const x = getClientX(evt);\n        const y = getClientY(evt);\n        // Dispatches the drop event to the graph which\n        // consumes and executes the source function\n        const pt = convertPoint(container, x, y);\n        const cell = graph.getCellAt(pt.x, pt.y);\n        if (cell) state = graph.view.getState(cell);\n      }\n      return state;\n    };\n    // Adds basic listeners for graph event dispatching outside of the\n    // container and finishing the handling of a single gesture\n    // Implemented via graph event dispatch loop to avoid duplicate events\n    // in Firefox and Chrome\n    graph.addMouseListener({\n      mouseDown: (sender, me) => {\n        const popupMenuHandler = graph.getPlugin('PopupMenuHandler');\n        popupMenuHandler?.hideMenu();\n      },\n      mouseMove: () => {\n        return;\n      },\n      mouseUp: () => {\n        return;\n      }\n    });\n    this.moveHandler = evt => {\n      const tooltipHandler = graph.getPlugin('TooltipHandler');\n      // Hides the tooltip if mouse is outside container\n      if (tooltipHandler && tooltipHandler.isHideOnHover()) {\n        tooltipHandler.hide();\n      }\n      if (this.captureDocumentGesture && graph.isMouseDown && graph.container != null && !this.isContainerEvent(evt) && graph.container.style.display !== 'none' && graph.container.style.visibility !== 'hidden' && !isConsumed(evt)) {\n        graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, getState(evt)));\n      }\n    };\n    this.endHandler = evt => {\n      if (this.captureDocumentGesture && graph.isMouseDown && graph.container != null && !this.isContainerEvent(evt) && graph.container.style.display !== 'none' && graph.container.style.visibility !== 'hidden') {\n        graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt));\n      }\n    };\n    InternalEvent.addGestureListeners(document, null, this.moveHandler, this.endHandler);\n  }\n  /**\n   * Creates and returns the DOM nodes for the SVG display.\n   */\n  createSvg() {\n    const {\n      container\n    } = this.graph;\n    const canvas = this.canvas = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    // For background image\n    this.backgroundPane = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    canvas.appendChild(this.backgroundPane);\n    // Adds two layers (background is early feature)\n    this.drawPane = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    canvas.appendChild(this.drawPane);\n    this.overlayPane = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    canvas.appendChild(this.overlayPane);\n    this.decoratorPane = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    canvas.appendChild(this.decoratorPane);\n    const root = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    root.style.left = '0px';\n    root.style.top = '0px';\n    root.style.width = '100%';\n    root.style.height = '100%';\n    // NOTE: In standards mode, the SVG must have block layout\n    // in order for the container DIV to not show scrollbars.\n    root.style.display = 'block';\n    root.appendChild(this.canvas);\n    if (container != null) {\n      container.appendChild(root);\n      this.updateContainerStyle(container);\n    }\n  }\n  /**\n   * Function: createHtml\n   *\n   * Creates the DOM nodes for the HTML display.\n   */\n  createHtml() {\n    const container = this.graph.container;\n    if (container != null) {\n      this.canvas = this.createHtmlPane('100%', '100%');\n      this.canvas.style.overflow = 'hidden';\n      // Uses minimal size for inner DIVs on Canvas. This is required\n      // for correct event processing in IE. If we have an overlapping\n      // DIV then the events on the cells are only fired for labels.\n      this.backgroundPane = this.createHtmlPane('1px', '1px');\n      this.drawPane = this.createHtmlPane('1px', '1px');\n      this.overlayPane = this.createHtmlPane('1px', '1px');\n      this.decoratorPane = this.createHtmlPane('1px', '1px');\n      this.canvas.appendChild(this.backgroundPane);\n      this.canvas.appendChild(this.drawPane);\n      this.canvas.appendChild(this.overlayPane);\n      this.canvas.appendChild(this.decoratorPane);\n      container.appendChild(this.canvas);\n      this.updateContainerStyle(container);\n    }\n  }\n  /**\n   * Function: updateHtmlCanvasSize\n   *\n   * Updates the size of the HTML canvas.\n   */\n  updateHtmlCanvasSize(width, height) {\n    if (this.graph.container != null) {\n      const ow = this.graph.container.offsetWidth;\n      const oh = this.graph.container.offsetHeight;\n      if (ow < width) {\n        this.canvas.style.width = width + 'px';\n      } else {\n        this.canvas.style.width = '100%';\n      }\n      if (oh < height) {\n        this.canvas.style.height = height + 'px';\n      } else {\n        this.canvas.style.height = '100%';\n      }\n    }\n  }\n  /**\n   * Function: createHtmlPane\n   *\n   * Creates and returns a drawing pane in HTML (DIV).\n   */\n  createHtmlPane(width, height) {\n    const pane = document.createElement('DIV');\n    if (width != null && height != null) {\n      pane.style.position = 'absolute';\n      pane.style.left = '0px';\n      pane.style.top = '0px';\n      pane.style.width = width;\n      pane.style.height = height;\n    } else {\n      pane.style.position = 'relative';\n    }\n    return pane;\n  }\n  /**\n   * Updates the style of the container after installing the SVG DOM elements.\n   */\n  updateContainerStyle(container) {\n    // Workaround for offset of container\n    const style = getCurrentStyle(container);\n    if (style != null && style.position == 'static') {\n      container.style.position = 'relative';\n    }\n    // Disables built-in pan and zoom in IE10 and later\n    if (Client.IS_POINTER) {\n      container.style.touchAction = 'none';\n    }\n  }\n  /**\n   * Destroys the view and all its resources.\n   */\n  destroy() {\n    let root = null;\n    if (this.canvas && this.canvas instanceof SVGElement) {\n      root = this.canvas.ownerSVGElement;\n    }\n    if (!root) {\n      root = this.canvas;\n    }\n    if (root && root.parentNode) {\n      this.clear(this.currentRoot, true);\n      InternalEvent.removeGestureListeners(document, null, this.moveHandler, this.endHandler);\n      InternalEvent.release(this.graph.container);\n      root.parentNode.removeChild(root);\n      this.moveHandler = null;\n      this.endHandler = null;\n      // @ts-expect-error Can be null when destroyed.\n      this.canvas = null;\n      // @ts-expect-error Can be null when destroyed.\n      this.backgroundPane = null;\n      // @ts-expect-error Can be null when destroyed.\n      this.drawPane = null;\n      // @ts-expect-error Can be null when destroyed.\n      this.overlayPane = null;\n      // @ts-expect-error Can be null when destroyed.\n      this.decoratorPane = null;\n    }\n  }\n}\nexport default GraphView;","map":{"version":3,"names":["Point","Rectangle","Dictionary","EventSource","EventObject","RectangleShape","ALIGN","Client","InternalEvent","convertPoint","getCurrentStyle","getOffset","getRotatedPoint","ptSegDistSq","relativeCcw","toRadians","MaxLog","Translations","CellState","UndoableEdit","ImageShape","InternalMouseEvent","CurrentRootChange","getClientX","getClientY","getSource","isConsumed","clone","StyleRegistry","GraphView","constructor","graph","backgroundImage","backgroundPageShape","EMPTY_POINT","doneResource","language","updatingDocumentResource","allowEval","captureDocumentGesture","rendering","currentRoot","graphBounds","scale","translate","states","updateStyle","lastNode","lastHtmlNode","lastForegroundNode","lastForegroundHtmlNode","endHandler","moveHandler","getGraphBounds","setGraphBounds","value","getScale","setScale","previousScale","isEventsEnabled","viewStateChanged","fireEvent","SCALE","getTranslate","isRendering","setRendering","setTranslate","dx","dy","previousTranslate","x","y","TRANSLATE","isAllowEval","setAllowEval","getStates","setStates","getCanvas","canvas","getBackgroundPane","backgroundPane","getDrawPane","drawPane","getOverlayPane","overlayPane","getDecoratorPane","decoratorPane","getBounds","cells","result","length","i","isVertex","isEdge","state","getState","fromRectangle","add","setCurrentRoot","root","change","execute","edit","UNDO","sizeDidChange","scaleAndTranslate","SCALE_AND_TRANSLATE","revalidate","refresh","clear","invalidate","validate","cell","force","recurse","getDataModel","getRoot","removeState","childCount","getChildCount","getChildAt","includeEdges","model","invalid","invalidating","child","edgeCount","getEdgeCount","getEdgeAt","t0","enter","window","status","get","resetValidationState","c","getBoundingBox","validateCellState","validateCell","getEmptyBounds","validateBackground","leave","bbox","shape","boundingBox","text","bounds","createBackgroundPageShape","validateBackgroundImage","validateBackgroundPage","bg","getBackgroundImage","imageSrc","src","destroy","dialect","init","redraw","redrawBackgroundImage","pageVisible","getBackgroundPageBounds","isShadow","node","isNativeDblClickEnabled","addListener","evt","dblClick","addGestureListeners","fireMouseEvent","MOUSE_DOWN","tooltipHandler","getPlugin","isHideOnHover","hide","isMouseDown","MOUSE_MOVE","MOUSE_UP","fmt","pageFormat","ps","pageScale","width","height","visible","isVisible","isCollapsed","style","invalidStyle","getCellStyle","getParent","setVisibleTerminalState","getVisibleTerminal","updateCellState","cellRenderer","updateCachedBounds","stateValidated","absoluteOffset","origin","parent","pState","offset","getChildOffsetForCell","geo","getGeometry","relative","point","getPoint","unscaledWidth","unscaledHeight","updateVertexState","updateEdgeState","alpha","rotation","cos","Math","sin","ct","getCenterX","getCenterY","cx","pt","updateVertexLabelOffset","source","getVisibleTerminalState","target","getTerminal","getTerminalPoint","updateFixedTerminalPoints","updatePoints","points","updateFloatingTerminalPoints","pts","absolutePoints","updateEdgeBounds","updateEdgeLabelOffset","h","labelPosition","CENTER","LEFT","lw","labelWidth","RIGHT","align","v","verticalLabelPosition","MIDDLE","TOP","BOTTOM","fg","keepEdgesInForeground","keepEdgesInBackground","htmlNode","insertStateAfter","edge","updateFixedTerminalPoint","getConnectionConstraint","terminal","constraint","setAbsoluteTerminalPoint","getFixedTerminalPoint","getConnectionPoint","s","tr","orig","updateBoundsFromStencil","previous","stencil","aspect","asp","computeAspect","setRect","w0","h0","push","edgeStyle","getEdgeStyle","getTerminalPort","trg","srcBounds","trgBounds","transformControlPoint","tmp","ignoreScale","isLoopStyleEnabled","sc","tc","orthogonalLoop","loopStyle","defaultLoopStyle","noEdgeStyle","getValue","eval","p0","pe","updateFloatingTerminalPoint","start","end","getFloatingTerminalPoint","next","getNextPoint","orth","isOrthogonal","center","border","perimeterSpacing","getPerimeterPoint","key","id","getCell","orthogonal","perimeter","getPerimeterFunction","getPerimeterBounds","flipH","flipV","getRoutingCenterX","f","routingCenterX","getRoutingCenterY","routingCenterY","opposite","count","min","max","best","contains","terminalDistance","sqrt","segments","minX","minY","maxX","maxY","segment","markerSize","geometry","gx","pointCount","dist","round","index","factor","gy","offsetX","offsetY","nx","ny","getRelativePoint","edgeState","totalLength","minDist","seg","x2","y2","x1","y1","px","py","xSegment","ySegment","projlenSq","dotprod","projlen","yDistance","direction","x0","y0","off","create","createState","put","getCellStates","getValues","remove","isContainerEvent","container","parentNode","isScrollEvent","clientX","clientY","outWidth","offsetWidth","inWidth","clientWidth","outHeight","offsetHeight","inHeight","clientHeight","installListeners","createSvg","IS_TOUCH","fireGestureEvent","consume","pointerId","IS_GC","IS_SF","getCellAt","view","addMouseListener","mouseDown","sender","me","popupMenuHandler","hideMenu","mouseMove","mouseUp","display","visibility","document","createElementNS","appendChild","left","top","updateContainerStyle","createHtml","createHtmlPane","overflow","updateHtmlCanvasSize","ow","oh","pane","createElement","position","IS_POINTER","touchAction","SVGElement","ownerSVGElement","removeGestureListeners","release","removeChild"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/@maxgraph/core/dist/view/GraphView.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from './geometry/Point';\nimport Rectangle from './geometry/Rectangle';\nimport Dictionary from '../util/Dictionary';\nimport EventSource from './event/EventSource';\nimport EventObject from './event/EventObject';\nimport RectangleShape from './geometry/node/RectangleShape';\nimport { ALIGN } from '../util/Constants';\nimport Client from '../Client';\nimport InternalEvent from './event/InternalEvent';\nimport { convertPoint, getCurrentStyle, getOffset } from '../util/styleUtils';\nimport { getRotatedPoint, ptSegDistSq, relativeCcw, toRadians } from '../util/mathUtils';\nimport MaxLog from '../gui/MaxLog';\nimport Translations from '../util/Translations';\nimport CellState from './cell/CellState';\nimport UndoableEdit from './undoable_changes/UndoableEdit';\nimport ImageShape from './geometry/node/ImageShape';\nimport InternalMouseEvent from './event/InternalMouseEvent';\nimport CurrentRootChange from './undoable_changes/CurrentRootChange';\nimport { getClientX, getClientY, getSource, isConsumed } from '../util/EventUtils';\nimport { clone } from '../util/cloneUtils';\nimport StyleRegistry from './style/StyleRegistry';\n/**\n * @class GraphView\n * @extends {EventSource}\n *\n * Extends {@link EventSource} to implement a view for a graph. This class is in\n * charge of computing the absolute coordinates for the relative child\n * geometries, the points for perimeters and edge styles and keeping them\n * cached in {@link CellState}s for faster retrieval. The states are updated\n * whenever the model or the view state (translate, scale) changes. The scale\n * and translate are honoured in the bounds.\n *\n * #### Event: mxEvent.UNDO\n *\n * Fires after the root was changed in {@link setCurrentRoot}. The `edit`\n * property contains the {@link UndoableEdit} which contains the\n * {@link CurrentRootChange}.\n *\n * #### Event: mxEvent.SCALE_AND_TRANSLATE\n *\n * Fires after the scale and translate have been changed in {@link scaleAndTranslate}.\n * The `scale`, `previousScale`, `translate`\n * and `previousTranslate` properties contain the new and previous\n * scale and translate, respectively.\n *\n * #### Event: mxEvent.SCALE\n *\n * Fires after the scale was changed in {@link setScale}. The `scale` and\n * `previousScale` properties contain the new and previous scale.\n *\n * #### Event: mxEvent.TRANSLATE\n *\n * Fires after the translate was changed in {@link setTranslate}. The\n * `translate` and `previousTranslate` properties contain\n * the new and previous value for translate.\n *\n * #### Event: mxEvent.DOWN and mxEvent.UP\n *\n * Fire if the current root is changed by executing an {@link CurrentRootChange}.\n * The event name depends on the location of the root in the cell hierarchy\n * with respect to the current root. The `root` and\n * `previous` properties contain the new and previous root,\n * respectively.\n */\nexport class GraphView extends EventSource {\n    constructor(graph) {\n        super();\n        // TODO: Document me!\n        this.backgroundImage = null;\n        this.backgroundPageShape = null;\n        this.EMPTY_POINT = new Point();\n        /**\n         * Specifies the resource key for the status message after a long operation.\n         * If the resource for this key does not exist then the value is used as\n         * the status message. Default is 'done'.\n         */\n        this.doneResource = Client.language !== 'none' ? 'done' : '';\n        /**\n         * Specifies the resource key for the status message while the document is\n         * being updated. If the resource for this key does not exist then the\n         * value is used as the status message. Default is 'updatingDocument'.\n         */\n        this.updatingDocumentResource = Client.language !== 'none' ? 'updatingDocument' : '';\n        /**\n         * Specifies if string values in cell styles should be evaluated using\n         * {@link eval}. This will only be used if the string values can't be mapped\n         * to objects using {@link StyleRegistry}. Default is false. NOTE: Enabling this\n         * switch carries a possible security risk.\n         */\n        this.allowEval = false;\n        /**\n         * Specifies if a gesture should be captured when it goes outside of the\n         * graph container. Default is true.\n         */\n        this.captureDocumentGesture = true;\n        /**\n         * Specifies if shapes should be created, updated and destroyed using the\n         * methods of {@link cellRenderer} in {@link graph}. Default is true.\n         */\n        this.rendering = true;\n        /**\n         * {@link Cell} that acts as the root of the displayed cell hierarchy.\n         */\n        this.currentRoot = null;\n        this.graphBounds = new Rectangle();\n        this.scale = 1;\n        /**\n         * {@link Point} that specifies the current translation. Default is a new\n         * empty {@link Point}.\n         */\n        this.translate = new Point();\n        this.states = new Dictionary();\n        /**\n         * Specifies if the style should be updated in each validation step. If this\n         * is false then the style is only updated if the state is created or if the\n         * style of the cell was changed. Default is false.\n         */\n        this.updateStyle = false;\n        /**\n         * During validation, this contains the last DOM node that was processed.\n         */\n        this.lastNode = null;\n        /**\n         * During validation, this contains the last HTML DOM node that was processed.\n         */\n        this.lastHtmlNode = null;\n        /**\n         * During validation, this contains the last edge's DOM node that was processed.\n         */\n        this.lastForegroundNode = null;\n        /**\n         * During validation, this contains the last edge HTML DOM node that was processed.\n         */\n        this.lastForegroundHtmlNode = null;\n        this.endHandler = null;\n        this.moveHandler = null;\n        this.graph = graph;\n    }\n    /**\n     * Returns {@link graphBounds}.\n     */\n    getGraphBounds() {\n        return this.graphBounds;\n    }\n    /**\n     * Sets {@link graphBounds}.\n     */\n    setGraphBounds(value) {\n        this.graphBounds = value;\n    }\n    /**\n     * Returns the {@link scale}.\n     */\n    getScale() {\n        return this.scale;\n    }\n    /**\n     * Sets the scale and fires a {@link scale} event before calling {@link revalidate} followed\n     * by {@link graph.sizeDidChange}.\n     *\n     * @param value Decimal value that specifies the new scale (1 is 100%).\n     */\n    setScale(value) {\n        const previousScale = this.scale;\n        if (previousScale !== value) {\n            this.scale = value;\n            if (this.isEventsEnabled()) {\n                this.viewStateChanged();\n            }\n        }\n        this.fireEvent(new EventObject(InternalEvent.SCALE, { scale: value, previousScale }));\n    }\n    /**\n     * Returns the {@link translate}.\n     */\n    getTranslate() {\n        return this.translate;\n    }\n    isRendering() {\n        return this.rendering;\n    }\n    setRendering(value) {\n        this.rendering = value;\n    }\n    /**\n     * Sets the translation and fires a {@link translate} event before calling\n     * {@link revalidate} followed by {@link graph.sizeDidChange}. The translation is the\n     * negative of the origin.\n     *\n     * @param dx X-coordinate of the translation.\n     * @param dy Y-coordinate of the translation.\n     */\n    setTranslate(dx, dy) {\n        const previousTranslate = new Point(this.translate.x, this.translate.y);\n        if (this.translate.x !== dx || this.translate.y !== dy) {\n            this.translate.x = dx;\n            this.translate.y = dy;\n            if (this.isEventsEnabled()) {\n                this.viewStateChanged();\n            }\n        }\n        this.fireEvent(new EventObject(InternalEvent.TRANSLATE, {\n            translate: this.translate,\n            previousTranslate: previousTranslate,\n        }));\n    }\n    isAllowEval() {\n        return this.allowEval;\n    }\n    setAllowEval(value) {\n        this.allowEval = value;\n    }\n    /**\n     * Returns {@link states}.\n     */\n    getStates() {\n        return this.states;\n    }\n    /**\n     * Sets {@link states}.\n     */\n    setStates(value) {\n        this.states = value;\n    }\n    /**\n     * Returns the DOM node that contains the background-, draw- and\n     * overlay- and decoratorpanes.\n     */\n    getCanvas() {\n        return this.canvas;\n    }\n    /**\n     * Returns the DOM node that represents the background layer.\n     */\n    getBackgroundPane() {\n        return this.backgroundPane;\n    }\n    /**\n     * Returns the DOM node that represents the main drawing layer.\n     */\n    getDrawPane() {\n        return this.drawPane;\n    }\n    /**\n     * Returns the DOM node that represents the layer above the drawing layer.\n     */\n    getOverlayPane() {\n        return this.overlayPane;\n    }\n    /**\n     * Returns the DOM node that represents the topmost drawing layer.\n     */\n    getDecoratorPane() {\n        return this.decoratorPane;\n    }\n    /**\n     * Returns the union of all {@link mxCellStates} for the given array of {@link Cell}.\n     *\n     * @param cells Array of {@link Cell} whose bounds should be returned.\n     */\n    getBounds(cells) {\n        let result = null;\n        if (cells.length > 0) {\n            for (let i = 0; i < cells.length; i += 1) {\n                if (cells[i].isVertex() || cells[i].isEdge()) {\n                    const state = this.getState(cells[i]);\n                    if (state) {\n                        if (!result) {\n                            result = Rectangle.fromRectangle(state);\n                        }\n                        else {\n                            result.add(state);\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Sets and returns the current root and fires an {@link undo} event before\n     * calling {@link graph.sizeDidChange}.\n     *\n     * @param root {@link mxCell} that specifies the root of the displayed cell hierarchy.\n     */\n    setCurrentRoot(root) {\n        if (this.currentRoot !== root) {\n            const change = new CurrentRootChange(this, root);\n            change.execute();\n            const edit = new UndoableEdit(this, true);\n            edit.add(change);\n            this.fireEvent(new EventObject(InternalEvent.UNDO, { edit }));\n            this.graph.sizeDidChange();\n            this.currentRoot = root;\n        }\n        return root;\n    }\n    /**\n     * Sets the scale and translation and fires a {@link scale} and {@link translate} event\n     * before calling {@link revalidate} followed by {@link graph.sizeDidChange}.\n     *\n     * @param scale Decimal value that specifies the new scale (1 is 100%).\n     * @param dx X-coordinate of the translation.\n     * @param dy Y-coordinate of the translation.\n     */\n    scaleAndTranslate(scale, dx, dy) {\n        const previousScale = this.scale;\n        const previousTranslate = new Point(this.translate.x, this.translate.y);\n        if (this.scale !== scale || this.translate.x !== dx || this.translate.y !== dy) {\n            this.scale = scale;\n            this.translate.x = dx;\n            this.translate.y = dy;\n            if (this.isEventsEnabled()) {\n                this.viewStateChanged();\n            }\n        }\n        this.fireEvent(new EventObject(InternalEvent.SCALE_AND_TRANSLATE, {\n            scale,\n            previousScale,\n            translate: this.translate,\n            previousTranslate: previousTranslate,\n        }));\n    }\n    /**\n     * Invoked after {@link scale} and/or {@link translate} has changed.\n     */\n    viewStateChanged() {\n        this.revalidate();\n        this.graph.sizeDidChange();\n    }\n    /**\n     * Clears the view if {@link currentRoot} is not null and revalidates.\n     */\n    refresh() {\n        if (this.currentRoot) {\n            this.clear();\n        }\n        this.revalidate();\n    }\n    /**\n     * Revalidates the complete view with all cell states.\n     */\n    revalidate() {\n        this.invalidate();\n        this.validate();\n    }\n    /**\n     * Removes the state of the given cell and all descendants if the given\n     * cell is not the current root.\n     *\n     * @param cell Optional {@link Cell} for which the state should be removed. Default\n     * is the root of the model.\n     * @param force Boolean indicating if the current root should be ignored for\n     * recursion.\n     */\n    clear(cell, force = false, recurse = true) {\n        if (!cell) {\n            cell = this.graph.getDataModel().getRoot();\n        }\n        if (cell) {\n            this.removeState(cell);\n            if (recurse && (force || cell !== this.currentRoot)) {\n                const childCount = cell.getChildCount();\n                for (let i = 0; i < childCount; i += 1) {\n                    this.clear(cell.getChildAt(i), force);\n                }\n            }\n            else {\n                this.invalidate(cell);\n            }\n        }\n    }\n    /**\n     * Invalidates the state of the given cell, all its descendants and\n     * connected edges.\n     *\n     * @param cell Optional {@link Cell} to be invalidated. Default is the root of the\n     * model.\n     */\n    invalidate(cell = null, recurse = true, includeEdges = true) {\n        const model = this.graph.getDataModel();\n        cell = cell ?? model.getRoot();\n        if (cell) {\n            const state = this.getState(cell);\n            if (state) {\n                state.invalid = true;\n            }\n            // Avoids infinite loops for invalid graphs\n            if (!cell.invalidating) {\n                cell.invalidating = true;\n                // Recursively invalidates all descendants\n                if (recurse) {\n                    const childCount = cell.getChildCount();\n                    for (let i = 0; i < childCount; i += 1) {\n                        const child = cell.getChildAt(i);\n                        this.invalidate(child, recurse, includeEdges);\n                    }\n                }\n                // Propagates invalidation to all connected edges\n                if (includeEdges) {\n                    const edgeCount = cell.getEdgeCount();\n                    for (let i = 0; i < edgeCount; i += 1) {\n                        this.invalidate(cell.getEdgeAt(i), recurse, includeEdges);\n                    }\n                }\n                cell.invalidating = false;\n            }\n        }\n    }\n    /**\n     * Calls {@link validateCell} and {@link validateCellState} and updates the {@link graphBounds}\n     * using {@link getBoundingBox}. Finally the background is validated using\n     * {@link validateBackground}.\n     *\n     * @param cell Optional {@link Cell} to be used as the root of the validation.\n     * Default is {@link currentRoot} or the root of the model.\n     */\n    validate(cell = null) {\n        const t0 = MaxLog.enter('mxGraphView.validate');\n        window.status =\n            Translations.get(this.updatingDocumentResource) || this.updatingDocumentResource;\n        this.resetValidationState();\n        const c = cell || (this.currentRoot ?? this.graph.getDataModel().getRoot());\n        if (c) {\n            const graphBounds = this.getBoundingBox(this.validateCellState(c ? this.validateCell(c) : null));\n            this.setGraphBounds(graphBounds ?? this.getEmptyBounds());\n            this.validateBackground();\n            this.resetValidationState();\n        }\n        window.status = Translations.get(this.doneResource) || this.doneResource;\n        MaxLog.leave('mxGraphView.validate', t0);\n    }\n    /**\n     * Returns the bounds for an empty graph. This returns a rectangle at\n     * {@link translate} with the size of 0 x 0.\n     */\n    getEmptyBounds() {\n        return new Rectangle(this.translate.x * this.scale, this.translate.y * this.scale);\n    }\n    /**\n     * Returns the bounding box of the shape and the label for the given\n     * {@link CellState} and its children if recurse is true.\n     *\n     * @param state {@link CellState} whose bounding box should be returned.\n     * @param recurse Optional boolean indicating if the children should be included.\n     * Default is true.\n     */\n    getBoundingBox(state = null, recurse = true) {\n        let bbox = null;\n        if (state) {\n            if (state.shape && state.shape.boundingBox) {\n                bbox = state.shape.boundingBox.clone();\n            }\n            // Adds label bounding box to graph bounds\n            if (state.text && state.text.boundingBox) {\n                if (bbox) {\n                    bbox.add(state.text.boundingBox);\n                }\n                else {\n                    bbox = state.text.boundingBox.clone();\n                }\n            }\n            if (recurse) {\n                const childCount = state.cell.getChildCount();\n                for (let i = 0; i < childCount; i += 1) {\n                    const bounds = this.getBoundingBox(this.getState(state.cell.getChildAt(i)));\n                    if (bounds) {\n                        if (!bbox) {\n                            bbox = bounds;\n                        }\n                        else {\n                            bbox.add(bounds);\n                        }\n                    }\n                }\n            }\n        }\n        return bbox;\n    }\n    /**\n     * Creates and returns the shape used as the background page.\n     *\n     * @param bounds {@link mxRectangle} that represents the bounds of the shape.\n     */\n    createBackgroundPageShape(bounds) {\n        return new RectangleShape(bounds, 'white', 'black');\n    }\n    /**\n     * Calls {@link validateBackgroundImage} and {@link validateBackgroundPage}.\n     */\n    validateBackground() {\n        this.validateBackgroundImage();\n        this.validateBackgroundPage();\n    }\n    /**\n     * Validates the background image.\n     */\n    validateBackgroundImage() {\n        const bg = this.graph.getBackgroundImage();\n        if (bg) {\n            if (!this.backgroundImage || this.backgroundImage.imageSrc !== bg.src) {\n                if (this.backgroundImage) {\n                    this.backgroundImage.destroy();\n                }\n                const bounds = new Rectangle(0, 0, 1, 1);\n                this.backgroundImage = new ImageShape(bounds, bg.src);\n                this.backgroundImage.dialect = this.graph.dialect;\n                this.backgroundImage.init(this.backgroundPane);\n                this.backgroundImage.redraw();\n            }\n            this.redrawBackgroundImage(this.backgroundImage, bg);\n        }\n        else if (this.backgroundImage) {\n            this.backgroundImage.destroy();\n            this.backgroundImage = null;\n        }\n    }\n    /**\n     * Validates the background page.\n     */\n    validateBackgroundPage() {\n        const graph = this.graph;\n        if (graph.pageVisible) {\n            const bounds = this.getBackgroundPageBounds();\n            if (this.backgroundPageShape == null) {\n                this.backgroundPageShape = this.createBackgroundPageShape(bounds);\n                this.backgroundPageShape.scale = this.scale;\n                this.backgroundPageShape.isShadow = true;\n                this.backgroundPageShape.dialect = this.graph.dialect;\n                this.backgroundPageShape.init(this.backgroundPane);\n                this.backgroundPageShape.redraw();\n                if (this.backgroundPageShape.node) {\n                    // Adds listener for double click handling on background\n                    if (graph.isNativeDblClickEnabled()) {\n                        InternalEvent.addListener(this.backgroundPageShape.node, 'dblclick', ((evt) => {\n                            graph.dblClick(evt);\n                        }));\n                    }\n                    // Adds basic listeners for graph event dispatching outside of the\n                    // container and finishing the handling of a single gesture\n                    InternalEvent.addGestureListeners(this.backgroundPageShape.node, (evt) => {\n                        graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt));\n                    }, (evt) => {\n                        const tooltipHandler = graph.getPlugin('TooltipHandler');\n                        // Hides the tooltip if mouse is outside container\n                        if (tooltipHandler && tooltipHandler.isHideOnHover()) {\n                            tooltipHandler.hide();\n                        }\n                        if (graph.isMouseDown && !isConsumed(evt)) {\n                            graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt));\n                        }\n                    }, (evt) => {\n                        graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt));\n                    });\n                }\n            }\n            else {\n                this.backgroundPageShape.scale = this.scale;\n                this.backgroundPageShape.bounds = bounds;\n                this.backgroundPageShape.redraw();\n            }\n        }\n        else if (this.backgroundPageShape) {\n            this.backgroundPageShape.destroy();\n            this.backgroundPageShape = null;\n        }\n    }\n    /**\n     * Returns the bounds for the background page.\n     */\n    getBackgroundPageBounds() {\n        const fmt = this.graph.pageFormat;\n        const ps = this.scale * this.graph.pageScale;\n        return new Rectangle(this.scale * this.translate.x, this.scale * this.translate.y, fmt.width * ps, fmt.height * ps);\n    }\n    /**\n     * Updates the bounds and redraws the background image.\n     *\n     * Example:\n     *\n     * If the background image should not be scaled, this can be replaced with\n     * the following.\n     *\n     * @example\n     * ```javascript\n     * redrawBackground(backgroundImage, bg)\n     * {\n     *   backgroundImage.bounds.x = this.translate.x;\n     *   backgroundImage.bounds.y = this.translate.y;\n     *   backgroundImage.bounds.width = bg.width;\n     *   backgroundImage.bounds.height = bg.height;\n     *\n     *   backgroundImage.redraw();\n     * };\n     * ```\n     *\n     * @param backgroundImage {@link mxImageShape} that represents the background image.\n     * @param bg {@link mxImage} that specifies the image and its dimensions.\n     */\n    redrawBackgroundImage(backgroundImage, bg) {\n        backgroundImage.scale = this.scale;\n        if (backgroundImage.bounds) {\n            const bounds = backgroundImage.bounds;\n            bounds.x = this.scale * this.translate.x;\n            bounds.y = this.scale * this.translate.y;\n            bounds.width = this.scale * bg.width;\n            bounds.height = this.scale * bg.height;\n        }\n        backgroundImage.redraw();\n    }\n    /**\n     * Recursively creates the cell state for the given cell if visible is true and\n     * the given cell is visible. If the cell is not visible but the state exists\n     * then it is removed using {@link removeState}.\n     *\n     * @param cell {@link mxCell} whose {@link CellState} should be created.\n     * @param visible Optional boolean indicating if the cell should be visible. Default\n     * is true.\n     */\n    validateCell(cell, visible = true) {\n        visible = visible && cell.isVisible();\n        const state = this.getState(cell, visible);\n        if (state && !visible) {\n            this.removeState(cell);\n        }\n        else {\n            const childCount = cell.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                this.validateCell(cell.getChildAt(i), visible && (!cell.isCollapsed() || cell === this.currentRoot));\n            }\n        }\n        return cell;\n    }\n    /**\n     * Validates and repaints the {@link CellState} for the given {@link Cell}.\n     *\n     * @param cell {@link mxCell} whose {@link CellState} should be validated.\n     * @param recurse Optional boolean indicating if the children of the cell should be\n     * validated. Default is true.\n     */\n    validateCellState(cell, recurse = true) {\n        let state = null;\n        if (cell) {\n            state = this.getState(cell);\n            if (state) {\n                if (state.invalid) {\n                    state.invalid = false;\n                    if (!state.style || state.invalidStyle) {\n                        state.style = this.graph.getCellStyle(state.cell);\n                        state.invalidStyle = false;\n                    }\n                    if (cell !== this.currentRoot) {\n                        this.validateCellState(cell.getParent(), false);\n                    }\n                    state.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(cell, true), false), true);\n                    state.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(cell, false), false), false);\n                    this.updateCellState(state);\n                    // Repaint happens immediately after the cell is validated\n                    if (cell !== this.currentRoot && !state.invalid) {\n                        this.graph.cellRenderer.redraw(state, false, this.isRendering());\n                        // Handles changes to invertex paintbounds after update of rendering shape\n                        state.updateCachedBounds();\n                    }\n                }\n                if (recurse && !state.invalid) {\n                    // Updates order in DOM if recursively traversing\n                    if (state.shape) {\n                        this.stateValidated(state);\n                    }\n                    const childCount = cell.getChildCount();\n                    for (let i = 0; i < childCount; i += 1) {\n                        this.validateCellState(cell.getChildAt(i));\n                    }\n                }\n            }\n        }\n        return state;\n    }\n    /**\n     * Updates the given {@link CellState}.\n     *\n     * @param state {@link CellState} to be updated.\n     */\n    updateCellState(state) {\n        const absoluteOffset = state.absoluteOffset;\n        const origin = state.origin;\n        absoluteOffset.x = 0;\n        absoluteOffset.y = 0;\n        origin.x = 0;\n        origin.y = 0;\n        state.length = 0;\n        if (state.cell !== this.currentRoot) {\n            const parent = state.cell.getParent();\n            const pState = parent ? this.getState(parent) : null;\n            if (pState && pState.cell !== this.currentRoot) {\n                origin.x += pState.origin.x;\n                origin.y += pState.origin.y;\n            }\n            let offset = this.graph.getChildOffsetForCell(state.cell);\n            if (offset) {\n                origin.x += offset.x;\n                origin.y += offset.y;\n            }\n            const geo = state.cell.getGeometry();\n            if (geo) {\n                if (!state.cell.isEdge()) {\n                    offset = geo.offset ? geo.offset : this.EMPTY_POINT;\n                    if (geo.relative && pState) {\n                        if (pState.cell.isEdge()) {\n                            const point = this.getPoint(pState, geo);\n                            if (point) {\n                                origin.x += point.x / this.scale - pState.origin.x - this.translate.x;\n                                origin.y += point.y / this.scale - pState.origin.y - this.translate.y;\n                            }\n                        }\n                        else {\n                            origin.x += geo.x * pState.unscaledWidth + offset.x;\n                            origin.y += geo.y * pState.unscaledHeight + offset.y;\n                        }\n                    }\n                    else {\n                        absoluteOffset.x = this.scale * offset.x;\n                        absoluteOffset.y = this.scale * offset.y;\n                        origin.x += geo.x;\n                        origin.y += geo.y;\n                    }\n                }\n                state.x = this.scale * (this.translate.x + origin.x);\n                state.y = this.scale * (this.translate.y + origin.y);\n                state.width = this.scale * geo.width;\n                state.unscaledWidth = geo.width;\n                state.height = this.scale * geo.height;\n                state.unscaledHeight = geo.height;\n                if (state.cell.isVertex()) {\n                    this.updateVertexState(state, geo);\n                }\n                if (state.cell.isEdge()) {\n                    this.updateEdgeState(state, geo);\n                }\n            }\n        }\n        state.updateCachedBounds();\n    }\n    /**\n     * Validates the given cell state.\n     */\n    updateVertexState(state, geo) {\n        const parent = state.cell.getParent();\n        const pState = parent ? this.getState(parent) : null;\n        if (geo.relative && pState && !pState.cell.isEdge()) {\n            const alpha = toRadians(pState.style.rotation ?? 0);\n            if (alpha !== 0) {\n                const cos = Math.cos(alpha);\n                const sin = Math.sin(alpha);\n                const ct = new Point(state.getCenterX(), state.getCenterY());\n                const cx = new Point(pState.getCenterX(), pState.getCenterY());\n                const pt = getRotatedPoint(ct, cos, sin, cx);\n                state.x = pt.x - state.width / 2;\n                state.y = pt.y - state.height / 2;\n            }\n        }\n        this.updateVertexLabelOffset(state);\n    }\n    /**\n     * Validates the given cell state.\n     */\n    updateEdgeState(state, geo) {\n        const source = state.getVisibleTerminalState(true);\n        const target = state.getVisibleTerminalState(false);\n        // This will remove edges with no terminals and no terminal points\n        // as such edges are invalid and produce NPEs in the edge styles.\n        // Also removes connected edges that have no visible terminals.\n        if ((state.cell.getTerminal(true) && !source) ||\n            (!source && !geo.getTerminalPoint(true)) ||\n            (state.cell.getTerminal(false) && !target) ||\n            (!target && !geo.getTerminalPoint(false))) {\n            this.clear(state.cell, true);\n        }\n        else {\n            this.updateFixedTerminalPoints(state, source, target);\n            this.updatePoints(state, geo.points, source, target);\n            this.updateFloatingTerminalPoints(state, source, target);\n            const pts = state.absolutePoints;\n            if (state.cell !== this.currentRoot &&\n                (pts == null || pts.length < 2 || pts[0] == null || pts[pts.length - 1] == null)) {\n                // This will remove edges with invalid points from the list of states in the view.\n                // Happens if the one of the terminals and the corresponding terminal point is null.\n                this.clear(state.cell, true);\n            }\n            else {\n                this.updateEdgeBounds(state);\n                this.updateEdgeLabelOffset(state);\n            }\n        }\n    }\n    /**\n     * Updates the absoluteOffset of the given vertex cell state. This takes\n     * into account the label position styles.\n     *\n     * @param state {@link CellState} whose absolute offset should be updated.\n     */\n    updateVertexLabelOffset(state) {\n        const h = state.style.labelPosition ?? ALIGN.CENTER;\n        if (h === ALIGN.LEFT) {\n            let lw = state.style.labelWidth ?? null;\n            if (lw != null) {\n                lw *= this.scale;\n            }\n            else {\n                lw = state.width;\n            }\n            // @ts-ignore\n            state.absoluteOffset.x -= lw;\n        }\n        else if (h === ALIGN.RIGHT) {\n            // @ts-ignore\n            state.absoluteOffset.x += state.width;\n        }\n        else if (h === ALIGN.CENTER) {\n            const lw = state.style.labelWidth ?? null;\n            if (lw != null) {\n                // Aligns text block with given width inside the vertex width\n                const align = state.style.align ?? ALIGN.CENTER;\n                let dx = 0;\n                if (align === ALIGN.CENTER) {\n                    dx = 0.5;\n                }\n                else if (align === ALIGN.RIGHT) {\n                    dx = 1;\n                }\n                if (dx !== 0) {\n                    // @ts-ignore\n                    state.absoluteOffset.x -= (lw * this.scale - state.width) * dx;\n                }\n            }\n        }\n        const v = state.style.verticalLabelPosition ?? ALIGN.MIDDLE;\n        if (v === ALIGN.TOP) {\n            // @ts-ignore\n            state.absoluteOffset.y -= state.height;\n        }\n        else if (v === ALIGN.BOTTOM) {\n            // @ts-ignore\n            state.absoluteOffset.y += state.height;\n        }\n    }\n    /**\n     * Resets the current validation state.\n     */\n    resetValidationState() {\n        this.lastNode = null;\n        this.lastHtmlNode = null;\n        this.lastForegroundNode = null;\n        this.lastForegroundHtmlNode = null;\n    }\n    /**\n     * Invoked when a state has been processed in {@link validatePoints}. This is used\n     * to update the order of the DOM nodes of the shape.\n     *\n     * @param state {@link CellState} that represents the cell state.\n     */\n    stateValidated(state) {\n        const graph = this.graph;\n        const fg = (state.cell.isEdge() && graph.keepEdgesInForeground) ||\n            (state.cell.isVertex() && graph.keepEdgesInBackground);\n        const htmlNode = fg\n            ? this.lastForegroundHtmlNode || this.lastHtmlNode\n            : this.lastHtmlNode;\n        const node = fg ? this.lastForegroundNode || this.lastNode : this.lastNode;\n        const result = graph.cellRenderer.insertStateAfter(state, node, htmlNode);\n        if (fg) {\n            this.lastForegroundHtmlNode = result[1];\n            this.lastForegroundNode = result[0];\n        }\n        else {\n            this.lastHtmlNode = result[1];\n            this.lastNode = result[0];\n        }\n    }\n    /**\n     * Sets the initial absolute terminal points in the given state before the edge\n     * style is computed.\n     *\n     * @param edge {@link CellState} whose initial terminal points should be updated.\n     * @param source {@link CellState} which represents the source terminal.\n     * @param target {@link CellState} which represents the target terminal.\n     */\n    updateFixedTerminalPoints(edge, source, target) {\n        this.updateFixedTerminalPoint(edge, source, true, this.graph.getConnectionConstraint(edge, source, true));\n        this.updateFixedTerminalPoint(edge, target, false, this.graph.getConnectionConstraint(edge, target, false));\n    }\n    /**\n     * Sets the fixed source or target terminal point on the given edge.\n     *\n     * @param edge <CellState> whose terminal point should be updated.\n     * @param terminal <CellState> which represents the actual terminal.\n     * @param source Boolean that specifies if the terminal is the source.\n     * @param constraint {@link ConnectionConstraint} that specifies the connection.\n     */\n    updateFixedTerminalPoint(edge, terminal, source, constraint) {\n        edge.setAbsoluteTerminalPoint(this.getFixedTerminalPoint(edge, terminal, source, constraint), source);\n    }\n    /**\n     * Returns the fixed source or target terminal point for the given edge.\n     *\n     * @param edge <CellState> whose terminal point should be returned.\n     * @param terminal <CellState> which represents the actual terminal.\n     * @param source Boolean that specifies if the terminal is the source.\n     * @param constraint {@link ConnectionConstraint} that specifies the connection.\n     */\n    getFixedTerminalPoint(edge, terminal, source, constraint) {\n        let pt = null;\n        if (constraint && terminal) {\n            pt = this.graph.getConnectionPoint(terminal, constraint, false); // FIXME Rounding introduced bugs when calculating label positions -> , this.graph.isOrthogonal(edge));\n        }\n        if (!pt && !terminal) {\n            const s = this.scale;\n            const tr = this.translate;\n            const orig = edge.origin;\n            const geo = edge.cell.getGeometry();\n            pt = geo.getTerminalPoint(source);\n            if (pt) {\n                pt = new Point(s * (tr.x + pt.x + orig.x), s * (tr.y + pt.y + orig.y));\n            }\n        }\n        return pt;\n    }\n    /**\n     * Updates the bounds of the given cell state to reflect the bounds of the stencil\n     * if it has a fixed aspect and returns the previous bounds as an {@link Rectangle} if\n     * the bounds have been modified or null otherwise.\n     *\n     * @param edge {@link CellState} whose bounds should be updated.\n     */\n    updateBoundsFromStencil(state) {\n        let previous = null;\n        if (state &&\n            state.shape &&\n            state.shape.stencil &&\n            state.shape.stencil.aspect === 'fixed') {\n            previous = Rectangle.fromRectangle(state);\n            const asp = state.shape.stencil.computeAspect(null, // this argument is not used\n            state.x, state.y, state.width, state.height);\n            state.setRect(asp.x, asp.y, state.shape.stencil.w0 * asp.width, state.shape.stencil.h0 * asp.height);\n        }\n        return previous;\n    }\n    /**\n     * Updates the absolute points in the given state using the specified array\n     * of {@link Point} as the relative points.\n     *\n     * @param edge {@link CellState} whose absolute points should be updated.\n     * @param points Array of {@link Point} that constitute the relative points.\n     * @param source {@link CellState} that represents the source terminal.\n     * @param target {@link CellState} that represents the target terminal.\n     */\n    updatePoints(edge, points, source, target) {\n        const pts = [];\n        pts.push(edge.absolutePoints[0]);\n        const edgeStyle = this.getEdgeStyle(edge, points, source, target);\n        if (edgeStyle && source) {\n            // target can be null\n            const src = this.getTerminalPort(edge, source, true);\n            const trg = target ? this.getTerminalPort(edge, target, false) : null;\n            // Uses the stencil bounds for routing and restores after routing\n            const srcBounds = this.updateBoundsFromStencil(src);\n            const trgBounds = this.updateBoundsFromStencil(trg);\n            edgeStyle(edge, src, trg, points, pts);\n            // Restores previous bounds\n            if (src && srcBounds) {\n                src.setRect(srcBounds.x, srcBounds.y, srcBounds.width, srcBounds.height);\n            }\n            if (trg && trgBounds) {\n                trg.setRect(trgBounds.x, trgBounds.y, trgBounds.width, trgBounds.height);\n            }\n        }\n        else if (points) {\n            for (let i = 0; i < points.length; i += 1) {\n                if (points[i]) {\n                    const pt = clone(points[i]);\n                    pts.push(this.transformControlPoint(edge, pt));\n                }\n            }\n        }\n        const tmp = edge.absolutePoints;\n        pts.push(tmp[tmp.length - 1]);\n        edge.absolutePoints = pts;\n    }\n    /**\n     * Transforms the given control point to an absolute point.\n     */\n    transformControlPoint(state, pt, ignoreScale = false) {\n        if (state && pt) {\n            const orig = state.origin;\n            const scale = ignoreScale ? 1 : this.scale;\n            return new Point(scale * (pt.x + this.translate.x + orig.x), scale * (pt.y + this.translate.y + orig.y));\n        }\n        return null;\n    }\n    /**\n     * Returns true if the given edge should be routed with {@link graph.defaultLoopStyle}\n     * or the {@link CellStateStyle.STYLE_LOOP} defined for the given edge.\n     * This implementation returns `true` if the given edge is a loop and does not\n     */\n    isLoopStyleEnabled(edge, points = [], source = null, target = null) {\n        const sc = this.graph.getConnectionConstraint(edge, source, true);\n        const tc = this.graph.getConnectionConstraint(edge, target, false);\n        if ((points == null || points.length < 2) &&\n            !((edge.style.orthogonalLoop ?? false) ||\n                ((sc == null || sc.point == null) && (tc == null || tc.point == null)))) {\n            return source != null && source === target;\n        }\n        return false;\n    }\n    /**\n     * Returns the edge style function to be used to render the given edge state.\n     */\n    getEdgeStyle(edge, points = [], source = null, target = null) {\n        let edgeStyle = this.isLoopStyleEnabled(edge, points, source, target)\n            ? edge.style.loopStyle ?? this.graph.defaultLoopStyle\n            : !edge.style.noEdgeStyle ?? false\n                ? edge.style.edgeStyle\n                : null;\n        // Converts string values to objects\n        if (typeof edgeStyle === 'string') {\n            let tmp = StyleRegistry.getValue(edgeStyle);\n            if (!tmp && this.isAllowEval()) {\n                tmp = eval(edgeStyle);\n            }\n            edgeStyle = tmp;\n        }\n        if (typeof edgeStyle === 'function') {\n            return edgeStyle;\n        }\n        return null;\n    }\n    /**\n     * Updates the terminal points in the given state after the edge style was\n     * computed for the edge.\n     *\n     * @param state {@link CellState} whose terminal points should be updated.\n     * @param source {@link CellState} that represents the source terminal.\n     * @param target {@link CellState} that represents the target terminal.\n     */\n    updateFloatingTerminalPoints(state, source, target) {\n        const pts = state.absolutePoints;\n        const p0 = pts[0];\n        const pe = pts[pts.length - 1];\n        if (!pe && target) {\n            this.updateFloatingTerminalPoint(state, target, source, false);\n        }\n        if (!p0 && source) {\n            this.updateFloatingTerminalPoint(state, source, target, true);\n        }\n    }\n    /**\n     * Updates the absolute terminal point in the given state for the given\n     * start and end state, where start is the source if source is true.\n     *\n     * @param edge {@link CellState} whose terminal point should be updated.\n     * @param start {@link CellState} for the terminal on \"this\" side of the edge.\n     * @param end {@link CellState} for the terminal on the other side of the edge.\n     * @param source Boolean indicating if start is the source terminal state.\n     */\n    updateFloatingTerminalPoint(edge, start, end, source) {\n        edge.setAbsoluteTerminalPoint(this.getFloatingTerminalPoint(edge, start, end, source), source);\n    }\n    /**\n     * Returns the floating terminal point for the given edge, start and end\n     * state, where start is the source if source is true.\n     *\n     * @param edge {@link CellState} whose terminal point should be returned.\n     * @param start {@link CellState} for the terminal on \"this\" side of the edge.\n     * @param end {@link CellState} for the terminal on the other side of the edge.\n     * @param source Boolean indicating if start is the source terminal state.\n     */\n    getFloatingTerminalPoint(edge, start, end, source) {\n        start = this.getTerminalPort(edge, start, source);\n        let next = this.getNextPoint(edge, end, source);\n        const orth = this.graph.isOrthogonal(edge);\n        const alpha = toRadians(start.style.rotation ?? 0);\n        const center = new Point(start.getCenterX(), start.getCenterY());\n        if (alpha !== 0) {\n            const cos = Math.cos(-alpha);\n            const sin = Math.sin(-alpha);\n            next = getRotatedPoint(next, cos, sin, center);\n        }\n        let border = edge.style.perimeterSpacing ?? 0;\n        border +=\n            edge.style[source ? 'sourcePerimeterSpacing' : 'targetPerimeterSpacing'] ?? 0;\n        let pt = this.getPerimeterPoint(start, next, alpha === 0 && orth, border);\n        if (pt && alpha !== 0) {\n            const cos = Math.cos(alpha);\n            const sin = Math.sin(alpha);\n            pt = getRotatedPoint(pt, cos, sin, center);\n        }\n        return pt;\n    }\n    /**\n     * Returns an {@link CellState} that represents the source or target terminal or\n     * port for the given edge.\n     *\n     * @param state {@link CellState} that represents the state of the edge.\n     * @param terminal {@link CellState} that represents the terminal.\n     * @param source Boolean indicating if the given terminal is the source terminal.\n     */\n    getTerminalPort(state, terminal, source = false) {\n        const key = source ? 'sourcePort' : 'targetPort';\n        const id = state.style[key];\n        if (id) {\n            const cell = this.graph.getDataModel().getCell(id);\n            if (cell) {\n                const tmp = this.getState(cell, false);\n                // Only uses ports where a cell state exists\n                if (tmp) {\n                    terminal = tmp;\n                }\n            }\n        }\n        return terminal;\n    }\n    /**\n     * Returns an {@link Point} that defines the location of the intersection point between\n     * the perimeter and the line between the center of the shape and the given point.\n     *\n     * @param terminal {@link CellState} for the source or target terminal.\n     * @param next {@link Point} that lies outside the given terminal.\n     * @param orthogonal Boolean that specifies if the orthogonal projection onto\n     * the perimeter should be returned. If this is false then the intersection\n     * of the perimeter and the line between the next and the center point is\n     * returned.\n     * @param border Optional border between the perimeter and the shape.\n     */\n    getPerimeterPoint(terminal, next, orthogonal, border = 0) {\n        let point = null;\n        if (terminal != null) {\n            const perimeter = this.getPerimeterFunction(terminal);\n            if (perimeter != null && next != null) {\n                const bounds = this.getPerimeterBounds(terminal, border);\n                if (bounds.width > 0 || bounds.height > 0) {\n                    point = new Point(next.x, next.y);\n                    let flipH = false;\n                    let flipV = false;\n                    if (terminal.cell.isVertex()) {\n                        flipH = !!terminal.style.flipH;\n                        flipV = !!terminal.style.flipV;\n                        if (flipH) {\n                            point.x = 2 * bounds.getCenterX() - point.x;\n                        }\n                        if (flipV) {\n                            point.y = 2 * bounds.getCenterY() - point.y;\n                        }\n                    }\n                    point = perimeter(bounds, terminal, point, orthogonal);\n                    if (point != null) {\n                        if (flipH) {\n                            point.x = 2 * bounds.getCenterX() - point.x;\n                        }\n                        if (flipV) {\n                            point.y = 2 * bounds.getCenterY() - point.y;\n                        }\n                    }\n                }\n            }\n            if (point == null) {\n                point = this.getPoint(terminal);\n            }\n        }\n        return point;\n    }\n    /**\n     * Returns the x-coordinate of the center point for automatic routing.\n     */\n    getRoutingCenterX(state) {\n        const f = state.style ? state.style.routingCenterX ?? 0 : 0;\n        return state.getCenterX() + f * state.width;\n    }\n    /**\n     * Returns the y-coordinate of the center point for automatic routing.\n     */\n    getRoutingCenterY(state) {\n        const f = state.style ? state.style.routingCenterY ?? 0 : 0;\n        return state.getCenterY() + f * state.height;\n    }\n    /**\n     * Returns the perimeter bounds for the given terminal, edge pair as an\n     * {@link Rectangle}.\n     *\n     * If you have a model where each terminal has a relative child that should\n     * act as the graphical endpoint for a connection from/to the terminal, then\n     * this method can be replaced as follows:\n     *\n     * @example\n     * ```javascript\n     * var oldGetPerimeterBounds = getPerimeterBounds;\n     * getPerimeterBounds(terminal, edge, isSource)\n     * {\n     *   var model = this.graph.getDataModel();\n     *   var childCount = model.getChildCount(terminal.cell);\n     *\n     *   if (childCount > 0)\n     *   {\n     *     var child = model.getChildAt(terminal.cell, 0);\n     *     var geo = model.getGeometry(child);\n     *\n     *     if (geo != null &&\n     *         geo.relative)\n     *     {\n     *       var state = this.getState(child);\n     *\n     *       if (state != null)\n     *       {\n     *         terminal = state;\n     *       }\n     *     }\n     *   }\n     *\n     *   return oldGetPerimeterBounds.apply(this, arguments);\n     * };\n     * ```\n     *\n     * @param terminal CellState that represents the terminal.\n     * @param border Number that adds a border between the shape and the perimeter.\n     */\n    getPerimeterBounds(terminal, border = 0) {\n        border += terminal.style.perimeterSpacing ?? 0;\n        return terminal.getPerimeterBounds(border * this.scale);\n    }\n    /**\n     * Returns the perimeter function for the given state.\n     */\n    getPerimeterFunction(state) {\n        let perimeter = state.style.perimeter;\n        // Converts string values to objects\n        if (typeof perimeter === 'string') {\n            let tmp = StyleRegistry.getValue(perimeter);\n            if (tmp == null && this.isAllowEval()) {\n                tmp = eval(perimeter);\n            }\n            perimeter = tmp;\n        }\n        if (typeof perimeter === 'function') {\n            return perimeter;\n        }\n        return null;\n    }\n    /**\n     * Returns the nearest point in the list of absolute points or the center\n     * of the opposite terminal.\n     *\n     * @param edge {@link CellState} that represents the edge.\n     * @param opposite {@link CellState} that represents the opposite terminal.\n     * @param source Boolean indicating if the next point for the source or target\n     * should be returned.\n     */\n    getNextPoint(edge, opposite, source = false) {\n        const pts = edge.absolutePoints;\n        let point = null;\n        if (pts.length >= 2) {\n            const count = pts.length;\n            point = pts[source ? Math.min(1, count - 1) : Math.max(0, count - 2)];\n        }\n        if (!point && opposite) {\n            point = new Point(opposite.getCenterX(), opposite.getCenterY());\n        }\n        return point; // shouldn't return null, but really?\n    }\n    /**\n     * Returns the nearest ancestor terminal that is visible. The edge appears\n     * to be connected to this terminal on the display. The result of this method\n     * is cached in {@link CellState.getVisibleTerminalState}.\n     *\n     * @param edge {@link mxCell} whose visible terminal should be returned.\n     * @param source Boolean that specifies if the source or target terminal\n     * should be returned.\n     */\n    getVisibleTerminal(edge, source) {\n        const model = this.graph.getDataModel();\n        let result = edge.getTerminal(source);\n        let best = result;\n        while (result && result !== this.currentRoot) {\n            if ((best && !best.isVisible()) || result.isCollapsed()) {\n                best = result;\n            }\n            result = result.getParent();\n        }\n        // Checks if the result is valid for the current view state\n        if (best &&\n            (!model.contains(best) ||\n                best.getParent() === model.getRoot() ||\n                best === this.currentRoot)) {\n            best = null;\n        }\n        return best;\n    }\n    /**\n     * Updates the given state using the bounding box of t\n     * he absolute points.\n     * Also updates {@link CellState.terminalDistance}, {@link CellState.length} and\n     * {@link CellState.segments}.\n     *\n     * @param state {@link CellState} whose bounds should be updated.\n     */\n    updateEdgeBounds(state) {\n        const points = state.absolutePoints;\n        const p0 = points[0];\n        const pe = points[points.length - 1];\n        if (p0 && pe && (p0.x !== pe.x || p0.y !== pe.y)) {\n            const dx = pe.x - p0.x;\n            const dy = pe.y - p0.y;\n            state.terminalDistance = Math.sqrt(dx * dx + dy * dy);\n        }\n        else {\n            state.terminalDistance = 0;\n        }\n        let length = 0;\n        const segments = [];\n        let pt = p0;\n        if (pt) {\n            let minX = pt.x;\n            let minY = pt.y;\n            let maxX = minX;\n            let maxY = minY;\n            for (let i = 1; i < points.length; i += 1) {\n                const tmp = points[i];\n                if (tmp) {\n                    const dx = pt.x - tmp.x;\n                    const dy = pt.y - tmp.y;\n                    const segment = Math.sqrt(dx * dx + dy * dy);\n                    segments.push(segment);\n                    length += segment;\n                    pt = tmp;\n                    minX = Math.min(pt.x, minX);\n                    minY = Math.min(pt.y, minY);\n                    maxX = Math.max(pt.x, maxX);\n                    maxY = Math.max(pt.y, maxY);\n                }\n            }\n            state.length = length;\n            state.segments = segments;\n            const markerSize = 1; // TODO: include marker size\n            state.x = minX;\n            state.y = minY;\n            state.width = Math.max(markerSize, maxX - minX);\n            state.height = Math.max(markerSize, maxY - minY);\n        }\n    }\n    /**\n     * Returns the absolute point on the edge for the given relative\n     * {@link Geometry} as an {@link Point}. The edge is represented by the given\n     * {@link CellState}.\n     *\n     * @param state {@link CellState} that represents the state of the parent edge.\n     * @param geometry {@link mxGeometry} that represents the relative location.\n     */\n    getPoint(state, geometry = null) {\n        let x = state.getCenterX();\n        let y = state.getCenterY();\n        if (state.segments != null && (geometry == null || geometry.relative)) {\n            const gx = geometry != null ? geometry.x / 2 : 0;\n            const pointCount = state.absolutePoints.length;\n            const dist = Math.round((gx + 0.5) * state.length);\n            let segment = state.segments[0];\n            let length = 0;\n            let index = 1;\n            while (dist >= Math.round(length + segment) && index < pointCount - 1) {\n                length += segment;\n                segment = state.segments[index++];\n            }\n            const factor = segment === 0 ? 0 : (dist - length) / segment;\n            const p0 = state.absolutePoints[index - 1];\n            const pe = state.absolutePoints[index];\n            if (p0 != null && pe != null) {\n                let gy = 0;\n                let offsetX = 0;\n                let offsetY = 0;\n                if (geometry != null) {\n                    gy = geometry.y;\n                    const { offset } = geometry;\n                    if (offset != null) {\n                        offsetX = offset.x;\n                        offsetY = offset.y;\n                    }\n                }\n                const dx = pe.x - p0.x;\n                const dy = pe.y - p0.y;\n                const nx = segment === 0 ? 0 : dy / segment;\n                const ny = segment === 0 ? 0 : dx / segment;\n                x = p0.x + dx * factor + (nx * gy + offsetX) * this.scale;\n                y = p0.y + dy * factor - (ny * gy - offsetY) * this.scale;\n            }\n        }\n        else if (geometry != null) {\n            const { offset } = geometry;\n            if (offset != null) {\n                x += offset.x;\n                y += offset.y;\n            }\n        }\n        return new Point(x, y);\n    }\n    /**\n     * Gets the relative point that describes the given, absolute label\n     * position for the given edge state.\n     *\n     * @param state {@link CellState} that represents the state of the parent edge.\n     * @param x Specifies the x-coordinate of the absolute label location.\n     * @param y Specifies the y-coordinate of the absolute label location.\n     */\n    getRelativePoint(edgeState, x, y) {\n        const geometry = edgeState.cell.getGeometry();\n        if (geometry) {\n            const absolutePoints = edgeState.absolutePoints;\n            const pointCount = absolutePoints.length;\n            if (geometry.relative && pointCount > 1) {\n                const totalLength = edgeState.length;\n                const { segments } = edgeState;\n                // Works out which line segment the point of the label is closest to\n                let p0 = absolutePoints[0];\n                let pe = absolutePoints[1];\n                let minDist = ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y);\n                let length = 0;\n                let index = 0;\n                let tmp = 0;\n                for (let i = 2; i < pointCount; i += 1) {\n                    p0 = pe;\n                    pe = absolutePoints[i];\n                    const dist = ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y);\n                    tmp += segments[i - 2];\n                    if (dist <= minDist) {\n                        minDist = dist;\n                        index = i - 1;\n                        length = tmp;\n                    }\n                }\n                const seg = segments[index];\n                p0 = absolutePoints[index];\n                pe = absolutePoints[index + 1];\n                const x2 = p0.x;\n                const y2 = p0.y;\n                const x1 = pe.x;\n                const y1 = pe.y;\n                let px = x;\n                let py = y;\n                const xSegment = x2 - x1;\n                const ySegment = y2 - y1;\n                px -= x1;\n                py -= y1;\n                let projlenSq = 0;\n                px = xSegment - px;\n                py = ySegment - py;\n                const dotprod = px * xSegment + py * ySegment;\n                if (dotprod <= 0.0) {\n                    projlenSq = 0;\n                }\n                else {\n                    projlenSq = (dotprod * dotprod) / (xSegment * xSegment + ySegment * ySegment);\n                }\n                let projlen = Math.sqrt(projlenSq);\n                if (projlen > seg) {\n                    projlen = seg;\n                }\n                let yDistance = Math.sqrt(ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y));\n                const direction = relativeCcw(p0.x, p0.y, pe.x, pe.y, x, y);\n                if (direction === -1) {\n                    yDistance = -yDistance;\n                }\n                // Constructs the relative point for the label\n                return new Point(((totalLength / 2 - length - projlen) / totalLength) * -2, yDistance / this.scale);\n            }\n        }\n        return new Point();\n    }\n    /**\n     * Updates {@link CellState.absoluteOffset} for the given state. The absolute\n     * offset is normally used for the position of the edge label. Is is\n     * calculated from the geometry as an absolute offset from the center\n     * between the two endpoints if the geometry is absolute, or as the\n     * relative distance between the center along the line and the absolute\n     * orthogonal distance if the geometry is relative.\n     *\n     * @param state {@link CellState} whose absolute offset should be updated.\n     */\n    updateEdgeLabelOffset(state) {\n        const points = state.absolutePoints;\n        const absoluteOffset = state.absoluteOffset;\n        absoluteOffset.x = state.getCenterX();\n        absoluteOffset.y = state.getCenterY();\n        if (points.length > 0 && state.segments) {\n            const geometry = state.cell.getGeometry();\n            if (geometry) {\n                if (geometry.relative) {\n                    const offset = this.getPoint(state, geometry);\n                    state.absoluteOffset = offset;\n                }\n                else {\n                    const p0 = points[0];\n                    const pe = points[points.length - 1];\n                    if (p0 && pe) {\n                        const dx = pe.x - p0.x;\n                        const dy = pe.y - p0.y;\n                        let x0 = 0;\n                        let y0 = 0;\n                        const off = geometry.offset;\n                        if (off) {\n                            x0 = off.x;\n                            y0 = off.y;\n                        }\n                        const x = p0.x + dx / 2 + x0 * this.scale;\n                        const y = p0.y + dy / 2 + y0 * this.scale;\n                        absoluteOffset.x = x;\n                        absoluteOffset.y = y;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Returns the {@link CellState} for the given cell. If create is true, then\n     * the state is created if it does not yet exist.\n     *\n     * @param cell {@link mxCell} for which the {@link CellState} should be returned.\n     * @param create Optional boolean indicating if a new state should be created\n     * if it does not yet exist. Default is false.\n     */\n    getState(cell, create = false) {\n        let state = this.states.get(cell);\n        if (create && (!state || this.updateStyle) && cell.isVisible()) {\n            if (!state) {\n                state = this.createState(cell);\n                this.states.put(cell, state);\n            }\n            else {\n                state.style = this.graph.getCellStyle(cell);\n            }\n        }\n        return state;\n    }\n    /**\n     * Returns the {@link mxCellStates} for the given array of {@link Cell}. The array\n     * contains all states that are not null, that is, the returned array may\n     * have less elements than the given array. If no argument is given, then\n     * this returns {@link states}.\n     */\n    getCellStates(cells = null) {\n        if (!cells) {\n            return this.states.getValues();\n        }\n        const result = [];\n        for (const cell of cells) {\n            const state = this.getState(cell);\n            if (state) {\n                result.push(state);\n            }\n        }\n        return result;\n    }\n    /**\n     * Removes and returns the {@link CellState} for the given cell.\n     *\n     * @param cell {@link mxCell} for which the {@link CellState} should be removed.\n     */\n    removeState(cell) {\n        const state = this.states.remove(cell);\n        if (state) {\n            this.graph.cellRenderer.destroy(state);\n            state.invalid = true;\n            state.destroy();\n        }\n        return state;\n    }\n    /**\n     * Creates and returns an {@link CellState} for the given cell and initializes\n     * it using {@link cellRenderer.initialize}.\n     *\n     * @param cell {@link mxCell} for which a new {@link CellState} should be created.\n     */\n    createState(cell) {\n        return new CellState(this, cell, this.graph.getCellStyle(cell));\n    }\n    /**\n     * Returns true if the event origin is one of the drawing panes or\n     * containers of the view.\n     */\n    isContainerEvent(evt) {\n        const source = getSource(evt);\n        return (source &&\n            (source === this.graph.container ||\n                // @ts-ignore parentNode may exist\n                source.parentNode === this.backgroundPane ||\n                // @ts-ignore parentNode may exist\n                (source.parentNode && source.parentNode.parentNode === this.backgroundPane) ||\n                source === this.canvas.parentNode ||\n                source === this.canvas ||\n                source === this.backgroundPane ||\n                source === this.drawPane ||\n                source === this.overlayPane ||\n                source === this.decoratorPane));\n    }\n    /**\n     * Returns true if the event origin is one of the scrollbars of the\n     * container in IE. Such events are ignored.\n     */\n    isScrollEvent(evt) {\n        const graph = this.graph;\n        const offset = getOffset(graph.container);\n        const pt = new Point(evt.clientX - offset.x, evt.clientY - offset.y);\n        const container = graph.container;\n        const outWidth = container.offsetWidth;\n        const inWidth = container.clientWidth;\n        if (outWidth > inWidth && pt.x > inWidth + 2 && pt.x <= outWidth) {\n            return true;\n        }\n        const outHeight = container.offsetHeight;\n        const inHeight = container.clientHeight;\n        return outHeight > inHeight && pt.y > inHeight + 2 && pt.y <= outHeight;\n    }\n    /**\n     * Initializes the graph event dispatch loop for the specified container\n     * and invokes {@link create} to create the required DOM nodes for the display.\n     */\n    init() {\n        this.installListeners();\n        this.createSvg();\n    }\n    /**\n     * Installs the required listeners in the container.\n     */\n    installListeners() {\n        const graph = this.graph;\n        const { container } = graph;\n        // Support for touch device gestures (eg. pinch to zoom)\n        // Double-tap handling is implemented in mxGraph.fireMouseEvent\n        if (Client.IS_TOUCH) {\n            InternalEvent.addListener(container, 'gesturestart', ((evt) => {\n                graph.fireGestureEvent(evt);\n                InternalEvent.consume(evt);\n            }));\n            InternalEvent.addListener(container, 'gesturechange', ((evt) => {\n                graph.fireGestureEvent(evt);\n                InternalEvent.consume(evt);\n            }));\n            InternalEvent.addListener(container, 'gestureend', ((evt) => {\n                graph.fireGestureEvent(evt);\n                InternalEvent.consume(evt);\n            }));\n        }\n        // Fires event only for one pointer per gesture\n        let pointerId = null;\n        // Adds basic listeners for graph event dispatching\n        InternalEvent.addGestureListeners(container, ((evt) => {\n            // Condition to avoid scrollbar events starting a rubberband selection\n            if (this.isContainerEvent(evt) &&\n                ((!Client.IS_GC && !Client.IS_SF) || !this.isScrollEvent(evt))) {\n                graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt));\n                // @ts-ignore\n                pointerId = evt.pointerId;\n            }\n        }), (evt) => {\n            if (this.isContainerEvent(evt) &&\n                // @ts-ignore\n                (pointerId === null || evt.pointerId === pointerId)) {\n                graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt));\n            }\n        }, (evt) => {\n            if (this.isContainerEvent(evt)) {\n                graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt));\n            }\n            pointerId = null;\n        });\n        // Adds listener for double click handling on background, this does always\n        // use native event handler, we assume that the DOM of the background\n        // does not change during the double click\n        InternalEvent.addListener(container, 'dblclick', ((evt) => {\n            if (this.isContainerEvent(evt)) {\n                graph.dblClick(evt);\n            }\n        }));\n        // Workaround for touch events which started on some DOM node\n        // on top of the container, in which case the cells under the\n        // mouse for the move and up events are not detected.\n        const getState = (evt) => {\n            let state = null;\n            // Workaround for touch events which started on some DOM node\n            // on top of the container, in which case the cells under the\n            // mouse for the move and up events are not detected.\n            if (Client.IS_TOUCH) {\n                const x = getClientX(evt);\n                const y = getClientY(evt);\n                // Dispatches the drop event to the graph which\n                // consumes and executes the source function\n                const pt = convertPoint(container, x, y);\n                const cell = graph.getCellAt(pt.x, pt.y);\n                if (cell)\n                    state = graph.view.getState(cell);\n            }\n            return state;\n        };\n        // Adds basic listeners for graph event dispatching outside of the\n        // container and finishing the handling of a single gesture\n        // Implemented via graph event dispatch loop to avoid duplicate events\n        // in Firefox and Chrome\n        graph.addMouseListener({\n            mouseDown: (sender, me) => {\n                const popupMenuHandler = graph.getPlugin('PopupMenuHandler');\n                popupMenuHandler?.hideMenu();\n            },\n            mouseMove: () => {\n                return;\n            },\n            mouseUp: () => {\n                return;\n            },\n        });\n        this.moveHandler = (evt) => {\n            const tooltipHandler = graph.getPlugin('TooltipHandler');\n            // Hides the tooltip if mouse is outside container\n            if (tooltipHandler && tooltipHandler.isHideOnHover()) {\n                tooltipHandler.hide();\n            }\n            if (this.captureDocumentGesture &&\n                graph.isMouseDown &&\n                graph.container != null &&\n                !this.isContainerEvent(evt) &&\n                graph.container.style.display !== 'none' &&\n                graph.container.style.visibility !== 'hidden' &&\n                !isConsumed(evt)) {\n                graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, getState(evt)));\n            }\n        };\n        this.endHandler = (evt) => {\n            if (this.captureDocumentGesture &&\n                graph.isMouseDown &&\n                graph.container != null &&\n                !this.isContainerEvent(evt) &&\n                graph.container.style.display !== 'none' &&\n                graph.container.style.visibility !== 'hidden') {\n                graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt));\n            }\n        };\n        InternalEvent.addGestureListeners(document, null, this.moveHandler, this.endHandler);\n    }\n    /**\n     * Creates and returns the DOM nodes for the SVG display.\n     */\n    createSvg() {\n        const { container } = this.graph;\n        const canvas = (this.canvas = document.createElementNS('http://www.w3.org/2000/svg', 'g'));\n        // For background image\n        this.backgroundPane = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n        canvas.appendChild(this.backgroundPane);\n        // Adds two layers (background is early feature)\n        this.drawPane = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n        canvas.appendChild(this.drawPane);\n        this.overlayPane = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n        canvas.appendChild(this.overlayPane);\n        this.decoratorPane = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n        canvas.appendChild(this.decoratorPane);\n        const root = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        root.style.left = '0px';\n        root.style.top = '0px';\n        root.style.width = '100%';\n        root.style.height = '100%';\n        // NOTE: In standards mode, the SVG must have block layout\n        // in order for the container DIV to not show scrollbars.\n        root.style.display = 'block';\n        root.appendChild(this.canvas);\n        if (container != null) {\n            container.appendChild(root);\n            this.updateContainerStyle(container);\n        }\n    }\n    /**\n     * Function: createHtml\n     *\n     * Creates the DOM nodes for the HTML display.\n     */\n    createHtml() {\n        const container = this.graph.container;\n        if (container != null) {\n            this.canvas = this.createHtmlPane('100%', '100%');\n            this.canvas.style.overflow = 'hidden';\n            // Uses minimal size for inner DIVs on Canvas. This is required\n            // for correct event processing in IE. If we have an overlapping\n            // DIV then the events on the cells are only fired for labels.\n            this.backgroundPane = this.createHtmlPane('1px', '1px');\n            this.drawPane = this.createHtmlPane('1px', '1px');\n            this.overlayPane = this.createHtmlPane('1px', '1px');\n            this.decoratorPane = this.createHtmlPane('1px', '1px');\n            this.canvas.appendChild(this.backgroundPane);\n            this.canvas.appendChild(this.drawPane);\n            this.canvas.appendChild(this.overlayPane);\n            this.canvas.appendChild(this.decoratorPane);\n            container.appendChild(this.canvas);\n            this.updateContainerStyle(container);\n        }\n    }\n    /**\n     * Function: updateHtmlCanvasSize\n     *\n     * Updates the size of the HTML canvas.\n     */\n    updateHtmlCanvasSize(width, height) {\n        if (this.graph.container != null) {\n            const ow = this.graph.container.offsetWidth;\n            const oh = this.graph.container.offsetHeight;\n            if (ow < width) {\n                this.canvas.style.width = width + 'px';\n            }\n            else {\n                this.canvas.style.width = '100%';\n            }\n            if (oh < height) {\n                this.canvas.style.height = height + 'px';\n            }\n            else {\n                this.canvas.style.height = '100%';\n            }\n        }\n    }\n    /**\n     * Function: createHtmlPane\n     *\n     * Creates and returns a drawing pane in HTML (DIV).\n     */\n    createHtmlPane(width, height) {\n        const pane = document.createElement('DIV');\n        if (width != null && height != null) {\n            pane.style.position = 'absolute';\n            pane.style.left = '0px';\n            pane.style.top = '0px';\n            pane.style.width = width;\n            pane.style.height = height;\n        }\n        else {\n            pane.style.position = 'relative';\n        }\n        return pane;\n    }\n    /**\n     * Updates the style of the container after installing the SVG DOM elements.\n     */\n    updateContainerStyle(container) {\n        // Workaround for offset of container\n        const style = getCurrentStyle(container);\n        if (style != null && style.position == 'static') {\n            container.style.position = 'relative';\n        }\n        // Disables built-in pan and zoom in IE10 and later\n        if (Client.IS_POINTER) {\n            container.style.touchAction = 'none';\n        }\n    }\n    /**\n     * Destroys the view and all its resources.\n     */\n    destroy() {\n        let root = null;\n        if (this.canvas && this.canvas instanceof SVGElement) {\n            root = this.canvas.ownerSVGElement;\n        }\n        if (!root) {\n            root = this.canvas;\n        }\n        if (root && root.parentNode) {\n            this.clear(this.currentRoot, true);\n            InternalEvent.removeGestureListeners(document, null, this.moveHandler, this.endHandler);\n            InternalEvent.release(this.graph.container);\n            root.parentNode.removeChild(root);\n            this.moveHandler = null;\n            this.endHandler = null;\n            // @ts-expect-error Can be null when destroyed.\n            this.canvas = null;\n            // @ts-expect-error Can be null when destroyed.\n            this.backgroundPane = null;\n            // @ts-expect-error Can be null when destroyed.\n            this.drawPane = null;\n            // @ts-expect-error Can be null when destroyed.\n            this.overlayPane = null;\n            // @ts-expect-error Can be null when destroyed.\n            this.decoratorPane = null;\n        }\n    }\n}\nexport default GraphView;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}