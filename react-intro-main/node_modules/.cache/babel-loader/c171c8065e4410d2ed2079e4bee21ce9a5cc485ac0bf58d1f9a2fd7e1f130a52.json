{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { isMultiTouchEvent } from '../../util/EventUtils';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport { Graph } from '../Graph';\nimport { mixInto } from '../../util/Utils';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst EditingMixin = {\n  /**\n   * Specifies the return value for {@link isCellEditable}.\n   * @default true\n   */\n  cellsEditable: true,\n  /*****************************************************************************\n   * Group: Cell in-place editing\n   *****************************************************************************/\n  /**\n   * Calls {@link startEditingAtCell} using the given cell or the first selection\n   * cell.\n   *\n   * @param evt Optional mouse event that triggered the editing.\n   */\n  startEditing(evt) {\n    this.startEditingAtCell(null, evt);\n  },\n  /**\n   * Fires a {@link InternalEvent.START_EDITING} event and invokes {@link CellEditorHandler.startEditing}.\n   * After editing was started, a {@link InternalEvent.EDITING_STARTED} event is\n   * fired.\n   *\n   * @param cell {@link mxCell} to start the in-place editor for.\n   * @param evt Optional mouse event that triggered the editing.\n   */\n  startEditingAtCell() {\n    let cell = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let evt = arguments.length > 1 ? arguments[1] : undefined;\n    if (!evt || !isMultiTouchEvent(evt)) {\n      if (!cell) {\n        cell = this.getSelectionCell();\n        if (cell && !this.isCellEditable(cell)) {\n          cell = null;\n        }\n      } else {\n        this.fireEvent(new EventObject(InternalEvent.START_EDITING, {\n          cell,\n          event: evt\n        }));\n        const cellEditorHandler = this.getPlugin('CellEditorHandler');\n        cellEditorHandler === null || cellEditorHandler === void 0 || cellEditorHandler.startEditing(cell, evt);\n        this.fireEvent(new EventObject(InternalEvent.EDITING_STARTED, {\n          cell,\n          event: evt\n        }));\n      }\n    }\n  },\n  /**\n   * Returns the initial value for in-place editing. This implementation\n   * returns {@link convertValueToString} for the given cell. If this function is\n   * overridden, then {@link GraphDataModel.valueForCellChanged} should take care\n   * of correctly storing the actual new value inside the user object.\n   *\n   * @param cell {@link mxCell} for which the initial editing value should be returned.\n   * @param evt Optional mouse event that triggered the editor.\n   */\n  getEditingValue(cell, evt) {\n    return this.convertValueToString(cell);\n  },\n  /**\n   * Stops the current editing  and fires a {@link InternalEvent.EDITING_STOPPED} event.\n   *\n   * @param cancel Boolean that specifies if the current editing value\n   * should be stored.\n   */\n  stopEditing() {\n    let cancel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const cellEditorHandler = this.getPlugin('CellEditorHandler');\n    cellEditorHandler === null || cellEditorHandler === void 0 || cellEditorHandler.stopEditing(cancel);\n    this.fireEvent(new EventObject(InternalEvent.EDITING_STOPPED, {\n      cancel\n    }));\n  },\n  /**\n   * Sets the label of the specified cell to the given value using\n   * {@link cellLabelChanged} and fires {@link InternalEvent.LABEL_CHANGED} while the\n   * transaction is in progress. Returns the cell whose label was changed.\n   *\n   * @param cell {@link mxCell} whose label should be changed.\n   * @param value New label to be assigned.\n   * @param evt Optional event that triggered the change.\n   */\n  labelChanged(cell, value, evt) {\n    this.batchUpdate(() => {\n      const old = cell.value;\n      this.cellLabelChanged(cell, value, this.isAutoSizeCell(cell));\n      this.fireEvent(new EventObject(InternalEvent.LABEL_CHANGED, {\n        cell: cell,\n        value: value,\n        old: old,\n        event: evt\n      }));\n    });\n    return cell;\n  },\n  /**\n   * Sets the new label for a cell. If autoSize is true then\n   * {@link cellSizeUpdated} will be called.\n   *\n   * In the following example, the function is extended to map changes to\n   * attributes in an XML node, as shown in {@link convertValueToString}.\n   * Alternatively, the handling of this can be implemented as shown in\n   * {@link GraphDataModel.valueForCellChanged} without the need to clone the\n   * user object.\n   *\n   * ```javascript\n   * var graphCellLabelChanged = graph.cellLabelChanged;\n   * graph.cellLabelChanged = function(cell, newValue, autoSize)\n   * {\n   * \t// Cloned for correct undo/redo\n   * \tvar elt = cell.value.cloneNode(true);\n   *  elt.setAttribute('label', newValue);\n   *\n   *  newValue = elt;\n   *  graphCellLabelChanged.apply(this, arguments);\n   * };\n   * ```\n   *\n   * @param cell {@link mxCell} whose label should be changed.\n   * @param value New label to be assigned.\n   * @param autoSize Boolean that specifies if {@link cellSizeUpdated} should be called.\n   */\n  cellLabelChanged(cell, value) {\n    let autoSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    this.batchUpdate(() => {\n      this.getDataModel().setValue(cell, value);\n      if (autoSize) {\n        this.cellSizeUpdated(cell, false);\n      }\n    });\n  },\n  /*****************************************************************************\n   * Group: Graph behaviour\n   *****************************************************************************/\n  /**\n   * Returns true if the given cell is currently being edited.\n   * If no cell is specified then this returns true if any\n   * cell is currently being edited.\n   *\n   * @param cell {@link Cell} that should be checked.\n   */\n  isEditing() {\n    let cell = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    const cellEditorHandler = this.getPlugin('CellEditorHandler');\n    const editingCell = cellEditorHandler === null || cellEditorHandler === void 0 ? void 0 : cellEditorHandler.getEditingCell();\n    return !cell ? !!editingCell : cell === editingCell;\n  },\n  /**\n   * Returns true if the given cell is editable. This returns {@link cellsEditable} for\n   * all given cells if {@link isCellLocked} does not return true for the given cell\n   * and its style does not specify {@link 'editable'} to be 0.\n   *\n   * @param cell {@link mxCell} whose editable state should be returned.\n   */\n  isCellEditable(cell) {\n    const style = this.getCurrentCellStyle(cell);\n    return this.isCellsEditable() && !this.isCellLocked(cell) && (style.editable || false);\n  },\n  /**\n   * Returns {@link cellsEditable}.\n   */\n  isCellsEditable() {\n    return this.cellsEditable;\n  },\n  /**\n   * Specifies if the graph should allow in-place editing for cell labels.\n   * This implementation updates {@link cellsEditable}.\n   *\n   * @param value Boolean indicating if the graph should allow in-place\n   * editing.\n   */\n  setCellsEditable(value) {\n    this.cellsEditable = value;\n  }\n};\nmixInto(Graph)(EditingMixin);","map":{"version":3,"names":["isMultiTouchEvent","EventObject","InternalEvent","Graph","mixInto","EditingMixin","cellsEditable","startEditing","evt","startEditingAtCell","cell","arguments","length","undefined","getSelectionCell","isCellEditable","fireEvent","START_EDITING","event","cellEditorHandler","getPlugin","EDITING_STARTED","getEditingValue","convertValueToString","stopEditing","cancel","EDITING_STOPPED","labelChanged","value","batchUpdate","old","cellLabelChanged","isAutoSizeCell","LABEL_CHANGED","autoSize","getDataModel","setValue","cellSizeUpdated","isEditing","editingCell","getEditingCell","style","getCurrentCellStyle","isCellsEditable","isCellLocked","editable","setCellsEditable"],"sources":["D:/ospanel/domains/old/react/react-intro/node_modules/@maxgraph/core/dist/view/mixins/EditingMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { isMultiTouchEvent } from '../../util/EventUtils';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport { Graph } from '../Graph';\nimport { mixInto } from '../../util/Utils';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst EditingMixin = {\n    /**\n     * Specifies the return value for {@link isCellEditable}.\n     * @default true\n     */\n    cellsEditable: true,\n    /*****************************************************************************\n     * Group: Cell in-place editing\n     *****************************************************************************/\n    /**\n     * Calls {@link startEditingAtCell} using the given cell or the first selection\n     * cell.\n     *\n     * @param evt Optional mouse event that triggered the editing.\n     */\n    startEditing(evt) {\n        this.startEditingAtCell(null, evt);\n    },\n    /**\n     * Fires a {@link InternalEvent.START_EDITING} event and invokes {@link CellEditorHandler.startEditing}.\n     * After editing was started, a {@link InternalEvent.EDITING_STARTED} event is\n     * fired.\n     *\n     * @param cell {@link mxCell} to start the in-place editor for.\n     * @param evt Optional mouse event that triggered the editing.\n     */\n    startEditingAtCell(cell = null, evt) {\n        if (!evt || !isMultiTouchEvent(evt)) {\n            if (!cell) {\n                cell = this.getSelectionCell();\n                if (cell && !this.isCellEditable(cell)) {\n                    cell = null;\n                }\n            }\n            else {\n                this.fireEvent(new EventObject(InternalEvent.START_EDITING, { cell, event: evt }));\n                const cellEditorHandler = this.getPlugin('CellEditorHandler');\n                cellEditorHandler?.startEditing(cell, evt);\n                this.fireEvent(new EventObject(InternalEvent.EDITING_STARTED, { cell, event: evt }));\n            }\n        }\n    },\n    /**\n     * Returns the initial value for in-place editing. This implementation\n     * returns {@link convertValueToString} for the given cell. If this function is\n     * overridden, then {@link GraphDataModel.valueForCellChanged} should take care\n     * of correctly storing the actual new value inside the user object.\n     *\n     * @param cell {@link mxCell} for which the initial editing value should be returned.\n     * @param evt Optional mouse event that triggered the editor.\n     */\n    getEditingValue(cell, evt) {\n        return this.convertValueToString(cell);\n    },\n    /**\n     * Stops the current editing  and fires a {@link InternalEvent.EDITING_STOPPED} event.\n     *\n     * @param cancel Boolean that specifies if the current editing value\n     * should be stored.\n     */\n    stopEditing(cancel = false) {\n        const cellEditorHandler = this.getPlugin('CellEditorHandler');\n        cellEditorHandler?.stopEditing(cancel);\n        this.fireEvent(new EventObject(InternalEvent.EDITING_STOPPED, { cancel }));\n    },\n    /**\n     * Sets the label of the specified cell to the given value using\n     * {@link cellLabelChanged} and fires {@link InternalEvent.LABEL_CHANGED} while the\n     * transaction is in progress. Returns the cell whose label was changed.\n     *\n     * @param cell {@link mxCell} whose label should be changed.\n     * @param value New label to be assigned.\n     * @param evt Optional event that triggered the change.\n     */\n    labelChanged(cell, value, evt) {\n        this.batchUpdate(() => {\n            const old = cell.value;\n            this.cellLabelChanged(cell, value, this.isAutoSizeCell(cell));\n            this.fireEvent(new EventObject(InternalEvent.LABEL_CHANGED, {\n                cell: cell,\n                value: value,\n                old: old,\n                event: evt,\n            }));\n        });\n        return cell;\n    },\n    /**\n     * Sets the new label for a cell. If autoSize is true then\n     * {@link cellSizeUpdated} will be called.\n     *\n     * In the following example, the function is extended to map changes to\n     * attributes in an XML node, as shown in {@link convertValueToString}.\n     * Alternatively, the handling of this can be implemented as shown in\n     * {@link GraphDataModel.valueForCellChanged} without the need to clone the\n     * user object.\n     *\n     * ```javascript\n     * var graphCellLabelChanged = graph.cellLabelChanged;\n     * graph.cellLabelChanged = function(cell, newValue, autoSize)\n     * {\n     * \t// Cloned for correct undo/redo\n     * \tvar elt = cell.value.cloneNode(true);\n     *  elt.setAttribute('label', newValue);\n     *\n     *  newValue = elt;\n     *  graphCellLabelChanged.apply(this, arguments);\n     * };\n     * ```\n     *\n     * @param cell {@link mxCell} whose label should be changed.\n     * @param value New label to be assigned.\n     * @param autoSize Boolean that specifies if {@link cellSizeUpdated} should be called.\n     */\n    cellLabelChanged(cell, value, autoSize = false) {\n        this.batchUpdate(() => {\n            this.getDataModel().setValue(cell, value);\n            if (autoSize) {\n                this.cellSizeUpdated(cell, false);\n            }\n        });\n    },\n    /*****************************************************************************\n     * Group: Graph behaviour\n     *****************************************************************************/\n    /**\n     * Returns true if the given cell is currently being edited.\n     * If no cell is specified then this returns true if any\n     * cell is currently being edited.\n     *\n     * @param cell {@link Cell} that should be checked.\n     */\n    isEditing(cell = null) {\n        const cellEditorHandler = this.getPlugin('CellEditorHandler');\n        const editingCell = cellEditorHandler?.getEditingCell();\n        return !cell ? !!editingCell : cell === editingCell;\n    },\n    /**\n     * Returns true if the given cell is editable. This returns {@link cellsEditable} for\n     * all given cells if {@link isCellLocked} does not return true for the given cell\n     * and its style does not specify {@link 'editable'} to be 0.\n     *\n     * @param cell {@link mxCell} whose editable state should be returned.\n     */\n    isCellEditable(cell) {\n        const style = this.getCurrentCellStyle(cell);\n        return (this.isCellsEditable() && !this.isCellLocked(cell) && (style.editable || false));\n    },\n    /**\n     * Returns {@link cellsEditable}.\n     */\n    isCellsEditable() {\n        return this.cellsEditable;\n    },\n    /**\n     * Specifies if the graph should allow in-place editing for cell labels.\n     * This implementation updates {@link cellsEditable}.\n     *\n     * @param value Boolean indicating if the graph should allow in-place\n     * editing.\n     */\n    setCellsEditable(value) {\n        this.cellsEditable = value;\n    },\n};\nmixInto(Graph)(EditingMixin);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}