{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../geometry/Point';\nimport CellStatePreview from '../cell/CellStatePreview';\nimport Animation from './Animation';\n/**\n * Implements animation for morphing cells. Here is an example of\n * using this class for animating the result of a layout algorithm:\n *\n * ```javascript\n * graph.getDataModel().beginUpdate();\n * try\n * {\n *   let circleLayout = new mxCircleLayout(graph);\n *   circleLayout.execute(graph.getDefaultParent());\n * }\n * finally\n * {\n *   let morph = new Morphing(graph);\n *   morph.addListener(mxEvent.DONE, ()=>\n *   {\n *     graph.getDataModel().endUpdate();\n *   });\n *\n *   morph.startAnimation();\n * }\n * ```\n *\n * Constructor: Morphing\n *\n * Constructs an animation.\n *\n * @param graph Reference to the enclosing {@link Graph}.\n * @param steps Optional number of steps in the morphing animation. Default is 6.\n * @param ease Optional easing constant for the animation. Default is 1.5.\n * @param delay Optional delay between the animation steps. Passed to <Animation>.\n */\nclass Morphing extends Animation {\n  constructor(graph, steps = 6, ease = 1.5, delay) {\n    super(delay);\n    /**\n     * Contains the current step.\n     */\n    this.step = 0;\n    /**\n     * Optional array of cells to be animated. If this is not specified\n     * then all cells are checked and animated if they have been moved\n     * in the current transaction.\n     */\n    this.cells = null;\n    this.graph = graph;\n    this.steps = steps;\n    this.ease = ease;\n  }\n  /**\n   * Animation step.\n   */\n  updateAnimation() {\n    super.updateAnimation();\n    const move = new CellStatePreview(this.graph);\n    if (this.cells != null) {\n      // Animates the given cells individually without recursion\n      for (const cell of this.cells) {\n        this.animateCell(cell, move, false);\n      }\n    } else {\n      // Animates all changed cells by using recursion to find\n      // the changed cells but not for the animation itself\n      this.animateCell(this.graph.getDataModel().getRoot(), move, true);\n    }\n    this.show(move);\n    if (move.isEmpty() || this.step++ >= this.steps) {\n      this.stopAnimation();\n    }\n  }\n  /**\n   * Shows the changes in the given <CellStatePreview>.\n   */\n  show(move) {\n    move.show();\n  }\n  /**\n   * Animates the given cell state using <CellStatePreview.moveState>.\n   */\n  animateCell(cell, move, recurse = false) {\n    const state = this.graph.getView().getState(cell);\n    let delta = null;\n    if (state != null) {\n      // Moves the animated state from where it will be after the model\n      // change by subtracting the given delta vector from that location\n      delta = this.getDelta(state);\n      if (cell.isVertex() && (delta.x != 0 || delta.y != 0)) {\n        const translate = this.graph.view.getTranslate();\n        const scale = this.graph.view.getScale();\n        delta.x += translate.x * scale;\n        delta.y += translate.y * scale;\n        move.moveState(state, -delta.x / this.ease, -delta.y / this.ease);\n      }\n    }\n    if (recurse && !this.stopRecursion(state, delta)) {\n      const childCount = cell.getChildCount();\n      for (let i = 0; i < childCount; i += 1) {\n        this.animateCell(cell.getChildAt(i), move, recurse);\n      }\n    }\n  }\n  /**\n   * Returns true if the animation should not recursively find more\n   * deltas for children if the given parent state has been animated.\n   */\n  stopRecursion(state = null, delta = null) {\n    return delta != null && (delta.x != 0 || delta.y != 0);\n  }\n  /**\n   * Returns the vector between the current rendered state and the future\n   * location of the state after the display will be updated.\n   */\n  getDelta(state) {\n    const origin = this.getOriginForCell(state.cell);\n    const translate = this.graph.getView().getTranslate();\n    const scale = this.graph.getView().getScale();\n    const x = state.x / scale - translate.x;\n    const y = state.y / scale - translate.y;\n    return new Point((origin.x - x) * scale, (origin.y - y) * scale);\n  }\n  /**\n   * Returns the top, left corner of the given cell. TODO: Improve performance\n   * by using caching inside this method as the result per cell never changes\n   * during the lifecycle of this object.\n   */\n  getOriginForCell(cell = null) {\n    let result = null;\n    if (cell != null) {\n      const parent = cell.getParent();\n      const geo = cell.getGeometry();\n      result = this.getOriginForCell(parent);\n      // TODO: Handle offsets\n      if (geo != null && parent != null) {\n        if (geo.relative) {\n          const pgeo = parent.getGeometry();\n          if (pgeo != null) {\n            result.x += geo.x * pgeo.width;\n            result.y += geo.y * pgeo.height;\n          }\n        } else {\n          result.x += geo.x;\n          result.y += geo.y;\n        }\n      }\n    }\n    if (result == null) {\n      const t = this.graph.view.getTranslate();\n      result = new Point(-t.x, -t.y);\n    }\n    return result;\n  }\n}\nexport default Morphing;","map":{"version":3,"names":["Point","CellStatePreview","Animation","Morphing","constructor","graph","steps","ease","delay","step","cells","updateAnimation","move","cell","animateCell","getDataModel","getRoot","show","isEmpty","stopAnimation","recurse","state","getView","getState","delta","getDelta","isVertex","x","y","translate","view","getTranslate","scale","getScale","moveState","stopRecursion","childCount","getChildCount","i","getChildAt","origin","getOriginForCell","result","parent","getParent","geo","getGeometry","relative","pgeo","width","height","t"],"sources":["D:/ospanel/domains/react/react-intro/node_modules/@maxgraph/core/dist/view/animate/Morphing.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../geometry/Point';\nimport CellStatePreview from '../cell/CellStatePreview';\nimport Animation from './Animation';\n/**\n * Implements animation for morphing cells. Here is an example of\n * using this class for animating the result of a layout algorithm:\n *\n * ```javascript\n * graph.getDataModel().beginUpdate();\n * try\n * {\n *   let circleLayout = new mxCircleLayout(graph);\n *   circleLayout.execute(graph.getDefaultParent());\n * }\n * finally\n * {\n *   let morph = new Morphing(graph);\n *   morph.addListener(mxEvent.DONE, ()=>\n *   {\n *     graph.getDataModel().endUpdate();\n *   });\n *\n *   morph.startAnimation();\n * }\n * ```\n *\n * Constructor: Morphing\n *\n * Constructs an animation.\n *\n * @param graph Reference to the enclosing {@link Graph}.\n * @param steps Optional number of steps in the morphing animation. Default is 6.\n * @param ease Optional easing constant for the animation. Default is 1.5.\n * @param delay Optional delay between the animation steps. Passed to <Animation>.\n */\nclass Morphing extends Animation {\n    constructor(graph, steps = 6, ease = 1.5, delay) {\n        super(delay);\n        /**\n         * Contains the current step.\n         */\n        this.step = 0;\n        /**\n         * Optional array of cells to be animated. If this is not specified\n         * then all cells are checked and animated if they have been moved\n         * in the current transaction.\n         */\n        this.cells = null;\n        this.graph = graph;\n        this.steps = steps;\n        this.ease = ease;\n    }\n    /**\n     * Animation step.\n     */\n    updateAnimation() {\n        super.updateAnimation();\n        const move = new CellStatePreview(this.graph);\n        if (this.cells != null) {\n            // Animates the given cells individually without recursion\n            for (const cell of this.cells) {\n                this.animateCell(cell, move, false);\n            }\n        }\n        else {\n            // Animates all changed cells by using recursion to find\n            // the changed cells but not for the animation itself\n            this.animateCell(this.graph.getDataModel().getRoot(), move, true);\n        }\n        this.show(move);\n        if (move.isEmpty() || this.step++ >= this.steps) {\n            this.stopAnimation();\n        }\n    }\n    /**\n     * Shows the changes in the given <CellStatePreview>.\n     */\n    show(move) {\n        move.show();\n    }\n    /**\n     * Animates the given cell state using <CellStatePreview.moveState>.\n     */\n    animateCell(cell, move, recurse = false) {\n        const state = this.graph.getView().getState(cell);\n        let delta = null;\n        if (state != null) {\n            // Moves the animated state from where it will be after the model\n            // change by subtracting the given delta vector from that location\n            delta = this.getDelta(state);\n            if (cell.isVertex() && (delta.x != 0 || delta.y != 0)) {\n                const translate = this.graph.view.getTranslate();\n                const scale = this.graph.view.getScale();\n                delta.x += translate.x * scale;\n                delta.y += translate.y * scale;\n                move.moveState(state, -delta.x / this.ease, -delta.y / this.ease);\n            }\n        }\n        if (recurse && !this.stopRecursion(state, delta)) {\n            const childCount = cell.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                this.animateCell(cell.getChildAt(i), move, recurse);\n            }\n        }\n    }\n    /**\n     * Returns true if the animation should not recursively find more\n     * deltas for children if the given parent state has been animated.\n     */\n    stopRecursion(state = null, delta = null) {\n        return delta != null && (delta.x != 0 || delta.y != 0);\n    }\n    /**\n     * Returns the vector between the current rendered state and the future\n     * location of the state after the display will be updated.\n     */\n    getDelta(state) {\n        const origin = this.getOriginForCell(state.cell);\n        const translate = this.graph.getView().getTranslate();\n        const scale = this.graph.getView().getScale();\n        const x = state.x / scale - translate.x;\n        const y = state.y / scale - translate.y;\n        return new Point((origin.x - x) * scale, (origin.y - y) * scale);\n    }\n    /**\n     * Returns the top, left corner of the given cell. TODO: Improve performance\n     * by using caching inside this method as the result per cell never changes\n     * during the lifecycle of this object.\n     */\n    getOriginForCell(cell = null) {\n        let result = null;\n        if (cell != null) {\n            const parent = cell.getParent();\n            const geo = cell.getGeometry();\n            result = this.getOriginForCell(parent);\n            // TODO: Handle offsets\n            if (geo != null && parent != null) {\n                if (geo.relative) {\n                    const pgeo = parent.getGeometry();\n                    if (pgeo != null) {\n                        result.x += geo.x * pgeo.width;\n                        result.y += geo.y * pgeo.height;\n                    }\n                }\n                else {\n                    result.x += geo.x;\n                    result.y += geo.y;\n                }\n            }\n        }\n        if (result == null) {\n            const t = this.graph.view.getTranslate();\n            result = new Point(-t.x, -t.y);\n        }\n        return result;\n    }\n}\nexport default Morphing;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}