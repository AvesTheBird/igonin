{"ast":null,"code":"var _StickyScrollController;\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar StickyScrollController_1;\nimport { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { StickyScrollWidget, StickyScrollWidgetState } from './stickyScrollWidget.js';\nimport { StickyLineCandidateProvider } from './stickyScrollProvider.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IContextMenuService } from '../../../../platform/contextview/browser/contextView.js';\nimport { MenuId } from '../../../../platform/actions/common/actions.js';\nimport { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { ClickLinkGesture } from '../../gotoSymbol/browser/link/clickLinkGesture.js';\nimport { Range } from '../../../common/core/range.js';\nimport { getDefinitionsAtPosition } from '../../gotoSymbol/browser/goToSymbol.js';\nimport { goToDefinitionWithLocation } from '../../inlayHints/browser/inlayHintsLocations.js';\nimport { Position } from '../../../common/core/position.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport { ILanguageFeatureDebounceService } from '../../../common/services/languageFeatureDebounce.js';\nimport * as dom from '../../../../base/browser/dom.js';\nimport { StickyRange } from './stickyScrollElement.js';\nimport { StandardMouseEvent } from '../../../../base/browser/mouseEvent.js';\nimport { FoldingController } from '../../folding/browser/folding.js';\nimport { toggleCollapseState } from '../../folding/browser/foldingModel.js';\nlet StickyScrollController = (_StickyScrollController = class StickyScrollController extends Disposable {\n  constructor(_editor, _contextMenuService, _languageFeaturesService, _instaService, _languageConfigurationService, _languageFeatureDebounceService, _contextKeyService) {\n    super();\n    this._editor = _editor;\n    this._contextMenuService = _contextMenuService;\n    this._languageFeaturesService = _languageFeaturesService;\n    this._instaService = _instaService;\n    this._contextKeyService = _contextKeyService;\n    this._sessionStore = new DisposableStore();\n    this._maxStickyLines = Number.MAX_SAFE_INTEGER;\n    this._candidateDefinitionsLength = -1;\n    this._focusedStickyElementIndex = -1;\n    this._enabled = false;\n    this._focused = false;\n    this._positionRevealed = false;\n    this._onMouseDown = false;\n    this._endLineNumbers = [];\n    this._stickyScrollWidget = new StickyScrollWidget(this._editor);\n    this._stickyLineCandidateProvider = new StickyLineCandidateProvider(this._editor, _languageFeaturesService, _languageConfigurationService);\n    this._register(this._stickyScrollWidget);\n    this._register(this._stickyLineCandidateProvider);\n    this._widgetState = StickyScrollWidgetState.Empty;\n    this._onDidResize();\n    this._readConfiguration();\n    const stickyScrollDomNode = this._stickyScrollWidget.getDomNode();\n    this._register(this._editor.onDidChangeConfiguration(e => {\n      this._readConfigurationChange(e);\n    }));\n    this._register(dom.addDisposableListener(stickyScrollDomNode, dom.EventType.CONTEXT_MENU, async event => {\n      this._onContextMenu(dom.getWindow(stickyScrollDomNode), event);\n    }));\n    this._stickyScrollFocusedContextKey = EditorContextKeys.stickyScrollFocused.bindTo(this._contextKeyService);\n    this._stickyScrollVisibleContextKey = EditorContextKeys.stickyScrollVisible.bindTo(this._contextKeyService);\n    const focusTracker = this._register(dom.trackFocus(stickyScrollDomNode));\n    this._register(focusTracker.onDidBlur(_ => {\n      // Suppose that the blurring is caused by scrolling, then keep the focus on the sticky scroll\n      // This is determined by the fact that the height of the widget has become zero and there has been no position revealing\n      if (this._positionRevealed === false && stickyScrollDomNode.clientHeight === 0) {\n        this._focusedStickyElementIndex = -1;\n        this.focus();\n      }\n      // In all other casees, dispose the focus on the sticky scroll\n      else {\n        this._disposeFocusStickyScrollStore();\n      }\n    }));\n    this._register(focusTracker.onDidFocus(_ => {\n      this.focus();\n    }));\n    this._registerMouseListeners();\n    // Suppose that mouse down on the sticky scroll, then do not focus on the sticky scroll because this will be followed by the revealing of a position\n    this._register(dom.addDisposableListener(stickyScrollDomNode, dom.EventType.MOUSE_DOWN, e => {\n      this._onMouseDown = true;\n    }));\n  }\n  static get(editor) {\n    return editor.getContribution(StickyScrollController_1.ID);\n  }\n  _disposeFocusStickyScrollStore() {\n    var _this$_focusDisposabl;\n    this._stickyScrollFocusedContextKey.set(false);\n    (_this$_focusDisposabl = this._focusDisposableStore) === null || _this$_focusDisposabl === void 0 || _this$_focusDisposabl.dispose();\n    this._focused = false;\n    this._positionRevealed = false;\n    this._onMouseDown = false;\n  }\n  focus() {\n    // If the mouse is down, do not focus on the sticky scroll\n    if (this._onMouseDown) {\n      this._onMouseDown = false;\n      this._editor.focus();\n      return;\n    }\n    const focusState = this._stickyScrollFocusedContextKey.get();\n    if (focusState === true) {\n      return;\n    }\n    this._focused = true;\n    this._focusDisposableStore = new DisposableStore();\n    this._stickyScrollFocusedContextKey.set(true);\n    this._focusedStickyElementIndex = this._stickyScrollWidget.lineNumbers.length - 1;\n    this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex);\n  }\n  focusNext() {\n    if (this._focusedStickyElementIndex < this._stickyScrollWidget.lineNumberCount - 1) {\n      this._focusNav(true);\n    }\n  }\n  focusPrevious() {\n    if (this._focusedStickyElementIndex > 0) {\n      this._focusNav(false);\n    }\n  }\n  selectEditor() {\n    this._editor.focus();\n  }\n  // True is next, false is previous\n  _focusNav(direction) {\n    this._focusedStickyElementIndex = direction ? this._focusedStickyElementIndex + 1 : this._focusedStickyElementIndex - 1;\n    this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex);\n  }\n  goToFocused() {\n    const lineNumbers = this._stickyScrollWidget.lineNumbers;\n    this._disposeFocusStickyScrollStore();\n    this._revealPosition({\n      lineNumber: lineNumbers[this._focusedStickyElementIndex],\n      column: 1\n    });\n  }\n  _revealPosition(position) {\n    this._reveaInEditor(position, () => this._editor.revealPosition(position));\n  }\n  _revealLineInCenterIfOutsideViewport(position) {\n    this._reveaInEditor(position, () => this._editor.revealLineInCenterIfOutsideViewport(position.lineNumber, 0 /* ScrollType.Smooth */));\n  }\n  _reveaInEditor(position, revealFunction) {\n    if (this._focused) {\n      this._disposeFocusStickyScrollStore();\n    }\n    this._positionRevealed = true;\n    revealFunction();\n    this._editor.setSelection(Range.fromPositions(position));\n    this._editor.focus();\n  }\n  _registerMouseListeners() {\n    const sessionStore = this._register(new DisposableStore());\n    const gesture = this._register(new ClickLinkGesture(this._editor, {\n      extractLineNumberFromMouseEvent: e => {\n        const position = this._stickyScrollWidget.getEditorPositionFromNode(e.target.element);\n        return position ? position.lineNumber : 0;\n      }\n    }));\n    const getMouseEventTarget = mouseEvent => {\n      if (!this._editor.hasModel()) {\n        return null;\n      }\n      if (mouseEvent.target.type !== 12 /* MouseTargetType.OVERLAY_WIDGET */ || mouseEvent.target.detail !== this._stickyScrollWidget.getId()) {\n        // not hovering over our widget\n        return null;\n      }\n      const mouseTargetElement = mouseEvent.target.element;\n      if (!mouseTargetElement || mouseTargetElement.innerText !== mouseTargetElement.innerHTML) {\n        // not on a span element rendering text\n        return null;\n      }\n      const position = this._stickyScrollWidget.getEditorPositionFromNode(mouseTargetElement);\n      if (!position) {\n        // not hovering a sticky scroll line\n        return null;\n      }\n      return {\n        range: new Range(position.lineNumber, position.column, position.lineNumber, position.column + mouseTargetElement.innerText.length),\n        textElement: mouseTargetElement\n      };\n    };\n    const stickyScrollWidgetDomNode = this._stickyScrollWidget.getDomNode();\n    this._register(dom.addStandardDisposableListener(stickyScrollWidgetDomNode, dom.EventType.CLICK, mouseEvent => {\n      if (mouseEvent.ctrlKey || mouseEvent.altKey || mouseEvent.metaKey) {\n        // modifier pressed\n        return;\n      }\n      if (!mouseEvent.leftButton) {\n        // not left click\n        return;\n      }\n      if (mouseEvent.shiftKey) {\n        // shift click\n        const lineIndex = this._stickyScrollWidget.getLineIndexFromChildDomNode(mouseEvent.target);\n        if (lineIndex === null) {\n          return;\n        }\n        const position = new Position(this._endLineNumbers[lineIndex], 1);\n        this._revealLineInCenterIfOutsideViewport(position);\n        return;\n      }\n      const isInFoldingIconDomNode = this._stickyScrollWidget.isInFoldingIconDomNode(mouseEvent.target);\n      if (isInFoldingIconDomNode) {\n        // clicked on folding icon\n        const lineNumber = this._stickyScrollWidget.getLineNumberFromChildDomNode(mouseEvent.target);\n        this._toggleFoldingRegionForLine(lineNumber);\n        return;\n      }\n      const isInStickyLine = this._stickyScrollWidget.isInStickyLine(mouseEvent.target);\n      if (!isInStickyLine) {\n        return;\n      }\n      // normal click\n      let position = this._stickyScrollWidget.getEditorPositionFromNode(mouseEvent.target);\n      if (!position) {\n        const lineNumber = this._stickyScrollWidget.getLineNumberFromChildDomNode(mouseEvent.target);\n        if (lineNumber === null) {\n          // not hovering a sticky scroll line\n          return;\n        }\n        position = new Position(lineNumber, 1);\n      }\n      this._revealPosition(position);\n    }));\n    this._register(dom.addStandardDisposableListener(stickyScrollWidgetDomNode, dom.EventType.MOUSE_MOVE, mouseEvent => {\n      if (mouseEvent.shiftKey) {\n        const currentEndForLineIndex = this._stickyScrollWidget.getLineIndexFromChildDomNode(mouseEvent.target);\n        if (currentEndForLineIndex === null || this._showEndForLine !== null && this._showEndForLine === currentEndForLineIndex) {\n          return;\n        }\n        this._showEndForLine = currentEndForLineIndex;\n        this._renderStickyScroll();\n        return;\n      }\n      if (this._showEndForLine !== undefined) {\n        this._showEndForLine = undefined;\n        this._renderStickyScroll();\n      }\n    }));\n    this._register(dom.addDisposableListener(stickyScrollWidgetDomNode, dom.EventType.MOUSE_LEAVE, e => {\n      if (this._showEndForLine !== undefined) {\n        this._showEndForLine = undefined;\n        this._renderStickyScroll();\n      }\n    }));\n    this._register(gesture.onMouseMoveOrRelevantKeyDown(_ref => {\n      let [mouseEvent, _keyboardEvent] = _ref;\n      const mouseTarget = getMouseEventTarget(mouseEvent);\n      if (!mouseTarget || !mouseEvent.hasTriggerModifier || !this._editor.hasModel()) {\n        sessionStore.clear();\n        return;\n      }\n      const {\n        range,\n        textElement\n      } = mouseTarget;\n      if (!range.equalsRange(this._stickyRangeProjectedOnEditor)) {\n        this._stickyRangeProjectedOnEditor = range;\n        sessionStore.clear();\n      } else if (textElement.style.textDecoration === 'underline') {\n        return;\n      }\n      const cancellationToken = new CancellationTokenSource();\n      sessionStore.add(toDisposable(() => cancellationToken.dispose(true)));\n      let currentHTMLChild;\n      getDefinitionsAtPosition(this._languageFeaturesService.definitionProvider, this._editor.getModel(), new Position(range.startLineNumber, range.startColumn + 1), false, cancellationToken.token).then(candidateDefinitions => {\n        if (cancellationToken.token.isCancellationRequested) {\n          return;\n        }\n        if (candidateDefinitions.length !== 0) {\n          this._candidateDefinitionsLength = candidateDefinitions.length;\n          const childHTML = textElement;\n          if (currentHTMLChild !== childHTML) {\n            sessionStore.clear();\n            currentHTMLChild = childHTML;\n            currentHTMLChild.style.textDecoration = 'underline';\n            sessionStore.add(toDisposable(() => {\n              currentHTMLChild.style.textDecoration = 'none';\n            }));\n          } else if (!currentHTMLChild) {\n            currentHTMLChild = childHTML;\n            currentHTMLChild.style.textDecoration = 'underline';\n            sessionStore.add(toDisposable(() => {\n              currentHTMLChild.style.textDecoration = 'none';\n            }));\n          }\n        } else {\n          sessionStore.clear();\n        }\n      });\n    }));\n    this._register(gesture.onCancel(() => {\n      sessionStore.clear();\n    }));\n    this._register(gesture.onExecute(async e => {\n      if (e.target.type !== 12 /* MouseTargetType.OVERLAY_WIDGET */ || e.target.detail !== this._stickyScrollWidget.getId()) {\n        // not hovering over our widget\n        return;\n      }\n      const position = this._stickyScrollWidget.getEditorPositionFromNode(e.target.element);\n      if (!position) {\n        // not hovering a sticky scroll line\n        return;\n      }\n      if (!this._editor.hasModel() || !this._stickyRangeProjectedOnEditor) {\n        return;\n      }\n      if (this._candidateDefinitionsLength > 1) {\n        if (this._focused) {\n          this._disposeFocusStickyScrollStore();\n        }\n        this._revealPosition({\n          lineNumber: position.lineNumber,\n          column: 1\n        });\n      }\n      this._instaService.invokeFunction(goToDefinitionWithLocation, e, this._editor, {\n        uri: this._editor.getModel().uri,\n        range: this._stickyRangeProjectedOnEditor\n      });\n    }));\n  }\n  _onContextMenu(targetWindow, e) {\n    const event = new StandardMouseEvent(targetWindow, e);\n    this._contextMenuService.showContextMenu({\n      menuId: MenuId.StickyScrollContext,\n      getAnchor: () => event\n    });\n  }\n  _toggleFoldingRegionForLine(line) {\n    if (!this._foldingModel || line === null) {\n      return;\n    }\n    const stickyLine = this._stickyScrollWidget.getRenderedStickyLine(line);\n    const foldingIcon = stickyLine === null || stickyLine === void 0 ? void 0 : stickyLine.foldingIcon;\n    if (!foldingIcon) {\n      return;\n    }\n    toggleCollapseState(this._foldingModel, Number.MAX_VALUE, [line]);\n    foldingIcon.isCollapsed = !foldingIcon.isCollapsed;\n    const scrollTop = (foldingIcon.isCollapsed ? this._editor.getTopForLineNumber(foldingIcon.foldingEndLine) : this._editor.getTopForLineNumber(foldingIcon.foldingStartLine)) - this._editor.getOption(67 /* EditorOption.lineHeight */) * stickyLine.index + 1;\n    this._editor.setScrollTop(scrollTop);\n    this._renderStickyScroll(line);\n  }\n  _readConfiguration() {\n    const options = this._editor.getOption(116 /* EditorOption.stickyScroll */);\n    if (options.enabled === false) {\n      this._editor.removeOverlayWidget(this._stickyScrollWidget);\n      this._sessionStore.clear();\n      this._enabled = false;\n      return;\n    } else if (options.enabled && !this._enabled) {\n      // When sticky scroll was just enabled, add the listeners on the sticky scroll\n      this._editor.addOverlayWidget(this._stickyScrollWidget);\n      this._sessionStore.add(this._editor.onDidScrollChange(e => {\n        if (e.scrollTopChanged) {\n          this._showEndForLine = undefined;\n          this._renderStickyScroll();\n        }\n      }));\n      this._sessionStore.add(this._editor.onDidLayoutChange(() => this._onDidResize()));\n      this._sessionStore.add(this._editor.onDidChangeModelTokens(e => this._onTokensChange(e)));\n      this._sessionStore.add(this._stickyLineCandidateProvider.onDidChangeStickyScroll(() => {\n        this._showEndForLine = undefined;\n        this._renderStickyScroll();\n      }));\n      this._enabled = true;\n    }\n    const lineNumberOption = this._editor.getOption(68 /* EditorOption.lineNumbers */);\n    if (lineNumberOption.renderType === 2 /* RenderLineNumbersType.Relative */) {\n      this._sessionStore.add(this._editor.onDidChangeCursorPosition(() => {\n        this._showEndForLine = undefined;\n        this._renderStickyScroll(0);\n      }));\n    }\n  }\n  _readConfigurationChange(event) {\n    if (event.hasChanged(116 /* EditorOption.stickyScroll */) || event.hasChanged(73 /* EditorOption.minimap */) || event.hasChanged(67 /* EditorOption.lineHeight */) || event.hasChanged(111 /* EditorOption.showFoldingControls */) || event.hasChanged(68 /* EditorOption.lineNumbers */)) {\n      this._readConfiguration();\n    }\n    if (event.hasChanged(68 /* EditorOption.lineNumbers */)) {\n      this._renderStickyScroll(0);\n    }\n  }\n  _needsUpdate(event) {\n    const stickyLineNumbers = this._stickyScrollWidget.getCurrentLines();\n    for (const stickyLineNumber of stickyLineNumbers) {\n      for (const range of event.ranges) {\n        if (stickyLineNumber >= range.fromLineNumber && stickyLineNumber <= range.toLineNumber) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  _onTokensChange(event) {\n    if (this._needsUpdate(event)) {\n      // Rebuilding the whole widget from line 0\n      this._renderStickyScroll(0);\n    }\n  }\n  _onDidResize() {\n    const layoutInfo = this._editor.getLayoutInfo();\n    // Make sure sticky scroll doesn't take up more than 25% of the editor\n    const theoreticalLines = layoutInfo.height / this._editor.getOption(67 /* EditorOption.lineHeight */);\n    this._maxStickyLines = Math.round(theoreticalLines * .25);\n  }\n  async _renderStickyScroll(rebuildFromLine) {\n    const model = this._editor.getModel();\n    if (!model || model.isTooLargeForTokenization()) {\n      this._resetState();\n      return;\n    }\n    const nextRebuildFromLine = this._updateAndGetMinRebuildFromLine(rebuildFromLine);\n    const stickyWidgetVersion = this._stickyLineCandidateProvider.getVersionId();\n    const shouldUpdateState = stickyWidgetVersion === undefined || stickyWidgetVersion === model.getVersionId();\n    if (shouldUpdateState) {\n      if (!this._focused) {\n        await this._updateState(nextRebuildFromLine);\n      } else {\n        // Suppose that previously the sticky scroll widget had height 0, then if there are visible lines, set the last line as focused\n        if (this._focusedStickyElementIndex === -1) {\n          await this._updateState(nextRebuildFromLine);\n          this._focusedStickyElementIndex = this._stickyScrollWidget.lineNumberCount - 1;\n          if (this._focusedStickyElementIndex !== -1) {\n            this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex);\n          }\n        } else {\n          const focusedStickyElementLineNumber = this._stickyScrollWidget.lineNumbers[this._focusedStickyElementIndex];\n          await this._updateState(nextRebuildFromLine);\n          // Suppose that after setting the state, there are no sticky lines, set the focused index to -1\n          if (this._stickyScrollWidget.lineNumberCount === 0) {\n            this._focusedStickyElementIndex = -1;\n          } else {\n            const previousFocusedLineNumberExists = this._stickyScrollWidget.lineNumbers.includes(focusedStickyElementLineNumber);\n            // If the line number is still there, do not change anything\n            // If the line number is not there, set the new focused line to be the last line\n            if (!previousFocusedLineNumberExists) {\n              this._focusedStickyElementIndex = this._stickyScrollWidget.lineNumberCount - 1;\n            }\n            this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex);\n          }\n        }\n      }\n    }\n  }\n  _updateAndGetMinRebuildFromLine(rebuildFromLine) {\n    if (rebuildFromLine !== undefined) {\n      const minRebuildFromLineOrInfinity = this._minRebuildFromLine !== undefined ? this._minRebuildFromLine : Infinity;\n      this._minRebuildFromLine = Math.min(rebuildFromLine, minRebuildFromLineOrInfinity);\n    }\n    return this._minRebuildFromLine;\n  }\n  async _updateState(rebuildFromLine) {\n    var _await$FoldingControl, _FoldingController$ge;\n    this._minRebuildFromLine = undefined;\n    this._foldingModel = (_await$FoldingControl = await ((_FoldingController$ge = FoldingController.get(this._editor)) === null || _FoldingController$ge === void 0 ? void 0 : _FoldingController$ge.getFoldingModel())) !== null && _await$FoldingControl !== void 0 ? _await$FoldingControl : undefined;\n    this._widgetState = this.findScrollWidgetState();\n    const stickyWidgetHasLines = this._widgetState.startLineNumbers.length > 0;\n    this._stickyScrollVisibleContextKey.set(stickyWidgetHasLines);\n    this._stickyScrollWidget.setState(this._widgetState, this._foldingModel, rebuildFromLine);\n  }\n  async _resetState() {\n    this._minRebuildFromLine = undefined;\n    this._foldingModel = undefined;\n    this._widgetState = StickyScrollWidgetState.Empty;\n    this._stickyScrollVisibleContextKey.set(false);\n    this._stickyScrollWidget.setState(undefined, undefined);\n  }\n  findScrollWidgetState() {\n    const lineHeight = this._editor.getOption(67 /* EditorOption.lineHeight */);\n    const maxNumberStickyLines = Math.min(this._maxStickyLines, this._editor.getOption(116 /* EditorOption.stickyScroll */).maxLineCount);\n    const scrollTop = this._editor.getScrollTop();\n    let lastLineRelativePosition = 0;\n    const startLineNumbers = [];\n    const endLineNumbers = [];\n    const arrayVisibleRanges = this._editor.getVisibleRanges();\n    if (arrayVisibleRanges.length !== 0) {\n      const fullVisibleRange = new StickyRange(arrayVisibleRanges[0].startLineNumber, arrayVisibleRanges[arrayVisibleRanges.length - 1].endLineNumber);\n      const candidateRanges = this._stickyLineCandidateProvider.getCandidateStickyLinesIntersecting(fullVisibleRange);\n      for (const range of candidateRanges) {\n        const start = range.startLineNumber;\n        const end = range.endLineNumber;\n        const depth = range.nestingDepth;\n        if (end - start > 0) {\n          const topOfElementAtDepth = (depth - 1) * lineHeight;\n          const bottomOfElementAtDepth = depth * lineHeight;\n          const bottomOfBeginningLine = this._editor.getBottomForLineNumber(start) - scrollTop;\n          const topOfEndLine = this._editor.getTopForLineNumber(end) - scrollTop;\n          const bottomOfEndLine = this._editor.getBottomForLineNumber(end) - scrollTop;\n          if (topOfElementAtDepth > topOfEndLine && topOfElementAtDepth <= bottomOfEndLine) {\n            startLineNumbers.push(start);\n            endLineNumbers.push(end + 1);\n            lastLineRelativePosition = bottomOfEndLine - bottomOfElementAtDepth;\n            break;\n          } else if (bottomOfElementAtDepth > bottomOfBeginningLine && bottomOfElementAtDepth <= bottomOfEndLine) {\n            startLineNumbers.push(start);\n            endLineNumbers.push(end + 1);\n          }\n          if (startLineNumbers.length === maxNumberStickyLines) {\n            break;\n          }\n        }\n      }\n    }\n    this._endLineNumbers = endLineNumbers;\n    return new StickyScrollWidgetState(startLineNumbers, endLineNumbers, lastLineRelativePosition, this._showEndForLine);\n  }\n  dispose() {\n    super.dispose();\n    this._sessionStore.dispose();\n  }\n}, StickyScrollController_1 = _StickyScrollController, _StickyScrollController.ID = 'store.contrib.stickyScrollController', _StickyScrollController);\nStickyScrollController = StickyScrollController_1 = __decorate([__param(1, IContextMenuService), __param(2, ILanguageFeaturesService), __param(3, IInstantiationService), __param(4, ILanguageConfigurationService), __param(5, ILanguageFeatureDebounceService), __param(6, IContextKeyService)], StickyScrollController);\nexport { StickyScrollController };","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","StickyScrollController_1","Disposable","DisposableStore","toDisposable","ILanguageFeaturesService","StickyScrollWidget","StickyScrollWidgetState","StickyLineCandidateProvider","IInstantiationService","IContextMenuService","MenuId","IContextKeyService","EditorContextKeys","ClickLinkGesture","Range","getDefinitionsAtPosition","goToDefinitionWithLocation","Position","CancellationTokenSource","ILanguageConfigurationService","ILanguageFeatureDebounceService","dom","StickyRange","StandardMouseEvent","FoldingController","toggleCollapseState","StickyScrollController","_StickyScrollController","constructor","_editor","_contextMenuService","_languageFeaturesService","_instaService","_languageConfigurationService","_languageFeatureDebounceService","_contextKeyService","_sessionStore","_maxStickyLines","Number","MAX_SAFE_INTEGER","_candidateDefinitionsLength","_focusedStickyElementIndex","_enabled","_focused","_positionRevealed","_onMouseDown","_endLineNumbers","_stickyScrollWidget","_stickyLineCandidateProvider","_register","_widgetState","Empty","_onDidResize","_readConfiguration","stickyScrollDomNode","getDomNode","onDidChangeConfiguration","e","_readConfigurationChange","addDisposableListener","EventType","CONTEXT_MENU","event","_onContextMenu","getWindow","_stickyScrollFocusedContextKey","stickyScrollFocused","bindTo","_stickyScrollVisibleContextKey","stickyScrollVisible","focusTracker","trackFocus","onDidBlur","_","clientHeight","focus","_disposeFocusStickyScrollStore","onDidFocus","_registerMouseListeners","MOUSE_DOWN","get","editor","getContribution","ID","_this$_focusDisposabl","set","_focusDisposableStore","dispose","focusState","lineNumbers","focusLineWithIndex","focusNext","lineNumberCount","_focusNav","focusPrevious","selectEditor","direction","goToFocused","_revealPosition","lineNumber","column","position","_reveaInEditor","revealPosition","_revealLineInCenterIfOutsideViewport","revealLineInCenterIfOutsideViewport","revealFunction","setSelection","fromPositions","sessionStore","gesture","extractLineNumberFromMouseEvent","getEditorPositionFromNode","element","getMouseEventTarget","mouseEvent","hasModel","type","detail","getId","mouseTargetElement","innerText","innerHTML","range","textElement","stickyScrollWidgetDomNode","addStandardDisposableListener","CLICK","ctrlKey","altKey","metaKey","leftButton","shiftKey","lineIndex","getLineIndexFromChildDomNode","isInFoldingIconDomNode","getLineNumberFromChildDomNode","_toggleFoldingRegionForLine","isInStickyLine","MOUSE_MOVE","currentEndForLineIndex","_showEndForLine","_renderStickyScroll","undefined","MOUSE_LEAVE","onMouseMoveOrRelevantKeyDown","_ref","_keyboardEvent","mouseTarget","hasTriggerModifier","clear","equalsRange","_stickyRangeProjectedOnEditor","style","textDecoration","cancellationToken","add","currentHTMLChild","definitionProvider","getModel","startLineNumber","startColumn","token","then","candidateDefinitions","isCancellationRequested","childHTML","onCancel","onExecute","invokeFunction","uri","targetWindow","showContextMenu","menuId","StickyScrollContext","getAnchor","line","_foldingModel","stickyLine","getRenderedStickyLine","foldingIcon","MAX_VALUE","isCollapsed","scrollTop","getTopForLineNumber","foldingEndLine","foldingStartLine","getOption","index","setScrollTop","options","enabled","removeOverlayWidget","addOverlayWidget","onDidScrollChange","scrollTopChanged","onDidLayoutChange","onDidChangeModelTokens","_onTokensChange","onDidChangeStickyScroll","lineNumberOption","renderType","onDidChangeCursorPosition","hasChanged","_needsUpdate","stickyLineNumbers","getCurrentLines","stickyLineNumber","ranges","fromLineNumber","toLineNumber","layoutInfo","getLayoutInfo","theoreticalLines","height","Math","round","rebuildFromLine","model","isTooLargeForTokenization","_resetState","nextRebuildFromLine","_updateAndGetMinRebuildFromLine","stickyWidgetVersion","getVersionId","shouldUpdateState","_updateState","focusedStickyElementLineNumber","previousFocusedLineNumberExists","includes","minRebuildFromLineOrInfinity","_minRebuildFromLine","Infinity","min","_await$FoldingControl","_FoldingController$ge","getFoldingModel","findScrollWidgetState","stickyWidgetHasLines","startLineNumbers","setState","lineHeight","maxNumberStickyLines","maxLineCount","getScrollTop","lastLineRelativePosition","endLineNumbers","arrayVisibleRanges","getVisibleRanges","fullVisibleRange","endLineNumber","candidateRanges","getCandidateStickyLinesIntersecting","start","end","depth","nestingDepth","topOfElementAtDepth","bottomOfElementAtDepth","bottomOfBeginningLine","getBottomForLineNumber","topOfEndLine","bottomOfEndLine","push"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollController.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar StickyScrollController_1;\nimport { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { StickyScrollWidget, StickyScrollWidgetState } from './stickyScrollWidget.js';\nimport { StickyLineCandidateProvider } from './stickyScrollProvider.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IContextMenuService } from '../../../../platform/contextview/browser/contextView.js';\nimport { MenuId } from '../../../../platform/actions/common/actions.js';\nimport { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { ClickLinkGesture } from '../../gotoSymbol/browser/link/clickLinkGesture.js';\nimport { Range } from '../../../common/core/range.js';\nimport { getDefinitionsAtPosition } from '../../gotoSymbol/browser/goToSymbol.js';\nimport { goToDefinitionWithLocation } from '../../inlayHints/browser/inlayHintsLocations.js';\nimport { Position } from '../../../common/core/position.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport { ILanguageFeatureDebounceService } from '../../../common/services/languageFeatureDebounce.js';\nimport * as dom from '../../../../base/browser/dom.js';\nimport { StickyRange } from './stickyScrollElement.js';\nimport { StandardMouseEvent } from '../../../../base/browser/mouseEvent.js';\nimport { FoldingController } from '../../folding/browser/folding.js';\nimport { toggleCollapseState } from '../../folding/browser/foldingModel.js';\nlet StickyScrollController = class StickyScrollController extends Disposable {\n    static { StickyScrollController_1 = this; }\n    static { this.ID = 'store.contrib.stickyScrollController'; }\n    constructor(_editor, _contextMenuService, _languageFeaturesService, _instaService, _languageConfigurationService, _languageFeatureDebounceService, _contextKeyService) {\n        super();\n        this._editor = _editor;\n        this._contextMenuService = _contextMenuService;\n        this._languageFeaturesService = _languageFeaturesService;\n        this._instaService = _instaService;\n        this._contextKeyService = _contextKeyService;\n        this._sessionStore = new DisposableStore();\n        this._maxStickyLines = Number.MAX_SAFE_INTEGER;\n        this._candidateDefinitionsLength = -1;\n        this._focusedStickyElementIndex = -1;\n        this._enabled = false;\n        this._focused = false;\n        this._positionRevealed = false;\n        this._onMouseDown = false;\n        this._endLineNumbers = [];\n        this._stickyScrollWidget = new StickyScrollWidget(this._editor);\n        this._stickyLineCandidateProvider = new StickyLineCandidateProvider(this._editor, _languageFeaturesService, _languageConfigurationService);\n        this._register(this._stickyScrollWidget);\n        this._register(this._stickyLineCandidateProvider);\n        this._widgetState = StickyScrollWidgetState.Empty;\n        this._onDidResize();\n        this._readConfiguration();\n        const stickyScrollDomNode = this._stickyScrollWidget.getDomNode();\n        this._register(this._editor.onDidChangeConfiguration(e => {\n            this._readConfigurationChange(e);\n        }));\n        this._register(dom.addDisposableListener(stickyScrollDomNode, dom.EventType.CONTEXT_MENU, async (event) => {\n            this._onContextMenu(dom.getWindow(stickyScrollDomNode), event);\n        }));\n        this._stickyScrollFocusedContextKey = EditorContextKeys.stickyScrollFocused.bindTo(this._contextKeyService);\n        this._stickyScrollVisibleContextKey = EditorContextKeys.stickyScrollVisible.bindTo(this._contextKeyService);\n        const focusTracker = this._register(dom.trackFocus(stickyScrollDomNode));\n        this._register(focusTracker.onDidBlur(_ => {\n            // Suppose that the blurring is caused by scrolling, then keep the focus on the sticky scroll\n            // This is determined by the fact that the height of the widget has become zero and there has been no position revealing\n            if (this._positionRevealed === false && stickyScrollDomNode.clientHeight === 0) {\n                this._focusedStickyElementIndex = -1;\n                this.focus();\n            }\n            // In all other casees, dispose the focus on the sticky scroll\n            else {\n                this._disposeFocusStickyScrollStore();\n            }\n        }));\n        this._register(focusTracker.onDidFocus(_ => {\n            this.focus();\n        }));\n        this._registerMouseListeners();\n        // Suppose that mouse down on the sticky scroll, then do not focus on the sticky scroll because this will be followed by the revealing of a position\n        this._register(dom.addDisposableListener(stickyScrollDomNode, dom.EventType.MOUSE_DOWN, (e) => {\n            this._onMouseDown = true;\n        }));\n    }\n    static get(editor) {\n        return editor.getContribution(StickyScrollController_1.ID);\n    }\n    _disposeFocusStickyScrollStore() {\n        this._stickyScrollFocusedContextKey.set(false);\n        this._focusDisposableStore?.dispose();\n        this._focused = false;\n        this._positionRevealed = false;\n        this._onMouseDown = false;\n    }\n    focus() {\n        // If the mouse is down, do not focus on the sticky scroll\n        if (this._onMouseDown) {\n            this._onMouseDown = false;\n            this._editor.focus();\n            return;\n        }\n        const focusState = this._stickyScrollFocusedContextKey.get();\n        if (focusState === true) {\n            return;\n        }\n        this._focused = true;\n        this._focusDisposableStore = new DisposableStore();\n        this._stickyScrollFocusedContextKey.set(true);\n        this._focusedStickyElementIndex = this._stickyScrollWidget.lineNumbers.length - 1;\n        this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex);\n    }\n    focusNext() {\n        if (this._focusedStickyElementIndex < this._stickyScrollWidget.lineNumberCount - 1) {\n            this._focusNav(true);\n        }\n    }\n    focusPrevious() {\n        if (this._focusedStickyElementIndex > 0) {\n            this._focusNav(false);\n        }\n    }\n    selectEditor() {\n        this._editor.focus();\n    }\n    // True is next, false is previous\n    _focusNav(direction) {\n        this._focusedStickyElementIndex = direction ? this._focusedStickyElementIndex + 1 : this._focusedStickyElementIndex - 1;\n        this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex);\n    }\n    goToFocused() {\n        const lineNumbers = this._stickyScrollWidget.lineNumbers;\n        this._disposeFocusStickyScrollStore();\n        this._revealPosition({ lineNumber: lineNumbers[this._focusedStickyElementIndex], column: 1 });\n    }\n    _revealPosition(position) {\n        this._reveaInEditor(position, () => this._editor.revealPosition(position));\n    }\n    _revealLineInCenterIfOutsideViewport(position) {\n        this._reveaInEditor(position, () => this._editor.revealLineInCenterIfOutsideViewport(position.lineNumber, 0 /* ScrollType.Smooth */));\n    }\n    _reveaInEditor(position, revealFunction) {\n        if (this._focused) {\n            this._disposeFocusStickyScrollStore();\n        }\n        this._positionRevealed = true;\n        revealFunction();\n        this._editor.setSelection(Range.fromPositions(position));\n        this._editor.focus();\n    }\n    _registerMouseListeners() {\n        const sessionStore = this._register(new DisposableStore());\n        const gesture = this._register(new ClickLinkGesture(this._editor, {\n            extractLineNumberFromMouseEvent: (e) => {\n                const position = this._stickyScrollWidget.getEditorPositionFromNode(e.target.element);\n                return position ? position.lineNumber : 0;\n            }\n        }));\n        const getMouseEventTarget = (mouseEvent) => {\n            if (!this._editor.hasModel()) {\n                return null;\n            }\n            if (mouseEvent.target.type !== 12 /* MouseTargetType.OVERLAY_WIDGET */ || mouseEvent.target.detail !== this._stickyScrollWidget.getId()) {\n                // not hovering over our widget\n                return null;\n            }\n            const mouseTargetElement = mouseEvent.target.element;\n            if (!mouseTargetElement || mouseTargetElement.innerText !== mouseTargetElement.innerHTML) {\n                // not on a span element rendering text\n                return null;\n            }\n            const position = this._stickyScrollWidget.getEditorPositionFromNode(mouseTargetElement);\n            if (!position) {\n                // not hovering a sticky scroll line\n                return null;\n            }\n            return {\n                range: new Range(position.lineNumber, position.column, position.lineNumber, position.column + mouseTargetElement.innerText.length),\n                textElement: mouseTargetElement\n            };\n        };\n        const stickyScrollWidgetDomNode = this._stickyScrollWidget.getDomNode();\n        this._register(dom.addStandardDisposableListener(stickyScrollWidgetDomNode, dom.EventType.CLICK, (mouseEvent) => {\n            if (mouseEvent.ctrlKey || mouseEvent.altKey || mouseEvent.metaKey) {\n                // modifier pressed\n                return;\n            }\n            if (!mouseEvent.leftButton) {\n                // not left click\n                return;\n            }\n            if (mouseEvent.shiftKey) {\n                // shift click\n                const lineIndex = this._stickyScrollWidget.getLineIndexFromChildDomNode(mouseEvent.target);\n                if (lineIndex === null) {\n                    return;\n                }\n                const position = new Position(this._endLineNumbers[lineIndex], 1);\n                this._revealLineInCenterIfOutsideViewport(position);\n                return;\n            }\n            const isInFoldingIconDomNode = this._stickyScrollWidget.isInFoldingIconDomNode(mouseEvent.target);\n            if (isInFoldingIconDomNode) {\n                // clicked on folding icon\n                const lineNumber = this._stickyScrollWidget.getLineNumberFromChildDomNode(mouseEvent.target);\n                this._toggleFoldingRegionForLine(lineNumber);\n                return;\n            }\n            const isInStickyLine = this._stickyScrollWidget.isInStickyLine(mouseEvent.target);\n            if (!isInStickyLine) {\n                return;\n            }\n            // normal click\n            let position = this._stickyScrollWidget.getEditorPositionFromNode(mouseEvent.target);\n            if (!position) {\n                const lineNumber = this._stickyScrollWidget.getLineNumberFromChildDomNode(mouseEvent.target);\n                if (lineNumber === null) {\n                    // not hovering a sticky scroll line\n                    return;\n                }\n                position = new Position(lineNumber, 1);\n            }\n            this._revealPosition(position);\n        }));\n        this._register(dom.addStandardDisposableListener(stickyScrollWidgetDomNode, dom.EventType.MOUSE_MOVE, (mouseEvent) => {\n            if (mouseEvent.shiftKey) {\n                const currentEndForLineIndex = this._stickyScrollWidget.getLineIndexFromChildDomNode(mouseEvent.target);\n                if (currentEndForLineIndex === null || this._showEndForLine !== null && this._showEndForLine === currentEndForLineIndex) {\n                    return;\n                }\n                this._showEndForLine = currentEndForLineIndex;\n                this._renderStickyScroll();\n                return;\n            }\n            if (this._showEndForLine !== undefined) {\n                this._showEndForLine = undefined;\n                this._renderStickyScroll();\n            }\n        }));\n        this._register(dom.addDisposableListener(stickyScrollWidgetDomNode, dom.EventType.MOUSE_LEAVE, (e) => {\n            if (this._showEndForLine !== undefined) {\n                this._showEndForLine = undefined;\n                this._renderStickyScroll();\n            }\n        }));\n        this._register(gesture.onMouseMoveOrRelevantKeyDown(([mouseEvent, _keyboardEvent]) => {\n            const mouseTarget = getMouseEventTarget(mouseEvent);\n            if (!mouseTarget || !mouseEvent.hasTriggerModifier || !this._editor.hasModel()) {\n                sessionStore.clear();\n                return;\n            }\n            const { range, textElement } = mouseTarget;\n            if (!range.equalsRange(this._stickyRangeProjectedOnEditor)) {\n                this._stickyRangeProjectedOnEditor = range;\n                sessionStore.clear();\n            }\n            else if (textElement.style.textDecoration === 'underline') {\n                return;\n            }\n            const cancellationToken = new CancellationTokenSource();\n            sessionStore.add(toDisposable(() => cancellationToken.dispose(true)));\n            let currentHTMLChild;\n            getDefinitionsAtPosition(this._languageFeaturesService.definitionProvider, this._editor.getModel(), new Position(range.startLineNumber, range.startColumn + 1), false, cancellationToken.token).then((candidateDefinitions => {\n                if (cancellationToken.token.isCancellationRequested) {\n                    return;\n                }\n                if (candidateDefinitions.length !== 0) {\n                    this._candidateDefinitionsLength = candidateDefinitions.length;\n                    const childHTML = textElement;\n                    if (currentHTMLChild !== childHTML) {\n                        sessionStore.clear();\n                        currentHTMLChild = childHTML;\n                        currentHTMLChild.style.textDecoration = 'underline';\n                        sessionStore.add(toDisposable(() => {\n                            currentHTMLChild.style.textDecoration = 'none';\n                        }));\n                    }\n                    else if (!currentHTMLChild) {\n                        currentHTMLChild = childHTML;\n                        currentHTMLChild.style.textDecoration = 'underline';\n                        sessionStore.add(toDisposable(() => {\n                            currentHTMLChild.style.textDecoration = 'none';\n                        }));\n                    }\n                }\n                else {\n                    sessionStore.clear();\n                }\n            }));\n        }));\n        this._register(gesture.onCancel(() => {\n            sessionStore.clear();\n        }));\n        this._register(gesture.onExecute(async (e) => {\n            if (e.target.type !== 12 /* MouseTargetType.OVERLAY_WIDGET */ || e.target.detail !== this._stickyScrollWidget.getId()) {\n                // not hovering over our widget\n                return;\n            }\n            const position = this._stickyScrollWidget.getEditorPositionFromNode(e.target.element);\n            if (!position) {\n                // not hovering a sticky scroll line\n                return;\n            }\n            if (!this._editor.hasModel() || !this._stickyRangeProjectedOnEditor) {\n                return;\n            }\n            if (this._candidateDefinitionsLength > 1) {\n                if (this._focused) {\n                    this._disposeFocusStickyScrollStore();\n                }\n                this._revealPosition({ lineNumber: position.lineNumber, column: 1 });\n            }\n            this._instaService.invokeFunction(goToDefinitionWithLocation, e, this._editor, { uri: this._editor.getModel().uri, range: this._stickyRangeProjectedOnEditor });\n        }));\n    }\n    _onContextMenu(targetWindow, e) {\n        const event = new StandardMouseEvent(targetWindow, e);\n        this._contextMenuService.showContextMenu({\n            menuId: MenuId.StickyScrollContext,\n            getAnchor: () => event,\n        });\n    }\n    _toggleFoldingRegionForLine(line) {\n        if (!this._foldingModel || line === null) {\n            return;\n        }\n        const stickyLine = this._stickyScrollWidget.getRenderedStickyLine(line);\n        const foldingIcon = stickyLine?.foldingIcon;\n        if (!foldingIcon) {\n            return;\n        }\n        toggleCollapseState(this._foldingModel, Number.MAX_VALUE, [line]);\n        foldingIcon.isCollapsed = !foldingIcon.isCollapsed;\n        const scrollTop = (foldingIcon.isCollapsed ?\n            this._editor.getTopForLineNumber(foldingIcon.foldingEndLine)\n            : this._editor.getTopForLineNumber(foldingIcon.foldingStartLine))\n            - this._editor.getOption(67 /* EditorOption.lineHeight */) * stickyLine.index + 1;\n        this._editor.setScrollTop(scrollTop);\n        this._renderStickyScroll(line);\n    }\n    _readConfiguration() {\n        const options = this._editor.getOption(116 /* EditorOption.stickyScroll */);\n        if (options.enabled === false) {\n            this._editor.removeOverlayWidget(this._stickyScrollWidget);\n            this._sessionStore.clear();\n            this._enabled = false;\n            return;\n        }\n        else if (options.enabled && !this._enabled) {\n            // When sticky scroll was just enabled, add the listeners on the sticky scroll\n            this._editor.addOverlayWidget(this._stickyScrollWidget);\n            this._sessionStore.add(this._editor.onDidScrollChange((e) => {\n                if (e.scrollTopChanged) {\n                    this._showEndForLine = undefined;\n                    this._renderStickyScroll();\n                }\n            }));\n            this._sessionStore.add(this._editor.onDidLayoutChange(() => this._onDidResize()));\n            this._sessionStore.add(this._editor.onDidChangeModelTokens((e) => this._onTokensChange(e)));\n            this._sessionStore.add(this._stickyLineCandidateProvider.onDidChangeStickyScroll(() => {\n                this._showEndForLine = undefined;\n                this._renderStickyScroll();\n            }));\n            this._enabled = true;\n        }\n        const lineNumberOption = this._editor.getOption(68 /* EditorOption.lineNumbers */);\n        if (lineNumberOption.renderType === 2 /* RenderLineNumbersType.Relative */) {\n            this._sessionStore.add(this._editor.onDidChangeCursorPosition(() => {\n                this._showEndForLine = undefined;\n                this._renderStickyScroll(0);\n            }));\n        }\n    }\n    _readConfigurationChange(event) {\n        if (event.hasChanged(116 /* EditorOption.stickyScroll */)\n            || event.hasChanged(73 /* EditorOption.minimap */)\n            || event.hasChanged(67 /* EditorOption.lineHeight */)\n            || event.hasChanged(111 /* EditorOption.showFoldingControls */)\n            || event.hasChanged(68 /* EditorOption.lineNumbers */)) {\n            this._readConfiguration();\n        }\n        if (event.hasChanged(68 /* EditorOption.lineNumbers */)) {\n            this._renderStickyScroll(0);\n        }\n    }\n    _needsUpdate(event) {\n        const stickyLineNumbers = this._stickyScrollWidget.getCurrentLines();\n        for (const stickyLineNumber of stickyLineNumbers) {\n            for (const range of event.ranges) {\n                if (stickyLineNumber >= range.fromLineNumber && stickyLineNumber <= range.toLineNumber) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    _onTokensChange(event) {\n        if (this._needsUpdate(event)) {\n            // Rebuilding the whole widget from line 0\n            this._renderStickyScroll(0);\n        }\n    }\n    _onDidResize() {\n        const layoutInfo = this._editor.getLayoutInfo();\n        // Make sure sticky scroll doesn't take up more than 25% of the editor\n        const theoreticalLines = layoutInfo.height / this._editor.getOption(67 /* EditorOption.lineHeight */);\n        this._maxStickyLines = Math.round(theoreticalLines * .25);\n    }\n    async _renderStickyScroll(rebuildFromLine) {\n        const model = this._editor.getModel();\n        if (!model || model.isTooLargeForTokenization()) {\n            this._resetState();\n            return;\n        }\n        const nextRebuildFromLine = this._updateAndGetMinRebuildFromLine(rebuildFromLine);\n        const stickyWidgetVersion = this._stickyLineCandidateProvider.getVersionId();\n        const shouldUpdateState = stickyWidgetVersion === undefined || stickyWidgetVersion === model.getVersionId();\n        if (shouldUpdateState) {\n            if (!this._focused) {\n                await this._updateState(nextRebuildFromLine);\n            }\n            else {\n                // Suppose that previously the sticky scroll widget had height 0, then if there are visible lines, set the last line as focused\n                if (this._focusedStickyElementIndex === -1) {\n                    await this._updateState(nextRebuildFromLine);\n                    this._focusedStickyElementIndex = this._stickyScrollWidget.lineNumberCount - 1;\n                    if (this._focusedStickyElementIndex !== -1) {\n                        this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex);\n                    }\n                }\n                else {\n                    const focusedStickyElementLineNumber = this._stickyScrollWidget.lineNumbers[this._focusedStickyElementIndex];\n                    await this._updateState(nextRebuildFromLine);\n                    // Suppose that after setting the state, there are no sticky lines, set the focused index to -1\n                    if (this._stickyScrollWidget.lineNumberCount === 0) {\n                        this._focusedStickyElementIndex = -1;\n                    }\n                    else {\n                        const previousFocusedLineNumberExists = this._stickyScrollWidget.lineNumbers.includes(focusedStickyElementLineNumber);\n                        // If the line number is still there, do not change anything\n                        // If the line number is not there, set the new focused line to be the last line\n                        if (!previousFocusedLineNumberExists) {\n                            this._focusedStickyElementIndex = this._stickyScrollWidget.lineNumberCount - 1;\n                        }\n                        this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex);\n                    }\n                }\n            }\n        }\n    }\n    _updateAndGetMinRebuildFromLine(rebuildFromLine) {\n        if (rebuildFromLine !== undefined) {\n            const minRebuildFromLineOrInfinity = this._minRebuildFromLine !== undefined ? this._minRebuildFromLine : Infinity;\n            this._minRebuildFromLine = Math.min(rebuildFromLine, minRebuildFromLineOrInfinity);\n        }\n        return this._minRebuildFromLine;\n    }\n    async _updateState(rebuildFromLine) {\n        this._minRebuildFromLine = undefined;\n        this._foldingModel = await FoldingController.get(this._editor)?.getFoldingModel() ?? undefined;\n        this._widgetState = this.findScrollWidgetState();\n        const stickyWidgetHasLines = this._widgetState.startLineNumbers.length > 0;\n        this._stickyScrollVisibleContextKey.set(stickyWidgetHasLines);\n        this._stickyScrollWidget.setState(this._widgetState, this._foldingModel, rebuildFromLine);\n    }\n    async _resetState() {\n        this._minRebuildFromLine = undefined;\n        this._foldingModel = undefined;\n        this._widgetState = StickyScrollWidgetState.Empty;\n        this._stickyScrollVisibleContextKey.set(false);\n        this._stickyScrollWidget.setState(undefined, undefined);\n    }\n    findScrollWidgetState() {\n        const lineHeight = this._editor.getOption(67 /* EditorOption.lineHeight */);\n        const maxNumberStickyLines = Math.min(this._maxStickyLines, this._editor.getOption(116 /* EditorOption.stickyScroll */).maxLineCount);\n        const scrollTop = this._editor.getScrollTop();\n        let lastLineRelativePosition = 0;\n        const startLineNumbers = [];\n        const endLineNumbers = [];\n        const arrayVisibleRanges = this._editor.getVisibleRanges();\n        if (arrayVisibleRanges.length !== 0) {\n            const fullVisibleRange = new StickyRange(arrayVisibleRanges[0].startLineNumber, arrayVisibleRanges[arrayVisibleRanges.length - 1].endLineNumber);\n            const candidateRanges = this._stickyLineCandidateProvider.getCandidateStickyLinesIntersecting(fullVisibleRange);\n            for (const range of candidateRanges) {\n                const start = range.startLineNumber;\n                const end = range.endLineNumber;\n                const depth = range.nestingDepth;\n                if (end - start > 0) {\n                    const topOfElementAtDepth = (depth - 1) * lineHeight;\n                    const bottomOfElementAtDepth = depth * lineHeight;\n                    const bottomOfBeginningLine = this._editor.getBottomForLineNumber(start) - scrollTop;\n                    const topOfEndLine = this._editor.getTopForLineNumber(end) - scrollTop;\n                    const bottomOfEndLine = this._editor.getBottomForLineNumber(end) - scrollTop;\n                    if (topOfElementAtDepth > topOfEndLine && topOfElementAtDepth <= bottomOfEndLine) {\n                        startLineNumbers.push(start);\n                        endLineNumbers.push(end + 1);\n                        lastLineRelativePosition = bottomOfEndLine - bottomOfElementAtDepth;\n                        break;\n                    }\n                    else if (bottomOfElementAtDepth > bottomOfBeginningLine && bottomOfElementAtDepth <= bottomOfEndLine) {\n                        startLineNumbers.push(start);\n                        endLineNumbers.push(end + 1);\n                    }\n                    if (startLineNumbers.length === maxNumberStickyLines) {\n                        break;\n                    }\n                }\n            }\n        }\n        this._endLineNumbers = endLineNumbers;\n        return new StickyScrollWidgetState(startLineNumbers, endLineNumbers, lastLineRelativePosition, this._showEndForLine);\n    }\n    dispose() {\n        super.dispose();\n        this._sessionStore.dispose();\n    }\n};\nStickyScrollController = StickyScrollController_1 = __decorate([\n    __param(1, IContextMenuService),\n    __param(2, ILanguageFeaturesService),\n    __param(3, IInstantiationService),\n    __param(4, ILanguageConfigurationService),\n    __param(5, ILanguageFeatureDebounceService),\n    __param(6, IContextKeyService)\n], StickyScrollController);\nexport { StickyScrollController };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}