{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as DOM from './dom.js';\nimport * as dompurify from './dompurify/dompurify.js';\nimport { DomEmitter } from './event.js';\nimport { createElement } from './formattedTextRenderer.js';\nimport { StandardKeyboardEvent } from './keyboardEvent.js';\nimport { StandardMouseEvent } from './mouseEvent.js';\nimport { renderLabelWithIcons } from './ui/iconLabel/iconLabels.js';\nimport { onUnexpectedError } from '../common/errors.js';\nimport { Event } from '../common/event.js';\nimport { escapeDoubleQuotes, parseHrefAndDimensions, removeMarkdownEscapes } from '../common/htmlContent.js';\nimport { markdownEscapeEscapedIcons } from '../common/iconLabels.js';\nimport { defaultGenerator } from '../common/idGenerator.js';\nimport { Lazy } from '../common/lazy.js';\nimport { DisposableStore, toDisposable } from '../common/lifecycle.js';\nimport * as marked from '../common/marked/marked.js';\nimport { parse } from '../common/marshalling.js';\nimport { FileAccess, Schemas } from '../common/network.js';\nimport { cloneAndChange } from '../common/objects.js';\nimport { dirname, resolvePath } from '../common/resources.js';\nimport { escape } from '../common/strings.js';\nimport { URI } from '../common/uri.js';\nconst defaultMarkedRenderers = Object.freeze({\n  image: _ref => {\n    let {\n      href,\n      title,\n      text\n    } = _ref;\n    let dimensions = [];\n    let attributes = [];\n    if (href) {\n      ({\n        href,\n        dimensions\n      } = parseHrefAndDimensions(href));\n      attributes.push(\"src=\\\"\".concat(escapeDoubleQuotes(href), \"\\\"\"));\n    }\n    if (text) {\n      attributes.push(\"alt=\\\"\".concat(escapeDoubleQuotes(text), \"\\\"\"));\n    }\n    if (title) {\n      attributes.push(\"title=\\\"\".concat(escapeDoubleQuotes(title), \"\\\"\"));\n    }\n    if (dimensions.length) {\n      attributes = attributes.concat(dimensions);\n    }\n    return '<img ' + attributes.join(' ') + '>';\n  },\n  paragraph(_ref2) {\n    let {\n      tokens\n    } = _ref2;\n    return \"<p>\".concat(this.parser.parseInline(tokens), \"</p>\");\n  },\n  link(_ref3) {\n    let {\n      href,\n      title,\n      tokens\n    } = _ref3;\n    let text = this.parser.parseInline(tokens);\n    if (typeof href !== 'string') {\n      return '';\n    }\n    // Remove markdown escapes. Workaround for https://github.com/chjj/marked/issues/829\n    if (href === text) {\n      // raw link case\n      text = removeMarkdownEscapes(text);\n    }\n    title = typeof title === 'string' ? escapeDoubleQuotes(removeMarkdownEscapes(title)) : '';\n    href = removeMarkdownEscapes(href);\n    // HTML Encode href\n    href = href.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;');\n    return \"<a href=\\\"\".concat(href, \"\\\" title=\\\"\").concat(title || href, \"\\\" draggable=\\\"false\\\">\").concat(text, \"</a>\");\n  }\n});\n/**\n * Low-level way create a html element from a markdown string.\n *\n * **Note** that for most cases you should be using [`MarkdownRenderer`](./src/vs/editor/contrib/markdownRenderer/browser/markdownRenderer.ts)\n * which comes with support for pretty code block rendering and which uses the default way of handling links.\n */\nexport function renderMarkdown(markdown) {\n  var _markdown$value;\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let markedOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const disposables = new DisposableStore();\n  let isDisposed = false;\n  const element = createElement(options);\n  const _uriMassage = function (part) {\n    let data;\n    try {\n      data = parse(decodeURIComponent(part));\n    } catch (e) {\n      // ignore\n    }\n    if (!data) {\n      return part;\n    }\n    data = cloneAndChange(data, value => {\n      if (markdown.uris && markdown.uris[value]) {\n        return URI.revive(markdown.uris[value]);\n      } else {\n        return undefined;\n      }\n    });\n    return encodeURIComponent(JSON.stringify(data));\n  };\n  const _href = function (href, isDomUri) {\n    const data = markdown.uris && markdown.uris[href];\n    let uri = URI.revive(data);\n    if (isDomUri) {\n      if (href.startsWith(Schemas.data + ':')) {\n        return href;\n      }\n      if (!uri) {\n        uri = URI.parse(href);\n      }\n      // this URI will end up as \"src\"-attribute of a dom node\n      // and because of that special rewriting needs to be done\n      // so that the URI uses a protocol that's understood by\n      // browsers (like http or https)\n      return FileAccess.uriToBrowserUri(uri).toString(true);\n    }\n    if (!uri) {\n      return href;\n    }\n    if (URI.parse(href).toString() === uri.toString()) {\n      return href; // no transformation performed\n    }\n    if (uri.query) {\n      uri = uri.with({\n        query: _uriMassage(uri.query)\n      });\n    }\n    return uri.toString();\n  };\n  const renderer = new marked.Renderer();\n  renderer.image = defaultMarkedRenderers.image;\n  renderer.link = defaultMarkedRenderers.link;\n  renderer.paragraph = defaultMarkedRenderers.paragraph;\n  // Will collect [id, renderedElement] tuples\n  const codeBlocks = [];\n  const syncCodeBlocks = [];\n  if (options.codeBlockRendererSync) {\n    renderer.code = _ref4 => {\n      let {\n        text,\n        lang\n      } = _ref4;\n      const id = defaultGenerator.nextId();\n      const value = options.codeBlockRendererSync(postProcessCodeBlockLanguageId(lang), text);\n      syncCodeBlocks.push([id, value]);\n      return \"<div class=\\\"code\\\" data-code=\\\"\".concat(id, \"\\\">\").concat(escape(text), \"</div>\");\n    };\n  } else if (options.codeBlockRenderer) {\n    renderer.code = _ref5 => {\n      let {\n        text,\n        lang\n      } = _ref5;\n      const id = defaultGenerator.nextId();\n      const value = options.codeBlockRenderer(postProcessCodeBlockLanguageId(lang), text);\n      codeBlocks.push(value.then(element => [id, element]));\n      return \"<div class=\\\"code\\\" data-code=\\\"\".concat(id, \"\\\">\").concat(escape(text), \"</div>\");\n    };\n  }\n  if (options.actionHandler) {\n    const _activateLink = function (event) {\n      let target = event.target;\n      if (target.tagName !== 'A') {\n        target = target.parentElement;\n        if (!target || target.tagName !== 'A') {\n          return;\n        }\n      }\n      try {\n        let href = target.dataset['href'];\n        if (href) {\n          if (markdown.baseUri) {\n            href = resolveWithBaseUri(URI.from(markdown.baseUri), href);\n          }\n          options.actionHandler.callback(href, event);\n        }\n      } catch (err) {\n        onUnexpectedError(err);\n      } finally {\n        event.preventDefault();\n      }\n    };\n    const onClick = options.actionHandler.disposables.add(new DomEmitter(element, 'click'));\n    const onAuxClick = options.actionHandler.disposables.add(new DomEmitter(element, 'auxclick'));\n    options.actionHandler.disposables.add(Event.any(onClick.event, onAuxClick.event)(e => {\n      const mouseEvent = new StandardMouseEvent(DOM.getWindow(element), e);\n      if (!mouseEvent.leftButton && !mouseEvent.middleButton) {\n        return;\n      }\n      _activateLink(mouseEvent);\n    }));\n    options.actionHandler.disposables.add(DOM.addDisposableListener(element, 'keydown', e => {\n      const keyboardEvent = new StandardKeyboardEvent(e);\n      if (!keyboardEvent.equals(10 /* KeyCode.Space */) && !keyboardEvent.equals(3 /* KeyCode.Enter */)) {\n        return;\n      }\n      _activateLink(keyboardEvent);\n    }));\n  }\n  if (!markdown.supportHtml) {\n    // Note: we always pass the output through dompurify after this so that we don't rely on\n    // marked for real sanitization.\n    renderer.html = _ref6 => {\n      var _options$sanitizerOpt;\n      let {\n        text\n      } = _ref6;\n      if ((_options$sanitizerOpt = options.sanitizerOptions) !== null && _options$sanitizerOpt !== void 0 && _options$sanitizerOpt.replaceWithPlaintext) {\n        return escape(text);\n      }\n      const match = markdown.isTrusted ? text.match(/^(<span[^>]+>)|(<\\/\\s*span>)$/) : undefined;\n      return match ? text : '';\n    };\n  }\n  markedOptions.renderer = renderer;\n  // values that are too long will freeze the UI\n  let value = (_markdown$value = markdown.value) !== null && _markdown$value !== void 0 ? _markdown$value : '';\n  if (value.length > 100000) {\n    value = \"\".concat(value.substr(0, 100000), \"\\u2026\");\n  }\n  // escape theme icons\n  if (markdown.supportThemeIcons) {\n    value = markdownEscapeEscapedIcons(value);\n  }\n  let renderedMarkdown;\n  if (options.fillInIncompleteTokens) {\n    // The defaults are applied by parse but not lexer()/parser(), and they need to be present\n    const opts = {\n      ...marked.defaults,\n      ...markedOptions\n    };\n    const tokens = marked.lexer(value, opts);\n    const newTokens = fillInIncompleteTokens(tokens);\n    renderedMarkdown = marked.parser(newTokens, opts);\n  } else {\n    renderedMarkdown = marked.parse(value, {\n      ...markedOptions,\n      async: false\n    });\n  }\n  // Rewrite theme icons\n  if (markdown.supportThemeIcons) {\n    const elements = renderLabelWithIcons(renderedMarkdown);\n    renderedMarkdown = elements.map(e => typeof e === 'string' ? e : e.outerHTML).join('');\n  }\n  const htmlParser = new DOMParser();\n  const markdownHtmlDoc = htmlParser.parseFromString(sanitizeRenderedMarkdown({\n    isTrusted: markdown.isTrusted,\n    ...options.sanitizerOptions\n  }, renderedMarkdown), 'text/html');\n  markdownHtmlDoc.body.querySelectorAll('img, audio, video, source').forEach(img => {\n    const src = img.getAttribute('src'); // Get the raw 'src' attribute value as text, not the resolved 'src'\n    if (src) {\n      let href = src;\n      try {\n        if (markdown.baseUri) {\n          // absolute or relative local path, or file: uri\n          href = resolveWithBaseUri(URI.from(markdown.baseUri), href);\n        }\n      } catch (err) {}\n      img.setAttribute('src', _href(href, true));\n      if (options.remoteImageIsAllowed) {\n        const uri = URI.parse(href);\n        if (uri.scheme !== Schemas.file && uri.scheme !== Schemas.data && !options.remoteImageIsAllowed(uri)) {\n          img.replaceWith(DOM.$('', undefined, img.outerHTML));\n        }\n      }\n    }\n  });\n  markdownHtmlDoc.body.querySelectorAll('a').forEach(a => {\n    const href = a.getAttribute('href'); // Get the raw 'href' attribute value as text, not the resolved 'href'\n    a.setAttribute('href', ''); // Clear out href. We use the `data-href` for handling clicks instead\n    if (!href || /^data:|javascript:/i.test(href) || /^command:/i.test(href) && !markdown.isTrusted || /^command:(\\/\\/\\/)?_workbench\\.downloadResource/i.test(href)) {\n      // drop the link\n      a.replaceWith(...a.childNodes);\n    } else {\n      let resolvedHref = _href(href, false);\n      if (markdown.baseUri) {\n        resolvedHref = resolveWithBaseUri(URI.from(markdown.baseUri), href);\n      }\n      a.dataset.href = resolvedHref;\n    }\n  });\n  element.innerHTML = sanitizeRenderedMarkdown({\n    isTrusted: markdown.isTrusted,\n    ...options.sanitizerOptions\n  }, markdownHtmlDoc.body.innerHTML);\n  if (codeBlocks.length > 0) {\n    Promise.all(codeBlocks).then(tuples => {\n      var _options$asyncRenderC;\n      if (isDisposed) {\n        return;\n      }\n      const renderedElements = new Map(tuples);\n      const placeholderElements = element.querySelectorAll(\"div[data-code]\");\n      for (const placeholderElement of placeholderElements) {\n        var _placeholderElement$d;\n        const renderedElement = renderedElements.get((_placeholderElement$d = placeholderElement.dataset['code']) !== null && _placeholderElement$d !== void 0 ? _placeholderElement$d : '');\n        if (renderedElement) {\n          DOM.reset(placeholderElement, renderedElement);\n        }\n      }\n      (_options$asyncRenderC = options.asyncRenderCallback) === null || _options$asyncRenderC === void 0 || _options$asyncRenderC.call(options);\n    });\n  } else if (syncCodeBlocks.length > 0) {\n    const renderedElements = new Map(syncCodeBlocks);\n    const placeholderElements = element.querySelectorAll(\"div[data-code]\");\n    for (const placeholderElement of placeholderElements) {\n      var _placeholderElement$d2;\n      const renderedElement = renderedElements.get((_placeholderElement$d2 = placeholderElement.dataset['code']) !== null && _placeholderElement$d2 !== void 0 ? _placeholderElement$d2 : '');\n      if (renderedElement) {\n        DOM.reset(placeholderElement, renderedElement);\n      }\n    }\n  }\n  // signal size changes for image tags\n  if (options.asyncRenderCallback) {\n    for (const img of element.getElementsByTagName('img')) {\n      const listener = disposables.add(DOM.addDisposableListener(img, 'load', () => {\n        listener.dispose();\n        options.asyncRenderCallback();\n      }));\n    }\n  }\n  return {\n    element,\n    dispose: () => {\n      isDisposed = true;\n      disposables.dispose();\n    }\n  };\n}\nfunction postProcessCodeBlockLanguageId(lang) {\n  if (!lang) {\n    return '';\n  }\n  const parts = lang.split(/[\\s+|:|,|\\{|\\?]/, 1);\n  if (parts.length) {\n    return parts[0];\n  }\n  return lang;\n}\nfunction resolveWithBaseUri(baseUri, href) {\n  const hasScheme = /^\\w[\\w\\d+.-]*:/.test(href);\n  if (hasScheme) {\n    return href;\n  }\n  if (baseUri.path.endsWith('/')) {\n    return resolvePath(baseUri, href).toString();\n  } else {\n    return resolvePath(dirname(baseUri), href).toString();\n  }\n}\nconst selfClosingTags = ['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'];\nfunction sanitizeRenderedMarkdown(options, renderedMarkdown) {\n  const {\n    config,\n    allowedSchemes\n  } = getSanitizerOptions(options);\n  const store = new DisposableStore();\n  store.add(addDompurifyHook('uponSanitizeAttribute', (element, e) => {\n    var _element$attributes$g;\n    if (e.attrName === 'style' || e.attrName === 'class') {\n      if (element.tagName === 'SPAN') {\n        if (e.attrName === 'style') {\n          e.keepAttr = /^(color\\:(#[0-9a-fA-F]+|var\\(--vscode(-[a-zA-Z]+)+\\));)?(background-color\\:(#[0-9a-fA-F]+|var\\(--vscode(-[a-zA-Z]+)+\\));)?(border-radius:[0-9]+px;)?$/.test(e.attrValue);\n          return;\n        } else if (e.attrName === 'class') {\n          e.keepAttr = /^codicon codicon-[a-z\\-]+( codicon-modifier-[a-z\\-]+)?$/.test(e.attrValue);\n          return;\n        }\n      }\n      e.keepAttr = false;\n      return;\n    } else if (element.tagName === 'INPUT' && ((_element$attributes$g = element.attributes.getNamedItem('type')) === null || _element$attributes$g === void 0 ? void 0 : _element$attributes$g.value) === 'checkbox') {\n      if (e.attrName === 'type' && e.attrValue === 'checkbox' || e.attrName === 'disabled' || e.attrName === 'checked') {\n        e.keepAttr = true;\n        return;\n      }\n      e.keepAttr = false;\n    }\n  }));\n  store.add(addDompurifyHook('uponSanitizeElement', (element, e) => {\n    if (e.tagName === 'input') {\n      var _element$attributes$g2;\n      if (((_element$attributes$g2 = element.attributes.getNamedItem('type')) === null || _element$attributes$g2 === void 0 ? void 0 : _element$attributes$g2.value) === 'checkbox') {\n        element.setAttribute('disabled', '');\n      } else if (!options.replaceWithPlaintext) {\n        element.remove();\n      }\n    }\n    if (options.replaceWithPlaintext && !e.allowedTags[e.tagName] && e.tagName !== 'body') {\n      if (element.parentElement) {\n        let startTagText;\n        let endTagText;\n        if (e.tagName === '#comment') {\n          startTagText = \"<!--\".concat(element.textContent, \"-->\");\n        } else {\n          const isSelfClosing = selfClosingTags.includes(e.tagName);\n          const attrString = element.attributes.length ? ' ' + Array.from(element.attributes).map(attr => \"\".concat(attr.name, \"=\\\"\").concat(attr.value, \"\\\"\")).join(' ') : '';\n          startTagText = \"<\".concat(e.tagName).concat(attrString, \">\");\n          if (!isSelfClosing) {\n            endTagText = \"</\".concat(e.tagName, \">\");\n          }\n        }\n        const fragment = document.createDocumentFragment();\n        const textNode = element.parentElement.ownerDocument.createTextNode(startTagText);\n        fragment.appendChild(textNode);\n        const endTagTextNode = endTagText ? element.parentElement.ownerDocument.createTextNode(endTagText) : undefined;\n        while (element.firstChild) {\n          fragment.appendChild(element.firstChild);\n        }\n        if (endTagTextNode) {\n          fragment.appendChild(endTagTextNode);\n        }\n        element.parentElement.replaceChild(fragment, element);\n      }\n    }\n  }));\n  store.add(DOM.hookDomPurifyHrefAndSrcSanitizer(allowedSchemes));\n  try {\n    return dompurify.sanitize(renderedMarkdown, {\n      ...config,\n      RETURN_TRUSTED_TYPE: true\n    });\n  } finally {\n    store.dispose();\n  }\n}\nexport const allowedMarkdownAttr = ['align', 'autoplay', 'alt', 'checked', 'class', 'colspan', 'controls', 'data-code', 'data-href', 'disabled', 'draggable', 'height', 'href', 'loop', 'muted', 'playsinline', 'poster', 'rowspan', 'src', 'style', 'target', 'title', 'type', 'width', 'start'];\nfunction getSanitizerOptions(options) {\n  var _options$allowedTags;\n  const allowedSchemes = [Schemas.http, Schemas.https, Schemas.mailto, Schemas.data, Schemas.file, Schemas.vscodeFileResource, Schemas.vscodeRemote, Schemas.vscodeRemoteResource];\n  if (options.isTrusted) {\n    allowedSchemes.push(Schemas.command);\n  }\n  return {\n    config: {\n      // allowedTags should included everything that markdown renders to.\n      // Since we have our own sanitize function for marked, it's possible we missed some tag so let dompurify make sure.\n      // HTML tags that can result from markdown are from reading https://spec.commonmark.org/0.29/\n      // HTML table tags that can result from markdown are from https://github.github.com/gfm/#tables-extension-\n      ALLOWED_TAGS: (_options$allowedTags = options.allowedTags) !== null && _options$allowedTags !== void 0 ? _options$allowedTags : [...DOM.basicMarkupHtmlTags],\n      ALLOWED_ATTR: allowedMarkdownAttr,\n      ALLOW_UNKNOWN_PROTOCOLS: true\n    },\n    allowedSchemes\n  };\n}\n/**\n * Strips all markdown from `string`, if it's an IMarkdownString. For example\n * `# Header` would be output as `Header`. If it's not, the string is returned.\n */\nexport function renderStringAsPlaintext(string) {\n  return typeof string === 'string' ? string : renderMarkdownAsPlaintext(string);\n}\n/**\n * Strips all markdown from `markdown`. For example `# Header` would be output as `Header`.\n * provide @param withCodeBlocks to retain code blocks\n */\nexport function renderMarkdownAsPlaintext(markdown, withCodeBlocks) {\n  var _markdown$value2;\n  // values that are too long will freeze the UI\n  let value = (_markdown$value2 = markdown.value) !== null && _markdown$value2 !== void 0 ? _markdown$value2 : '';\n  if (value.length > 100000) {\n    value = \"\".concat(value.substr(0, 100000), \"\\u2026\");\n  }\n  const html = marked.parse(value, {\n    async: false,\n    renderer: withCodeBlocks ? plainTextWithCodeBlocksRenderer.value : plainTextRenderer.value\n  }).replace(/&(#\\d+|[a-zA-Z]+);/g, m => {\n    var _unescapeInfo$get;\n    return (_unescapeInfo$get = unescapeInfo.get(m)) !== null && _unescapeInfo$get !== void 0 ? _unescapeInfo$get : m;\n  });\n  return sanitizeRenderedMarkdown({\n    isTrusted: false\n  }, html).toString();\n}\nconst unescapeInfo = new Map([['&quot;', '\"'], ['&nbsp;', ' '], ['&amp;', '&'], ['&#39;', '\\''], ['&lt;', '<'], ['&gt;', '>']]);\nfunction createRenderer() {\n  const renderer = new marked.Renderer();\n  renderer.code = _ref7 => {\n    let {\n      text\n    } = _ref7;\n    return text;\n  };\n  renderer.blockquote = _ref8 => {\n    let {\n      text\n    } = _ref8;\n    return text + '\\n';\n  };\n  renderer.html = _ => {\n    return '';\n  };\n  renderer.heading = function (_ref9) {\n    let {\n      tokens\n    } = _ref9;\n    return this.parser.parseInline(tokens) + '\\n';\n  };\n  renderer.hr = () => {\n    return '';\n  };\n  renderer.list = function (_ref10) {\n    let {\n      items\n    } = _ref10;\n    return items.map(x => this.listitem(x)).join('\\n') + '\\n';\n  };\n  renderer.listitem = _ref11 => {\n    let {\n      text\n    } = _ref11;\n    return text + '\\n';\n  };\n  renderer.paragraph = function (_ref12) {\n    let {\n      tokens\n    } = _ref12;\n    return this.parser.parseInline(tokens) + '\\n';\n  };\n  renderer.table = function (_ref13) {\n    let {\n      header,\n      rows\n    } = _ref13;\n    return header.map(cell => this.tablecell(cell)).join(' ') + '\\n' + rows.map(cells => cells.map(cell => this.tablecell(cell)).join(' ')).join('\\n') + '\\n';\n  };\n  renderer.tablerow = _ref14 => {\n    let {\n      text\n    } = _ref14;\n    return text;\n  };\n  renderer.tablecell = function (_ref15) {\n    let {\n      tokens\n    } = _ref15;\n    return this.parser.parseInline(tokens);\n  };\n  renderer.strong = _ref16 => {\n    let {\n      text\n    } = _ref16;\n    return text;\n  };\n  renderer.em = _ref17 => {\n    let {\n      text\n    } = _ref17;\n    return text;\n  };\n  renderer.codespan = _ref18 => {\n    let {\n      text\n    } = _ref18;\n    return text;\n  };\n  renderer.br = _ => {\n    return '\\n';\n  };\n  renderer.del = _ref19 => {\n    let {\n      text\n    } = _ref19;\n    return text;\n  };\n  renderer.image = _ => {\n    return '';\n  };\n  renderer.text = _ref20 => {\n    let {\n      text\n    } = _ref20;\n    return text;\n  };\n  renderer.link = _ref21 => {\n    let {\n      text\n    } = _ref21;\n    return text;\n  };\n  return renderer;\n}\nconst plainTextRenderer = new Lazy(withCodeBlocks => createRenderer());\nconst plainTextWithCodeBlocksRenderer = new Lazy(() => {\n  const renderer = createRenderer();\n  renderer.code = _ref22 => {\n    let {\n      text\n    } = _ref22;\n    return \"\\n```\\n\".concat(text, \"\\n```\\n\");\n  };\n  return renderer;\n});\nfunction mergeRawTokenText(tokens) {\n  let mergedTokenText = '';\n  tokens.forEach(token => {\n    mergedTokenText += token.raw;\n  });\n  return mergedTokenText;\n}\nfunction completeSingleLinePattern(token) {\n  if (!token.tokens) {\n    return undefined;\n  }\n  for (let i = token.tokens.length - 1; i >= 0; i--) {\n    const subtoken = token.tokens[i];\n    if (subtoken.type === 'text') {\n      const lines = subtoken.raw.split('\\n');\n      const lastLine = lines[lines.length - 1];\n      if (lastLine.includes('`')) {\n        return completeCodespan(token);\n      } else if (lastLine.includes('**')) {\n        return completeDoublestar(token);\n      } else if (lastLine.match(/\\*\\w/)) {\n        return completeStar(token);\n      } else if (lastLine.match(/(^|\\s)__\\w/)) {\n        return completeDoubleUnderscore(token);\n      } else if (lastLine.match(/(^|\\s)_\\w/)) {\n        return completeUnderscore(token);\n      } else if (\n      // Text with start of link target\n      hasLinkTextAndStartOfLinkTarget(lastLine) ||\n      // This token doesn't have the link text, eg if it contains other markdown constructs that are in other subtokens.\n      // But some preceding token does have an unbalanced [ at least\n      hasStartOfLinkTargetAndNoLinkText(lastLine) && token.tokens.slice(0, i).some(t => t.type === 'text' && t.raw.match(/\\[[^\\]]*$/))) {\n        var _nextTwoSubTokens$, _nextTwoSubTokens$2;\n        const nextTwoSubTokens = token.tokens.slice(i + 1);\n        // A markdown link can look like\n        // [link text](https://microsoft.com \"more text\")\n        // Where \"more text\" is a title for the link or an argument to a vscode command link\n        if (\n        // If the link was parsed as a link, then look for a link token and a text token with a quote\n        ((_nextTwoSubTokens$ = nextTwoSubTokens[0]) === null || _nextTwoSubTokens$ === void 0 ? void 0 : _nextTwoSubTokens$.type) === 'link' && ((_nextTwoSubTokens$2 = nextTwoSubTokens[1]) === null || _nextTwoSubTokens$2 === void 0 ? void 0 : _nextTwoSubTokens$2.type) === 'text' && nextTwoSubTokens[1].raw.match(/^ *\"[^\"]*$/) ||\n        // And if the link was not parsed as a link (eg command link), just look for a single quote in this token\n        lastLine.match(/^[^\"]* +\"[^\"]*$/)) {\n          return completeLinkTargetArg(token);\n        }\n        return completeLinkTarget(token);\n      }\n      // Contains the start of link text, and no following tokens contain the link target\n      else if (lastLine.match(/(^|\\s)\\[\\w*/)) {\n        return completeLinkText(token);\n      }\n    }\n  }\n  return undefined;\n}\nfunction hasLinkTextAndStartOfLinkTarget(str) {\n  return !!str.match(/(^|\\s)\\[.*\\]\\(\\w*/);\n}\nfunction hasStartOfLinkTargetAndNoLinkText(str) {\n  return !!str.match(/^[^\\[]*\\]\\([^\\)]*$/);\n}\nfunction completeListItemPattern(list) {\n  var _lastListItem$raw$mat;\n  // Patch up this one list item\n  const lastListItem = list.items[list.items.length - 1];\n  const lastListSubToken = lastListItem.tokens ? lastListItem.tokens[lastListItem.tokens.length - 1] : undefined;\n  /*\n  Example list token structures:\n   list\n      list_item\n          text\n              text\n              codespan\n              link\n      list_item\n          text\n          code // Complete indented codeblock\n      list_item\n          text\n          space\n          text\n              text // Incomplete indented codeblock\n      list_item\n          text\n          list // Nested list\n              list_item\n                  text\n                      text\n   Contrast with paragraph:\n  paragraph\n      text\n      codespan\n  */\n  let newToken;\n  if ((lastListSubToken === null || lastListSubToken === void 0 ? void 0 : lastListSubToken.type) === 'text' && !('inRawBlock' in lastListItem)) {\n    // Why does Tag have a type of 'text'\n    newToken = completeSingleLinePattern(lastListSubToken);\n  }\n  if (!newToken || newToken.type !== 'paragraph') {\n    // 'text' item inside the list item turns into paragraph\n    // Nothing to fix, or not a pattern we were expecting\n    return;\n  }\n  const previousListItemsText = mergeRawTokenText(list.items.slice(0, -1));\n  // Grabbing the `- ` or `1. ` or `* ` off the list item because I can't find a better way to do this\n  const lastListItemLead = (_lastListItem$raw$mat = lastListItem.raw.match(/^(\\s*(-|\\d+\\.|\\*) +)/)) === null || _lastListItem$raw$mat === void 0 ? void 0 : _lastListItem$raw$mat[0];\n  if (!lastListItemLead) {\n    // Is badly formatted\n    return;\n  }\n  const newListItemText = lastListItemLead + mergeRawTokenText(lastListItem.tokens.slice(0, -1)) + newToken.raw;\n  const newList = marked.lexer(previousListItemsText + newListItemText)[0];\n  if (newList.type !== 'list') {\n    // Something went wrong\n    return;\n  }\n  return newList;\n}\nconst maxIncompleteTokensFixRounds = 3;\nexport function fillInIncompleteTokens(tokens) {\n  for (let i = 0; i < maxIncompleteTokensFixRounds; i++) {\n    const newTokens = fillInIncompleteTokensOnce(tokens);\n    if (newTokens) {\n      tokens = newTokens;\n    } else {\n      break;\n    }\n  }\n  return tokens;\n}\nfunction fillInIncompleteTokensOnce(tokens) {\n  let i;\n  let newTokens;\n  for (i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (token.type === 'paragraph' && token.raw.match(/(\\n|^)\\|/)) {\n      newTokens = completeTable(tokens.slice(i));\n      break;\n    }\n    if (i === tokens.length - 1 && token.type === 'list') {\n      const newListToken = completeListItemPattern(token);\n      if (newListToken) {\n        newTokens = [newListToken];\n        break;\n      }\n    }\n    if (i === tokens.length - 1 && token.type === 'paragraph') {\n      // Only operates on a single token, because any newline that follows this should break these patterns\n      const newToken = completeSingleLinePattern(token);\n      if (newToken) {\n        newTokens = [newToken];\n        break;\n      }\n    }\n  }\n  if (newTokens) {\n    const newTokensList = [...tokens.slice(0, i), ...newTokens];\n    newTokensList.links = tokens.links;\n    return newTokensList;\n  }\n  return null;\n}\nfunction completeCodespan(token) {\n  return completeWithString(token, '`');\n}\nfunction completeStar(tokens) {\n  return completeWithString(tokens, '*');\n}\nfunction completeUnderscore(tokens) {\n  return completeWithString(tokens, '_');\n}\nfunction completeLinkTarget(tokens) {\n  return completeWithString(tokens, ')');\n}\nfunction completeLinkTargetArg(tokens) {\n  return completeWithString(tokens, '\")');\n}\nfunction completeLinkText(tokens) {\n  return completeWithString(tokens, '](https://microsoft.com)');\n}\nfunction completeDoublestar(tokens) {\n  return completeWithString(tokens, '**');\n}\nfunction completeDoubleUnderscore(tokens) {\n  return completeWithString(tokens, '__');\n}\nfunction completeWithString(tokens, closingString) {\n  const mergedRawText = mergeRawTokenText(Array.isArray(tokens) ? tokens : [tokens]);\n  // If it was completed correctly, this should be a single token.\n  // Expecting either a Paragraph or a List\n  return marked.lexer(mergedRawText + closingString)[0];\n}\nfunction completeTable(tokens) {\n  const mergedRawText = mergeRawTokenText(tokens);\n  const lines = mergedRawText.split('\\n');\n  let numCols; // The number of line1 col headers\n  let hasSeparatorRow = false;\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    if (typeof numCols === 'undefined' && line.match(/^\\s*\\|/)) {\n      const line1Matches = line.match(/(\\|[^\\|]+)(?=\\||$)/g);\n      if (line1Matches) {\n        numCols = line1Matches.length;\n      }\n    } else if (typeof numCols === 'number') {\n      if (line.match(/^\\s*\\|/)) {\n        if (i !== lines.length - 1) {\n          // We got the line1 header row, and the line2 separator row, but there are more lines, and it wasn't parsed as a table!\n          // That's strange and means that the table is probably malformed in the source, so I won't try to patch it up.\n          return undefined;\n        }\n        // Got a line2 separator row- partial or complete, doesn't matter, we'll replace it with a correct one\n        hasSeparatorRow = true;\n      } else {\n        // The line after the header row isn't a valid separator row, so the table is malformed, don't fix it up\n        return undefined;\n      }\n    }\n  }\n  if (typeof numCols === 'number' && numCols > 0) {\n    const prefixText = hasSeparatorRow ? lines.slice(0, -1).join('\\n') : mergedRawText;\n    const line1EndsInPipe = !!prefixText.match(/\\|\\s*$/);\n    const newRawText = prefixText + (line1EndsInPipe ? '' : '|') + \"\\n|\".concat(' --- |'.repeat(numCols));\n    return marked.lexer(newRawText);\n  }\n  return undefined;\n}\nfunction addDompurifyHook(hook, cb) {\n  dompurify.addHook(hook, cb);\n  return toDisposable(() => dompurify.removeHook(hook));\n}","map":{"version":3,"names":["DOM","dompurify","DomEmitter","createElement","StandardKeyboardEvent","StandardMouseEvent","renderLabelWithIcons","onUnexpectedError","Event","escapeDoubleQuotes","parseHrefAndDimensions","removeMarkdownEscapes","markdownEscapeEscapedIcons","defaultGenerator","Lazy","DisposableStore","toDisposable","marked","parse","FileAccess","Schemas","cloneAndChange","dirname","resolvePath","escape","URI","defaultMarkedRenderers","Object","freeze","image","_ref","href","title","text","dimensions","attributes","push","concat","length","join","paragraph","_ref2","tokens","parser","parseInline","link","_ref3","replace","renderMarkdown","markdown","_markdown$value","options","arguments","undefined","markedOptions","disposables","isDisposed","element","_uriMassage","part","data","decodeURIComponent","e","value","uris","revive","encodeURIComponent","JSON","stringify","_href","isDomUri","uri","startsWith","uriToBrowserUri","toString","query","with","renderer","Renderer","codeBlocks","syncCodeBlocks","codeBlockRendererSync","code","_ref4","lang","id","nextId","postProcessCodeBlockLanguageId","codeBlockRenderer","_ref5","then","actionHandler","_activateLink","event","target","tagName","parentElement","dataset","baseUri","resolveWithBaseUri","from","callback","err","preventDefault","onClick","add","onAuxClick","any","mouseEvent","getWindow","leftButton","middleButton","addDisposableListener","keyboardEvent","equals","supportHtml","html","_ref6","_options$sanitizerOpt","sanitizerOptions","replaceWithPlaintext","match","isTrusted","substr","supportThemeIcons","renderedMarkdown","fillInIncompleteTokens","opts","defaults","lexer","newTokens","async","elements","map","outerHTML","htmlParser","DOMParser","markdownHtmlDoc","parseFromString","sanitizeRenderedMarkdown","body","querySelectorAll","forEach","img","src","getAttribute","setAttribute","remoteImageIsAllowed","scheme","file","replaceWith","$","a","test","childNodes","resolvedHref","innerHTML","Promise","all","tuples","_options$asyncRenderC","renderedElements","Map","placeholderElements","placeholderElement","_placeholderElement$d","renderedElement","get","reset","asyncRenderCallback","call","_placeholderElement$d2","getElementsByTagName","listener","dispose","parts","split","hasScheme","path","endsWith","selfClosingTags","config","allowedSchemes","getSanitizerOptions","store","addDompurifyHook","_element$attributes$g","attrName","keepAttr","attrValue","getNamedItem","_element$attributes$g2","remove","allowedTags","startTagText","endTagText","textContent","isSelfClosing","includes","attrString","Array","attr","name","fragment","document","createDocumentFragment","textNode","ownerDocument","createTextNode","appendChild","endTagTextNode","firstChild","replaceChild","hookDomPurifyHrefAndSrcSanitizer","sanitize","RETURN_TRUSTED_TYPE","allowedMarkdownAttr","_options$allowedTags","http","https","mailto","vscodeFileResource","vscodeRemote","vscodeRemoteResource","command","ALLOWED_TAGS","basicMarkupHtmlTags","ALLOWED_ATTR","ALLOW_UNKNOWN_PROTOCOLS","renderStringAsPlaintext","string","renderMarkdownAsPlaintext","withCodeBlocks","_markdown$value2","plainTextWithCodeBlocksRenderer","plainTextRenderer","m","_unescapeInfo$get","unescapeInfo","createRenderer","_ref7","blockquote","_ref8","_","heading","_ref9","hr","list","_ref10","items","x","listitem","_ref11","_ref12","table","_ref13","header","rows","cell","tablecell","cells","tablerow","_ref14","_ref15","strong","_ref16","em","_ref17","codespan","_ref18","br","del","_ref19","_ref20","_ref21","_ref22","mergeRawTokenText","mergedTokenText","token","raw","completeSingleLinePattern","i","subtoken","type","lines","lastLine","completeCodespan","completeDoublestar","completeStar","completeDoubleUnderscore","completeUnderscore","hasLinkTextAndStartOfLinkTarget","hasStartOfLinkTargetAndNoLinkText","slice","some","t","_nextTwoSubTokens$","_nextTwoSubTokens$2","nextTwoSubTokens","completeLinkTargetArg","completeLinkTarget","completeLinkText","str","completeListItemPattern","_lastListItem$raw$mat","lastListItem","lastListSubToken","newToken","previousListItemsText","lastListItemLead","newListItemText","newList","maxIncompleteTokensFixRounds","fillInIncompleteTokensOnce","completeTable","newListToken","newTokensList","links","completeWithString","closingString","mergedRawText","isArray","numCols","hasSeparatorRow","line","trim","line1Matches","prefixText","line1EndsInPipe","newRawText","repeat","hook","cb","addHook","removeHook"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/base/browser/markdownRenderer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as DOM from './dom.js';\nimport * as dompurify from './dompurify/dompurify.js';\nimport { DomEmitter } from './event.js';\nimport { createElement } from './formattedTextRenderer.js';\nimport { StandardKeyboardEvent } from './keyboardEvent.js';\nimport { StandardMouseEvent } from './mouseEvent.js';\nimport { renderLabelWithIcons } from './ui/iconLabel/iconLabels.js';\nimport { onUnexpectedError } from '../common/errors.js';\nimport { Event } from '../common/event.js';\nimport { escapeDoubleQuotes, parseHrefAndDimensions, removeMarkdownEscapes } from '../common/htmlContent.js';\nimport { markdownEscapeEscapedIcons } from '../common/iconLabels.js';\nimport { defaultGenerator } from '../common/idGenerator.js';\nimport { Lazy } from '../common/lazy.js';\nimport { DisposableStore, toDisposable } from '../common/lifecycle.js';\nimport * as marked from '../common/marked/marked.js';\nimport { parse } from '../common/marshalling.js';\nimport { FileAccess, Schemas } from '../common/network.js';\nimport { cloneAndChange } from '../common/objects.js';\nimport { dirname, resolvePath } from '../common/resources.js';\nimport { escape } from '../common/strings.js';\nimport { URI } from '../common/uri.js';\nconst defaultMarkedRenderers = Object.freeze({\n    image: ({ href, title, text }) => {\n        let dimensions = [];\n        let attributes = [];\n        if (href) {\n            ({ href, dimensions } = parseHrefAndDimensions(href));\n            attributes.push(`src=\"${escapeDoubleQuotes(href)}\"`);\n        }\n        if (text) {\n            attributes.push(`alt=\"${escapeDoubleQuotes(text)}\"`);\n        }\n        if (title) {\n            attributes.push(`title=\"${escapeDoubleQuotes(title)}\"`);\n        }\n        if (dimensions.length) {\n            attributes = attributes.concat(dimensions);\n        }\n        return '<img ' + attributes.join(' ') + '>';\n    },\n    paragraph({ tokens }) {\n        return `<p>${this.parser.parseInline(tokens)}</p>`;\n    },\n    link({ href, title, tokens }) {\n        let text = this.parser.parseInline(tokens);\n        if (typeof href !== 'string') {\n            return '';\n        }\n        // Remove markdown escapes. Workaround for https://github.com/chjj/marked/issues/829\n        if (href === text) { // raw link case\n            text = removeMarkdownEscapes(text);\n        }\n        title = typeof title === 'string' ? escapeDoubleQuotes(removeMarkdownEscapes(title)) : '';\n        href = removeMarkdownEscapes(href);\n        // HTML Encode href\n        href = href.replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#39;');\n        return `<a href=\"${href}\" title=\"${title || href}\" draggable=\"false\">${text}</a>`;\n    },\n});\n/**\n * Low-level way create a html element from a markdown string.\n *\n * **Note** that for most cases you should be using [`MarkdownRenderer`](./src/vs/editor/contrib/markdownRenderer/browser/markdownRenderer.ts)\n * which comes with support for pretty code block rendering and which uses the default way of handling links.\n */\nexport function renderMarkdown(markdown, options = {}, markedOptions = {}) {\n    const disposables = new DisposableStore();\n    let isDisposed = false;\n    const element = createElement(options);\n    const _uriMassage = function (part) {\n        let data;\n        try {\n            data = parse(decodeURIComponent(part));\n        }\n        catch (e) {\n            // ignore\n        }\n        if (!data) {\n            return part;\n        }\n        data = cloneAndChange(data, value => {\n            if (markdown.uris && markdown.uris[value]) {\n                return URI.revive(markdown.uris[value]);\n            }\n            else {\n                return undefined;\n            }\n        });\n        return encodeURIComponent(JSON.stringify(data));\n    };\n    const _href = function (href, isDomUri) {\n        const data = markdown.uris && markdown.uris[href];\n        let uri = URI.revive(data);\n        if (isDomUri) {\n            if (href.startsWith(Schemas.data + ':')) {\n                return href;\n            }\n            if (!uri) {\n                uri = URI.parse(href);\n            }\n            // this URI will end up as \"src\"-attribute of a dom node\n            // and because of that special rewriting needs to be done\n            // so that the URI uses a protocol that's understood by\n            // browsers (like http or https)\n            return FileAccess.uriToBrowserUri(uri).toString(true);\n        }\n        if (!uri) {\n            return href;\n        }\n        if (URI.parse(href).toString() === uri.toString()) {\n            return href; // no transformation performed\n        }\n        if (uri.query) {\n            uri = uri.with({ query: _uriMassage(uri.query) });\n        }\n        return uri.toString();\n    };\n    const renderer = new marked.Renderer();\n    renderer.image = defaultMarkedRenderers.image;\n    renderer.link = defaultMarkedRenderers.link;\n    renderer.paragraph = defaultMarkedRenderers.paragraph;\n    // Will collect [id, renderedElement] tuples\n    const codeBlocks = [];\n    const syncCodeBlocks = [];\n    if (options.codeBlockRendererSync) {\n        renderer.code = ({ text, lang }) => {\n            const id = defaultGenerator.nextId();\n            const value = options.codeBlockRendererSync(postProcessCodeBlockLanguageId(lang), text);\n            syncCodeBlocks.push([id, value]);\n            return `<div class=\"code\" data-code=\"${id}\">${escape(text)}</div>`;\n        };\n    }\n    else if (options.codeBlockRenderer) {\n        renderer.code = ({ text, lang }) => {\n            const id = defaultGenerator.nextId();\n            const value = options.codeBlockRenderer(postProcessCodeBlockLanguageId(lang), text);\n            codeBlocks.push(value.then(element => [id, element]));\n            return `<div class=\"code\" data-code=\"${id}\">${escape(text)}</div>`;\n        };\n    }\n    if (options.actionHandler) {\n        const _activateLink = function (event) {\n            let target = event.target;\n            if (target.tagName !== 'A') {\n                target = target.parentElement;\n                if (!target || target.tagName !== 'A') {\n                    return;\n                }\n            }\n            try {\n                let href = target.dataset['href'];\n                if (href) {\n                    if (markdown.baseUri) {\n                        href = resolveWithBaseUri(URI.from(markdown.baseUri), href);\n                    }\n                    options.actionHandler.callback(href, event);\n                }\n            }\n            catch (err) {\n                onUnexpectedError(err);\n            }\n            finally {\n                event.preventDefault();\n            }\n        };\n        const onClick = options.actionHandler.disposables.add(new DomEmitter(element, 'click'));\n        const onAuxClick = options.actionHandler.disposables.add(new DomEmitter(element, 'auxclick'));\n        options.actionHandler.disposables.add(Event.any(onClick.event, onAuxClick.event)(e => {\n            const mouseEvent = new StandardMouseEvent(DOM.getWindow(element), e);\n            if (!mouseEvent.leftButton && !mouseEvent.middleButton) {\n                return;\n            }\n            _activateLink(mouseEvent);\n        }));\n        options.actionHandler.disposables.add(DOM.addDisposableListener(element, 'keydown', (e) => {\n            const keyboardEvent = new StandardKeyboardEvent(e);\n            if (!keyboardEvent.equals(10 /* KeyCode.Space */) && !keyboardEvent.equals(3 /* KeyCode.Enter */)) {\n                return;\n            }\n            _activateLink(keyboardEvent);\n        }));\n    }\n    if (!markdown.supportHtml) {\n        // Note: we always pass the output through dompurify after this so that we don't rely on\n        // marked for real sanitization.\n        renderer.html = ({ text }) => {\n            if (options.sanitizerOptions?.replaceWithPlaintext) {\n                return escape(text);\n            }\n            const match = markdown.isTrusted ? text.match(/^(<span[^>]+>)|(<\\/\\s*span>)$/) : undefined;\n            return match ? text : '';\n        };\n    }\n    markedOptions.renderer = renderer;\n    // values that are too long will freeze the UI\n    let value = markdown.value ?? '';\n    if (value.length > 100_000) {\n        value = `${value.substr(0, 100_000)}â€¦`;\n    }\n    // escape theme icons\n    if (markdown.supportThemeIcons) {\n        value = markdownEscapeEscapedIcons(value);\n    }\n    let renderedMarkdown;\n    if (options.fillInIncompleteTokens) {\n        // The defaults are applied by parse but not lexer()/parser(), and they need to be present\n        const opts = {\n            ...marked.defaults,\n            ...markedOptions\n        };\n        const tokens = marked.lexer(value, opts);\n        const newTokens = fillInIncompleteTokens(tokens);\n        renderedMarkdown = marked.parser(newTokens, opts);\n    }\n    else {\n        renderedMarkdown = marked.parse(value, { ...markedOptions, async: false });\n    }\n    // Rewrite theme icons\n    if (markdown.supportThemeIcons) {\n        const elements = renderLabelWithIcons(renderedMarkdown);\n        renderedMarkdown = elements.map(e => typeof e === 'string' ? e : e.outerHTML).join('');\n    }\n    const htmlParser = new DOMParser();\n    const markdownHtmlDoc = htmlParser.parseFromString(sanitizeRenderedMarkdown({ isTrusted: markdown.isTrusted, ...options.sanitizerOptions }, renderedMarkdown), 'text/html');\n    markdownHtmlDoc.body.querySelectorAll('img, audio, video, source')\n        .forEach(img => {\n        const src = img.getAttribute('src'); // Get the raw 'src' attribute value as text, not the resolved 'src'\n        if (src) {\n            let href = src;\n            try {\n                if (markdown.baseUri) { // absolute or relative local path, or file: uri\n                    href = resolveWithBaseUri(URI.from(markdown.baseUri), href);\n                }\n            }\n            catch (err) { }\n            img.setAttribute('src', _href(href, true));\n            if (options.remoteImageIsAllowed) {\n                const uri = URI.parse(href);\n                if (uri.scheme !== Schemas.file && uri.scheme !== Schemas.data && !options.remoteImageIsAllowed(uri)) {\n                    img.replaceWith(DOM.$('', undefined, img.outerHTML));\n                }\n            }\n        }\n    });\n    markdownHtmlDoc.body.querySelectorAll('a')\n        .forEach(a => {\n        const href = a.getAttribute('href'); // Get the raw 'href' attribute value as text, not the resolved 'href'\n        a.setAttribute('href', ''); // Clear out href. We use the `data-href` for handling clicks instead\n        if (!href\n            || /^data:|javascript:/i.test(href)\n            || (/^command:/i.test(href) && !markdown.isTrusted)\n            || /^command:(\\/\\/\\/)?_workbench\\.downloadResource/i.test(href)) {\n            // drop the link\n            a.replaceWith(...a.childNodes);\n        }\n        else {\n            let resolvedHref = _href(href, false);\n            if (markdown.baseUri) {\n                resolvedHref = resolveWithBaseUri(URI.from(markdown.baseUri), href);\n            }\n            a.dataset.href = resolvedHref;\n        }\n    });\n    element.innerHTML = sanitizeRenderedMarkdown({ isTrusted: markdown.isTrusted, ...options.sanitizerOptions }, markdownHtmlDoc.body.innerHTML);\n    if (codeBlocks.length > 0) {\n        Promise.all(codeBlocks).then((tuples) => {\n            if (isDisposed) {\n                return;\n            }\n            const renderedElements = new Map(tuples);\n            const placeholderElements = element.querySelectorAll(`div[data-code]`);\n            for (const placeholderElement of placeholderElements) {\n                const renderedElement = renderedElements.get(placeholderElement.dataset['code'] ?? '');\n                if (renderedElement) {\n                    DOM.reset(placeholderElement, renderedElement);\n                }\n            }\n            options.asyncRenderCallback?.();\n        });\n    }\n    else if (syncCodeBlocks.length > 0) {\n        const renderedElements = new Map(syncCodeBlocks);\n        const placeholderElements = element.querySelectorAll(`div[data-code]`);\n        for (const placeholderElement of placeholderElements) {\n            const renderedElement = renderedElements.get(placeholderElement.dataset['code'] ?? '');\n            if (renderedElement) {\n                DOM.reset(placeholderElement, renderedElement);\n            }\n        }\n    }\n    // signal size changes for image tags\n    if (options.asyncRenderCallback) {\n        for (const img of element.getElementsByTagName('img')) {\n            const listener = disposables.add(DOM.addDisposableListener(img, 'load', () => {\n                listener.dispose();\n                options.asyncRenderCallback();\n            }));\n        }\n    }\n    return {\n        element,\n        dispose: () => {\n            isDisposed = true;\n            disposables.dispose();\n        }\n    };\n}\nfunction postProcessCodeBlockLanguageId(lang) {\n    if (!lang) {\n        return '';\n    }\n    const parts = lang.split(/[\\s+|:|,|\\{|\\?]/, 1);\n    if (parts.length) {\n        return parts[0];\n    }\n    return lang;\n}\nfunction resolveWithBaseUri(baseUri, href) {\n    const hasScheme = /^\\w[\\w\\d+.-]*:/.test(href);\n    if (hasScheme) {\n        return href;\n    }\n    if (baseUri.path.endsWith('/')) {\n        return resolvePath(baseUri, href).toString();\n    }\n    else {\n        return resolvePath(dirname(baseUri), href).toString();\n    }\n}\nconst selfClosingTags = ['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'];\nfunction sanitizeRenderedMarkdown(options, renderedMarkdown) {\n    const { config, allowedSchemes } = getSanitizerOptions(options);\n    const store = new DisposableStore();\n    store.add(addDompurifyHook('uponSanitizeAttribute', (element, e) => {\n        if (e.attrName === 'style' || e.attrName === 'class') {\n            if (element.tagName === 'SPAN') {\n                if (e.attrName === 'style') {\n                    e.keepAttr = /^(color\\:(#[0-9a-fA-F]+|var\\(--vscode(-[a-zA-Z]+)+\\));)?(background-color\\:(#[0-9a-fA-F]+|var\\(--vscode(-[a-zA-Z]+)+\\));)?(border-radius:[0-9]+px;)?$/.test(e.attrValue);\n                    return;\n                }\n                else if (e.attrName === 'class') {\n                    e.keepAttr = /^codicon codicon-[a-z\\-]+( codicon-modifier-[a-z\\-]+)?$/.test(e.attrValue);\n                    return;\n                }\n            }\n            e.keepAttr = false;\n            return;\n        }\n        else if (element.tagName === 'INPUT' && element.attributes.getNamedItem('type')?.value === 'checkbox') {\n            if ((e.attrName === 'type' && e.attrValue === 'checkbox') || e.attrName === 'disabled' || e.attrName === 'checked') {\n                e.keepAttr = true;\n                return;\n            }\n            e.keepAttr = false;\n        }\n    }));\n    store.add(addDompurifyHook('uponSanitizeElement', (element, e) => {\n        if (e.tagName === 'input') {\n            if (element.attributes.getNamedItem('type')?.value === 'checkbox') {\n                element.setAttribute('disabled', '');\n            }\n            else if (!options.replaceWithPlaintext) {\n                element.remove();\n            }\n        }\n        if (options.replaceWithPlaintext && !e.allowedTags[e.tagName] && e.tagName !== 'body') {\n            if (element.parentElement) {\n                let startTagText;\n                let endTagText;\n                if (e.tagName === '#comment') {\n                    startTagText = `<!--${element.textContent}-->`;\n                }\n                else {\n                    const isSelfClosing = selfClosingTags.includes(e.tagName);\n                    const attrString = element.attributes.length ?\n                        ' ' + Array.from(element.attributes)\n                            .map(attr => `${attr.name}=\"${attr.value}\"`)\n                            .join(' ')\n                        : '';\n                    startTagText = `<${e.tagName}${attrString}>`;\n                    if (!isSelfClosing) {\n                        endTagText = `</${e.tagName}>`;\n                    }\n                }\n                const fragment = document.createDocumentFragment();\n                const textNode = element.parentElement.ownerDocument.createTextNode(startTagText);\n                fragment.appendChild(textNode);\n                const endTagTextNode = endTagText ? element.parentElement.ownerDocument.createTextNode(endTagText) : undefined;\n                while (element.firstChild) {\n                    fragment.appendChild(element.firstChild);\n                }\n                if (endTagTextNode) {\n                    fragment.appendChild(endTagTextNode);\n                }\n                element.parentElement.replaceChild(fragment, element);\n            }\n        }\n    }));\n    store.add(DOM.hookDomPurifyHrefAndSrcSanitizer(allowedSchemes));\n    try {\n        return dompurify.sanitize(renderedMarkdown, { ...config, RETURN_TRUSTED_TYPE: true });\n    }\n    finally {\n        store.dispose();\n    }\n}\nexport const allowedMarkdownAttr = [\n    'align',\n    'autoplay',\n    'alt',\n    'checked',\n    'class',\n    'colspan',\n    'controls',\n    'data-code',\n    'data-href',\n    'disabled',\n    'draggable',\n    'height',\n    'href',\n    'loop',\n    'muted',\n    'playsinline',\n    'poster',\n    'rowspan',\n    'src',\n    'style',\n    'target',\n    'title',\n    'type',\n    'width',\n    'start',\n];\nfunction getSanitizerOptions(options) {\n    const allowedSchemes = [\n        Schemas.http,\n        Schemas.https,\n        Schemas.mailto,\n        Schemas.data,\n        Schemas.file,\n        Schemas.vscodeFileResource,\n        Schemas.vscodeRemote,\n        Schemas.vscodeRemoteResource,\n    ];\n    if (options.isTrusted) {\n        allowedSchemes.push(Schemas.command);\n    }\n    return {\n        config: {\n            // allowedTags should included everything that markdown renders to.\n            // Since we have our own sanitize function for marked, it's possible we missed some tag so let dompurify make sure.\n            // HTML tags that can result from markdown are from reading https://spec.commonmark.org/0.29/\n            // HTML table tags that can result from markdown are from https://github.github.com/gfm/#tables-extension-\n            ALLOWED_TAGS: options.allowedTags ?? [...DOM.basicMarkupHtmlTags],\n            ALLOWED_ATTR: allowedMarkdownAttr,\n            ALLOW_UNKNOWN_PROTOCOLS: true,\n        },\n        allowedSchemes\n    };\n}\n/**\n * Strips all markdown from `string`, if it's an IMarkdownString. For example\n * `# Header` would be output as `Header`. If it's not, the string is returned.\n */\nexport function renderStringAsPlaintext(string) {\n    return typeof string === 'string' ? string : renderMarkdownAsPlaintext(string);\n}\n/**\n * Strips all markdown from `markdown`. For example `# Header` would be output as `Header`.\n * provide @param withCodeBlocks to retain code blocks\n */\nexport function renderMarkdownAsPlaintext(markdown, withCodeBlocks) {\n    // values that are too long will freeze the UI\n    let value = markdown.value ?? '';\n    if (value.length > 100_000) {\n        value = `${value.substr(0, 100_000)}â€¦`;\n    }\n    const html = marked.parse(value, { async: false, renderer: withCodeBlocks ? plainTextWithCodeBlocksRenderer.value : plainTextRenderer.value }).replace(/&(#\\d+|[a-zA-Z]+);/g, m => unescapeInfo.get(m) ?? m);\n    return sanitizeRenderedMarkdown({ isTrusted: false }, html).toString();\n}\nconst unescapeInfo = new Map([\n    ['&quot;', '\"'],\n    ['&nbsp;', ' '],\n    ['&amp;', '&'],\n    ['&#39;', '\\''],\n    ['&lt;', '<'],\n    ['&gt;', '>'],\n]);\nfunction createRenderer() {\n    const renderer = new marked.Renderer();\n    renderer.code = ({ text }) => {\n        return text;\n    };\n    renderer.blockquote = ({ text }) => {\n        return text + '\\n';\n    };\n    renderer.html = (_) => {\n        return '';\n    };\n    renderer.heading = function ({ tokens }) {\n        return this.parser.parseInline(tokens) + '\\n';\n    };\n    renderer.hr = () => {\n        return '';\n    };\n    renderer.list = function ({ items }) {\n        return items.map(x => this.listitem(x)).join('\\n') + '\\n';\n    };\n    renderer.listitem = ({ text }) => {\n        return text + '\\n';\n    };\n    renderer.paragraph = function ({ tokens }) {\n        return this.parser.parseInline(tokens) + '\\n';\n    };\n    renderer.table = function ({ header, rows }) {\n        return header.map(cell => this.tablecell(cell)).join(' ') + '\\n' + rows.map(cells => cells.map(cell => this.tablecell(cell)).join(' ')).join('\\n') + '\\n';\n    };\n    renderer.tablerow = ({ text }) => {\n        return text;\n    };\n    renderer.tablecell = function ({ tokens }) {\n        return this.parser.parseInline(tokens);\n    };\n    renderer.strong = ({ text }) => {\n        return text;\n    };\n    renderer.em = ({ text }) => {\n        return text;\n    };\n    renderer.codespan = ({ text }) => {\n        return text;\n    };\n    renderer.br = (_) => {\n        return '\\n';\n    };\n    renderer.del = ({ text }) => {\n        return text;\n    };\n    renderer.image = (_) => {\n        return '';\n    };\n    renderer.text = ({ text }) => {\n        return text;\n    };\n    renderer.link = ({ text }) => {\n        return text;\n    };\n    return renderer;\n}\nconst plainTextRenderer = new Lazy((withCodeBlocks) => createRenderer());\nconst plainTextWithCodeBlocksRenderer = new Lazy(() => {\n    const renderer = createRenderer();\n    renderer.code = ({ text }) => {\n        return `\\n\\`\\`\\`\\n${text}\\n\\`\\`\\`\\n`;\n    };\n    return renderer;\n});\nfunction mergeRawTokenText(tokens) {\n    let mergedTokenText = '';\n    tokens.forEach(token => {\n        mergedTokenText += token.raw;\n    });\n    return mergedTokenText;\n}\nfunction completeSingleLinePattern(token) {\n    if (!token.tokens) {\n        return undefined;\n    }\n    for (let i = token.tokens.length - 1; i >= 0; i--) {\n        const subtoken = token.tokens[i];\n        if (subtoken.type === 'text') {\n            const lines = subtoken.raw.split('\\n');\n            const lastLine = lines[lines.length - 1];\n            if (lastLine.includes('`')) {\n                return completeCodespan(token);\n            }\n            else if (lastLine.includes('**')) {\n                return completeDoublestar(token);\n            }\n            else if (lastLine.match(/\\*\\w/)) {\n                return completeStar(token);\n            }\n            else if (lastLine.match(/(^|\\s)__\\w/)) {\n                return completeDoubleUnderscore(token);\n            }\n            else if (lastLine.match(/(^|\\s)_\\w/)) {\n                return completeUnderscore(token);\n            }\n            else if (\n            // Text with start of link target\n            hasLinkTextAndStartOfLinkTarget(lastLine) ||\n                // This token doesn't have the link text, eg if it contains other markdown constructs that are in other subtokens.\n                // But some preceding token does have an unbalanced [ at least\n                hasStartOfLinkTargetAndNoLinkText(lastLine) && token.tokens.slice(0, i).some(t => t.type === 'text' && t.raw.match(/\\[[^\\]]*$/))) {\n                const nextTwoSubTokens = token.tokens.slice(i + 1);\n                // A markdown link can look like\n                // [link text](https://microsoft.com \"more text\")\n                // Where \"more text\" is a title for the link or an argument to a vscode command link\n                if (\n                // If the link was parsed as a link, then look for a link token and a text token with a quote\n                nextTwoSubTokens[0]?.type === 'link' && nextTwoSubTokens[1]?.type === 'text' && nextTwoSubTokens[1].raw.match(/^ *\"[^\"]*$/) ||\n                    // And if the link was not parsed as a link (eg command link), just look for a single quote in this token\n                    lastLine.match(/^[^\"]* +\"[^\"]*$/)) {\n                    return completeLinkTargetArg(token);\n                }\n                return completeLinkTarget(token);\n            }\n            // Contains the start of link text, and no following tokens contain the link target\n            else if (lastLine.match(/(^|\\s)\\[\\w*/)) {\n                return completeLinkText(token);\n            }\n        }\n    }\n    return undefined;\n}\nfunction hasLinkTextAndStartOfLinkTarget(str) {\n    return !!str.match(/(^|\\s)\\[.*\\]\\(\\w*/);\n}\nfunction hasStartOfLinkTargetAndNoLinkText(str) {\n    return !!str.match(/^[^\\[]*\\]\\([^\\)]*$/);\n}\nfunction completeListItemPattern(list) {\n    // Patch up this one list item\n    const lastListItem = list.items[list.items.length - 1];\n    const lastListSubToken = lastListItem.tokens ? lastListItem.tokens[lastListItem.tokens.length - 1] : undefined;\n    /*\n    Example list token structures:\n\n    list\n        list_item\n            text\n                text\n                codespan\n                link\n        list_item\n            text\n            code // Complete indented codeblock\n        list_item\n            text\n            space\n            text\n                text // Incomplete indented codeblock\n        list_item\n            text\n            list // Nested list\n                list_item\n                    text\n                        text\n\n    Contrast with paragraph:\n    paragraph\n        text\n        codespan\n    */\n    let newToken;\n    if (lastListSubToken?.type === 'text' && !('inRawBlock' in lastListItem)) { // Why does Tag have a type of 'text'\n        newToken = completeSingleLinePattern(lastListSubToken);\n    }\n    if (!newToken || newToken.type !== 'paragraph') { // 'text' item inside the list item turns into paragraph\n        // Nothing to fix, or not a pattern we were expecting\n        return;\n    }\n    const previousListItemsText = mergeRawTokenText(list.items.slice(0, -1));\n    // Grabbing the `- ` or `1. ` or `* ` off the list item because I can't find a better way to do this\n    const lastListItemLead = lastListItem.raw.match(/^(\\s*(-|\\d+\\.|\\*) +)/)?.[0];\n    if (!lastListItemLead) {\n        // Is badly formatted\n        return;\n    }\n    const newListItemText = lastListItemLead +\n        mergeRawTokenText(lastListItem.tokens.slice(0, -1)) +\n        newToken.raw;\n    const newList = marked.lexer(previousListItemsText + newListItemText)[0];\n    if (newList.type !== 'list') {\n        // Something went wrong\n        return;\n    }\n    return newList;\n}\nconst maxIncompleteTokensFixRounds = 3;\nexport function fillInIncompleteTokens(tokens) {\n    for (let i = 0; i < maxIncompleteTokensFixRounds; i++) {\n        const newTokens = fillInIncompleteTokensOnce(tokens);\n        if (newTokens) {\n            tokens = newTokens;\n        }\n        else {\n            break;\n        }\n    }\n    return tokens;\n}\nfunction fillInIncompleteTokensOnce(tokens) {\n    let i;\n    let newTokens;\n    for (i = 0; i < tokens.length; i++) {\n        const token = tokens[i];\n        if (token.type === 'paragraph' && token.raw.match(/(\\n|^)\\|/)) {\n            newTokens = completeTable(tokens.slice(i));\n            break;\n        }\n        if (i === tokens.length - 1 && token.type === 'list') {\n            const newListToken = completeListItemPattern(token);\n            if (newListToken) {\n                newTokens = [newListToken];\n                break;\n            }\n        }\n        if (i === tokens.length - 1 && token.type === 'paragraph') {\n            // Only operates on a single token, because any newline that follows this should break these patterns\n            const newToken = completeSingleLinePattern(token);\n            if (newToken) {\n                newTokens = [newToken];\n                break;\n            }\n        }\n    }\n    if (newTokens) {\n        const newTokensList = [\n            ...tokens.slice(0, i),\n            ...newTokens\n        ];\n        newTokensList.links = tokens.links;\n        return newTokensList;\n    }\n    return null;\n}\nfunction completeCodespan(token) {\n    return completeWithString(token, '`');\n}\nfunction completeStar(tokens) {\n    return completeWithString(tokens, '*');\n}\nfunction completeUnderscore(tokens) {\n    return completeWithString(tokens, '_');\n}\nfunction completeLinkTarget(tokens) {\n    return completeWithString(tokens, ')');\n}\nfunction completeLinkTargetArg(tokens) {\n    return completeWithString(tokens, '\")');\n}\nfunction completeLinkText(tokens) {\n    return completeWithString(tokens, '](https://microsoft.com)');\n}\nfunction completeDoublestar(tokens) {\n    return completeWithString(tokens, '**');\n}\nfunction completeDoubleUnderscore(tokens) {\n    return completeWithString(tokens, '__');\n}\nfunction completeWithString(tokens, closingString) {\n    const mergedRawText = mergeRawTokenText(Array.isArray(tokens) ? tokens : [tokens]);\n    // If it was completed correctly, this should be a single token.\n    // Expecting either a Paragraph or a List\n    return marked.lexer(mergedRawText + closingString)[0];\n}\nfunction completeTable(tokens) {\n    const mergedRawText = mergeRawTokenText(tokens);\n    const lines = mergedRawText.split('\\n');\n    let numCols; // The number of line1 col headers\n    let hasSeparatorRow = false;\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i].trim();\n        if (typeof numCols === 'undefined' && line.match(/^\\s*\\|/)) {\n            const line1Matches = line.match(/(\\|[^\\|]+)(?=\\||$)/g);\n            if (line1Matches) {\n                numCols = line1Matches.length;\n            }\n        }\n        else if (typeof numCols === 'number') {\n            if (line.match(/^\\s*\\|/)) {\n                if (i !== lines.length - 1) {\n                    // We got the line1 header row, and the line2 separator row, but there are more lines, and it wasn't parsed as a table!\n                    // That's strange and means that the table is probably malformed in the source, so I won't try to patch it up.\n                    return undefined;\n                }\n                // Got a line2 separator row- partial or complete, doesn't matter, we'll replace it with a correct one\n                hasSeparatorRow = true;\n            }\n            else {\n                // The line after the header row isn't a valid separator row, so the table is malformed, don't fix it up\n                return undefined;\n            }\n        }\n    }\n    if (typeof numCols === 'number' && numCols > 0) {\n        const prefixText = hasSeparatorRow ? lines.slice(0, -1).join('\\n') : mergedRawText;\n        const line1EndsInPipe = !!prefixText.match(/\\|\\s*$/);\n        const newRawText = prefixText + (line1EndsInPipe ? '' : '|') + `\\n|${' --- |'.repeat(numCols)}`;\n        return marked.lexer(newRawText);\n    }\n    return undefined;\n}\nfunction addDompurifyHook(hook, cb) {\n    dompurify.addHook(hook, cb);\n    return toDisposable(() => dompurify.removeHook(hook));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}