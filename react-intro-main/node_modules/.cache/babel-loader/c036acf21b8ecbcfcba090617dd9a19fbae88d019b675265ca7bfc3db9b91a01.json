{"ast":null,"code":"import React, { useEffect, useRef, useState } from 'react';\nimport axios from 'axios';\nimport { popup, ModelXmlSerializer, domUtils, styleUtils, mathUtils, cloneUtils, eventUtils, Graph, InternalEvent, RubberBandHandler, ConnectionHandler, ConnectionConstraint, Point, CylinderShape, CellRenderer, DomHelpers, EdgeStyle, Rectangle, EdgeHandler, StyleRegistry, EdgeSegmentHandler, UndoManager, CellEditorHandler, ConstraintHandler, Guide, ImageBox, GraphView, SelectionHandler, PanningHandler, TooltipHandler, SelectionCellsHandler, PopupMenuHandler, xmlUtils, Codec } from '@maxgraph/core';\nimport { contextMenuTypes, contextMenuValues, globalTypes, globalValues, rubberBandTypes, rubberBandValues } from './shared/args.js';\nimport { createGraphContainer } from './shared/configure.js';\n\n// style required by RubberBand\nimport '@maxgraph/core/css/common.css';\nimport { render } from 'react-dom';\n\n// TODO Убрать этот костыль\nlet invert = false;\nlet MyCustomCellEditorHandler;\nif (invert) {\n  container.style.backgroundColor = 'black';\n\n  // White in-place editor text color\n  MyCustomCellEditorHandler = class extends CellEditorHandler {\n    startEditing(cell, trigger) {\n      super.startEditing.apply(this, arguments);\n      if (this.textarea != null) {\n        this.textarea.style.color = '#FFFFFF';\n      }\n    }\n  };\n} else {\n  MyCustomCellEditorHandler = CellEditorHandler;\n}\n// Wire-mode\nlet checkbox = document.getElementById(\"wire\");\nclass MyCustomGraph extends Graph {\n  constructor(...args) {\n    super(...args);\n    this.resetEdgesOnConnect = false;\n  }\n  createEdgeSegmentHandler(state) {\n    return new MyCustomEdgeSegmentHandler(state);\n  }\n  createGraphView() {\n    return new MyCustomGraphView(this);\n  }\n  createEdgeHandler(state) {\n    return new MyCustomEdgeHandler(state);\n  }\n  createHandler(state) {\n    let result = null;\n    if (state != null) {\n      if (state.cell.isEdge()) {\n        let style = this.view.getEdgeStyle(state);\n        if (style == EdgeStyle.WireConnector) {\n          return new EdgeSegmentHandler(state);\n        }\n      }\n    }\n    return super.createHandler.apply(this, arguments);\n  }\n\n  // Adds oval markers for edge-to-edge connections.\n  getCellStyle(cell) {\n    let style = super.getCellStyle.apply(this, arguments);\n    if (style != null && cell !== null && cell !== void 0 && cell.isEdge()) {\n      var _cell$getTerminal, _cell$getTerminal2;\n      style = cloneUtils.clone(style);\n      if ((_cell$getTerminal = cell.getTerminal(true)) !== null && _cell$getTerminal !== void 0 && _cell$getTerminal.isEdge()) {\n        style.startArrow = 'oval';\n      }\n      if ((_cell$getTerminal2 = cell.getTerminal(false)) !== null && _cell$getTerminal2 !== void 0 && _cell$getTerminal2.isEdge()) {\n        style.endArrow = 'oval';\n      }\n    }\n    return style;\n  }\n  getTooltipForCell(cell) {\n    let tip = '';\n    if (cell != null) {\n      let src = cell.getTerminal(true);\n      if (src != null) {\n        tip += this.getTooltipForCell(src) + ' ';\n      }\n      let parent = cell.getParent();\n      if (parent.isVertex()) {\n        tip += this.getTooltipForCell(parent) + '.';\n      }\n      tip += super.getTooltipForCell.apply(this, arguments);\n      let trg = cell.getTerminal(false);\n      if (trg != null) {\n        tip += ' ' + this.getTooltipForCell(trg);\n      }\n    }\n    return tip;\n  }\n\n  // Alternative solution for implementing connection points without child cells.\n  // This can be extended as shown in portrefs.html example to allow for per-port\n  // incoming/outgoing direction.\n  getAllConnectionConstraints(terminal) {\n    let geo = terminal != null ? terminal.cell.getGeometry() : null;\n    if ((geo != null ? !geo.relative : false) && terminal.cell.isVertex() && terminal.cell.getChildCount() === 0) {\n      return [new ConnectionConstraint(new Point(0, 0.5), false), new ConnectionConstraint(new Point(1, 0.5), false)];\n    }\n    return null;\n  }\n}\nclass MyCustomConstraintHandler extends ConstraintHandler {\n  constructor(...args) {\n    super(...args);\n    // Replaces the port image\n    this.pointImage = new ImageBox('images/dot.gif', 10, 10);\n  }\n}\nclass MyCustomGuide extends Guide {\n  // Alt disables guides\n  isEnabledForEvent(evt) {\n    return !eventUtils.isAltDown(evt);\n  }\n}\nclass MyCustomEdgeHandler extends EdgeHandler {\n  constructor(...args) {\n    super(...args);\n    // Enables snapping waypoints to terminals\n    this.snapToTerminals = true;\n  }\n  isConnectableCell(cell) {\n    return graph.getPlugin('ConnectionHandler').isConnectableCell(cell);\n  }\n  connect(edge, terminal, isSource, isClone, me) {\n    let result = null;\n    let model = this.graph.getDataModel();\n    let parent = model.getParent(edge);\n    model.beginUpdate();\n    try {\n      result = super.connect.apply(this, arguments);\n      let geo = model.getGeometry(result);\n      if (geo != null) {\n        geo = geo.clone();\n        let pt = null;\n        if (terminal && terminal.isEdge) {\n          if (terminal.isEdge()) {\n            pt = this.abspoints[this.isSource ? 0 : this.abspoints.length - 1];\n            pt.x = pt.x / this.graph.view.scale - this.graph.view.translate.x;\n            pt.y = pt.y / this.graph.view.scale - this.graph.view.translate.y;\n            let pstate = this.graph.getView().getState(edge.getParent());\n            if (pstate != null) {\n              pt.x -= pstate.origin.x;\n              pt.y -= pstate.origin.y;\n            }\n            pt.x -= this.graph.panDx / this.graph.view.scale;\n            pt.y -= this.graph.panDy / this.graph.view.scale;\n          }\n        }\n        geo.setTerminalPoint(pt, isSource);\n        model.setGeometry(edge, geo);\n      }\n    } finally {\n      model.endUpdate();\n    }\n    return result;\n  }\n  createMarker() {\n    let marker = super.createMarker.apply(this, arguments);\n    // Adds in-place highlighting when reconnecting existing edges\n    marker.highlight.highlight = this.graph.getPlugin('ConnectionHandler').marker.highlight.highlight;\n    return marker;\n  }\n}\nclass MyCustomSelectionHandler extends SelectionHandler {\n  constructor(...args) {\n    super(...args);\n    this.previewColor = invert ? 'white' : 'black';\n    // Enables guides\n    this.guidesEnabled = true;\n  }\n  createGuide() {\n    return new MyCustomGuide(this.graph, this.getGuideStates());\n  }\n}\nclass MyCustomPanningHandler extends PanningHandler {\n  // Panning handler consumed right click so this must be\n  // disabled if right click should stop connection handler.\n  isPopupTrigger() {\n    return false;\n  }\n}\nclass MyCustomConnectionHandler extends ConnectionHandler {\n  constructor(...args) {\n    super(...args);\n    // If connect preview is not moved away then getCellAt is used to detect the cell under\n    // the mouse if the mouse is over the preview shape in IE (no event transparency), ie.\n    // the built-in hit-detection of the HTML document will not be used in this case.\n    this.movePreviewAway = false;\n    this.waypointsEnabled = true;\n  }\n  // Starts connections on the background in wire-mode\n  isStartEvent(me) {\n    return checkbox.checked || super.isStartEvent.apply(this, arguments);\n  }\n\n  // Avoids any connections for gestures within tolerance except when in wire-mode\n  // or when over a port\n  mouseUp(sender, me) {\n    if (this.first != null && this.previous != null) {\n      let point = styleUtils.convertPoint(this.graph.container, me.getX(), me.getY());\n      let dx = Math.abs(point.x - this.first.x);\n      let dy = Math.abs(point.y - this.first.y);\n      if (dx < this.graph.tolerance && dy < this.graph.tolerance) {\n        // Selects edges in non-wire mode for single clicks, but starts\n        // connecting for non-edges regardless of wire-mode\n        if (!checkbox.checked && this.previous.cell.isEdge()) {\n          this.reset();\n        }\n        return;\n      }\n    }\n    super.mouseUp.apply(this, arguments);\n  }\n\n  // Overrides methods to preview and create new edges.\n\n  // Sets source terminal point for edge-to-edge connections.\n  createEdgeState(me) {\n    let edge = this.graph.createEdge();\n    if (this.sourceConstraint != null && this.previous != null) {\n      edge.style = 'exitX' + '=' + this.sourceConstraint.point.x + ';' + 'exitY' + '=' + this.sourceConstraint.point.y + ';';\n    } else if (me.getCell().isEdge()) {\n      let scale = this.graph.view.scale;\n      let tr = this.graph.view.translate;\n      let pt = new Point(this.graph.snap(me.getGraphX() / scale) - tr.x, this.graph.snap(me.getGraphY() / scale) - tr.y);\n      edge.geometry.setTerminalPoint(pt, true);\n    }\n    return this.graph.view.createState(edge);\n  }\n\n  // Uses right mouse button to create edges on background (see also: lines 67 ff)\n  isStopEvent(me) {\n    return me.getState() != null || eventUtils.isRightMouseButton(me.getEvent());\n  }\n\n  // Updates target terminal point for edge-to-edge connections.\n  updateCurrentState(me, point) {\n    super.updateCurrentState.apply(this, arguments);\n    if (this.edgeState != null) {\n      this.edgeState.cell.geometry.setTerminalPoint(null, false);\n      if (this.shape != null && this.currentState != null && this.currentState.cell.isEdge()) {\n        let scale = this.graph.view.scale;\n        let tr = this.graph.view.translate;\n        let pt = new Point(this.graph.snap(me.getGraphX() / scale) - tr.x, this.graph.snap(me.getGraphY() / scale) - tr.y);\n        this.edgeState.cell.geometry.setTerminalPoint(pt, false);\n      }\n    }\n  }\n\n  // Adds in-place highlighting for complete cell area (no hotspot).\n  createMarker() {\n    let marker = super.createMarker.apply(this, arguments);\n\n    // Uses complete area of cell for new connections (no hotspot)\n    marker.intersects = function (state, evt) {\n      return true;\n    };\n\n    // Adds in-place highlighting\n    //const mxCellHighlightHighlight = mxCellHighlight.prototype.highlight;\n    marker.highlight.highlight = function (state) {\n      // TODO: Should this be a subclass of marker rather than assigning directly?\n      if (this.state != state) {\n        if (this.state != null) {\n          this.state.style = this.lastStyle;\n\n          // Workaround for shape using current stroke width if no strokewidth defined\n          this.state.style.strokeWidth = this.state.style.strokeWidth || '1';\n          this.state.style.strokeColor = this.state.style.strokeColor || 'none';\n          if (this.state.shape != null) {\n            this.state.view.graph.cellRenderer.configureShape(this.state);\n            this.state.shape.redraw();\n          }\n        }\n        if (state != null) {\n          this.lastStyle = state.style;\n          state.style = cloneUtils.clone(state.style);\n          state.style.strokeColor = '#00ff00';\n          state.style.strokeWidth = '3';\n          if (state.shape != null) {\n            state.view.graph.cellRenderer.configureShape(state);\n            state.shape.redraw();\n          }\n        }\n        this.state = state;\n      }\n    };\n    return marker;\n  }\n\n  // Makes sure non-relative cells can only be connected via constraints\n  isConnectableCell(cell) {\n    if (cell.isEdge()) {\n      return true;\n    } else {\n      let geo = cell != null ? cell.getGeometry() : null;\n      return geo != null ? geo.relative : false;\n    }\n  }\n}\nclass MyCustomGraphView extends GraphView {\n  // Computes the position of edge to edge connection points.\n  updateFixedTerminalPoint(edge, terminal, source, constraint) {\n    let pt = null;\n    if (constraint != null) {\n      pt = this.graph.getConnectionPoint(terminal, constraint);\n    }\n    if (source) {\n      edge.sourceSegment = null;\n    } else {\n      edge.targetSegment = null;\n    }\n    if (pt == null) {\n      let s = this.scale;\n      let tr = this.translate;\n      let orig = edge.origin;\n      let geo = edge.cell.getGeometry();\n      pt = geo.getTerminalPoint(source);\n\n      // Computes edge-to-edge connection point\n      if (pt != null) {\n        pt = new Point(s * (tr.x + pt.x + orig.x), s * (tr.y + pt.y + orig.y));\n\n        // Finds nearest segment on edge and computes intersection\n        if (terminal != null && terminal.absolutePoints != null) {\n          let seg = mathUtils.findNearestSegment(terminal, pt.x, pt.y);\n\n          // Finds orientation of the segment\n          let p0 = terminal.absolutePoints[seg];\n          let pe = terminal.absolutePoints[seg + 1];\n          let horizontal = p0.x - pe.x === 0;\n\n          // Stores the segment in the edge state\n          let key = source ? 'sourceConstraint' : 'targetConstraint';\n          let value = horizontal ? 'horizontal' : 'vertical';\n          edge.style[key] = value;\n\n          // Keeps the coordinate within the segment bounds\n          if (horizontal) {\n            pt.x = p0.x;\n            pt.y = Math.min(pt.y, Math.max(p0.y, pe.y));\n            pt.y = Math.max(pt.y, Math.min(p0.y, pe.y));\n          } else {\n            pt.y = p0.y;\n            pt.x = Math.min(pt.x, Math.max(p0.x, pe.x));\n            pt.x = Math.max(pt.x, Math.min(p0.x, pe.x));\n          }\n        }\n      }\n      // Computes constraint connection points on vertices and ports\n      else if (terminal != null && terminal.cell.geometry.relative) {\n        pt = new Point(this.getRoutingCenterX(terminal), this.getRoutingCenterY(terminal));\n      }\n\n      // Snaps point to grid\n      /*if (pt != null)\n      {\n        let tr = this.graph.view.translate;\n        let s = this.graph.view.scale;\n         pt.x = (this.graph.snap(pt.x / s - tr.x) + tr.x) * s;\n        pt.y = (this.graph.snap(pt.y / s - tr.y) + tr.y) * s;\n      }*/\n    }\n    edge.setAbsoluteTerminalPoint(pt, source);\n  }\n}\nclass MyCustomEdgeSegmentHandler extends EdgeSegmentHandler {\n  clonePreviewState(point, terminal) {\n    let clone = super.clonePreviewState.apply(this, arguments);\n    clone.cell = clone.cell.clone();\n    if (this.isSource || this.isTarget) {\n      clone.cell.geometry = clone.cell.geometry.clone();\n\n      // Sets the terminal point of an edge if we're moving one of the endpoints\n      if (clone.cell.isEdge()) {\n        // TODO: Only set this if the target or source terminal is an edge\n        clone.cell.geometry.setTerminalPoint(point, this.isSource);\n      } else {\n        clone.cell.geometry.setTerminalPoint(null, this.isSource);\n      }\n    }\n    return clone;\n  }\n}\nexport { MyCustomGraph, MyCustomEdgeSegmentHandler, MyCustomGraphView, MyCustomConnectionHandler, MyCustomPanningHandler, MyCustomSelectionHandler, MyCustomEdgeHandler, MyCustomConstraintHandler };","map":{"version":3,"names":["React","useEffect","useRef","useState","axios","popup","ModelXmlSerializer","domUtils","styleUtils","mathUtils","cloneUtils","eventUtils","Graph","InternalEvent","RubberBandHandler","ConnectionHandler","ConnectionConstraint","Point","CylinderShape","CellRenderer","DomHelpers","EdgeStyle","Rectangle","EdgeHandler","StyleRegistry","EdgeSegmentHandler","UndoManager","CellEditorHandler","ConstraintHandler","Guide","ImageBox","GraphView","SelectionHandler","PanningHandler","TooltipHandler","SelectionCellsHandler","PopupMenuHandler","xmlUtils","Codec","contextMenuTypes","contextMenuValues","globalTypes","globalValues","rubberBandTypes","rubberBandValues","createGraphContainer","render","invert","MyCustomCellEditorHandler","container","style","backgroundColor","startEditing","cell","trigger","apply","arguments","textarea","color","checkbox","document","getElementById","MyCustomGraph","constructor","args","resetEdgesOnConnect","createEdgeSegmentHandler","state","MyCustomEdgeSegmentHandler","createGraphView","MyCustomGraphView","createEdgeHandler","MyCustomEdgeHandler","createHandler","result","isEdge","view","getEdgeStyle","WireConnector","getCellStyle","_cell$getTerminal","_cell$getTerminal2","clone","getTerminal","startArrow","endArrow","getTooltipForCell","tip","src","parent","getParent","isVertex","trg","getAllConnectionConstraints","terminal","geo","getGeometry","relative","getChildCount","MyCustomConstraintHandler","pointImage","MyCustomGuide","isEnabledForEvent","evt","isAltDown","snapToTerminals","isConnectableCell","graph","getPlugin","connect","edge","isSource","isClone","me","model","getDataModel","beginUpdate","pt","abspoints","length","x","scale","translate","y","pstate","getView","getState","origin","panDx","panDy","setTerminalPoint","setGeometry","endUpdate","createMarker","marker","highlight","MyCustomSelectionHandler","previewColor","guidesEnabled","createGuide","getGuideStates","MyCustomPanningHandler","isPopupTrigger","MyCustomConnectionHandler","movePreviewAway","waypointsEnabled","isStartEvent","checked","mouseUp","sender","first","previous","point","convertPoint","getX","getY","dx","Math","abs","dy","tolerance","reset","createEdgeState","createEdge","sourceConstraint","getCell","tr","snap","getGraphX","getGraphY","geometry","createState","isStopEvent","isRightMouseButton","getEvent","updateCurrentState","edgeState","shape","currentState","intersects","lastStyle","strokeWidth","strokeColor","cellRenderer","configureShape","redraw","updateFixedTerminalPoint","source","constraint","getConnectionPoint","sourceSegment","targetSegment","s","orig","getTerminalPoint","absolutePoints","seg","findNearestSegment","p0","pe","horizontal","key","value","min","max","getRoutingCenterX","getRoutingCenterY","setAbsoluteTerminalPoint","clonePreviewState","isTarget"],"sources":["D:/OSPanel/domains/проекты open server/old/react/react-intro-main/src/components/MyCustomGraph.jsx"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\n\nimport axios from 'axios';\nimport {\n  popup,\n  ModelXmlSerializer,\n  domUtils,\n  styleUtils,\n  mathUtils,\n  cloneUtils,\n  eventUtils,\n  Graph,\n  InternalEvent,\n  RubberBandHandler,\n  ConnectionHandler,\n  ConnectionConstraint,\n  Point,\n  CylinderShape,\n  CellRenderer,\n  DomHelpers,\n  EdgeStyle,\n  Rectangle,\n  EdgeHandler,\n  StyleRegistry,\n  EdgeSegmentHandler,\n  UndoManager,\n  CellEditorHandler,\n  ConstraintHandler,\n  Guide,\n  ImageBox,\n  GraphView,\n  SelectionHandler,\n  PanningHandler,\n  TooltipHandler,\n  SelectionCellsHandler,\n  PopupMenuHandler,\n  xmlUtils,\n  Codec,\n} from '@maxgraph/core';\n\nimport {\n  contextMenuTypes,\n  contextMenuValues,\n  globalTypes,\n  globalValues,\n  rubberBandTypes,\n  rubberBandValues,\n} from './shared/args.js';\n\nimport { createGraphContainer } from './shared/configure.js';\n\n// style required by RubberBand\nimport '@maxgraph/core/css/common.css';\n\nimport { render } from 'react-dom';\n\n  // TODO Убрать этот костыль\n  let invert = false;\n  let MyCustomCellEditorHandler;\n\n  if (invert) {\n    container.style.backgroundColor = 'black';\n\n    // White in-place editor text color\n    MyCustomCellEditorHandler = class extends CellEditorHandler {\n      startEditing(cell, trigger) {\n        super.startEditing.apply(this, arguments);\n\n        if (this.textarea != null) {\n          this.textarea.style.color = '#FFFFFF';\n        }\n      }\n    };\n  } else {\n    MyCustomCellEditorHandler = CellEditorHandler;\n  }\n  // Wire-mode\n  let checkbox = document.getElementById(\"wire\");\n  \n  class MyCustomGraph extends Graph {\n    resetEdgesOnConnect = false;\n    createEdgeSegmentHandler(state) {\n      return new MyCustomEdgeSegmentHandler(state);\n    }\n\n    createGraphView() {\n      return new MyCustomGraphView(this);\n    }\n\n    createEdgeHandler(state) {\n      return new MyCustomEdgeHandler(state);\n    }\n\n    createHandler(state) {\n      let result = null;\n\n      if (state != null) {\n        if (state.cell.isEdge()) {\n          let style = this.view.getEdgeStyle(state);\n\n          if (style == EdgeStyle.WireConnector) {\n            return new EdgeSegmentHandler(state);\n          }\n        }\n      }\n\n      return super.createHandler.apply(this, arguments);\n    }\n\n    // Adds oval markers for edge-to-edge connections.\n    getCellStyle(cell) {\n      let style = super.getCellStyle.apply(this, arguments);\n\n      if (style != null && cell?.isEdge()) {\n        style = cloneUtils.clone(style);\n\n        if (cell.getTerminal(true)?.isEdge()) {\n          style.startArrow = 'oval';\n        }\n\n        if (cell.getTerminal(false)?.isEdge()) {\n          style.endArrow = 'oval';\n        }\n      }\n      return style;\n    }\n\n    getTooltipForCell(cell) {\n      let tip = '';\n\n      if (cell != null) {\n        let src = cell.getTerminal(true);\n        if (src != null) {\n          tip += this.getTooltipForCell(src) + ' ';\n        }\n\n        let parent = cell.getParent();\n        if (parent.isVertex()) {\n          tip += this.getTooltipForCell(parent) + '.';\n        }\n\n        tip += super.getTooltipForCell.apply(this, arguments);\n\n        let trg = cell.getTerminal(false);\n        if (trg != null) {\n          tip += ' ' + this.getTooltipForCell(trg);\n        }\n      }\n      return tip;\n    }\n\n    // Alternative solution for implementing connection points without child cells.\n    // This can be extended as shown in portrefs.html example to allow for per-port\n    // incoming/outgoing direction.\n    getAllConnectionConstraints(terminal) {\n      let geo = terminal != null ? terminal.cell.getGeometry() : null;\n\n      if (\n        (geo != null ? !geo.relative : false) &&\n        terminal.cell.isVertex() &&\n        terminal.cell.getChildCount() === 0\n      ) {\n        return [\n          new ConnectionConstraint(new Point(0, 0.5), false),\n          new ConnectionConstraint(new Point(1, 0.5), false),\n        ];\n      }\n      return null;\n    }\n  }\n\n  class MyCustomConstraintHandler extends ConstraintHandler {\n    // Replaces the port image\n    pointImage = new ImageBox('images/dot.gif', 10, 10);\n  }\n\n  class MyCustomGuide extends Guide {\n    // Alt disables guides\n    isEnabledForEvent(evt) {\n      return !eventUtils.isAltDown(evt);\n    }\n  }\n\n  class MyCustomEdgeHandler extends EdgeHandler {\n    // Enables snapping waypoints to terminals\n    snapToTerminals = true;\n\n    isConnectableCell(cell) {\n      return graph.getPlugin('ConnectionHandler').isConnectableCell(cell);\n    }\n\n    connect(edge, terminal, isSource, isClone, me) {\n      let result = null;\n      let model = this.graph.getDataModel();\n      let parent = model.getParent(edge);\n\n      model.beginUpdate();\n      try {\n        result = super.connect.apply(this, arguments);\n        let geo = model.getGeometry(result);\n\n        if (geo != null) {\n          geo = geo.clone();\n          let pt = null;\n          if (terminal && terminal.isEdge) {\n            if (terminal.isEdge()) {\n              pt = this.abspoints[this.isSource ? 0 : this.abspoints.length - 1];\n              pt.x = pt.x / this.graph.view.scale - this.graph.view.translate.x;\n              pt.y = pt.y / this.graph.view.scale - this.graph.view.translate.y;\n\n              let pstate = this.graph.getView().getState(edge.getParent());\n\n              if (pstate != null) {\n                pt.x -= pstate.origin.x;\n                pt.y -= pstate.origin.y;\n              }\n\n              pt.x -= this.graph.panDx / this.graph.view.scale;\n              pt.y -= this.graph.panDy / this.graph.view.scale;\n            }\n          }\n\n          geo.setTerminalPoint(pt, isSource);\n          model.setGeometry(edge, geo);\n        }\n      } finally {\n        model.endUpdate();\n      }\n\n      return result;\n    }\n\n    createMarker() {\n      let marker = super.createMarker.apply(this, arguments);\n      // Adds in-place highlighting when reconnecting existing edges\n      marker.highlight.highlight =\n        this.graph.getPlugin('ConnectionHandler').marker.highlight.highlight;\n      return marker;\n    }\n  }\n\n  class MyCustomSelectionHandler extends SelectionHandler {\n\n    previewColor = invert ? 'white' : 'black';\n    // Enables guides\n    guidesEnabled = true;\n\n    createGuide() {\n      return new MyCustomGuide(this.graph, this.getGuideStates());\n    }\n  }\n\n  class MyCustomPanningHandler extends PanningHandler {\n    // Panning handler consumed right click so this must be\n    // disabled if right click should stop connection handler.\n    isPopupTrigger() {\n      return false;\n    }\n  }\n\n  class MyCustomConnectionHandler extends ConnectionHandler {\n    // If connect preview is not moved away then getCellAt is used to detect the cell under\n    // the mouse if the mouse is over the preview shape in IE (no event transparency), ie.\n    // the built-in hit-detection of the HTML document will not be used in this case.\n    movePreviewAway = false;\n    waypointsEnabled = true;\n\n    // Starts connections on the background in wire-mode\n    isStartEvent(me) {\n      return checkbox.checked || super.isStartEvent.apply(this, arguments);\n    }\n\n    // Avoids any connections for gestures within tolerance except when in wire-mode\n    // or when over a port\n    mouseUp(sender, me) {\n      if (this.first != null && this.previous != null) {\n        let point = styleUtils.convertPoint(this.graph.container, me.getX(), me.getY());\n        let dx = Math.abs(point.x - this.first.x);\n        let dy = Math.abs(point.y - this.first.y);\n\n        if (dx < this.graph.tolerance && dy < this.graph.tolerance) {\n          // Selects edges in non-wire mode for single clicks, but starts\n          // connecting for non-edges regardless of wire-mode\n          if (!checkbox.checked && this.previous.cell.isEdge()) {\n            this.reset();\n          }\n          return;\n        }\n      }\n      super.mouseUp.apply(this, arguments);\n    }\n\n    // Overrides methods to preview and create new edges.\n\n    // Sets source terminal point for edge-to-edge connections.\n    createEdgeState(me) {\n      let edge = this.graph.createEdge();\n\n      if (this.sourceConstraint != null && this.previous != null) {\n        edge.style =\n          'exitX' +\n          '=' +\n          this.sourceConstraint.point.x +\n          ';' +\n          'exitY' +\n          '=' +\n          this.sourceConstraint.point.y +\n          ';';\n      } else if (me.getCell().isEdge()) {\n        let scale = this.graph.view.scale;\n        let tr = this.graph.view.translate;\n        let pt = new Point(\n          this.graph.snap(me.getGraphX() / scale) - tr.x,\n          this.graph.snap(me.getGraphY() / scale) - tr.y\n        );\n        edge.geometry.setTerminalPoint(pt, true);\n      }\n\n      return this.graph.view.createState(edge);\n    }\n\n    // Uses right mouse button to create edges on background (see also: lines 67 ff)\n    isStopEvent(me) {\n      return me.getState() != null || eventUtils.isRightMouseButton(me.getEvent());\n    }\n\n    // Updates target terminal point for edge-to-edge connections.\n    updateCurrentState(me, point) {\n      super.updateCurrentState.apply(this, arguments);\n\n      if (this.edgeState != null) {\n        this.edgeState.cell.geometry.setTerminalPoint(null, false);\n\n        if (\n          this.shape != null &&\n          this.currentState != null &&\n          this.currentState.cell.isEdge()\n        ) {\n          let scale = this.graph.view.scale;\n          let tr = this.graph.view.translate;\n          let pt = new Point(\n            this.graph.snap(me.getGraphX() / scale) - tr.x,\n            this.graph.snap(me.getGraphY() / scale) - tr.y\n          );\n          this.edgeState.cell.geometry.setTerminalPoint(pt, false);\n        }\n      }\n    }\n\n    // Adds in-place highlighting for complete cell area (no hotspot).\n    createMarker() {\n      let marker = super.createMarker.apply(this, arguments);\n\n      // Uses complete area of cell for new connections (no hotspot)\n      marker.intersects = function (state, evt) {\n        return true;\n      };\n\n      // Adds in-place highlighting\n      //const mxCellHighlightHighlight = mxCellHighlight.prototype.highlight;\n      marker.highlight.highlight = function (state) {\n        // TODO: Should this be a subclass of marker rather than assigning directly?\n        if (this.state != state) {\n          if (this.state != null) {\n            this.state.style = this.lastStyle;\n\n            // Workaround for shape using current stroke width if no strokewidth defined\n            this.state.style.strokeWidth = this.state.style.strokeWidth || '1';\n            this.state.style.strokeColor = this.state.style.strokeColor || 'none';\n\n            if (this.state.shape != null) {\n              this.state.view.graph.cellRenderer.configureShape(this.state);\n              this.state.shape.redraw();\n            }\n          }\n\n          if (state != null) {\n            this.lastStyle = state.style;\n            state.style = cloneUtils.clone(state.style);\n            state.style.strokeColor = '#00ff00';\n            state.style.strokeWidth = '3';\n\n            if (state.shape != null) {\n              state.view.graph.cellRenderer.configureShape(state);\n              state.shape.redraw();\n            }\n          }\n          this.state = state;\n        }\n      };\n\n      return marker;\n    }\n\n    // Makes sure non-relative cells can only be connected via constraints\n    isConnectableCell(cell) {\n      if (cell.isEdge()) {\n        return true;\n      } else {\n        let geo = cell != null ? cell.getGeometry() : null;\n        return geo != null ? geo.relative : false;\n      }\n    }\n  }\n\n  class MyCustomGraphView extends GraphView {\n    // Computes the position of edge to edge connection points.\n    updateFixedTerminalPoint(edge, terminal, source, constraint) {\n      let pt = null;\n\n      if (constraint != null) {\n        pt = this.graph.getConnectionPoint(terminal, constraint);\n      }\n\n      if (source) {\n        edge.sourceSegment = null;\n      } else {\n        edge.targetSegment = null;\n      }\n\n      if (pt == null) {\n        let s = this.scale;\n        let tr = this.translate;\n        let orig = edge.origin;\n        let geo = edge.cell.getGeometry();\n        pt = geo.getTerminalPoint(source);\n\n        // Computes edge-to-edge connection point\n        if (pt != null) {\n          pt = new Point(s * (tr.x + pt.x + orig.x), s * (tr.y + pt.y + orig.y));\n\n          // Finds nearest segment on edge and computes intersection\n          if (terminal != null && terminal.absolutePoints != null) {\n            let seg = mathUtils.findNearestSegment(terminal, pt.x, pt.y);\n\n            // Finds orientation of the segment\n            let p0 = terminal.absolutePoints[seg];\n            let pe = terminal.absolutePoints[seg + 1];\n            let horizontal = p0.x - pe.x === 0;\n\n            // Stores the segment in the edge state\n            let key = source ? 'sourceConstraint' : 'targetConstraint';\n            let value = horizontal ? 'horizontal' : 'vertical';\n            edge.style[key] = value;\n\n            // Keeps the coordinate within the segment bounds\n            if (horizontal) {\n              pt.x = p0.x;\n              pt.y = Math.min(pt.y, Math.max(p0.y, pe.y));\n              pt.y = Math.max(pt.y, Math.min(p0.y, pe.y));\n            } else {\n              pt.y = p0.y;\n              pt.x = Math.min(pt.x, Math.max(p0.x, pe.x));\n              pt.x = Math.max(pt.x, Math.min(p0.x, pe.x));\n            }\n          }\n        }\n        // Computes constraint connection points on vertices and ports\n        else if (terminal != null && terminal.cell.geometry.relative) {\n          pt = new Point(\n            this.getRoutingCenterX(terminal),\n            this.getRoutingCenterY(terminal)\n          );\n        }\n\n        // Snaps point to grid\n        /*if (pt != null)\n        {\n          let tr = this.graph.view.translate;\n          let s = this.graph.view.scale;\n\n          pt.x = (this.graph.snap(pt.x / s - tr.x) + tr.x) * s;\n          pt.y = (this.graph.snap(pt.y / s - tr.y) + tr.y) * s;\n        }*/\n      }\n\n      edge.setAbsoluteTerminalPoint(pt, source);\n    }\n  }\n\n  class MyCustomEdgeSegmentHandler extends EdgeSegmentHandler {\n    clonePreviewState(point, terminal) {\n      let clone = super.clonePreviewState.apply(this, arguments);\n      clone.cell = clone.cell.clone();\n\n      if (this.isSource || this.isTarget) {\n        clone.cell.geometry = clone.cell.geometry.clone();\n\n        // Sets the terminal point of an edge if we're moving one of the endpoints\n        if (clone.cell.isEdge()) {\n          // TODO: Only set this if the target or source terminal is an edge\n          clone.cell.geometry.setTerminalPoint(point, this.isSource);\n        } else {\n          clone.cell.geometry.setTerminalPoint(null, this.isSource);\n        }\n      }\n\n      return clone;\n    }\n  }\n\n\nexport {\n    MyCustomGraph, \n    MyCustomEdgeSegmentHandler, \n    MyCustomGraphView, \n    MyCustomConnectionHandler,  \n    MyCustomPanningHandler, \n    MyCustomSelectionHandler,\n    MyCustomEdgeHandler,\n    MyCustomConstraintHandler\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}