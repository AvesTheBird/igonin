{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../geometry/Point';\nimport { CURSOR } from '../../util/Constants';\nimport Rectangle from '../geometry/Rectangle';\nimport { contains } from '../../util/mathUtils';\nimport { setOpacity } from '../../util/styleUtils';\nimport ElbowEdgeHandler from './ElbowEdgeHandler';\nclass EdgeSegmentHandler extends ElbowEdgeHandler {\n  constructor(state) {\n    super(state);\n    this.points = [];\n  }\n  /**\n   * Returns the current absolute points.\n   */\n  getCurrentPoints() {\n    let pts = this.state.absolutePoints;\n    // Special case for straight edges where we add a virtual middle handle for moving the edge\n    const tol = Math.max(1, this.graph.view.scale);\n    if (pts.length === 2 && pts[0] && pts[1] || pts.length === 3 && pts[0] && pts[1] && pts[2] && (Math.abs(pts[0].x - pts[1].x) < tol && Math.abs(pts[1].x - pts[2].x) < tol || Math.abs(pts[0].y - pts[1].y) < tol && Math.abs(pts[1].y - pts[2].y) < tol)) {\n      const cx = pts[0].x + (pts[pts.length - 1].x - pts[0].x) / 2;\n      const cy = pts[0].y + (pts[pts.length - 1].y - pts[0].y) / 2;\n      pts = [pts[0], new Point(cx, cy), new Point(cx, cy), pts[pts.length - 1]];\n    }\n    return pts;\n  }\n  /**\n   * Updates the given preview state taking into account the state of the constraint handler.\n   */\n  getPreviewPoints(point) {\n    if (this.isSource || this.isTarget) {\n      return super.getPreviewPoints(point);\n    }\n    const pts = this.getCurrentPoints();\n    let last = this.convertPoint(pts[0].clone(), false);\n    point = this.convertPoint(point.clone(), false);\n    let result = [];\n    for (let i = 1; i < pts.length; i += 1) {\n      const pt = this.convertPoint(pts[i].clone(), false);\n      if (i === this.index) {\n        if (Math.round(last.x - pt.x) === 0) {\n          last.x = point.x;\n          pt.x = point.x;\n        }\n        if (Math.round(last.y - pt.y) === 0) {\n          last.y = point.y;\n          pt.y = point.y;\n        }\n      }\n      if (i < pts.length - 1) {\n        result.push(pt);\n      }\n      last = pt;\n    }\n    // Replaces single point that intersects with source or target\n    if (result.length === 1) {\n      const source = this.state.getVisibleTerminalState(true);\n      const target = this.state.getVisibleTerminalState(false);\n      const scale = this.state.view.getScale();\n      const tr = this.state.view.getTranslate();\n      const x = result[0].x * scale + tr.x;\n      const y = result[0].y * scale + tr.y;\n      if (source != null && contains(source, x, y) || target != null && contains(target, x, y)) {\n        result = [point, point];\n      }\n    }\n    return result;\n  }\n  /**\n   * Overridden to perform optimization of the edge style result.\n   */\n  updatePreviewState(edge, point, terminalState, me) {\n    super.updatePreviewState(edge, point, terminalState, me);\n    // Checks and corrects preview by running edge style again\n    if (!this.isSource && !this.isTarget) {\n      point = this.convertPoint(point.clone(), false);\n      const pts = edge.absolutePoints;\n      let pt0 = pts[0];\n      let pt1 = pts[1];\n      let result = [];\n      for (let i = 2; i < pts.length; i += 1) {\n        const pt2 = pts[i];\n        // Merges adjacent segments only if more than 2 to allow for straight edges\n        if ((Math.round(pt0.x - pt1.x) !== 0 || Math.round(pt1.x - pt2.x) !== 0) && (Math.round(pt0.y - pt1.y) !== 0 || Math.round(pt1.y - pt2.y) !== 0)) {\n          result.push(this.convertPoint(pt1.clone(), false));\n        }\n        pt0 = pt1;\n        pt1 = pt2;\n      }\n      const source = this.state.getVisibleTerminalState(true);\n      const target = this.state.getVisibleTerminalState(false);\n      const rpts = this.state.absolutePoints;\n      const end = pts[pts.length - 1];\n      // A straight line is represented by 3 handles\n      if (result.length === 0 && pts[0] && end && (Math.round(pts[0].x - end.x) === 0 || Math.round(pts[0].y - end.y) === 0)) {\n        result = [point, point];\n      }\n      // Handles special case of transitions from straight vertical to routed\n      else if (pts.length === 5 && result.length === 2 && source != null && target != null && rpts != null && Math.round(rpts[0].x - rpts[rpts.length - 1].x) === 0) {\n        const view = this.graph.getView();\n        const scale = view.getScale();\n        const tr = view.getTranslate();\n        let y0 = view.getRoutingCenterY(source) / scale - tr.y;\n        // Use fixed connection point y-coordinate if one exists\n        const sc = this.graph.getConnectionConstraint(edge, source, true);\n        if (sc != null) {\n          const pt = this.graph.getConnectionPoint(source, sc);\n          if (pt != null) {\n            this.convertPoint(pt, false);\n            y0 = pt.y;\n          }\n        }\n        let ye = view.getRoutingCenterY(target) / scale - tr.y;\n        // Use fixed connection point y-coordinate if one exists\n        const tc = this.graph.getConnectionConstraint(edge, target, false);\n        if (tc) {\n          const pt = this.graph.getConnectionPoint(target, tc);\n          if (pt != null) {\n            this.convertPoint(pt, false);\n            ye = pt.y;\n          }\n        }\n        result = [new Point(point.x, y0), new Point(point.x, ye)];\n      }\n      this.points = result;\n      // LATER: Check if points and result are different\n      edge.view.updateFixedTerminalPoints(edge, source, target);\n      edge.view.updatePoints(edge, this.points, source, target);\n      edge.view.updateFloatingTerminalPoints(edge, source, target);\n    }\n  }\n  /**\n   * Overriden to merge edge segments.\n   */\n  connect(edge, terminal, isSource, isClone, me) {\n    const model = this.graph.getDataModel();\n    let geo = edge.getGeometry();\n    let result = null;\n    // Merges adjacent edge segments\n    if (geo != null && geo.points != null && geo.points.length > 0) {\n      const pts = this.abspoints;\n      let pt0 = pts[0];\n      let pt1 = pts[1];\n      result = [];\n      for (let i = 2; i < pts.length; i += 1) {\n        const pt2 = pts[i];\n        // Merges adjacent segments only if more than 2 to allow for straight edges\n        if (pt0 && pt1 && pt2 && (Math.round(pt0.x - pt1.x) !== 0 || Math.round(pt1.x - pt2.x) !== 0) && (Math.round(pt0.y - pt1.y) !== 0 || Math.round(pt1.y - pt2.y) !== 0)) {\n          result.push(this.convertPoint(pt1.clone(), false));\n        }\n        pt0 = pt1;\n        pt1 = pt2;\n      }\n    }\n    this.graph.batchUpdate(() => {\n      if (result != null) {\n        geo = edge.getGeometry();\n        if (geo != null) {\n          geo = geo.clone();\n          geo.points = result;\n          model.setGeometry(edge, geo);\n        }\n      }\n      edge = super.connect(edge, terminal, isSource, isClone, me);\n    });\n    return edge;\n  }\n  /**\n   * Returns no tooltips.\n   */\n  getTooltipForNode(node) {\n    return null;\n  }\n  /**\n   * Adds custom bends for the center of each segment.\n   */\n  start(x, y, index) {\n    super.start(x, y, index);\n    if (this.bends != null && this.bends[index] != null && !this.isSource && !this.isTarget) {\n      setOpacity(this.bends[index].node, 100);\n    }\n  }\n  /**\n   * Adds custom bends for the center of each segment.\n   */\n  createBends() {\n    const bends = [];\n    // Source\n    let bend = this.createHandleShape(0);\n    this.initBend(bend);\n    bend.setCursor(CURSOR.TERMINAL_HANDLE);\n    bends.push(bend);\n    const pts = this.getCurrentPoints();\n    // Waypoints (segment handles)\n    if (this.graph.isCellBendable(this.state.cell)) {\n      if (this.points == null) {\n        this.points = [];\n      }\n      for (let i = 0; i < pts.length - 1; i += 1) {\n        bend = this.createVirtualBend();\n        bends.push(bend);\n        let horizontal = Math.round(pts[i].x - pts[i + 1].x) === 0;\n        // Special case where dy is 0 as well\n        if (Math.round(pts[i].y - pts[i + 1].y) === 0 && i < pts.length - 2) {\n          horizontal = Math.round(pts[i].x - pts[i + 2].x) === 0;\n        }\n        bend.setCursor(horizontal ? 'col-resize' : 'row-resize');\n        this.points.push(new Point(0, 0));\n      }\n    }\n    // Target\n    bend = this.createHandleShape(pts.length);\n    this.initBend(bend);\n    bend.setCursor(CURSOR.TERMINAL_HANDLE);\n    bends.push(bend);\n    return bends;\n  }\n  /**\n   * Overridden to invoke <refresh> before the redraw.\n   */\n  redraw() {\n    this.refresh();\n    super.redraw();\n  }\n  /**\n   * Updates the position of the custom bends.\n   */\n  redrawInnerBends(p0, pe) {\n    if (this.graph.isCellBendable(this.state.cell)) {\n      const pts = this.getCurrentPoints();\n      if (pts != null && pts.length > 1) {\n        let straight = false;\n        // Puts handle in the center of straight edges\n        if (pts.length === 4 && pts[0] && pts[1] && pts[2] && pts[3] && Math.round(pts[1].x - pts[2].x) === 0 && Math.round(pts[1].y - pts[2].y) === 0) {\n          straight = true;\n          if (Math.round(pts[0].y - pts[pts.length - 1].y) === 0) {\n            const cx = pts[0].x + (pts[pts.length - 1].x - pts[0].x) / 2;\n            pts[1] = new Point(cx, pts[1].y);\n            pts[2] = new Point(cx, pts[2].y);\n          } else {\n            const cy = pts[0].y + (pts[pts.length - 1].y - pts[0].y) / 2;\n            pts[1] = new Point(pts[1].x, cy);\n            pts[2] = new Point(pts[2].x, cy);\n          }\n        }\n        for (let i = 0; i < pts.length - 1; i += 1) {\n          if (this.bends[i + 1] != null) {\n            p0 = pts[i];\n            pe = pts[i + 1];\n            const pt = new Point(p0.x + (pe.x - p0.x) / 2, p0.y + (pe.y - p0.y) / 2);\n            const b = this.bends[i + 1].bounds;\n            this.bends[i + 1].bounds = new Rectangle(Math.floor(pt.x - b.width / 2), Math.floor(pt.y - b.height / 2), b.width, b.height);\n            this.bends[i + 1].redraw();\n            if (this.manageLabelHandle) {\n              this.checkLabelHandle(this.bends[i + 1].bounds);\n            }\n          }\n        }\n        if (straight) {\n          setOpacity(this.bends[1].node, this.virtualBendOpacity);\n          setOpacity(this.bends[3].node, this.virtualBendOpacity);\n        }\n      }\n    }\n  }\n}\nexport default EdgeSegmentHandler;","map":{"version":3,"names":["Point","CURSOR","Rectangle","contains","setOpacity","ElbowEdgeHandler","EdgeSegmentHandler","constructor","state","points","getCurrentPoints","pts","absolutePoints","tol","Math","max","graph","view","scale","length","abs","x","y","cx","cy","getPreviewPoints","point","isSource","isTarget","last","convertPoint","clone","result","i","pt","index","round","push","source","getVisibleTerminalState","target","getScale","tr","getTranslate","updatePreviewState","edge","terminalState","me","pt0","pt1","pt2","rpts","end","getView","y0","getRoutingCenterY","sc","getConnectionConstraint","getConnectionPoint","ye","tc","updateFixedTerminalPoints","updatePoints","updateFloatingTerminalPoints","connect","terminal","isClone","model","getDataModel","geo","getGeometry","abspoints","batchUpdate","setGeometry","getTooltipForNode","node","start","bends","createBends","bend","createHandleShape","initBend","setCursor","TERMINAL_HANDLE","isCellBendable","cell","createVirtualBend","horizontal","redraw","refresh","redrawInnerBends","p0","pe","straight","b","bounds","floor","width","height","manageLabelHandle","checkLabelHandle","virtualBendOpacity"],"sources":["D:/ospanel/domains/old/react/react-intro/node_modules/@maxgraph/core/dist/view/handler/EdgeSegmentHandler.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../geometry/Point';\nimport { CURSOR } from '../../util/Constants';\nimport Rectangle from '../geometry/Rectangle';\nimport { contains } from '../../util/mathUtils';\nimport { setOpacity } from '../../util/styleUtils';\nimport ElbowEdgeHandler from './ElbowEdgeHandler';\nclass EdgeSegmentHandler extends ElbowEdgeHandler {\n    constructor(state) {\n        super(state);\n        this.points = [];\n    }\n    /**\n     * Returns the current absolute points.\n     */\n    getCurrentPoints() {\n        let pts = this.state.absolutePoints;\n        // Special case for straight edges where we add a virtual middle handle for moving the edge\n        const tol = Math.max(1, this.graph.view.scale);\n        if ((pts.length === 2 && pts[0] && pts[1]) ||\n            (pts.length === 3 &&\n                pts[0] &&\n                pts[1] &&\n                pts[2] &&\n                ((Math.abs(pts[0].x - pts[1].x) < tol && Math.abs(pts[1].x - pts[2].x) < tol) ||\n                    (Math.abs(pts[0].y - pts[1].y) < tol && Math.abs(pts[1].y - pts[2].y) < tol)))) {\n            const cx = pts[0].x + (pts[pts.length - 1].x - pts[0].x) / 2;\n            const cy = pts[0].y + (pts[pts.length - 1].y - pts[0].y) / 2;\n            pts = [pts[0], new Point(cx, cy), new Point(cx, cy), pts[pts.length - 1]];\n        }\n        return pts;\n    }\n    /**\n     * Updates the given preview state taking into account the state of the constraint handler.\n     */\n    getPreviewPoints(point) {\n        if (this.isSource || this.isTarget) {\n            return super.getPreviewPoints(point);\n        }\n        const pts = this.getCurrentPoints();\n        let last = this.convertPoint(pts[0].clone(), false);\n        point = this.convertPoint(point.clone(), false);\n        let result = [];\n        for (let i = 1; i < pts.length; i += 1) {\n            const pt = this.convertPoint(pts[i].clone(), false);\n            if (i === this.index) {\n                if (Math.round(last.x - pt.x) === 0) {\n                    last.x = point.x;\n                    pt.x = point.x;\n                }\n                if (Math.round(last.y - pt.y) === 0) {\n                    last.y = point.y;\n                    pt.y = point.y;\n                }\n            }\n            if (i < pts.length - 1) {\n                result.push(pt);\n            }\n            last = pt;\n        }\n        // Replaces single point that intersects with source or target\n        if (result.length === 1) {\n            const source = this.state.getVisibleTerminalState(true);\n            const target = this.state.getVisibleTerminalState(false);\n            const scale = this.state.view.getScale();\n            const tr = this.state.view.getTranslate();\n            const x = result[0].x * scale + tr.x;\n            const y = result[0].y * scale + tr.y;\n            if ((source != null && contains(source, x, y)) ||\n                (target != null && contains(target, x, y))) {\n                result = [point, point];\n            }\n        }\n        return result;\n    }\n    /**\n     * Overridden to perform optimization of the edge style result.\n     */\n    updatePreviewState(edge, point, terminalState, me) {\n        super.updatePreviewState(edge, point, terminalState, me);\n        // Checks and corrects preview by running edge style again\n        if (!this.isSource && !this.isTarget) {\n            point = this.convertPoint(point.clone(), false);\n            const pts = edge.absolutePoints;\n            let pt0 = pts[0];\n            let pt1 = pts[1];\n            let result = [];\n            for (let i = 2; i < pts.length; i += 1) {\n                const pt2 = pts[i];\n                // Merges adjacent segments only if more than 2 to allow for straight edges\n                if ((Math.round(pt0.x - pt1.x) !== 0 || Math.round(pt1.x - pt2.x) !== 0) &&\n                    (Math.round(pt0.y - pt1.y) !== 0 || Math.round(pt1.y - pt2.y) !== 0)) {\n                    result.push(this.convertPoint(pt1.clone(), false));\n                }\n                pt0 = pt1;\n                pt1 = pt2;\n            }\n            const source = this.state.getVisibleTerminalState(true);\n            const target = this.state.getVisibleTerminalState(false);\n            const rpts = this.state.absolutePoints;\n            const end = pts[pts.length - 1];\n            // A straight line is represented by 3 handles\n            if (result.length === 0 &&\n                pts[0] &&\n                end &&\n                (Math.round(pts[0].x - end.x) === 0 || Math.round(pts[0].y - end.y) === 0)) {\n                result = [point, point];\n            }\n            // Handles special case of transitions from straight vertical to routed\n            else if (pts.length === 5 &&\n                result.length === 2 &&\n                source != null &&\n                target != null &&\n                rpts != null &&\n                Math.round(rpts[0].x - rpts[rpts.length - 1].x) === 0) {\n                const view = this.graph.getView();\n                const scale = view.getScale();\n                const tr = view.getTranslate();\n                let y0 = view.getRoutingCenterY(source) / scale - tr.y;\n                // Use fixed connection point y-coordinate if one exists\n                const sc = this.graph.getConnectionConstraint(edge, source, true);\n                if (sc != null) {\n                    const pt = this.graph.getConnectionPoint(source, sc);\n                    if (pt != null) {\n                        this.convertPoint(pt, false);\n                        y0 = pt.y;\n                    }\n                }\n                let ye = view.getRoutingCenterY(target) / scale - tr.y;\n                // Use fixed connection point y-coordinate if one exists\n                const tc = this.graph.getConnectionConstraint(edge, target, false);\n                if (tc) {\n                    const pt = this.graph.getConnectionPoint(target, tc);\n                    if (pt != null) {\n                        this.convertPoint(pt, false);\n                        ye = pt.y;\n                    }\n                }\n                result = [new Point(point.x, y0), new Point(point.x, ye)];\n            }\n            this.points = result;\n            // LATER: Check if points and result are different\n            edge.view.updateFixedTerminalPoints(edge, source, target);\n            edge.view.updatePoints(edge, this.points, source, target);\n            edge.view.updateFloatingTerminalPoints(edge, source, target);\n        }\n    }\n    /**\n     * Overriden to merge edge segments.\n     */\n    connect(edge, terminal, isSource, isClone, me) {\n        const model = this.graph.getDataModel();\n        let geo = edge.getGeometry();\n        let result = null;\n        // Merges adjacent edge segments\n        if (geo != null && geo.points != null && geo.points.length > 0) {\n            const pts = this.abspoints;\n            let pt0 = pts[0];\n            let pt1 = pts[1];\n            result = [];\n            for (let i = 2; i < pts.length; i += 1) {\n                const pt2 = pts[i];\n                // Merges adjacent segments only if more than 2 to allow for straight edges\n                if (pt0 &&\n                    pt1 &&\n                    pt2 &&\n                    (Math.round(pt0.x - pt1.x) !== 0 || Math.round(pt1.x - pt2.x) !== 0) &&\n                    (Math.round(pt0.y - pt1.y) !== 0 || Math.round(pt1.y - pt2.y) !== 0)) {\n                    result.push(this.convertPoint(pt1.clone(), false));\n                }\n                pt0 = pt1;\n                pt1 = pt2;\n            }\n        }\n        this.graph.batchUpdate(() => {\n            if (result != null) {\n                geo = edge.getGeometry();\n                if (geo != null) {\n                    geo = geo.clone();\n                    geo.points = result;\n                    model.setGeometry(edge, geo);\n                }\n            }\n            edge = super.connect(edge, terminal, isSource, isClone, me);\n        });\n        return edge;\n    }\n    /**\n     * Returns no tooltips.\n     */\n    getTooltipForNode(node) {\n        return null;\n    }\n    /**\n     * Adds custom bends for the center of each segment.\n     */\n    start(x, y, index) {\n        super.start(x, y, index);\n        if (this.bends != null &&\n            this.bends[index] != null &&\n            !this.isSource &&\n            !this.isTarget) {\n            setOpacity(this.bends[index].node, 100);\n        }\n    }\n    /**\n     * Adds custom bends for the center of each segment.\n     */\n    createBends() {\n        const bends = [];\n        // Source\n        let bend = this.createHandleShape(0);\n        this.initBend(bend);\n        bend.setCursor(CURSOR.TERMINAL_HANDLE);\n        bends.push(bend);\n        const pts = this.getCurrentPoints();\n        // Waypoints (segment handles)\n        if (this.graph.isCellBendable(this.state.cell)) {\n            if (this.points == null) {\n                this.points = [];\n            }\n            for (let i = 0; i < pts.length - 1; i += 1) {\n                bend = this.createVirtualBend();\n                bends.push(bend);\n                let horizontal = Math.round(pts[i].x - pts[i + 1].x) === 0;\n                // Special case where dy is 0 as well\n                if (Math.round(pts[i].y - pts[i + 1].y) === 0 && i < pts.length - 2) {\n                    horizontal = Math.round(pts[i].x - pts[i + 2].x) === 0;\n                }\n                bend.setCursor(horizontal ? 'col-resize' : 'row-resize');\n                this.points.push(new Point(0, 0));\n            }\n        }\n        // Target\n        bend = this.createHandleShape(pts.length);\n        this.initBend(bend);\n        bend.setCursor(CURSOR.TERMINAL_HANDLE);\n        bends.push(bend);\n        return bends;\n    }\n    /**\n     * Overridden to invoke <refresh> before the redraw.\n     */\n    redraw() {\n        this.refresh();\n        super.redraw();\n    }\n    /**\n     * Updates the position of the custom bends.\n     */\n    redrawInnerBends(p0, pe) {\n        if (this.graph.isCellBendable(this.state.cell)) {\n            const pts = this.getCurrentPoints();\n            if (pts != null && pts.length > 1) {\n                let straight = false;\n                // Puts handle in the center of straight edges\n                if (pts.length === 4 &&\n                    pts[0] &&\n                    pts[1] &&\n                    pts[2] &&\n                    pts[3] &&\n                    Math.round(pts[1].x - pts[2].x) === 0 &&\n                    Math.round(pts[1].y - pts[2].y) === 0) {\n                    straight = true;\n                    if (Math.round(pts[0].y - pts[pts.length - 1].y) === 0) {\n                        const cx = pts[0].x + (pts[pts.length - 1].x - pts[0].x) / 2;\n                        pts[1] = new Point(cx, pts[1].y);\n                        pts[2] = new Point(cx, pts[2].y);\n                    }\n                    else {\n                        const cy = pts[0].y + (pts[pts.length - 1].y - pts[0].y) / 2;\n                        pts[1] = new Point(pts[1].x, cy);\n                        pts[2] = new Point(pts[2].x, cy);\n                    }\n                }\n                for (let i = 0; i < pts.length - 1; i += 1) {\n                    if (this.bends[i + 1] != null) {\n                        p0 = pts[i];\n                        pe = pts[i + 1];\n                        const pt = new Point(p0.x + (pe.x - p0.x) / 2, p0.y + (pe.y - p0.y) / 2);\n                        const b = this.bends[i + 1].bounds;\n                        this.bends[i + 1].bounds = new Rectangle(Math.floor(pt.x - b.width / 2), Math.floor(pt.y - b.height / 2), b.width, b.height);\n                        this.bends[i + 1].redraw();\n                        if (this.manageLabelHandle) {\n                            this.checkLabelHandle(this.bends[i + 1].bounds);\n                        }\n                    }\n                }\n                if (straight) {\n                    setOpacity(this.bends[1].node, this.virtualBendOpacity);\n                    setOpacity(this.bends[3].node, this.virtualBendOpacity);\n                }\n            }\n        }\n    }\n}\nexport default EdgeSegmentHandler;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}