{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { htmlEntities } from '../../util/StringUtils';\nimport Translations from '../../util/Translations';\nimport { Graph } from '../Graph';\nimport { mixInto } from '../../util/Utils';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst TooltipMixin = {\n  /**\n   * Returns the string or DOM node that represents the tooltip for the given\n   * state, node and coordinate pair. This implementation checks if the given\n   * node is a folding icon or overlay and returns the respective tooltip. If\n   * this does not result in a tooltip, the handler for the cell is retrieved\n   * from {@link selectionCellsHandler} and the optional getTooltipForNode method is\n   * called. If no special tooltip exists here then {@link getTooltipForCell} is used\n   * with the cell in the given state as the argument to return a tooltip for the\n   * given state.\n   *\n   * @param state {@link CellState} whose tooltip should be returned.\n   * @param node DOM node that is currently under the mouse.\n   * @param x X-coordinate of the mouse.\n   * @param y Y-coordinate of the mouse.\n   */\n  getTooltip(state, node, x, y) {\n    let tip = null;\n    // Checks if the mouse is over the folding icon\n    if (state.control && (node === state.control.node || node.parentNode === state.control.node)) {\n      tip = this.getCollapseExpandResource();\n      tip = htmlEntities(Translations.get(tip) || tip, true).replace(/\\\\n/g, '<br>');\n    }\n    if (!tip && state.overlays) {\n      state.overlays.visit((id, shape) => {\n        // LATER: Exit loop if tip is not null\n        if (!tip && (node === shape.node || node.parentNode === shape.node)) {\n          var _shape$overlay$toStri;\n          tip = shape.overlay ? (_shape$overlay$toStri = shape.overlay.toString()) !== null && _shape$overlay$toStri !== void 0 ? _shape$overlay$toStri : null : null;\n        }\n      });\n    }\n    if (!tip) {\n      const selectionCellsHandler = this.getPlugin('SelectionCellsHandler');\n      const handler = selectionCellsHandler === null || selectionCellsHandler === void 0 ? void 0 : selectionCellsHandler.getHandler(state.cell);\n      // @ts-ignore Guarded against undefined error already.\n      if (handler && typeof handler.getTooltipForNode === 'function') {\n        // @ts-ignore Guarded against undefined error already.\n        tip = handler.getTooltipForNode(node);\n      }\n    }\n    if (!tip) {\n      tip = this.getTooltipForCell(state.cell);\n    }\n    return tip;\n  },\n  /**\n   * Returns the string or DOM node to be used as the tooltip for the given\n   * cell. This implementation uses the cells getTooltip function if it\n   * exists, or else it returns {@link convertValueToString} for the cell.\n   *\n   * @example\n   *\n   * ```javascript\n   * graph.getTooltipForCell = function(cell)\n   * {\n   *   return 'Hello, World!';\n   * }\n   * ```\n   *\n   * Replaces all tooltips with the string Hello, World!\n   *\n   * @param cell {@link mxCell} whose tooltip should be returned.\n   */\n  getTooltipForCell(cell) {\n    let tip = null;\n    if (cell && 'getTooltip' in cell) {\n      // @ts-ignore getTooltip() must exists.\n      tip = cell.getTooltip();\n    } else {\n      tip = this.convertValueToString(cell);\n    }\n    return tip;\n  },\n  /*****************************************************************************\n   * Group: Graph behaviour\n   *****************************************************************************/\n  /**\n   * Specifies if tooltips should be enabled.\n   *\n   * This implementation updates {@link TooltipHandler.enabled}.\n   *\n   * @param enabled Boolean indicating if tooltips should be enabled.\n   */\n  setTooltips(enabled) {\n    const tooltipHandler = this.getPlugin('TooltipHandler');\n    tooltipHandler === null || tooltipHandler === void 0 || tooltipHandler.setEnabled(enabled);\n  }\n};\nmixInto(Graph)(TooltipMixin);","map":{"version":3,"names":["htmlEntities","Translations","Graph","mixInto","TooltipMixin","getTooltip","state","node","x","y","tip","control","parentNode","getCollapseExpandResource","get","replace","overlays","visit","id","shape","_shape$overlay$toStri","overlay","toString","selectionCellsHandler","getPlugin","handler","getHandler","cell","getTooltipForNode","getTooltipForCell","convertValueToString","setTooltips","enabled","tooltipHandler","setEnabled"],"sources":["D:/ospanel/domains/проекты open server/old/react/react-intro-main/node_modules/@maxgraph/core/dist/view/mixins/TooltipMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { htmlEntities } from '../../util/StringUtils';\nimport Translations from '../../util/Translations';\nimport { Graph } from '../Graph';\nimport { mixInto } from '../../util/Utils';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst TooltipMixin = {\n    /**\n     * Returns the string or DOM node that represents the tooltip for the given\n     * state, node and coordinate pair. This implementation checks if the given\n     * node is a folding icon or overlay and returns the respective tooltip. If\n     * this does not result in a tooltip, the handler for the cell is retrieved\n     * from {@link selectionCellsHandler} and the optional getTooltipForNode method is\n     * called. If no special tooltip exists here then {@link getTooltipForCell} is used\n     * with the cell in the given state as the argument to return a tooltip for the\n     * given state.\n     *\n     * @param state {@link CellState} whose tooltip should be returned.\n     * @param node DOM node that is currently under the mouse.\n     * @param x X-coordinate of the mouse.\n     * @param y Y-coordinate of the mouse.\n     */\n    getTooltip(state, node, x, y) {\n        let tip = null;\n        // Checks if the mouse is over the folding icon\n        if (state.control &&\n            (node === state.control.node || node.parentNode === state.control.node)) {\n            tip = this.getCollapseExpandResource();\n            tip = htmlEntities(Translations.get(tip) || tip, true).replace(/\\\\n/g, '<br>');\n        }\n        if (!tip && state.overlays) {\n            state.overlays.visit((id, shape) => {\n                // LATER: Exit loop if tip is not null\n                if (!tip && (node === shape.node || node.parentNode === shape.node)) {\n                    tip = shape.overlay ? shape.overlay.toString() ?? null : null;\n                }\n            });\n        }\n        if (!tip) {\n            const selectionCellsHandler = this.getPlugin('SelectionCellsHandler');\n            const handler = selectionCellsHandler?.getHandler(state.cell);\n            // @ts-ignore Guarded against undefined error already.\n            if (handler && typeof handler.getTooltipForNode === 'function') {\n                // @ts-ignore Guarded against undefined error already.\n                tip = handler.getTooltipForNode(node);\n            }\n        }\n        if (!tip) {\n            tip = this.getTooltipForCell(state.cell);\n        }\n        return tip;\n    },\n    /**\n     * Returns the string or DOM node to be used as the tooltip for the given\n     * cell. This implementation uses the cells getTooltip function if it\n     * exists, or else it returns {@link convertValueToString} for the cell.\n     *\n     * @example\n     *\n     * ```javascript\n     * graph.getTooltipForCell = function(cell)\n     * {\n     *   return 'Hello, World!';\n     * }\n     * ```\n     *\n     * Replaces all tooltips with the string Hello, World!\n     *\n     * @param cell {@link mxCell} whose tooltip should be returned.\n     */\n    getTooltipForCell(cell) {\n        let tip = null;\n        if (cell && 'getTooltip' in cell) {\n            // @ts-ignore getTooltip() must exists.\n            tip = cell.getTooltip();\n        }\n        else {\n            tip = this.convertValueToString(cell);\n        }\n        return tip;\n    },\n    /*****************************************************************************\n     * Group: Graph behaviour\n     *****************************************************************************/\n    /**\n     * Specifies if tooltips should be enabled.\n     *\n     * This implementation updates {@link TooltipHandler.enabled}.\n     *\n     * @param enabled Boolean indicating if tooltips should be enabled.\n     */\n    setTooltips(enabled) {\n        const tooltipHandler = this.getPlugin('TooltipHandler');\n        tooltipHandler?.setEnabled(enabled);\n    },\n};\nmixInto(Graph)(TooltipMixin);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}