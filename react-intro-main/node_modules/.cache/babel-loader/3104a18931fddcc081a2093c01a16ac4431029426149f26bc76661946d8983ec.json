{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { getRotatedPoint, toRadians } from '../../util/mathUtils';\nimport Point from '../geometry/Point';\nimport ImageShape from '../geometry/node/ImageShape';\nimport Rectangle from '../geometry/Rectangle';\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport { DIALECT, HANDLE_FILLCOLOR, HANDLE_SIZE, HANDLE_STROKECOLOR } from '../../util/Constants';\nimport InternalEvent from '../event/InternalEvent';\n/**\n * Implements a single custom handle for vertices.\n *\n * @class VertexHandle\n */\nclass VertexHandle {\n  constructor(state, cursor = 'default', image = null, shape = null) {\n    this.dependencies = ['snap', 'cells'];\n    /**\n     * Specifies the cursor to be used for this handle. Default is 'default'.\n     */\n    this.cursor = 'default';\n    /**\n     * Specifies the {@link Image} to be used to render the handle. Default is null.\n     */\n    this.image = null;\n    /**\n     * Default is false.\n     */\n    this.ignoreGrid = false;\n    this.active = true;\n    this.graph = state.view.graph;\n    this.state = state;\n    this.cursor = cursor;\n    this.image = image;\n    this.shape = shape;\n    this.init();\n  }\n  /**\n   * Hook for subclassers to return the current position of the handle.\n   */\n  getPosition(bounds) {\n    return new Point();\n  }\n  /**\n   * Hooks for subclassers to update the style in the <state>.\n   */\n  setPosition(bounds, pt, me) {\n    return;\n  }\n  /**\n   * Hook for subclassers to execute the handle.\n   */\n  execute(me) {\n    return;\n  }\n  /**\n   * Sets the cell style with the given name to the corresponding value in <state>.\n   */\n  copyStyle(key) {\n    this.graph.setCellStyles(key, this.state.style[key], [this.state.cell]);\n  }\n  /**\n   * Processes the given {@link MouseEvent} and invokes <setPosition>.\n   */\n  processEvent(me) {\n    const {\n      scale\n    } = this.graph.view;\n    const tr = this.graph.view.translate;\n    let pt = new Point(me.getGraphX() / scale - tr.x, me.getGraphY() / scale - tr.y);\n    // Center shape on mouse cursor\n    if (this.shape != null && this.shape.bounds != null) {\n      pt.x -= this.shape.bounds.width / scale / 4;\n      pt.y -= this.shape.bounds.height / scale / 4;\n    }\n    // Snaps to grid for the rotated position then applies the rotation for the direction after that\n    const alpha1 = -toRadians(this.getRotation());\n    const alpha2 = -toRadians(this.getTotalRotation()) - alpha1;\n    pt = this.flipPoint(this.rotatePoint(this.snapPoint(this.rotatePoint(pt, alpha1), this.ignoreGrid || !this.graph.isGridEnabledEvent(me.getEvent())), alpha2));\n    this.redraw();\n  }\n  /**\n   * Should be called after <setPosition> in <processEvent>.\n   * This repaints the state using {@link CellRenderer}.\n   */\n  positionChanged() {\n    if (this.state.text != null) {\n      this.state.text.apply(this.state);\n    }\n    if (this.state.shape != null) {\n      this.state.shape.apply(this.state);\n    }\n    this.graph.cellRenderer.redraw(this.state, true);\n  }\n  /**\n   * Returns the rotation defined in the style of the cell.\n   */\n  getRotation() {\n    if (this.state.shape != null) {\n      return this.state.shape.getRotation();\n    }\n    return 0;\n  }\n  /**\n   * Returns the rotation from the style and the rotation from the direction of\n   * the cell.\n   */\n  getTotalRotation() {\n    if (this.state.shape != null) {\n      return this.state.shape.getShapeRotation();\n    }\n    return 0;\n  }\n  /**\n   * Creates and initializes the shapes required for this handle.\n   */\n  init() {\n    const html = this.isHtmlRequired();\n    if (this.image) {\n      this.shape = new ImageShape(new Rectangle(0, 0, this.image.width, this.image.height), this.image.src);\n      this.shape.preserveImageAspect = false;\n    } else if (!this.shape) {\n      this.shape = this.createShape(html);\n    }\n    this.initShape(html);\n  }\n  /**\n   * Creates and returns the shape for this handle.\n   */\n  createShape(html) {\n    const bounds = new Rectangle(0, 0, HANDLE_SIZE, HANDLE_SIZE);\n    return new RectangleShape(bounds, HANDLE_FILLCOLOR, HANDLE_STROKECOLOR);\n  }\n  /**\n   * Initializes <shape> and sets its cursor.\n   */\n  initShape(html) {\n    const shape = this.shape; // `this.shape` cannot be null.\n    if (html && shape.isHtmlAllowed()) {\n      shape.dialect = DIALECT.STRICTHTML;\n      shape.init(this.graph.container);\n    } else {\n      shape.dialect = this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;\n      if (this.cursor) {\n        shape.init(this.graph.getView().getOverlayPane());\n      }\n    }\n    InternalEvent.redirectMouseEvents(shape.node, this.graph, this.state);\n    shape.node.style.cursor = this.cursor;\n  }\n  /**\n   * Renders the shape for this handle.\n   */\n  redraw() {\n    if (this.shape && this.state.shape) {\n      let pt = this.getPosition(this.state.getPaintBounds());\n      if (pt) {\n        const alpha = toRadians(this.getTotalRotation());\n        pt = this.rotatePoint(this.flipPoint(pt), alpha);\n        const {\n          scale\n        } = this.graph.view;\n        const tr = this.graph.view.translate;\n        const shapeBounds = this.shape.bounds;\n        shapeBounds.x = Math.floor((pt.x + tr.x) * scale - shapeBounds.width / 2);\n        shapeBounds.y = Math.floor((pt.y + tr.y) * scale - shapeBounds.height / 2);\n        // Needed to force update of text bounds\n        this.shape.redraw();\n      }\n    }\n  }\n  /**\n   * Returns true if this handle should be rendered in HTML. This returns true if\n   * the text node is in the graph container.\n   */\n  isHtmlRequired() {\n    return !!this.state.text && this.state.text.node.parentNode === this.graph.container;\n  }\n  /**\n   * Rotates the point by the given angle.\n   */\n  rotatePoint(pt, alpha) {\n    const bounds = this.state.getCellBounds();\n    const cx = new Point(bounds.getCenterX(), bounds.getCenterY());\n    const cos = Math.cos(alpha);\n    const sin = Math.sin(alpha);\n    return getRotatedPoint(pt, cos, sin, cx);\n  }\n  /**\n   * Flips the given point vertically and/or horizontally.\n   */\n  flipPoint(pt) {\n    if (this.state.shape) {\n      const bounds = this.state.getCellBounds();\n      if (this.state.shape.flipH) {\n        pt.x = 2 * bounds.x + bounds.width - pt.x;\n      }\n      if (this.state.shape.flipV) {\n        pt.y = 2 * bounds.y + bounds.height - pt.y;\n      }\n    }\n    return pt;\n  }\n  /**\n   * Snaps the given point to the grid if ignore is false. This modifies\n   * the given point in-place and also returns it.\n   */\n  snapPoint(pt, ignore) {\n    if (!ignore) {\n      pt.x = this.graph.snap(pt.x);\n      pt.y = this.graph.snap(pt.y);\n    }\n    return pt;\n  }\n  /**\n   * Shows or hides this handle.\n   */\n  setVisible(visible) {\n    if (this.shape && this.shape.node) {\n      this.shape.node.style.display = visible ? '' : 'none';\n    }\n  }\n  /**\n   * Resets the state of this handle by setting its visibility to true.\n   */\n  reset() {\n    this.setVisible(true);\n    this.state.style = this.graph.getCellStyle(this.state.cell);\n    this.positionChanged();\n  }\n  /**\n   * Destroys this handle.\n   */\n  destroy() {\n    if (this.shape) {\n      this.shape.destroy();\n      this.shape = null;\n    }\n  }\n}\nexport default VertexHandle;","map":{"version":3,"names":["getRotatedPoint","toRadians","Point","ImageShape","Rectangle","RectangleShape","DIALECT","HANDLE_FILLCOLOR","HANDLE_SIZE","HANDLE_STROKECOLOR","InternalEvent","VertexHandle","constructor","state","cursor","image","shape","dependencies","ignoreGrid","active","graph","view","init","getPosition","bounds","setPosition","pt","me","execute","copyStyle","key","setCellStyles","style","cell","processEvent","scale","tr","translate","getGraphX","x","getGraphY","y","width","height","alpha1","getRotation","alpha2","getTotalRotation","flipPoint","rotatePoint","snapPoint","isGridEnabledEvent","getEvent","redraw","positionChanged","text","apply","cellRenderer","getShapeRotation","html","isHtmlRequired","src","preserveImageAspect","createShape","initShape","isHtmlAllowed","dialect","STRICTHTML","container","SVG","MIXEDHTML","getView","getOverlayPane","redirectMouseEvents","node","getPaintBounds","alpha","shapeBounds","Math","floor","parentNode","getCellBounds","cx","getCenterX","getCenterY","cos","sin","flipH","flipV","ignore","snap","setVisible","visible","display","reset","getCellStyle","destroy"],"sources":["D:/ospanel/domains/react/react-intro/node_modules/@maxgraph/core/dist/view/cell/VertexHandle.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { getRotatedPoint, toRadians } from '../../util/mathUtils';\nimport Point from '../geometry/Point';\nimport ImageShape from '../geometry/node/ImageShape';\nimport Rectangle from '../geometry/Rectangle';\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport { DIALECT, HANDLE_FILLCOLOR, HANDLE_SIZE, HANDLE_STROKECOLOR, } from '../../util/Constants';\nimport InternalEvent from '../event/InternalEvent';\n/**\n * Implements a single custom handle for vertices.\n *\n * @class VertexHandle\n */\nclass VertexHandle {\n    constructor(state, cursor = 'default', image = null, shape = null) {\n        this.dependencies = ['snap', 'cells'];\n        /**\n         * Specifies the cursor to be used for this handle. Default is 'default'.\n         */\n        this.cursor = 'default';\n        /**\n         * Specifies the {@link Image} to be used to render the handle. Default is null.\n         */\n        this.image = null;\n        /**\n         * Default is false.\n         */\n        this.ignoreGrid = false;\n        this.active = true;\n        this.graph = state.view.graph;\n        this.state = state;\n        this.cursor = cursor;\n        this.image = image;\n        this.shape = shape;\n        this.init();\n    }\n    /**\n     * Hook for subclassers to return the current position of the handle.\n     */\n    getPosition(bounds) {\n        return new Point();\n    }\n    /**\n     * Hooks for subclassers to update the style in the <state>.\n     */\n    setPosition(bounds, pt, me) {\n        return;\n    }\n    /**\n     * Hook for subclassers to execute the handle.\n     */\n    execute(me) {\n        return;\n    }\n    /**\n     * Sets the cell style with the given name to the corresponding value in <state>.\n     */\n    copyStyle(key) {\n        this.graph.setCellStyles(key, this.state.style[key], [this.state.cell]);\n    }\n    /**\n     * Processes the given {@link MouseEvent} and invokes <setPosition>.\n     */\n    processEvent(me) {\n        const { scale } = this.graph.view;\n        const tr = this.graph.view.translate;\n        let pt = new Point(me.getGraphX() / scale - tr.x, me.getGraphY() / scale - tr.y);\n        // Center shape on mouse cursor\n        if (this.shape != null && this.shape.bounds != null) {\n            pt.x -= this.shape.bounds.width / scale / 4;\n            pt.y -= this.shape.bounds.height / scale / 4;\n        }\n        // Snaps to grid for the rotated position then applies the rotation for the direction after that\n        const alpha1 = -toRadians(this.getRotation());\n        const alpha2 = -toRadians(this.getTotalRotation()) - alpha1;\n        pt = this.flipPoint(this.rotatePoint(this.snapPoint(this.rotatePoint(pt, alpha1), this.ignoreGrid || !this.graph.isGridEnabledEvent(me.getEvent())), alpha2));\n        this.redraw();\n    }\n    /**\n     * Should be called after <setPosition> in <processEvent>.\n     * This repaints the state using {@link CellRenderer}.\n     */\n    positionChanged() {\n        if (this.state.text != null) {\n            this.state.text.apply(this.state);\n        }\n        if (this.state.shape != null) {\n            this.state.shape.apply(this.state);\n        }\n        this.graph.cellRenderer.redraw(this.state, true);\n    }\n    /**\n     * Returns the rotation defined in the style of the cell.\n     */\n    getRotation() {\n        if (this.state.shape != null) {\n            return this.state.shape.getRotation();\n        }\n        return 0;\n    }\n    /**\n     * Returns the rotation from the style and the rotation from the direction of\n     * the cell.\n     */\n    getTotalRotation() {\n        if (this.state.shape != null) {\n            return this.state.shape.getShapeRotation();\n        }\n        return 0;\n    }\n    /**\n     * Creates and initializes the shapes required for this handle.\n     */\n    init() {\n        const html = this.isHtmlRequired();\n        if (this.image) {\n            this.shape = new ImageShape(new Rectangle(0, 0, this.image.width, this.image.height), this.image.src);\n            this.shape.preserveImageAspect = false;\n        }\n        else if (!this.shape) {\n            this.shape = this.createShape(html);\n        }\n        this.initShape(html);\n    }\n    /**\n     * Creates and returns the shape for this handle.\n     */\n    createShape(html) {\n        const bounds = new Rectangle(0, 0, HANDLE_SIZE, HANDLE_SIZE);\n        return new RectangleShape(bounds, HANDLE_FILLCOLOR, HANDLE_STROKECOLOR);\n    }\n    /**\n     * Initializes <shape> and sets its cursor.\n     */\n    initShape(html) {\n        const shape = this.shape; // `this.shape` cannot be null.\n        if (html && shape.isHtmlAllowed()) {\n            shape.dialect = DIALECT.STRICTHTML;\n            shape.init(this.graph.container);\n        }\n        else {\n            shape.dialect =\n                this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;\n            if (this.cursor) {\n                shape.init(this.graph.getView().getOverlayPane());\n            }\n        }\n        InternalEvent.redirectMouseEvents(shape.node, this.graph, this.state);\n        shape.node.style.cursor = this.cursor;\n    }\n    /**\n     * Renders the shape for this handle.\n     */\n    redraw() {\n        if (this.shape && this.state.shape) {\n            let pt = this.getPosition(this.state.getPaintBounds());\n            if (pt) {\n                const alpha = toRadians(this.getTotalRotation());\n                pt = this.rotatePoint(this.flipPoint(pt), alpha);\n                const { scale } = this.graph.view;\n                const tr = this.graph.view.translate;\n                const shapeBounds = this.shape.bounds;\n                shapeBounds.x = Math.floor((pt.x + tr.x) * scale - shapeBounds.width / 2);\n                shapeBounds.y = Math.floor((pt.y + tr.y) * scale - shapeBounds.height / 2);\n                // Needed to force update of text bounds\n                this.shape.redraw();\n            }\n        }\n    }\n    /**\n     * Returns true if this handle should be rendered in HTML. This returns true if\n     * the text node is in the graph container.\n     */\n    isHtmlRequired() {\n        return !!this.state.text && this.state.text.node.parentNode === this.graph.container;\n    }\n    /**\n     * Rotates the point by the given angle.\n     */\n    rotatePoint(pt, alpha) {\n        const bounds = this.state.getCellBounds();\n        const cx = new Point(bounds.getCenterX(), bounds.getCenterY());\n        const cos = Math.cos(alpha);\n        const sin = Math.sin(alpha);\n        return getRotatedPoint(pt, cos, sin, cx);\n    }\n    /**\n     * Flips the given point vertically and/or horizontally.\n     */\n    flipPoint(pt) {\n        if (this.state.shape) {\n            const bounds = this.state.getCellBounds();\n            if (this.state.shape.flipH) {\n                pt.x = 2 * bounds.x + bounds.width - pt.x;\n            }\n            if (this.state.shape.flipV) {\n                pt.y = 2 * bounds.y + bounds.height - pt.y;\n            }\n        }\n        return pt;\n    }\n    /**\n     * Snaps the given point to the grid if ignore is false. This modifies\n     * the given point in-place and also returns it.\n     */\n    snapPoint(pt, ignore) {\n        if (!ignore) {\n            pt.x = this.graph.snap(pt.x);\n            pt.y = this.graph.snap(pt.y);\n        }\n        return pt;\n    }\n    /**\n     * Shows or hides this handle.\n     */\n    setVisible(visible) {\n        if (this.shape && this.shape.node) {\n            this.shape.node.style.display = visible ? '' : 'none';\n        }\n    }\n    /**\n     * Resets the state of this handle by setting its visibility to true.\n     */\n    reset() {\n        this.setVisible(true);\n        this.state.style = this.graph.getCellStyle(this.state.cell);\n        this.positionChanged();\n    }\n    /**\n     * Destroys this handle.\n     */\n    destroy() {\n        if (this.shape) {\n            this.shape.destroy();\n            this.shape = null;\n        }\n    }\n}\nexport default VertexHandle;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}