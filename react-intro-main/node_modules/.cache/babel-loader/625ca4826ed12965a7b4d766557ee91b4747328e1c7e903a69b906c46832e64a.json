{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Image from '../image/ImageBox';\nimport Client from '../../Client';\nimport { DEFAULT_VALID_COLOR, DIALECT, HIGHLIGHT_OPACITY, HIGHLIGHT_SIZE, HIGHLIGHT_STROKEWIDTH } from '../../util/Constants';\nimport InternalEvent from '../event/InternalEvent';\nimport { intersects } from '../../util/mathUtils';\nimport Rectangle from '../geometry/Rectangle';\nimport ImageShape from '../geometry/node/ImageShape';\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport { isShiftDown } from '../../util/EventUtils';\n/**\n * Handles constraints on connection targets. This class is in charge of\n * showing fixed points when the mouse is over a vertex and handles constraints\n * to establish new connections.\n *\n * @class ConstraintHandler\n */\nclass ConstraintHandler {\n  constructor(graph) {\n    /**\n     * {@link Image} to be used as the image for fixed connection points.\n     */\n    this.pointImage = new Image(`${Client.imageBasePath}/point.gif`, 5, 5);\n    this.currentFocus = null;\n    this.currentFocusArea = null;\n    this.focusIcons = [];\n    this.constraints = null;\n    this.currentConstraint = null;\n    this.focusHighlight = null;\n    this.focusPoints = [];\n    this.currentPoint = null;\n    /**\n     * Specifies if events are handled. Default is true.\n     */\n    this.enabled = true;\n    /**\n     * Specifies the color for the highlight. Default is {@link DEFAULT_VALID_COLOR}.\n     */\n    this.highlightColor = DEFAULT_VALID_COLOR;\n    this.mouseleaveHandler = null;\n    this.graph = graph;\n    // Adds a graph model listener to update the current focus on changes\n    this.resetHandler = () => {\n      if (this.currentFocus && !this.graph.view.getState(this.currentFocus.cell)) {\n        this.reset();\n      } else {\n        this.redraw();\n      }\n    };\n    this.graph.model.addListener(InternalEvent.CHANGE, this.resetHandler);\n    this.graph.view.addListener(InternalEvent.SCALE_AND_TRANSLATE, this.resetHandler);\n    this.graph.view.addListener(InternalEvent.TRANSLATE, this.resetHandler);\n    this.graph.view.addListener(InternalEvent.SCALE, this.resetHandler);\n    this.graph.addListener(InternalEvent.ROOT, this.resetHandler);\n  }\n  /**\n   * Returns true if events are handled. This implementation\n   * returns {@link enabled}.\n   */\n  isEnabled() {\n    return this.enabled;\n  }\n  /**\n   * Enables or disables event handling. This implementation\n   * updates {@link enabled}.\n   *\n   * @param {boolean} enabled - Boolean that specifies the new enabled state.\n   */\n  setEnabled(enabled) {\n    this.enabled = enabled;\n  }\n  /**\n   * Resets the state of this handler.\n   */\n  reset() {\n    for (let i = 0; i < this.focusIcons.length; i += 1) {\n      this.focusIcons[i].destroy();\n    }\n    this.focusIcons = [];\n    if (this.focusHighlight) {\n      this.focusHighlight.destroy();\n      this.focusHighlight = null;\n    }\n    this.currentConstraint = null;\n    this.currentFocusArea = null;\n    this.currentPoint = null;\n    this.currentFocus = null;\n    this.focusPoints = [];\n  }\n  /**\n   * Returns the tolerance to be used for intersecting connection points. This\n   * implementation returns {@link mxGraph.tolerance}.\n   *\n   * @param me {@link mxMouseEvent} whose tolerance should be returned.\n   */\n  getTolerance(me) {\n    return this.graph.getEventTolerance();\n  }\n  /**\n   * Returns the tolerance to be used for intersecting connection points.\n   */\n  getImageForConstraint(state, constraint, point) {\n    return this.pointImage;\n  }\n  /**\n   * Returns true if the given {@link mxMouseEvent} should be ignored in {@link update}. This\n   * implementation always returns false.\n   */\n  isEventIgnored(me, source = false) {\n    return false;\n  }\n  /**\n   * Returns true if the given state should be ignored. This always returns false.\n   */\n  isStateIgnored(state, source = false) {\n    return false;\n  }\n  /**\n   * Destroys the {@link focusIcons} if they exist.\n   */\n  destroyIcons() {\n    for (let i = 0; i < this.focusIcons.length; i += 1) {\n      this.focusIcons[i].destroy();\n    }\n    this.focusIcons = [];\n    this.focusPoints = [];\n  }\n  /**\n   * Destroys the {@link focusHighlight} if one exists.\n   */\n  destroyFocusHighlight() {\n    if (this.focusHighlight) {\n      this.focusHighlight.destroy();\n      this.focusHighlight = null;\n    }\n  }\n  /**\n   * Returns true if the current focused state should not be changed for the given event.\n   * This returns true if shift and alt are pressed.\n   */\n  isKeepFocusEvent(me) {\n    return isShiftDown(me.getEvent());\n  }\n  /**\n   * Returns the cell for the given event.\n   */\n  getCellForEvent(me, point) {\n    let cell = me.getCell();\n    // Gets cell under actual point if different from event location\n    if (!cell && point && (me.getGraphX() !== point.x || me.getGraphY() !== point.y)) {\n      cell = this.graph.getCellAt(point.x, point.y);\n    }\n    // Uses connectable parent vertex if one exists\n    if (cell && !cell.isConnectable()) {\n      const parent = cell.getParent();\n      if (parent && parent.isVertex() && parent.isConnectable()) {\n        cell = parent;\n      }\n    }\n    if (cell) {\n      return this.graph.isCellLocked(cell) ? null : cell;\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Updates the state of this handler based on the given {@link mxMouseEvent}.\n   * Source is a boolean indicating if the cell is a source or target.\n   */\n  update(me, source, existingEdge, point) {\n    if (this.isEnabled() && !this.isEventIgnored(me)) {\n      // Lazy installation of mouseleave handler\n      if (!this.mouseleaveHandler && this.graph.container) {\n        this.mouseleaveHandler = () => {\n          this.reset();\n        };\n        InternalEvent.addListener(this.graph.container, 'mouseleave', this.resetHandler);\n      }\n      const tol = this.getTolerance(me);\n      const x = point ? point.x : me.getGraphX();\n      const y = point ? point.y : me.getGraphY();\n      const grid = new Rectangle(x - tol, y - tol, 2 * tol, 2 * tol);\n      const mouse = new Rectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol);\n      const state = this.graph.view.getState(this.getCellForEvent(me, point));\n      // Keeps focus icons visible while over vertex bounds and no other cell under mouse or shift is pressed\n      if (!this.isKeepFocusEvent(me) && (!this.currentFocusArea || !this.currentFocus || state || !this.currentFocus.cell.isVertex() || !intersects(this.currentFocusArea, mouse)) && state !== this.currentFocus) {\n        this.currentFocusArea = null;\n        this.currentFocus = null;\n        this.setFocus(me, state, source);\n      }\n      this.currentConstraint = null;\n      this.currentPoint = null;\n      let minDistSq = null;\n      let tmp;\n      if (this.focusIcons.length > 0 && this.constraints && (!state || this.currentFocus === state)) {\n        const cx = mouse.getCenterX();\n        const cy = mouse.getCenterY();\n        for (let i = 0; i < this.focusIcons.length; i += 1) {\n          const dx = cx - this.focusIcons[i].bounds.getCenterX();\n          const dy = cy - this.focusIcons[i].bounds.getCenterY();\n          tmp = dx * dx + dy * dy;\n          if ((this.intersects(this.focusIcons[i], mouse, source, existingEdge) || point && this.intersects(this.focusIcons[i], grid, source, existingEdge)) && (minDistSq === null || tmp < minDistSq)) {\n            this.currentConstraint = this.constraints[i];\n            this.currentPoint = this.focusPoints[i];\n            minDistSq = tmp;\n            tmp = this.focusIcons[i].bounds.clone();\n            tmp.grow(HIGHLIGHT_SIZE + 1);\n            tmp.width -= 1;\n            tmp.height -= 1;\n            if (!this.focusHighlight) {\n              const hl = this.createHighlightShape();\n              hl.dialect = DIALECT.SVG;\n              hl.pointerEvents = false;\n              hl.init(this.graph.getView().getOverlayPane());\n              this.focusHighlight = hl;\n              const getState = () => {\n                return this.currentFocus ? this.currentFocus : state;\n              };\n              InternalEvent.redirectMouseEvents(hl.node, this.graph, getState);\n            }\n            this.focusHighlight.bounds = tmp;\n            this.focusHighlight.redraw();\n          }\n        }\n      }\n      if (!this.currentConstraint) {\n        this.destroyFocusHighlight();\n      }\n    } else {\n      this.currentConstraint = null;\n      this.currentFocus = null;\n      this.currentPoint = null;\n    }\n  }\n  /**\n   * Transfers the focus to the given state as a source or target terminal. If\n   * the handler is not enabled then the outline is painted, but the constraints\n   * are ignored.\n   */\n  redraw() {\n    if (this.currentFocus && this.constraints && this.focusIcons.length > 0) {\n      const state = this.graph.view.getState(this.currentFocus.cell);\n      this.currentFocus = state;\n      this.currentFocusArea = new Rectangle(state.x, state.y, state.width, state.height);\n      for (let i = 0; i < this.constraints.length; i += 1) {\n        const cp = this.graph.getConnectionPoint(state, this.constraints[i]);\n        const img = this.getImageForConstraint(state, this.constraints[i], cp);\n        const bounds = new Rectangle(Math.round(cp.x - img.width / 2), Math.round(cp.y - img.height / 2), img.width, img.height);\n        this.focusIcons[i].bounds = bounds;\n        this.focusIcons[i].redraw();\n        this.currentFocusArea.add(this.focusIcons[i].bounds);\n        this.focusPoints[i] = cp;\n      }\n    }\n  }\n  /**\n   * Transfers the focus to the given state as a source or target terminal. If\n   * the handler is not enabled then the outline is painted, but the constraints\n   * are ignored.\n   */\n  setFocus(me, state, source) {\n    this.constraints = state && !this.isStateIgnored(state, source) && state.cell.isConnectable() ? this.isEnabled() ? this.graph.getAllConnectionConstraints(state, source) ?? [] : [] : null;\n    // Only uses cells which have constraints\n    if (this.constraints && state) {\n      this.currentFocus = state;\n      this.currentFocusArea = new Rectangle(state.x, state.y, state.width, state.height);\n      for (let i = 0; i < this.focusIcons.length; i += 1) {\n        this.focusIcons[i].destroy();\n      }\n      this.focusIcons = [];\n      this.focusPoints = [];\n      for (let i = 0; i < this.constraints.length; i += 1) {\n        const cp = this.graph.getConnectionPoint(state, this.constraints[i]);\n        const img = this.getImageForConstraint(state, this.constraints[i], cp);\n        const {\n          src\n        } = img;\n        const bounds = new Rectangle(Math.round(cp.x - img.width / 2), Math.round(cp.y - img.height / 2), img.width, img.height);\n        const icon = new ImageShape(bounds, src);\n        icon.dialect = this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;\n        icon.preserveImageAspect = false;\n        icon.init(this.graph.getView().getDecoratorPane());\n        // Move the icon behind all other overlays\n        if (icon.node.previousSibling) {\n          icon.node.parentNode?.insertBefore(icon.node, icon.node.parentNode.firstChild);\n        }\n        const getState = () => {\n          return this.currentFocus ? this.currentFocus : state;\n        };\n        icon.redraw();\n        InternalEvent.redirectMouseEvents(icon.node, this.graph, getState);\n        this.currentFocusArea.add(icon.bounds);\n        this.focusIcons.push(icon);\n        this.focusPoints.push(cp);\n      }\n      this.currentFocusArea.grow(this.getTolerance(me));\n    } else {\n      this.destroyIcons();\n      this.destroyFocusHighlight();\n    }\n  }\n  /**\n   * Create the shape used to paint the highlight.\n   *\n   * Returns true if the given icon intersects the given point.\n   */\n  createHighlightShape() {\n    const hl = new RectangleShape(new Rectangle(), this.highlightColor, this.highlightColor, HIGHLIGHT_STROKEWIDTH);\n    hl.opacity = HIGHLIGHT_OPACITY;\n    return hl;\n  }\n  /**\n   * Returns true if the given icon intersects the given rectangle.\n   */\n  intersects(icon, mouse, source, existingEdge) {\n    return intersects(icon.bounds, mouse);\n  }\n  /**\n   * Destroy this handler.\n   */\n  onDestroy() {\n    this.reset();\n    this.graph.model.removeListener(this.resetHandler);\n    this.graph.view.removeListener(this.resetHandler);\n    this.graph.removeListener(this.resetHandler);\n    if (this.mouseleaveHandler && this.graph.container) {\n      InternalEvent.removeListener(this.graph.container, 'mouseleave', this.mouseleaveHandler);\n      this.mouseleaveHandler = null;\n    }\n  }\n}\nexport default ConstraintHandler;","map":{"version":3,"names":["Image","Client","DEFAULT_VALID_COLOR","DIALECT","HIGHLIGHT_OPACITY","HIGHLIGHT_SIZE","HIGHLIGHT_STROKEWIDTH","InternalEvent","intersects","Rectangle","ImageShape","RectangleShape","isShiftDown","ConstraintHandler","constructor","graph","pointImage","imageBasePath","currentFocus","currentFocusArea","focusIcons","constraints","currentConstraint","focusHighlight","focusPoints","currentPoint","enabled","highlightColor","mouseleaveHandler","resetHandler","view","getState","cell","reset","redraw","model","addListener","CHANGE","SCALE_AND_TRANSLATE","TRANSLATE","SCALE","ROOT","isEnabled","setEnabled","i","length","destroy","getTolerance","me","getEventTolerance","getImageForConstraint","state","constraint","point","isEventIgnored","source","isStateIgnored","destroyIcons","destroyFocusHighlight","isKeepFocusEvent","getEvent","getCellForEvent","getCell","getGraphX","x","getGraphY","y","getCellAt","isConnectable","parent","getParent","isVertex","isCellLocked","update","existingEdge","container","tol","grid","mouse","setFocus","minDistSq","tmp","cx","getCenterX","cy","getCenterY","dx","bounds","dy","clone","grow","width","height","hl","createHighlightShape","dialect","SVG","pointerEvents","init","getView","getOverlayPane","redirectMouseEvents","node","cp","getConnectionPoint","img","Math","round","add","getAllConnectionConstraints","src","icon","MIXEDHTML","preserveImageAspect","getDecoratorPane","previousSibling","parentNode","insertBefore","firstChild","push","opacity","onDestroy","removeListener"],"sources":["D:/OSPanel/domains/react/react-intro-main/node_modules/@maxgraph/core/dist/view/handler/ConstraintHandler.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Image from '../image/ImageBox';\nimport Client from '../../Client';\nimport { DEFAULT_VALID_COLOR, DIALECT, HIGHLIGHT_OPACITY, HIGHLIGHT_SIZE, HIGHLIGHT_STROKEWIDTH, } from '../../util/Constants';\nimport InternalEvent from '../event/InternalEvent';\nimport { intersects } from '../../util/mathUtils';\nimport Rectangle from '../geometry/Rectangle';\nimport ImageShape from '../geometry/node/ImageShape';\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport { isShiftDown } from '../../util/EventUtils';\n/**\n * Handles constraints on connection targets. This class is in charge of\n * showing fixed points when the mouse is over a vertex and handles constraints\n * to establish new connections.\n *\n * @class ConstraintHandler\n */\nclass ConstraintHandler {\n    constructor(graph) {\n        /**\n         * {@link Image} to be used as the image for fixed connection points.\n         */\n        this.pointImage = new Image(`${Client.imageBasePath}/point.gif`, 5, 5);\n        this.currentFocus = null;\n        this.currentFocusArea = null;\n        this.focusIcons = [];\n        this.constraints = null;\n        this.currentConstraint = null;\n        this.focusHighlight = null;\n        this.focusPoints = [];\n        this.currentPoint = null;\n        /**\n         * Specifies if events are handled. Default is true.\n         */\n        this.enabled = true;\n        /**\n         * Specifies the color for the highlight. Default is {@link DEFAULT_VALID_COLOR}.\n         */\n        this.highlightColor = DEFAULT_VALID_COLOR;\n        this.mouseleaveHandler = null;\n        this.graph = graph;\n        // Adds a graph model listener to update the current focus on changes\n        this.resetHandler = () => {\n            if (this.currentFocus && !this.graph.view.getState(this.currentFocus.cell)) {\n                this.reset();\n            }\n            else {\n                this.redraw();\n            }\n        };\n        this.graph.model.addListener(InternalEvent.CHANGE, this.resetHandler);\n        this.graph.view.addListener(InternalEvent.SCALE_AND_TRANSLATE, this.resetHandler);\n        this.graph.view.addListener(InternalEvent.TRANSLATE, this.resetHandler);\n        this.graph.view.addListener(InternalEvent.SCALE, this.resetHandler);\n        this.graph.addListener(InternalEvent.ROOT, this.resetHandler);\n    }\n    /**\n     * Returns true if events are handled. This implementation\n     * returns {@link enabled}.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Enables or disables event handling. This implementation\n     * updates {@link enabled}.\n     *\n     * @param {boolean} enabled - Boolean that specifies the new enabled state.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n    }\n    /**\n     * Resets the state of this handler.\n     */\n    reset() {\n        for (let i = 0; i < this.focusIcons.length; i += 1) {\n            this.focusIcons[i].destroy();\n        }\n        this.focusIcons = [];\n        if (this.focusHighlight) {\n            this.focusHighlight.destroy();\n            this.focusHighlight = null;\n        }\n        this.currentConstraint = null;\n        this.currentFocusArea = null;\n        this.currentPoint = null;\n        this.currentFocus = null;\n        this.focusPoints = [];\n    }\n    /**\n     * Returns the tolerance to be used for intersecting connection points. This\n     * implementation returns {@link mxGraph.tolerance}.\n     *\n     * @param me {@link mxMouseEvent} whose tolerance should be returned.\n     */\n    getTolerance(me) {\n        return this.graph.getEventTolerance();\n    }\n    /**\n     * Returns the tolerance to be used for intersecting connection points.\n     */\n    getImageForConstraint(state, constraint, point) {\n        return this.pointImage;\n    }\n    /**\n     * Returns true if the given {@link mxMouseEvent} should be ignored in {@link update}. This\n     * implementation always returns false.\n     */\n    isEventIgnored(me, source = false) {\n        return false;\n    }\n    /**\n     * Returns true if the given state should be ignored. This always returns false.\n     */\n    isStateIgnored(state, source = false) {\n        return false;\n    }\n    /**\n     * Destroys the {@link focusIcons} if they exist.\n     */\n    destroyIcons() {\n        for (let i = 0; i < this.focusIcons.length; i += 1) {\n            this.focusIcons[i].destroy();\n        }\n        this.focusIcons = [];\n        this.focusPoints = [];\n    }\n    /**\n     * Destroys the {@link focusHighlight} if one exists.\n     */\n    destroyFocusHighlight() {\n        if (this.focusHighlight) {\n            this.focusHighlight.destroy();\n            this.focusHighlight = null;\n        }\n    }\n    /**\n     * Returns true if the current focused state should not be changed for the given event.\n     * This returns true if shift and alt are pressed.\n     */\n    isKeepFocusEvent(me) {\n        return isShiftDown(me.getEvent());\n    }\n    /**\n     * Returns the cell for the given event.\n     */\n    getCellForEvent(me, point) {\n        let cell = me.getCell();\n        // Gets cell under actual point if different from event location\n        if (!cell && point && (me.getGraphX() !== point.x || me.getGraphY() !== point.y)) {\n            cell = this.graph.getCellAt(point.x, point.y);\n        }\n        // Uses connectable parent vertex if one exists\n        if (cell && !cell.isConnectable()) {\n            const parent = cell.getParent();\n            if (parent && parent.isVertex() && parent.isConnectable()) {\n                cell = parent;\n            }\n        }\n        if (cell) {\n            return this.graph.isCellLocked(cell) ? null : cell;\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Updates the state of this handler based on the given {@link mxMouseEvent}.\n     * Source is a boolean indicating if the cell is a source or target.\n     */\n    update(me, source, existingEdge, point) {\n        if (this.isEnabled() && !this.isEventIgnored(me)) {\n            // Lazy installation of mouseleave handler\n            if (!this.mouseleaveHandler && this.graph.container) {\n                this.mouseleaveHandler = () => {\n                    this.reset();\n                };\n                InternalEvent.addListener(this.graph.container, 'mouseleave', this.resetHandler);\n            }\n            const tol = this.getTolerance(me);\n            const x = point ? point.x : me.getGraphX();\n            const y = point ? point.y : me.getGraphY();\n            const grid = new Rectangle(x - tol, y - tol, 2 * tol, 2 * tol);\n            const mouse = new Rectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol);\n            const state = this.graph.view.getState(this.getCellForEvent(me, point));\n            // Keeps focus icons visible while over vertex bounds and no other cell under mouse or shift is pressed\n            if (!this.isKeepFocusEvent(me) &&\n                (!this.currentFocusArea ||\n                    !this.currentFocus ||\n                    state ||\n                    !this.currentFocus.cell.isVertex() ||\n                    !intersects(this.currentFocusArea, mouse)) &&\n                state !== this.currentFocus) {\n                this.currentFocusArea = null;\n                this.currentFocus = null;\n                this.setFocus(me, state, source);\n            }\n            this.currentConstraint = null;\n            this.currentPoint = null;\n            let minDistSq = null;\n            let tmp;\n            if (this.focusIcons.length > 0 &&\n                this.constraints &&\n                (!state || this.currentFocus === state)) {\n                const cx = mouse.getCenterX();\n                const cy = mouse.getCenterY();\n                for (let i = 0; i < this.focusIcons.length; i += 1) {\n                    const dx = cx - this.focusIcons[i].bounds.getCenterX();\n                    const dy = cy - this.focusIcons[i].bounds.getCenterY();\n                    tmp = dx * dx + dy * dy;\n                    if ((this.intersects(this.focusIcons[i], mouse, source, existingEdge) ||\n                        (point &&\n                            this.intersects(this.focusIcons[i], grid, source, existingEdge))) &&\n                        (minDistSq === null || tmp < minDistSq)) {\n                        this.currentConstraint = this.constraints[i];\n                        this.currentPoint = this.focusPoints[i];\n                        minDistSq = tmp;\n                        tmp = this.focusIcons[i].bounds.clone();\n                        tmp.grow(HIGHLIGHT_SIZE + 1);\n                        tmp.width -= 1;\n                        tmp.height -= 1;\n                        if (!this.focusHighlight) {\n                            const hl = this.createHighlightShape();\n                            hl.dialect = DIALECT.SVG;\n                            hl.pointerEvents = false;\n                            hl.init(this.graph.getView().getOverlayPane());\n                            this.focusHighlight = hl;\n                            const getState = () => {\n                                return this.currentFocus ? this.currentFocus : state;\n                            };\n                            InternalEvent.redirectMouseEvents(hl.node, this.graph, getState);\n                        }\n                        this.focusHighlight.bounds = tmp;\n                        this.focusHighlight.redraw();\n                    }\n                }\n            }\n            if (!this.currentConstraint) {\n                this.destroyFocusHighlight();\n            }\n        }\n        else {\n            this.currentConstraint = null;\n            this.currentFocus = null;\n            this.currentPoint = null;\n        }\n    }\n    /**\n     * Transfers the focus to the given state as a source or target terminal. If\n     * the handler is not enabled then the outline is painted, but the constraints\n     * are ignored.\n     */\n    redraw() {\n        if (this.currentFocus && this.constraints && this.focusIcons.length > 0) {\n            const state = this.graph.view.getState(this.currentFocus.cell);\n            this.currentFocus = state;\n            this.currentFocusArea = new Rectangle(state.x, state.y, state.width, state.height);\n            for (let i = 0; i < this.constraints.length; i += 1) {\n                const cp = this.graph.getConnectionPoint(state, this.constraints[i]);\n                const img = this.getImageForConstraint(state, this.constraints[i], cp);\n                const bounds = new Rectangle(Math.round(cp.x - img.width / 2), Math.round(cp.y - img.height / 2), img.width, img.height);\n                this.focusIcons[i].bounds = bounds;\n                this.focusIcons[i].redraw();\n                this.currentFocusArea.add(this.focusIcons[i].bounds);\n                this.focusPoints[i] = cp;\n            }\n        }\n    }\n    /**\n     * Transfers the focus to the given state as a source or target terminal. If\n     * the handler is not enabled then the outline is painted, but the constraints\n     * are ignored.\n     */\n    setFocus(me, state, source) {\n        this.constraints =\n            state && !this.isStateIgnored(state, source) && state.cell.isConnectable()\n                ? this.isEnabled()\n                    ? this.graph.getAllConnectionConstraints(state, source) ?? []\n                    : []\n                : null;\n        // Only uses cells which have constraints\n        if (this.constraints && state) {\n            this.currentFocus = state;\n            this.currentFocusArea = new Rectangle(state.x, state.y, state.width, state.height);\n            for (let i = 0; i < this.focusIcons.length; i += 1) {\n                this.focusIcons[i].destroy();\n            }\n            this.focusIcons = [];\n            this.focusPoints = [];\n            for (let i = 0; i < this.constraints.length; i += 1) {\n                const cp = this.graph.getConnectionPoint(state, this.constraints[i]);\n                const img = this.getImageForConstraint(state, this.constraints[i], cp);\n                const { src } = img;\n                const bounds = new Rectangle(Math.round(cp.x - img.width / 2), Math.round(cp.y - img.height / 2), img.width, img.height);\n                const icon = new ImageShape(bounds, src);\n                icon.dialect =\n                    this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;\n                icon.preserveImageAspect = false;\n                icon.init(this.graph.getView().getDecoratorPane());\n                // Move the icon behind all other overlays\n                if (icon.node.previousSibling) {\n                    icon.node.parentNode?.insertBefore(icon.node, icon.node.parentNode.firstChild);\n                }\n                const getState = () => {\n                    return this.currentFocus ? this.currentFocus : state;\n                };\n                icon.redraw();\n                InternalEvent.redirectMouseEvents(icon.node, this.graph, getState);\n                this.currentFocusArea.add(icon.bounds);\n                this.focusIcons.push(icon);\n                this.focusPoints.push(cp);\n            }\n            this.currentFocusArea.grow(this.getTolerance(me));\n        }\n        else {\n            this.destroyIcons();\n            this.destroyFocusHighlight();\n        }\n    }\n    /**\n     * Create the shape used to paint the highlight.\n     *\n     * Returns true if the given icon intersects the given point.\n     */\n    createHighlightShape() {\n        const hl = new RectangleShape(new Rectangle(), this.highlightColor, this.highlightColor, HIGHLIGHT_STROKEWIDTH);\n        hl.opacity = HIGHLIGHT_OPACITY;\n        return hl;\n    }\n    /**\n     * Returns true if the given icon intersects the given rectangle.\n     */\n    intersects(icon, mouse, source, existingEdge) {\n        return intersects(icon.bounds, mouse);\n    }\n    /**\n     * Destroy this handler.\n     */\n    onDestroy() {\n        this.reset();\n        this.graph.model.removeListener(this.resetHandler);\n        this.graph.view.removeListener(this.resetHandler);\n        this.graph.removeListener(this.resetHandler);\n        if (this.mouseleaveHandler && this.graph.container) {\n            InternalEvent.removeListener(this.graph.container, 'mouseleave', this.mouseleaveHandler);\n            this.mouseleaveHandler = null;\n        }\n    }\n}\nexport default ConstraintHandler;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}