{"ast":null,"code":"var _CompletionOptions;\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { CancellationError, isCancellationError, onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { FuzzyScore } from '../../../../base/common/filters.js';\nimport { DisposableStore, isDisposable } from '../../../../base/common/lifecycle.js';\nimport { StopWatch } from '../../../../base/common/stopwatch.js';\nimport { assertType } from '../../../../base/common/types.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { ITextModelService } from '../../../common/services/resolverService.js';\nimport { SnippetParser } from '../../snippet/browser/snippetParser.js';\nimport { localize } from '../../../../nls.js';\nimport { MenuId } from '../../../../platform/actions/common/actions.js';\nimport { CommandsRegistry } from '../../../../platform/commands/common/commands.js';\nimport { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { historyNavigationVisible } from '../../../../platform/history/browser/contextScopedHistoryWidget.js';\nexport const Context = {\n  Visible: historyNavigationVisible,\n  HasFocusedSuggestion: new RawContextKey('suggestWidgetHasFocusedSuggestion', false, localize('suggestWidgetHasSelection', \"Whether any suggestion is focused\")),\n  DetailsVisible: new RawContextKey('suggestWidgetDetailsVisible', false, localize('suggestWidgetDetailsVisible', \"Whether suggestion details are visible\")),\n  MultipleSuggestions: new RawContextKey('suggestWidgetMultipleSuggestions', false, localize('suggestWidgetMultipleSuggestions', \"Whether there are multiple suggestions to pick from\")),\n  MakesTextEdit: new RawContextKey('suggestionMakesTextEdit', true, localize('suggestionMakesTextEdit', \"Whether inserting the current suggestion yields in a change or has everything already been typed\")),\n  AcceptSuggestionsOnEnter: new RawContextKey('acceptSuggestionOnEnter', true, localize('acceptSuggestionOnEnter', \"Whether suggestions are inserted when pressing Enter\")),\n  HasInsertAndReplaceRange: new RawContextKey('suggestionHasInsertAndReplaceRange', false, localize('suggestionHasInsertAndReplaceRange', \"Whether the current suggestion has insert and replace behaviour\")),\n  InsertMode: new RawContextKey('suggestionInsertMode', undefined, {\n    type: 'string',\n    description: localize('suggestionInsertMode', \"Whether the default behaviour is to insert or replace\")\n  }),\n  CanResolve: new RawContextKey('suggestionCanResolve', false, localize('suggestionCanResolve', \"Whether the current suggestion supports to resolve further details\"))\n};\nexport const suggestWidgetStatusbarMenu = new MenuId('suggestWidgetStatusBar');\nexport class CompletionItem {\n  constructor(position, completion, container, provider) {\n    var _completion$label;\n    this.position = position;\n    this.completion = completion;\n    this.container = container;\n    this.provider = provider;\n    // validation\n    this.isInvalid = false;\n    // sorting, filtering\n    this.score = FuzzyScore.Default;\n    this.distance = 0;\n    this.textLabel = typeof completion.label === 'string' ? completion.label : (_completion$label = completion.label) === null || _completion$label === void 0 ? void 0 : _completion$label.label;\n    // ensure lower-variants (perf)\n    this.labelLow = this.textLabel.toLowerCase();\n    // validate label\n    this.isInvalid = !this.textLabel;\n    this.sortTextLow = completion.sortText && completion.sortText.toLowerCase();\n    this.filterTextLow = completion.filterText && completion.filterText.toLowerCase();\n    this.extensionId = completion.extensionId;\n    // normalize ranges\n    if (Range.isIRange(completion.range)) {\n      this.editStart = new Position(completion.range.startLineNumber, completion.range.startColumn);\n      this.editInsertEnd = new Position(completion.range.endLineNumber, completion.range.endColumn);\n      this.editReplaceEnd = new Position(completion.range.endLineNumber, completion.range.endColumn);\n      // validate range\n      this.isInvalid = this.isInvalid || Range.spansMultipleLines(completion.range) || completion.range.startLineNumber !== position.lineNumber;\n    } else {\n      this.editStart = new Position(completion.range.insert.startLineNumber, completion.range.insert.startColumn);\n      this.editInsertEnd = new Position(completion.range.insert.endLineNumber, completion.range.insert.endColumn);\n      this.editReplaceEnd = new Position(completion.range.replace.endLineNumber, completion.range.replace.endColumn);\n      // validate ranges\n      this.isInvalid = this.isInvalid || Range.spansMultipleLines(completion.range.insert) || Range.spansMultipleLines(completion.range.replace) || completion.range.insert.startLineNumber !== position.lineNumber || completion.range.replace.startLineNumber !== position.lineNumber || completion.range.insert.startColumn !== completion.range.replace.startColumn;\n    }\n    // create the suggestion resolver\n    if (typeof provider.resolveCompletionItem !== 'function') {\n      this._resolveCache = Promise.resolve();\n      this._resolveDuration = 0;\n    }\n  }\n  // ---- resolving\n  get isResolved() {\n    return this._resolveDuration !== undefined;\n  }\n  get resolveDuration() {\n    return this._resolveDuration !== undefined ? this._resolveDuration : -1;\n  }\n  async resolve(token) {\n    if (!this._resolveCache) {\n      const sub = token.onCancellationRequested(() => {\n        this._resolveCache = undefined;\n        this._resolveDuration = undefined;\n      });\n      const sw = new StopWatch(true);\n      this._resolveCache = Promise.resolve(this.provider.resolveCompletionItem(this.completion, token)).then(value => {\n        Object.assign(this.completion, value);\n        this._resolveDuration = sw.elapsed();\n      }, err => {\n        if (isCancellationError(err)) {\n          // the IPC queue will reject the request with the\n          // cancellation error -> reset cached\n          this._resolveCache = undefined;\n          this._resolveDuration = undefined;\n        }\n      }).finally(() => {\n        sub.dispose();\n      });\n    }\n    return this._resolveCache;\n  }\n}\nexport class CompletionOptions {\n  constructor() {\n    let snippetSortOrder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n    let kindFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n    let providerFilter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n    let providerItemsToReuse = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Map();\n    let showDeprecated = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    this.snippetSortOrder = snippetSortOrder;\n    this.kindFilter = kindFilter;\n    this.providerFilter = providerFilter;\n    this.providerItemsToReuse = providerItemsToReuse;\n    this.showDeprecated = showDeprecated;\n  }\n}\n_CompletionOptions = CompletionOptions;\n_CompletionOptions.default = new _CompletionOptions();\nlet _snippetSuggestSupport;\nexport function getSnippetSuggestSupport() {\n  return _snippetSuggestSupport;\n}\nexport class CompletionItemModel {\n  constructor(items, needsClipboard, durations, disposable) {\n    this.items = items;\n    this.needsClipboard = needsClipboard;\n    this.durations = durations;\n    this.disposable = disposable;\n  }\n}\nexport async function provideSuggestionItems(registry, model, position) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : CompletionOptions.default;\n  let context = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n    triggerKind: 0 /* languages.CompletionTriggerKind.Invoke */\n  };\n  let token = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : CancellationToken.None;\n  const sw = new StopWatch();\n  position = position.clone();\n  const word = model.getWordAtPosition(position);\n  const defaultReplaceRange = word ? new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn) : Range.fromPositions(position);\n  const defaultRange = {\n    replace: defaultReplaceRange,\n    insert: defaultReplaceRange.setEndPosition(position.lineNumber, position.column)\n  };\n  const result = [];\n  const disposables = new DisposableStore();\n  const durations = [];\n  let needsClipboard = false;\n  const onCompletionList = (provider, container, sw) => {\n    var _provider$_debugDispl, _container$duration;\n    let didAddResult = false;\n    if (!container) {\n      return didAddResult;\n    }\n    for (const suggestion of container.suggestions) {\n      if (!options.kindFilter.has(suggestion.kind)) {\n        var _suggestion$tags;\n        // skip if not showing deprecated suggestions\n        if (!options.showDeprecated && suggestion !== null && suggestion !== void 0 && (_suggestion$tags = suggestion.tags) !== null && _suggestion$tags !== void 0 && _suggestion$tags.includes(1 /* languages.CompletionItemTag.Deprecated */)) {\n          continue;\n        }\n        // fill in default range when missing\n        if (!suggestion.range) {\n          suggestion.range = defaultRange;\n        }\n        // fill in default sortText when missing\n        if (!suggestion.sortText) {\n          suggestion.sortText = typeof suggestion.label === 'string' ? suggestion.label : suggestion.label.label;\n        }\n        if (!needsClipboard && suggestion.insertTextRules && suggestion.insertTextRules & 4 /* languages.CompletionItemInsertTextRule.InsertAsSnippet */) {\n          needsClipboard = SnippetParser.guessNeedsClipboard(suggestion.insertText);\n        }\n        result.push(new CompletionItem(position, suggestion, container, provider));\n        didAddResult = true;\n      }\n    }\n    if (isDisposable(container)) {\n      disposables.add(container);\n    }\n    durations.push({\n      providerName: (_provider$_debugDispl = provider._debugDisplayName) !== null && _provider$_debugDispl !== void 0 ? _provider$_debugDispl : 'unknown_provider',\n      elapsedProvider: (_container$duration = container.duration) !== null && _container$duration !== void 0 ? _container$duration : -1,\n      elapsedOverall: sw.elapsed()\n    });\n    return didAddResult;\n  };\n  // ask for snippets in parallel to asking \"real\" providers. Only do something if configured to\n  // do so - no snippet filter, no special-providers-only request\n  const snippetCompletions = (async () => {\n    if (!_snippetSuggestSupport || options.kindFilter.has(27 /* languages.CompletionItemKind.Snippet */)) {\n      return;\n    }\n    // we have items from a previous session that we can reuse\n    const reuseItems = options.providerItemsToReuse.get(_snippetSuggestSupport);\n    if (reuseItems) {\n      reuseItems.forEach(item => result.push(item));\n      return;\n    }\n    if (options.providerFilter.size > 0 && !options.providerFilter.has(_snippetSuggestSupport)) {\n      return;\n    }\n    const sw = new StopWatch();\n    const list = await _snippetSuggestSupport.provideCompletionItems(model, position, context, token);\n    onCompletionList(_snippetSuggestSupport, list, sw);\n  })();\n  // add suggestions from contributed providers - providers are ordered in groups of\n  // equal score and once a group produces a result the process stops\n  // get provider groups, always add snippet suggestion provider\n  for (const providerGroup of registry.orderedGroups(model)) {\n    // for each support in the group ask for suggestions\n    let didAddResult = false;\n    await Promise.all(providerGroup.map(async provider => {\n      // we have items from a previous session that we can reuse\n      if (options.providerItemsToReuse.has(provider)) {\n        const items = options.providerItemsToReuse.get(provider);\n        items.forEach(item => result.push(item));\n        didAddResult = didAddResult || items.length > 0;\n        return;\n      }\n      // check if this provider is filtered out\n      if (options.providerFilter.size > 0 && !options.providerFilter.has(provider)) {\n        return;\n      }\n      try {\n        const sw = new StopWatch();\n        const list = await provider.provideCompletionItems(model, position, context, token);\n        didAddResult = onCompletionList(provider, list, sw) || didAddResult;\n      } catch (err) {\n        onUnexpectedExternalError(err);\n      }\n    }));\n    if (didAddResult || token.isCancellationRequested) {\n      break;\n    }\n  }\n  await snippetCompletions;\n  if (token.isCancellationRequested) {\n    disposables.dispose();\n    return Promise.reject(new CancellationError());\n  }\n  return new CompletionItemModel(result.sort(getSuggestionComparator(options.snippetSortOrder)), needsClipboard, {\n    entries: durations,\n    elapsed: sw.elapsed()\n  }, disposables);\n}\nfunction defaultComparator(a, b) {\n  // check with 'sortText'\n  if (a.sortTextLow && b.sortTextLow) {\n    if (a.sortTextLow < b.sortTextLow) {\n      return -1;\n    } else if (a.sortTextLow > b.sortTextLow) {\n      return 1;\n    }\n  }\n  // check with 'label'\n  if (a.textLabel < b.textLabel) {\n    return -1;\n  } else if (a.textLabel > b.textLabel) {\n    return 1;\n  }\n  // check with 'type'\n  return a.completion.kind - b.completion.kind;\n}\nfunction snippetUpComparator(a, b) {\n  if (a.completion.kind !== b.completion.kind) {\n    if (a.completion.kind === 27 /* languages.CompletionItemKind.Snippet */) {\n      return -1;\n    } else if (b.completion.kind === 27 /* languages.CompletionItemKind.Snippet */) {\n      return 1;\n    }\n  }\n  return defaultComparator(a, b);\n}\nfunction snippetDownComparator(a, b) {\n  if (a.completion.kind !== b.completion.kind) {\n    if (a.completion.kind === 27 /* languages.CompletionItemKind.Snippet */) {\n      return 1;\n    } else if (b.completion.kind === 27 /* languages.CompletionItemKind.Snippet */) {\n      return -1;\n    }\n  }\n  return defaultComparator(a, b);\n}\nconst _snippetComparators = new Map();\n_snippetComparators.set(0 /* SnippetSortOrder.Top */, snippetUpComparator);\n_snippetComparators.set(2 /* SnippetSortOrder.Bottom */, snippetDownComparator);\n_snippetComparators.set(1 /* SnippetSortOrder.Inline */, defaultComparator);\nexport function getSuggestionComparator(snippetConfig) {\n  return _snippetComparators.get(snippetConfig);\n}\nCommandsRegistry.registerCommand('_executeCompletionItemProvider', async function (accessor) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  const [uri, position, triggerCharacter, maxItemsToResolve] = args;\n  assertType(URI.isUri(uri));\n  assertType(Position.isIPosition(position));\n  assertType(typeof triggerCharacter === 'string' || !triggerCharacter);\n  assertType(typeof maxItemsToResolve === 'number' || !maxItemsToResolve);\n  const {\n    completionProvider\n  } = accessor.get(ILanguageFeaturesService);\n  const ref = await accessor.get(ITextModelService).createModelReference(uri);\n  try {\n    const result = {\n      incomplete: false,\n      suggestions: []\n    };\n    const resolving = [];\n    const actualPosition = ref.object.textEditorModel.validatePosition(position);\n    const completions = await provideSuggestionItems(completionProvider, ref.object.textEditorModel, actualPosition, undefined, {\n      triggerCharacter: triggerCharacter !== null && triggerCharacter !== void 0 ? triggerCharacter : undefined,\n      triggerKind: triggerCharacter ? 1 /* languages.CompletionTriggerKind.TriggerCharacter */ : 0 /* languages.CompletionTriggerKind.Invoke */\n    });\n    for (const item of completions.items) {\n      if (resolving.length < (maxItemsToResolve !== null && maxItemsToResolve !== void 0 ? maxItemsToResolve : 0)) {\n        resolving.push(item.resolve(CancellationToken.None));\n      }\n      result.incomplete = result.incomplete || item.container.incomplete;\n      result.suggestions.push(item.completion);\n    }\n    try {\n      await Promise.all(resolving);\n      return result;\n    } finally {\n      setTimeout(() => completions.disposable.dispose(), 100);\n    }\n  } finally {\n    ref.dispose();\n  }\n});\nexport function showSimpleSuggestions(editor, provider) {\n  var _editor$getContributi;\n  (_editor$getContributi = editor.getContribution('editor.contrib.suggestController')) === null || _editor$getContributi === void 0 || _editor$getContributi.triggerSuggest(new Set().add(provider), undefined, true);\n}\nexport class QuickSuggestionsOptions {\n  static isAllOff(config) {\n    return config.other === 'off' && config.comments === 'off' && config.strings === 'off';\n  }\n  static isAllOn(config) {\n    return config.other === 'on' && config.comments === 'on' && config.strings === 'on';\n  }\n  static valueFor(config, tokenType) {\n    switch (tokenType) {\n      case 1 /* StandardTokenType.Comment */:\n        return config.comments;\n      case 2 /* StandardTokenType.String */:\n        return config.strings;\n      default:\n        return config.other;\n    }\n  }\n}","map":{"version":3,"names":["CancellationToken","CancellationError","isCancellationError","onUnexpectedExternalError","FuzzyScore","DisposableStore","isDisposable","StopWatch","assertType","URI","Position","Range","ITextModelService","SnippetParser","localize","MenuId","CommandsRegistry","RawContextKey","ILanguageFeaturesService","historyNavigationVisible","Context","Visible","HasFocusedSuggestion","DetailsVisible","MultipleSuggestions","MakesTextEdit","AcceptSuggestionsOnEnter","HasInsertAndReplaceRange","InsertMode","undefined","type","description","CanResolve","suggestWidgetStatusbarMenu","CompletionItem","constructor","position","completion","container","provider","_completion$label","isInvalid","score","Default","distance","textLabel","label","labelLow","toLowerCase","sortTextLow","sortText","filterTextLow","filterText","extensionId","isIRange","range","editStart","startLineNumber","startColumn","editInsertEnd","endLineNumber","endColumn","editReplaceEnd","spansMultipleLines","lineNumber","insert","replace","resolveCompletionItem","_resolveCache","Promise","resolve","_resolveDuration","isResolved","resolveDuration","token","sub","onCancellationRequested","sw","then","value","Object","assign","elapsed","err","finally","dispose","CompletionOptions","snippetSortOrder","arguments","length","kindFilter","Set","providerFilter","providerItemsToReuse","Map","showDeprecated","_CompletionOptions","default","_snippetSuggestSupport","getSnippetSuggestSupport","CompletionItemModel","items","needsClipboard","durations","disposable","provideSuggestionItems","registry","model","options","context","triggerKind","None","clone","word","getWordAtPosition","defaultReplaceRange","fromPositions","defaultRange","setEndPosition","column","result","disposables","onCompletionList","_provider$_debugDispl","_container$duration","didAddResult","suggestion","suggestions","has","kind","_suggestion$tags","tags","includes","insertTextRules","guessNeedsClipboard","insertText","push","add","providerName","_debugDisplayName","elapsedProvider","duration","elapsedOverall","snippetCompletions","reuseItems","get","forEach","item","size","list","provideCompletionItems","providerGroup","orderedGroups","all","map","isCancellationRequested","reject","sort","getSuggestionComparator","entries","defaultComparator","a","b","snippetUpComparator","snippetDownComparator","_snippetComparators","set","snippetConfig","registerCommand","accessor","_len","args","Array","_key","uri","triggerCharacter","maxItemsToResolve","isUri","isIPosition","completionProvider","ref","createModelReference","incomplete","resolving","actualPosition","object","textEditorModel","validatePosition","completions","setTimeout","showSimpleSuggestions","editor","_editor$getContributi","getContribution","triggerSuggest","QuickSuggestionsOptions","isAllOff","config","other","comments","strings","isAllOn","valueFor","tokenType"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggest.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { CancellationError, isCancellationError, onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { FuzzyScore } from '../../../../base/common/filters.js';\nimport { DisposableStore, isDisposable } from '../../../../base/common/lifecycle.js';\nimport { StopWatch } from '../../../../base/common/stopwatch.js';\nimport { assertType } from '../../../../base/common/types.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { ITextModelService } from '../../../common/services/resolverService.js';\nimport { SnippetParser } from '../../snippet/browser/snippetParser.js';\nimport { localize } from '../../../../nls.js';\nimport { MenuId } from '../../../../platform/actions/common/actions.js';\nimport { CommandsRegistry } from '../../../../platform/commands/common/commands.js';\nimport { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { historyNavigationVisible } from '../../../../platform/history/browser/contextScopedHistoryWidget.js';\nexport const Context = {\n    Visible: historyNavigationVisible,\n    HasFocusedSuggestion: new RawContextKey('suggestWidgetHasFocusedSuggestion', false, localize('suggestWidgetHasSelection', \"Whether any suggestion is focused\")),\n    DetailsVisible: new RawContextKey('suggestWidgetDetailsVisible', false, localize('suggestWidgetDetailsVisible', \"Whether suggestion details are visible\")),\n    MultipleSuggestions: new RawContextKey('suggestWidgetMultipleSuggestions', false, localize('suggestWidgetMultipleSuggestions', \"Whether there are multiple suggestions to pick from\")),\n    MakesTextEdit: new RawContextKey('suggestionMakesTextEdit', true, localize('suggestionMakesTextEdit', \"Whether inserting the current suggestion yields in a change or has everything already been typed\")),\n    AcceptSuggestionsOnEnter: new RawContextKey('acceptSuggestionOnEnter', true, localize('acceptSuggestionOnEnter', \"Whether suggestions are inserted when pressing Enter\")),\n    HasInsertAndReplaceRange: new RawContextKey('suggestionHasInsertAndReplaceRange', false, localize('suggestionHasInsertAndReplaceRange', \"Whether the current suggestion has insert and replace behaviour\")),\n    InsertMode: new RawContextKey('suggestionInsertMode', undefined, { type: 'string', description: localize('suggestionInsertMode', \"Whether the default behaviour is to insert or replace\") }),\n    CanResolve: new RawContextKey('suggestionCanResolve', false, localize('suggestionCanResolve', \"Whether the current suggestion supports to resolve further details\")),\n};\nexport const suggestWidgetStatusbarMenu = new MenuId('suggestWidgetStatusBar');\nexport class CompletionItem {\n    constructor(position, completion, container, provider) {\n        this.position = position;\n        this.completion = completion;\n        this.container = container;\n        this.provider = provider;\n        // validation\n        this.isInvalid = false;\n        // sorting, filtering\n        this.score = FuzzyScore.Default;\n        this.distance = 0;\n        this.textLabel = typeof completion.label === 'string'\n            ? completion.label\n            : completion.label?.label;\n        // ensure lower-variants (perf)\n        this.labelLow = this.textLabel.toLowerCase();\n        // validate label\n        this.isInvalid = !this.textLabel;\n        this.sortTextLow = completion.sortText && completion.sortText.toLowerCase();\n        this.filterTextLow = completion.filterText && completion.filterText.toLowerCase();\n        this.extensionId = completion.extensionId;\n        // normalize ranges\n        if (Range.isIRange(completion.range)) {\n            this.editStart = new Position(completion.range.startLineNumber, completion.range.startColumn);\n            this.editInsertEnd = new Position(completion.range.endLineNumber, completion.range.endColumn);\n            this.editReplaceEnd = new Position(completion.range.endLineNumber, completion.range.endColumn);\n            // validate range\n            this.isInvalid = this.isInvalid\n                || Range.spansMultipleLines(completion.range) || completion.range.startLineNumber !== position.lineNumber;\n        }\n        else {\n            this.editStart = new Position(completion.range.insert.startLineNumber, completion.range.insert.startColumn);\n            this.editInsertEnd = new Position(completion.range.insert.endLineNumber, completion.range.insert.endColumn);\n            this.editReplaceEnd = new Position(completion.range.replace.endLineNumber, completion.range.replace.endColumn);\n            // validate ranges\n            this.isInvalid = this.isInvalid\n                || Range.spansMultipleLines(completion.range.insert) || Range.spansMultipleLines(completion.range.replace)\n                || completion.range.insert.startLineNumber !== position.lineNumber || completion.range.replace.startLineNumber !== position.lineNumber\n                || completion.range.insert.startColumn !== completion.range.replace.startColumn;\n        }\n        // create the suggestion resolver\n        if (typeof provider.resolveCompletionItem !== 'function') {\n            this._resolveCache = Promise.resolve();\n            this._resolveDuration = 0;\n        }\n    }\n    // ---- resolving\n    get isResolved() {\n        return this._resolveDuration !== undefined;\n    }\n    get resolveDuration() {\n        return this._resolveDuration !== undefined ? this._resolveDuration : -1;\n    }\n    async resolve(token) {\n        if (!this._resolveCache) {\n            const sub = token.onCancellationRequested(() => {\n                this._resolveCache = undefined;\n                this._resolveDuration = undefined;\n            });\n            const sw = new StopWatch(true);\n            this._resolveCache = Promise.resolve(this.provider.resolveCompletionItem(this.completion, token)).then(value => {\n                Object.assign(this.completion, value);\n                this._resolveDuration = sw.elapsed();\n            }, err => {\n                if (isCancellationError(err)) {\n                    // the IPC queue will reject the request with the\n                    // cancellation error -> reset cached\n                    this._resolveCache = undefined;\n                    this._resolveDuration = undefined;\n                }\n            }).finally(() => {\n                sub.dispose();\n            });\n        }\n        return this._resolveCache;\n    }\n}\nexport class CompletionOptions {\n    static { this.default = new CompletionOptions(); }\n    constructor(snippetSortOrder = 2 /* SnippetSortOrder.Bottom */, kindFilter = new Set(), providerFilter = new Set(), providerItemsToReuse = new Map(), showDeprecated = true) {\n        this.snippetSortOrder = snippetSortOrder;\n        this.kindFilter = kindFilter;\n        this.providerFilter = providerFilter;\n        this.providerItemsToReuse = providerItemsToReuse;\n        this.showDeprecated = showDeprecated;\n    }\n}\nlet _snippetSuggestSupport;\nexport function getSnippetSuggestSupport() {\n    return _snippetSuggestSupport;\n}\nexport class CompletionItemModel {\n    constructor(items, needsClipboard, durations, disposable) {\n        this.items = items;\n        this.needsClipboard = needsClipboard;\n        this.durations = durations;\n        this.disposable = disposable;\n    }\n}\nexport async function provideSuggestionItems(registry, model, position, options = CompletionOptions.default, context = { triggerKind: 0 /* languages.CompletionTriggerKind.Invoke */ }, token = CancellationToken.None) {\n    const sw = new StopWatch();\n    position = position.clone();\n    const word = model.getWordAtPosition(position);\n    const defaultReplaceRange = word ? new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn) : Range.fromPositions(position);\n    const defaultRange = { replace: defaultReplaceRange, insert: defaultReplaceRange.setEndPosition(position.lineNumber, position.column) };\n    const result = [];\n    const disposables = new DisposableStore();\n    const durations = [];\n    let needsClipboard = false;\n    const onCompletionList = (provider, container, sw) => {\n        let didAddResult = false;\n        if (!container) {\n            return didAddResult;\n        }\n        for (const suggestion of container.suggestions) {\n            if (!options.kindFilter.has(suggestion.kind)) {\n                // skip if not showing deprecated suggestions\n                if (!options.showDeprecated && suggestion?.tags?.includes(1 /* languages.CompletionItemTag.Deprecated */)) {\n                    continue;\n                }\n                // fill in default range when missing\n                if (!suggestion.range) {\n                    suggestion.range = defaultRange;\n                }\n                // fill in default sortText when missing\n                if (!suggestion.sortText) {\n                    suggestion.sortText = typeof suggestion.label === 'string' ? suggestion.label : suggestion.label.label;\n                }\n                if (!needsClipboard && suggestion.insertTextRules && suggestion.insertTextRules & 4 /* languages.CompletionItemInsertTextRule.InsertAsSnippet */) {\n                    needsClipboard = SnippetParser.guessNeedsClipboard(suggestion.insertText);\n                }\n                result.push(new CompletionItem(position, suggestion, container, provider));\n                didAddResult = true;\n            }\n        }\n        if (isDisposable(container)) {\n            disposables.add(container);\n        }\n        durations.push({\n            providerName: provider._debugDisplayName ?? 'unknown_provider', elapsedProvider: container.duration ?? -1, elapsedOverall: sw.elapsed()\n        });\n        return didAddResult;\n    };\n    // ask for snippets in parallel to asking \"real\" providers. Only do something if configured to\n    // do so - no snippet filter, no special-providers-only request\n    const snippetCompletions = (async () => {\n        if (!_snippetSuggestSupport || options.kindFilter.has(27 /* languages.CompletionItemKind.Snippet */)) {\n            return;\n        }\n        // we have items from a previous session that we can reuse\n        const reuseItems = options.providerItemsToReuse.get(_snippetSuggestSupport);\n        if (reuseItems) {\n            reuseItems.forEach(item => result.push(item));\n            return;\n        }\n        if (options.providerFilter.size > 0 && !options.providerFilter.has(_snippetSuggestSupport)) {\n            return;\n        }\n        const sw = new StopWatch();\n        const list = await _snippetSuggestSupport.provideCompletionItems(model, position, context, token);\n        onCompletionList(_snippetSuggestSupport, list, sw);\n    })();\n    // add suggestions from contributed providers - providers are ordered in groups of\n    // equal score and once a group produces a result the process stops\n    // get provider groups, always add snippet suggestion provider\n    for (const providerGroup of registry.orderedGroups(model)) {\n        // for each support in the group ask for suggestions\n        let didAddResult = false;\n        await Promise.all(providerGroup.map(async (provider) => {\n            // we have items from a previous session that we can reuse\n            if (options.providerItemsToReuse.has(provider)) {\n                const items = options.providerItemsToReuse.get(provider);\n                items.forEach(item => result.push(item));\n                didAddResult = didAddResult || items.length > 0;\n                return;\n            }\n            // check if this provider is filtered out\n            if (options.providerFilter.size > 0 && !options.providerFilter.has(provider)) {\n                return;\n            }\n            try {\n                const sw = new StopWatch();\n                const list = await provider.provideCompletionItems(model, position, context, token);\n                didAddResult = onCompletionList(provider, list, sw) || didAddResult;\n            }\n            catch (err) {\n                onUnexpectedExternalError(err);\n            }\n        }));\n        if (didAddResult || token.isCancellationRequested) {\n            break;\n        }\n    }\n    await snippetCompletions;\n    if (token.isCancellationRequested) {\n        disposables.dispose();\n        return Promise.reject(new CancellationError());\n    }\n    return new CompletionItemModel(result.sort(getSuggestionComparator(options.snippetSortOrder)), needsClipboard, { entries: durations, elapsed: sw.elapsed() }, disposables);\n}\nfunction defaultComparator(a, b) {\n    // check with 'sortText'\n    if (a.sortTextLow && b.sortTextLow) {\n        if (a.sortTextLow < b.sortTextLow) {\n            return -1;\n        }\n        else if (a.sortTextLow > b.sortTextLow) {\n            return 1;\n        }\n    }\n    // check with 'label'\n    if (a.textLabel < b.textLabel) {\n        return -1;\n    }\n    else if (a.textLabel > b.textLabel) {\n        return 1;\n    }\n    // check with 'type'\n    return a.completion.kind - b.completion.kind;\n}\nfunction snippetUpComparator(a, b) {\n    if (a.completion.kind !== b.completion.kind) {\n        if (a.completion.kind === 27 /* languages.CompletionItemKind.Snippet */) {\n            return -1;\n        }\n        else if (b.completion.kind === 27 /* languages.CompletionItemKind.Snippet */) {\n            return 1;\n        }\n    }\n    return defaultComparator(a, b);\n}\nfunction snippetDownComparator(a, b) {\n    if (a.completion.kind !== b.completion.kind) {\n        if (a.completion.kind === 27 /* languages.CompletionItemKind.Snippet */) {\n            return 1;\n        }\n        else if (b.completion.kind === 27 /* languages.CompletionItemKind.Snippet */) {\n            return -1;\n        }\n    }\n    return defaultComparator(a, b);\n}\nconst _snippetComparators = new Map();\n_snippetComparators.set(0 /* SnippetSortOrder.Top */, snippetUpComparator);\n_snippetComparators.set(2 /* SnippetSortOrder.Bottom */, snippetDownComparator);\n_snippetComparators.set(1 /* SnippetSortOrder.Inline */, defaultComparator);\nexport function getSuggestionComparator(snippetConfig) {\n    return _snippetComparators.get(snippetConfig);\n}\nCommandsRegistry.registerCommand('_executeCompletionItemProvider', async (accessor, ...args) => {\n    const [uri, position, triggerCharacter, maxItemsToResolve] = args;\n    assertType(URI.isUri(uri));\n    assertType(Position.isIPosition(position));\n    assertType(typeof triggerCharacter === 'string' || !triggerCharacter);\n    assertType(typeof maxItemsToResolve === 'number' || !maxItemsToResolve);\n    const { completionProvider } = accessor.get(ILanguageFeaturesService);\n    const ref = await accessor.get(ITextModelService).createModelReference(uri);\n    try {\n        const result = {\n            incomplete: false,\n            suggestions: []\n        };\n        const resolving = [];\n        const actualPosition = ref.object.textEditorModel.validatePosition(position);\n        const completions = await provideSuggestionItems(completionProvider, ref.object.textEditorModel, actualPosition, undefined, { triggerCharacter: triggerCharacter ?? undefined, triggerKind: triggerCharacter ? 1 /* languages.CompletionTriggerKind.TriggerCharacter */ : 0 /* languages.CompletionTriggerKind.Invoke */ });\n        for (const item of completions.items) {\n            if (resolving.length < (maxItemsToResolve ?? 0)) {\n                resolving.push(item.resolve(CancellationToken.None));\n            }\n            result.incomplete = result.incomplete || item.container.incomplete;\n            result.suggestions.push(item.completion);\n        }\n        try {\n            await Promise.all(resolving);\n            return result;\n        }\n        finally {\n            setTimeout(() => completions.disposable.dispose(), 100);\n        }\n    }\n    finally {\n        ref.dispose();\n    }\n});\nexport function showSimpleSuggestions(editor, provider) {\n    editor.getContribution('editor.contrib.suggestController')?.triggerSuggest(new Set().add(provider), undefined, true);\n}\nexport class QuickSuggestionsOptions {\n    static isAllOff(config) {\n        return config.other === 'off' && config.comments === 'off' && config.strings === 'off';\n    }\n    static isAllOn(config) {\n        return config.other === 'on' && config.comments === 'on' && config.strings === 'on';\n    }\n    static valueFor(config, tokenType) {\n        switch (tokenType) {\n            case 1 /* StandardTokenType.Comment */: return config.comments;\n            case 2 /* StandardTokenType.String */: return config.strings;\n            default: return config.other;\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}