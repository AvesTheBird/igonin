{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Client from '../../../Client';\nimport { ABSOLUTE_LINE_HEIGHT, ALIGN, DEFAULT_FONTFAMILY, DEFAULT_FONTSIZE, DEFAULT_FONTSTYLE, DEFAULT_TEXT_DIRECTION, DIALECT, FONT, NONE, TEXT_DIRECTION, WORD_WRAP, LINE_HEIGHT } from '../../../util/Constants';\nimport { getBoundingBox } from '../../../util/mathUtils';\nimport { getAlignmentAsPoint, matchBinaryMask } from '../../../util/styleUtils';\nimport Point from '../Point';\nimport Shape from '../Shape';\nimport Rectangle from '../Rectangle';\nimport { htmlEntities, replaceTrailingNewlines, trim } from '../../../util/StringUtils';\nimport { isNode } from '../../../util/domUtils';\nimport SvgCanvas2D from '../../canvas/SvgCanvas2D';\n/**\n * Extends mxShape to implement a text shape.\n * To change vertical text from bottom to top to top to bottom,\n * the following code can be used:\n * ```javascript\n * mxText.prototype.verticalTextRotation = 90;\n * ```\n * @class TextShape\n * @extends {Shape}\n */\nclass TextShape extends Shape {\n  constructor(value, bounds, align = ALIGN.CENTER, valign = ALIGN.MIDDLE, color = 'black', family = DEFAULT_FONTFAMILY, size = DEFAULT_FONTSIZE, fontStyle = DEFAULT_FONTSTYLE, spacing = 2, spacingTop = 0, spacingRight = 0, spacingBottom = 0, spacingLeft = 0, horizontal = true, background = NONE, border = NONE, wrap = false, clipped = false, overflow = 'visible', labelPadding = 0, textDirection = DEFAULT_TEXT_DIRECTION) {\n    super();\n    this.margin = null;\n    this.unrotatedBoundingBox = null;\n    this.flipH = false;\n    this.flipV = false;\n    /**\n     * Specifies the spacing to be added to the top spacing. Default is 0. Use the\n     * value 5 here to get the same label positions as in mxGraph 1.x.\n     */\n    this.baseSpacingTop = 0;\n    /**\n     * Specifies the spacing to be added to the bottom spacing. Default is 0. Use the\n     * value 1 here to get the same label positions as in mxGraph 1.x.\n     */\n    this.baseSpacingBottom = 0;\n    /**\n     * Specifies the spacing to be added to the left spacing. Default is 0.\n     */\n    this.baseSpacingLeft = 0;\n    /**\n     * Specifies the spacing to be added to the right spacing. Default is 0.\n     */\n    this.baseSpacingRight = 0;\n    /**\n     * Specifies if linefeeds in HTML labels should be replaced with BR tags.\n     * Default is true.\n     */\n    this.replaceLinefeeds = true;\n    /**\n     * Rotation for vertical text. Default is -90 (bottom to top).\n     */\n    this.verticalTextRotation = -90;\n    /**\n     * Specifies if the string size should be measured in <updateBoundingBox> if\n     * the label is clipped and the label position is center and middle. If this is\n     * true, then the bounding box will be set to <bounds>. Default is true.\n     * <ignoreStringSize> has precedence over this switch.\n     */\n    this.ignoreClippedStringSize = true;\n    /**\n     * Specifies if the actual string size should be measured. If disabled the\n     * boundingBox will not ignore the actual size of the string, otherwise\n     * <bounds> will be used instead. Default is false.\n     */\n    this.ignoreStringSize = false;\n    /**\n     * Contains the last rendered text value. Used for caching.\n     */\n    this.lastValue = null;\n    /**\n     * Specifies if caching for HTML labels should be enabled. Default is true.\n     */\n    this.cacheEnabled = true;\n    this.value = value;\n    this.bounds = bounds;\n    this.color = color ?? 'black';\n    this.align = align ?? ALIGN.CENTER;\n    this.valign = valign ?? ALIGN.MIDDLE;\n    this.family = family ?? DEFAULT_FONTFAMILY;\n    this.size = size ?? DEFAULT_FONTSIZE;\n    this.fontStyle = fontStyle ?? DEFAULT_FONTSTYLE;\n    this.spacing = spacing ?? 2;\n    this.spacingTop = this.spacing + (spacingTop ?? 0);\n    this.spacingRight = this.spacing + (spacingRight ?? 0);\n    this.spacingBottom = this.spacing + (spacingBottom ?? 0);\n    this.spacingLeft = this.spacing + (spacingLeft ?? 0);\n    this.horizontal = horizontal ?? true;\n    this.background = background;\n    this.border = border;\n    this.wrap = wrap ?? false;\n    this.clipped = clipped ?? false;\n    this.overflow = overflow ?? 'visible';\n    this.labelPadding = labelPadding ?? 0;\n    this.textDirection = textDirection;\n    this.rotation = 0;\n    this.updateMargin();\n  }\n  /**\n   * Disables offset in IE9 for crisper image output.\n   */\n  getSvgScreenOffset() {\n    return 0;\n  }\n  /**\n   * Returns true if the bounds are not null and all of its variables are numeric.\n   */\n  checkBounds() {\n    return !isNaN(this.scale) && isFinite(this.scale) && this.scale > 0 && this.bounds && !isNaN(this.bounds.x) && !isNaN(this.bounds.y) && !isNaN(this.bounds.width) && !isNaN(this.bounds.height);\n  }\n  /**\n   * Generic rendering code.\n   */\n  paint(c, update = false) {\n    // Scale is passed-through to canvas\n    const s = this.scale;\n    const x = this.bounds.x / s;\n    const y = this.bounds.y / s;\n    const w = this.bounds.width / s;\n    const h = this.bounds.height / s;\n    this.updateTransform(c, x, y, w, h);\n    this.configureCanvas(c, x, y, w, h);\n    if (update) {\n      c.updateText(x, y, w, h, this.align, this.valign, this.wrap, this.overflow, this.clipped, this.getTextRotation(), this.node);\n    } else {\n      // Checks if text contains HTML markup\n      const realHtml = isNode(this.value) || this.dialect === DIALECT.STRICTHTML;\n      // Always renders labels as HTML in VML\n      const fmt = realHtml ? 'html' : '';\n      let val = this.value;\n      if (!realHtml && fmt === 'html') {\n        // @ts-ignore\n        val = htmlEntities(val, false);\n      }\n      if (fmt === 'html' && !isNode(this.value)) {\n        val = replaceTrailingNewlines(val, '<div><br></div>');\n      }\n      // Handles trailing newlines to make sure they are visible in rendering output\n      val = !isNode(this.value) && this.replaceLinefeeds && fmt === 'html' ? val.replace(/\\n/g, '<br/>') : val;\n      let dir = this.textDirection;\n      if (dir === TEXT_DIRECTION.AUTO && !realHtml) {\n        dir = this.getAutoDirection();\n      }\n      if (dir !== TEXT_DIRECTION.LTR && dir !== TEXT_DIRECTION.RTL) {\n        dir = TEXT_DIRECTION.DEFAULT;\n      }\n      c.text(x, y, w, h, val, this.align, this.valign, this.wrap, fmt, this.overflow, this.clipped, this.getTextRotation(), dir);\n    }\n  }\n  /**\n   * Renders the text using the given DOM nodes.\n   */\n  redraw() {\n    if (this.visible && this.checkBounds() && this.cacheEnabled && this.lastValue === this.value && (isNode(this.value) || this.dialect === DIALECT.STRICTHTML)) {\n      if (this.node.nodeName === 'DIV') {\n        this.redrawHtmlShape();\n        this.updateBoundingBox();\n      } else {\n        const canvas = this.createCanvas();\n        if (canvas) {\n          // Specifies if events should be handled\n          canvas.pointerEvents = this.pointerEvents;\n          this.paint(canvas, true);\n          this.destroyCanvas(canvas);\n          this.updateBoundingBox();\n        }\n      }\n    } else {\n      super.redraw();\n      if (isNode(this.value) || this.dialect === DIALECT.STRICTHTML) {\n        this.lastValue = this.value;\n      } else {\n        this.lastValue = null;\n      }\n    }\n  }\n  /**\n   * Resets all styles.\n   */\n  resetStyles() {\n    super.resetStyles();\n    this.color = 'black';\n    this.align = ALIGN.CENTER;\n    this.valign = ALIGN.MIDDLE;\n    this.family = DEFAULT_FONTFAMILY;\n    this.size = DEFAULT_FONTSIZE;\n    this.fontStyle = DEFAULT_FONTSTYLE;\n    this.spacing = 2;\n    this.spacingTop = 2;\n    this.spacingRight = 2;\n    this.spacingBottom = 2;\n    this.spacingLeft = 2;\n    this.horizontal = true;\n    this.background = NONE;\n    this.border = NONE;\n    this.textDirection = DEFAULT_TEXT_DIRECTION;\n    this.margin = null;\n  }\n  /**\n   * Extends mxShape to update the text styles.\n   *\n   * @param state <CellState> of the corresponding cell.\n   */\n  apply(state) {\n    const old = this.spacing;\n    super.apply(state);\n    if (this.style) {\n      this.fontStyle = this.style.fontStyle ?? this.fontStyle;\n      this.family = this.style.fontFamily ?? this.family;\n      this.size = this.style.fontSize ?? this.size;\n      this.color = this.style.fontColor ?? this.color;\n      this.align = this.style.align ?? this.align;\n      this.valign = this.style.verticalAlign ?? this.valign;\n      this.spacing = this.style.spacing ?? this.spacing;\n      this.spacingTop = (this.style.spacingTop ?? this.spacingTop - old) + this.spacing;\n      this.spacingRight = (this.style.spacingRight ?? this.spacingRight - old) + this.spacing;\n      this.spacingBottom = (this.style.spacingBottom ?? this.spacingBottom - old) + this.spacing;\n      this.spacingLeft = (this.style.spacingLeft ?? this.spacingLeft - old) + this.spacing;\n      this.horizontal = this.style.horizontal ?? this.horizontal;\n      this.background = this.style.labelBackgroundColor ?? this.background;\n      this.border = this.style.labelBorderColor ?? this.border;\n      this.textDirection = this.style.textDirection ?? DEFAULT_TEXT_DIRECTION;\n      this.opacity = this.style.textOpacity ?? 100;\n      this.updateMargin();\n    }\n    this.flipV = false;\n    this.flipH = false;\n  }\n  /**\n   * Used to determine the automatic text direction. Returns\n   * {@link Constants#TEXT_DIRECTION_LTR} or {@link Constants#TEXT_DIRECTION_RTL}\n   * depending on the contents of <value>. This is not invoked for HTML, wrapped\n   * content or if <value> is a DOM node.\n   */\n  getAutoDirection() {\n    // Looks for strong (directional) characters\n    const tmp = /[A-Za-z\\u05d0-\\u065f\\u066a-\\u06ef\\u06fa-\\u07ff\\ufb1d-\\ufdff\\ufe70-\\ufefc]/.exec(String(this.value));\n    // Returns the direction defined by the character\n    return tmp && tmp.length > 0 && tmp[0] > 'z' ? TEXT_DIRECTION.RTL : TEXT_DIRECTION.LTR;\n  }\n  /**\n   * Returns the node that contains the rendered input.\n   */\n  getContentNode() {\n    let result = this.node;\n    if (result) {\n      // Rendered with no foreignObject\n      if (!result.ownerSVGElement) {\n        // @ts-ignore\n        result = this.node.firstChild.firstChild;\n      } else {\n        // Innermost DIV that contains the actual content\n        // @ts-ignore\n        result = result.firstChild.firstChild.firstChild.firstChild.firstChild;\n      }\n    }\n    return result;\n  }\n  /**\n   * Updates the <boundingBox> for this shape using the given node and position.\n   */\n  updateBoundingBox() {\n    let {\n      node\n    } = this;\n    this.boundingBox = this.bounds.clone();\n    const rot = this.getTextRotation();\n    const h = this.style?.labelPosition ?? ALIGN.CENTER;\n    const v = this.style?.verticalLabelPosition ?? ALIGN.MIDDLE;\n    if (!this.ignoreStringSize && node && this.overflow !== 'fill' && (!this.clipped || !this.ignoreClippedStringSize || h !== ALIGN.CENTER || v !== ALIGN.MIDDLE)) {\n      let ow = null;\n      let oh = null;\n      if (node.firstChild && node.firstChild.firstChild && node.firstChild.firstChild.nodeName === 'foreignObject') {\n        // Uses second inner DIV for font metrics\n        // @ts-ignore\n        node = node.firstChild.firstChild.firstChild.firstChild;\n        // @ts-ignore\n        oh = node.offsetHeight * this.scale;\n        if (this.overflow === 'width') {\n          ow = this.boundingBox.width;\n        } else {\n          // @ts-ignore\n          ow = node.offsetWidth * this.scale;\n        }\n      } else {\n        try {\n          const b = node.getBBox();\n          // Workaround for bounding box of empty string\n          if (typeof this.value === 'string' && trim(this.value)?.length === 0) {\n            this.boundingBox = null;\n          } else if (b.width === 0 && b.height === 0) {\n            this.boundingBox = null;\n          } else {\n            this.boundingBox = new Rectangle(b.x, b.y, b.width, b.height);\n          }\n          return;\n        } catch (e) {\n          // Ignores NS_ERROR_FAILURE in FF if container display is none.\n        }\n      }\n      if (ow && oh) {\n        this.boundingBox = new Rectangle(this.bounds.x, this.bounds.y, ow, oh);\n      }\n    }\n    if (this.boundingBox) {\n      const margin = this.margin;\n      if (rot !== 0) {\n        // Accounts for pre-rotated x and y\n        const bbox = getBoundingBox(new Rectangle(margin.x * this.boundingBox.width, margin.y * this.boundingBox.height, this.boundingBox.width, this.boundingBox.height), rot, new Point(0, 0));\n        this.unrotatedBoundingBox = Rectangle.fromRectangle(this.boundingBox);\n        this.unrotatedBoundingBox.x += margin.x * this.unrotatedBoundingBox.width;\n        this.unrotatedBoundingBox.y += margin.y * this.unrotatedBoundingBox.height;\n        this.boundingBox.x += bbox.x;\n        this.boundingBox.y += bbox.y;\n        this.boundingBox.width = bbox.width;\n        this.boundingBox.height = bbox.height;\n      } else {\n        this.boundingBox.x += margin.x * this.boundingBox.width;\n        this.boundingBox.y += margin.y * this.boundingBox.height;\n        this.unrotatedBoundingBox = null;\n      }\n    }\n  }\n  /**\n   * Returns 0 to avoid using rotation in the canvas via updateTransform.\n   */\n  getShapeRotation() {\n    return 0;\n  }\n  /**\n   * Returns the rotation for the text label of the corresponding shape.\n   */\n  getTextRotation() {\n    return this.state && this.state.shape ? this.state.shape.getTextRotation() : 0;\n  }\n  /**\n   * Inverts the bounds if {@link Shape#isBoundsInverted} returns true or if the\n   * horizontal style is false.\n   */\n  isPaintBoundsInverted() {\n    return !this.horizontal && !!this.state && this.state.cell.isVertex();\n  }\n  /**\n   * Sets the state of the canvas for drawing the shape.\n   */\n  configureCanvas(c, x, y, w, h) {\n    super.configureCanvas(c, x, y, w, h);\n    c.setFontColor(this.color);\n    c.setFontBackgroundColor(this.background);\n    c.setFontBorderColor(this.border);\n    c.setFontFamily(this.family);\n    c.setFontSize(this.size);\n    c.setFontStyle(this.fontStyle);\n  }\n  /**\n   * Private helper function to create SVG elements\n   */\n  getHtmlValue() {\n    let val = this.value;\n    if (this.dialect !== DIALECT.STRICTHTML) {\n      // @ts-ignore\n      val = htmlEntities(val, false);\n    }\n    // Handles trailing newlines to make sure they are visible in rendering output\n    val = replaceTrailingNewlines(val, '<div><br></div>');\n    val = this.replaceLinefeeds ? val.replace(/\\n/g, '<br/>') : val;\n    return val;\n  }\n  /**\n   * Private helper function to create SVG elements\n   */\n  getTextCss() {\n    const lh = ABSOLUTE_LINE_HEIGHT ? `${this.size * LINE_HEIGHT}px` : LINE_HEIGHT;\n    let css = `display: inline-block; font-size: ${this.size}px; ` + `font-family: ${this.family}; color: ${this.color}; line-height: ${lh}; pointer-events: ${this.pointerEvents ? 'all' : 'none'}; `;\n    matchBinaryMask(this.fontStyle, FONT.BOLD) && (css += 'font-weight: bold; ');\n    matchBinaryMask(this.fontStyle, FONT.ITALIC) && (css += 'font-style: italic; ');\n    const txtDecor = [];\n    matchBinaryMask(this.fontStyle, FONT.UNDERLINE) && txtDecor.push('underline');\n    matchBinaryMask(this.fontStyle, FONT.STRIKETHROUGH) && txtDecor.push('line-through');\n    txtDecor.length > 0 && (css += `text-decoration: ${txtDecor.join(' ')}; `);\n    return css;\n  }\n  /**\n   * Updates the HTML node(s) to reflect the latest bounds and scale.\n   */\n  redrawHtmlShape() {\n    const w = Math.max(0, Math.round(this.bounds.width / this.scale));\n    const h = Math.max(0, Math.round(this.bounds.height / this.scale));\n    const flex = `position: absolute; left: ${Math.round(this.bounds.x)}px; ` + `top: ${Math.round(this.bounds.y)}px; pointer-events: none; `;\n    const block = this.getTextCss();\n    const margin = this.margin;\n    const node = this.node;\n    SvgCanvas2D.createCss(w + 2, h, this.align, this.valign, this.wrap, this.overflow, this.clipped, this.background !== NONE ? htmlEntities(this.background, true) : null, this.border !== NONE ? htmlEntities(this.border, true) : null, flex, block, this.scale, (dx, dy, flex, item, block, ofl) => {\n      const r = this.getTextRotation();\n      let tr = (this.scale !== 1 ? `scale(${this.scale}) ` : '') + (r !== 0 ? `rotate(${r}deg) ` : '') + (margin.x !== 0 || margin.y !== 0 ? `translate(${margin.x * 100}%,${margin.y * 100}%)` : '');\n      if (tr !== '') {\n        tr = `transform-origin: 0 0; transform: ${tr}; `;\n      }\n      if (ofl === '') {\n        flex += item;\n        item = `display:inline-block; min-width: 100%; ${tr}`;\n      } else {\n        item += tr;\n        if (Client.IS_SF) {\n          item += '-webkit-clip-path: content-box;';\n        }\n      }\n      if (this.opacity < 100) {\n        block += `opacity: ${this.opacity / 100}; `;\n      }\n      node.setAttribute('style', flex);\n      const html = isNode(this.value) ?\n      // @ts-ignore\n      this.value.outerHTML : this.getHtmlValue();\n      if (!node.firstChild) {\n        node.innerHTML = `<div><div>${html}</div></div>`;\n      }\n      // @ts-ignore\n      node.firstChild.firstChild.setAttribute('style', block);\n      // @ts-ignore\n      node.firstChild.setAttribute('style', item);\n    });\n  }\n  /**\n   * Sets the inner HTML of the given element to the <value>.\n   */\n  updateInnerHtml(elt) {\n    if (isNode(this.value)) {\n      // @ts-ignore\n      elt.innerHTML = this.value.outerHTML;\n    } else {\n      let val = this.value;\n      if (this.dialect !== DIALECT.STRICTHTML) {\n        // LATER: Can be cached in updateValue\n        val = htmlEntities(val, false);\n      }\n      // Handles trailing newlines to make sure they are visible in rendering output\n      val = replaceTrailingNewlines(val, '<div>&nbsp;</div>');\n      val = this.replaceLinefeeds ? val.replace(/\\n/g, '<br/>') : val;\n      val = `<div style=\"display:inline-block;_display:inline;\">${val}</div>`;\n      elt.innerHTML = val;\n    }\n  }\n  /**\n   * Updates the HTML node(s) to reflect the latest bounds and scale.\n   */\n  updateValue() {\n    const node = this.node;\n    if (isNode(this.value)) {\n      node.innerHTML = '';\n      node.appendChild(this.value);\n    } else {\n      let val = this.value;\n      if (this.dialect !== DIALECT.STRICTHTML) {\n        val = htmlEntities(val, false);\n      }\n      // Handles trailing newlines to make sure they are visible in rendering output\n      val = replaceTrailingNewlines(val, '<div><br></div>');\n      val = this.replaceLinefeeds ? val.replace(/\\n/g, '<br/>') : val;\n      const bg = this.background !== NONE ? this.background : null;\n      const bd = this.border !== NONE ? this.border : null;\n      if (this.overflow === 'fill' || this.overflow === 'width') {\n        if (bg) {\n          node.style.backgroundColor = bg;\n        }\n        if (bd) {\n          node.style.border = `1px solid ${bd}`;\n        }\n      } else {\n        let css = '';\n        if (bg) {\n          css += `background-color:${htmlEntities(bg, true)};`;\n        }\n        if (bd) {\n          css += `border:1px solid ${htmlEntities(bd, true)};`;\n        }\n        // Wrapper DIV for background, zoom needed for inline in quirks\n        // and to measure wrapped font sizes in all browsers\n        // FIXME: Background size in quirks mode for wrapped text\n        const lh = ABSOLUTE_LINE_HEIGHT ? `${this.size * LINE_HEIGHT}px` : LINE_HEIGHT;\n        val = `<div style=\"zoom:1;${css}display:inline-block;_display:inline;text-decoration:inherit;` + `padding-bottom:1px;padding-right:1px;line-height:${lh}\">${val}</div>`;\n      }\n      node.innerHTML = val;\n      // Sets text direction\n      const divs = node.getElementsByTagName('div');\n      if (divs.length > 0) {\n        let dir = this.textDirection;\n        if (dir === TEXT_DIRECTION.AUTO && this.dialect !== DIALECT.STRICTHTML) {\n          dir = this.getAutoDirection();\n        }\n        if (dir === TEXT_DIRECTION.LTR || dir === TEXT_DIRECTION.RTL) {\n          divs[divs.length - 1].setAttribute('dir', dir);\n        } else {\n          divs[divs.length - 1].removeAttribute('dir');\n        }\n      }\n    }\n  }\n  /**\n   * Updates the HTML node(s) to reflect the latest bounds and scale.\n   */\n  updateFont(node) {\n    const {\n      style\n    } = node;\n    // @ts-ignore\n    style.lineHeight = ABSOLUTE_LINE_HEIGHT ? `${this.size * LINE_HEIGHT}px` : LINE_HEIGHT;\n    style.fontSize = `${this.size}px`;\n    style.fontFamily = this.family;\n    style.verticalAlign = 'top';\n    style.color = this.color;\n    matchBinaryMask(this.fontStyle, FONT.BOLD) ? style.fontWeight = 'bold' : style.fontWeight = '';\n    matchBinaryMask(this.fontStyle, FONT.ITALIC) ? style.fontStyle = 'italic' : style.fontStyle = '';\n    const txtDecor = [];\n    matchBinaryMask(this.fontStyle, FONT.UNDERLINE) && txtDecor.push('underline');\n    matchBinaryMask(this.fontStyle, FONT.STRIKETHROUGH) && txtDecor.push('line-through');\n    txtDecor.length > 0 && (style.textDecoration = txtDecor.join(' '));\n    if (this.align === ALIGN.CENTER) {\n      style.textAlign = 'center';\n    } else if (this.align === ALIGN.RIGHT) {\n      style.textAlign = 'right';\n    } else {\n      style.textAlign = 'left';\n    }\n  }\n  /**\n   * Updates the HTML node(s) to reflect the latest bounds and scale.\n   */\n  updateSize(node, enableWrap = false) {\n    const w = Math.max(0, Math.round(this.bounds.width / this.scale));\n    const h = Math.max(0, Math.round(this.bounds.height / this.scale));\n    const {\n      style\n    } = node;\n    // NOTE: Do not use maxWidth here because wrapping will\n    // go wrong if the cell is outside of the viewable area\n    if (this.clipped) {\n      style.overflow = 'hidden';\n      style.maxHeight = `${h}px`;\n      style.maxWidth = `${w}px`;\n    } else if (this.overflow === 'fill') {\n      style.width = `${w + 1}px`;\n      style.height = `${h + 1}px`;\n      style.overflow = 'hidden';\n    } else if (this.overflow === 'width') {\n      style.width = `${w + 1}px`;\n      style.maxHeight = `${h + 1}px`;\n      style.overflow = 'hidden';\n    }\n    if (this.wrap && w > 0) {\n      style.wordWrap = WORD_WRAP;\n      style.whiteSpace = 'normal';\n      style.width = `${w}px`;\n      if (enableWrap && this.overflow !== 'fill' && this.overflow !== 'width') {\n        let sizeDiv = node;\n        if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName === 'DIV') {\n          // @ts-ignore\n          sizeDiv = sizeDiv.firstChild;\n          if (node.style.wordWrap === 'break-word') {\n            sizeDiv.style.width = '100%';\n          }\n        }\n        let tmp = sizeDiv.offsetWidth;\n        // Workaround for text measuring in hidden containers\n        if (tmp === 0) {\n          const prev = node.parentNode;\n          node.style.visibility = 'hidden';\n          document.body.appendChild(node);\n          tmp = sizeDiv.offsetWidth;\n          node.style.visibility = '';\n          prev.appendChild(node);\n        }\n        tmp += 3;\n        if (this.clipped) {\n          tmp = Math.min(tmp, w);\n        }\n        style.width = `${tmp}px`;\n      }\n    } else {\n      style.whiteSpace = 'nowrap';\n    }\n  }\n  /**\n   * Returns the spacing as an {@link Point}.\n   */\n  updateMargin() {\n    this.margin = getAlignmentAsPoint(this.align, this.valign);\n  }\n  /**\n   * Returns the spacing as an {@link Point}.\n   */\n  getSpacing() {\n    let dx = 0;\n    let dy = 0;\n    if (this.align === ALIGN.CENTER) {\n      dx = (this.spacingLeft - this.spacingRight) / 2;\n    } else if (this.align === ALIGN.RIGHT) {\n      dx = -this.spacingRight - this.baseSpacingRight;\n    } else {\n      dx = this.spacingLeft + this.baseSpacingLeft;\n    }\n    if (this.valign === ALIGN.MIDDLE) {\n      dy = (this.spacingTop - this.spacingBottom) / 2;\n    } else if (this.valign === ALIGN.BOTTOM) {\n      dy = -this.spacingBottom - this.baseSpacingBottom;\n    } else {\n      dy = this.spacingTop + this.baseSpacingTop;\n    }\n    return new Point(dx, dy);\n  }\n}\nexport default TextShape;","map":{"version":3,"names":["Client","ABSOLUTE_LINE_HEIGHT","ALIGN","DEFAULT_FONTFAMILY","DEFAULT_FONTSIZE","DEFAULT_FONTSTYLE","DEFAULT_TEXT_DIRECTION","DIALECT","FONT","NONE","TEXT_DIRECTION","WORD_WRAP","LINE_HEIGHT","getBoundingBox","getAlignmentAsPoint","matchBinaryMask","Point","Shape","Rectangle","htmlEntities","replaceTrailingNewlines","trim","isNode","SvgCanvas2D","TextShape","constructor","value","bounds","align","CENTER","valign","MIDDLE","color","family","size","fontStyle","spacing","spacingTop","spacingRight","spacingBottom","spacingLeft","horizontal","background","border","wrap","clipped","overflow","labelPadding","textDirection","margin","unrotatedBoundingBox","flipH","flipV","baseSpacingTop","baseSpacingBottom","baseSpacingLeft","baseSpacingRight","replaceLinefeeds","verticalTextRotation","ignoreClippedStringSize","ignoreStringSize","lastValue","cacheEnabled","rotation","updateMargin","getSvgScreenOffset","checkBounds","isNaN","scale","isFinite","x","y","width","height","paint","c","update","s","w","h","updateTransform","configureCanvas","updateText","getTextRotation","node","realHtml","dialect","STRICTHTML","fmt","val","replace","dir","AUTO","getAutoDirection","LTR","RTL","DEFAULT","text","redraw","visible","nodeName","redrawHtmlShape","updateBoundingBox","canvas","createCanvas","pointerEvents","destroyCanvas","resetStyles","apply","state","old","style","fontFamily","fontSize","fontColor","verticalAlign","labelBackgroundColor","labelBorderColor","opacity","textOpacity","tmp","exec","String","length","getContentNode","result","ownerSVGElement","firstChild","boundingBox","clone","rot","labelPosition","v","verticalLabelPosition","ow","oh","offsetHeight","offsetWidth","b","getBBox","e","bbox","fromRectangle","getShapeRotation","shape","isPaintBoundsInverted","cell","isVertex","setFontColor","setFontBackgroundColor","setFontBorderColor","setFontFamily","setFontSize","setFontStyle","getHtmlValue","getTextCss","lh","css","BOLD","ITALIC","txtDecor","UNDERLINE","push","STRIKETHROUGH","join","Math","max","round","flex","block","createCss","dx","dy","item","ofl","r","tr","IS_SF","setAttribute","html","outerHTML","innerHTML","updateInnerHtml","elt","updateValue","appendChild","bg","bd","backgroundColor","divs","getElementsByTagName","removeAttribute","updateFont","lineHeight","fontWeight","textDecoration","textAlign","RIGHT","updateSize","enableWrap","maxHeight","maxWidth","wordWrap","whiteSpace","sizeDiv","prev","parentNode","visibility","document","body","min","getSpacing","BOTTOM"],"sources":["D:/ospanel/domains/react/react-intro/node_modules/@maxgraph/core/dist/view/geometry/node/TextShape.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Client from '../../../Client';\nimport { ABSOLUTE_LINE_HEIGHT, ALIGN, DEFAULT_FONTFAMILY, DEFAULT_FONTSIZE, DEFAULT_FONTSTYLE, DEFAULT_TEXT_DIRECTION, DIALECT, FONT, NONE, TEXT_DIRECTION, WORD_WRAP, LINE_HEIGHT, } from '../../../util/Constants';\nimport { getBoundingBox } from '../../../util/mathUtils';\nimport { getAlignmentAsPoint, matchBinaryMask } from '../../../util/styleUtils';\nimport Point from '../Point';\nimport Shape from '../Shape';\nimport Rectangle from '../Rectangle';\nimport { htmlEntities, replaceTrailingNewlines, trim } from '../../../util/StringUtils';\nimport { isNode } from '../../../util/domUtils';\nimport SvgCanvas2D from '../../canvas/SvgCanvas2D';\n/**\n * Extends mxShape to implement a text shape.\n * To change vertical text from bottom to top to top to bottom,\n * the following code can be used:\n * ```javascript\n * mxText.prototype.verticalTextRotation = 90;\n * ```\n * @class TextShape\n * @extends {Shape}\n */\nclass TextShape extends Shape {\n    constructor(value, bounds, align = ALIGN.CENTER, valign = ALIGN.MIDDLE, color = 'black', family = DEFAULT_FONTFAMILY, size = DEFAULT_FONTSIZE, fontStyle = DEFAULT_FONTSTYLE, spacing = 2, spacingTop = 0, spacingRight = 0, spacingBottom = 0, spacingLeft = 0, horizontal = true, background = NONE, border = NONE, wrap = false, clipped = false, overflow = 'visible', labelPadding = 0, textDirection = DEFAULT_TEXT_DIRECTION) {\n        super();\n        this.margin = null;\n        this.unrotatedBoundingBox = null;\n        this.flipH = false;\n        this.flipV = false;\n        /**\n         * Specifies the spacing to be added to the top spacing. Default is 0. Use the\n         * value 5 here to get the same label positions as in mxGraph 1.x.\n         */\n        this.baseSpacingTop = 0;\n        /**\n         * Specifies the spacing to be added to the bottom spacing. Default is 0. Use the\n         * value 1 here to get the same label positions as in mxGraph 1.x.\n         */\n        this.baseSpacingBottom = 0;\n        /**\n         * Specifies the spacing to be added to the left spacing. Default is 0.\n         */\n        this.baseSpacingLeft = 0;\n        /**\n         * Specifies the spacing to be added to the right spacing. Default is 0.\n         */\n        this.baseSpacingRight = 0;\n        /**\n         * Specifies if linefeeds in HTML labels should be replaced with BR tags.\n         * Default is true.\n         */\n        this.replaceLinefeeds = true;\n        /**\n         * Rotation for vertical text. Default is -90 (bottom to top).\n         */\n        this.verticalTextRotation = -90;\n        /**\n         * Specifies if the string size should be measured in <updateBoundingBox> if\n         * the label is clipped and the label position is center and middle. If this is\n         * true, then the bounding box will be set to <bounds>. Default is true.\n         * <ignoreStringSize> has precedence over this switch.\n         */\n        this.ignoreClippedStringSize = true;\n        /**\n         * Specifies if the actual string size should be measured. If disabled the\n         * boundingBox will not ignore the actual size of the string, otherwise\n         * <bounds> will be used instead. Default is false.\n         */\n        this.ignoreStringSize = false;\n        /**\n         * Contains the last rendered text value. Used for caching.\n         */\n        this.lastValue = null;\n        /**\n         * Specifies if caching for HTML labels should be enabled. Default is true.\n         */\n        this.cacheEnabled = true;\n        this.value = value;\n        this.bounds = bounds;\n        this.color = color ?? 'black';\n        this.align = align ?? ALIGN.CENTER;\n        this.valign = valign ?? ALIGN.MIDDLE;\n        this.family = family ?? DEFAULT_FONTFAMILY;\n        this.size = size ?? DEFAULT_FONTSIZE;\n        this.fontStyle = fontStyle ?? DEFAULT_FONTSTYLE;\n        this.spacing = spacing ?? 2;\n        this.spacingTop = this.spacing + (spacingTop ?? 0);\n        this.spacingRight = this.spacing + (spacingRight ?? 0);\n        this.spacingBottom = this.spacing + (spacingBottom ?? 0);\n        this.spacingLeft = this.spacing + (spacingLeft ?? 0);\n        this.horizontal = horizontal ?? true;\n        this.background = background;\n        this.border = border;\n        this.wrap = wrap ?? false;\n        this.clipped = clipped ?? false;\n        this.overflow = overflow ?? 'visible';\n        this.labelPadding = labelPadding ?? 0;\n        this.textDirection = textDirection;\n        this.rotation = 0;\n        this.updateMargin();\n    }\n    /**\n     * Disables offset in IE9 for crisper image output.\n     */\n    getSvgScreenOffset() {\n        return 0;\n    }\n    /**\n     * Returns true if the bounds are not null and all of its variables are numeric.\n     */\n    checkBounds() {\n        return (!isNaN(this.scale) &&\n            isFinite(this.scale) &&\n            this.scale > 0 &&\n            this.bounds &&\n            !isNaN(this.bounds.x) &&\n            !isNaN(this.bounds.y) &&\n            !isNaN(this.bounds.width) &&\n            !isNaN(this.bounds.height));\n    }\n    /**\n     * Generic rendering code.\n     */\n    paint(c, update = false) {\n        // Scale is passed-through to canvas\n        const s = this.scale;\n        const x = this.bounds.x / s;\n        const y = this.bounds.y / s;\n        const w = this.bounds.width / s;\n        const h = this.bounds.height / s;\n        this.updateTransform(c, x, y, w, h);\n        this.configureCanvas(c, x, y, w, h);\n        if (update) {\n            c.updateText(x, y, w, h, this.align, this.valign, this.wrap, this.overflow, this.clipped, this.getTextRotation(), this.node);\n        }\n        else {\n            // Checks if text contains HTML markup\n            const realHtml = isNode(this.value) || this.dialect === DIALECT.STRICTHTML;\n            // Always renders labels as HTML in VML\n            const fmt = realHtml ? 'html' : '';\n            let val = this.value;\n            if (!realHtml && fmt === 'html') {\n                // @ts-ignore\n                val = htmlEntities(val, false);\n            }\n            if (fmt === 'html' && !isNode(this.value)) {\n                val = replaceTrailingNewlines(val, '<div><br></div>');\n            }\n            // Handles trailing newlines to make sure they are visible in rendering output\n            val =\n                !isNode(this.value) && this.replaceLinefeeds && fmt === 'html'\n                    ? val.replace(/\\n/g, '<br/>')\n                    : val;\n            let dir = this.textDirection;\n            if (dir === TEXT_DIRECTION.AUTO && !realHtml) {\n                dir = this.getAutoDirection();\n            }\n            if (dir !== TEXT_DIRECTION.LTR && dir !== TEXT_DIRECTION.RTL) {\n                dir = TEXT_DIRECTION.DEFAULT;\n            }\n            c.text(x, y, w, h, val, this.align, this.valign, this.wrap, fmt, this.overflow, this.clipped, this.getTextRotation(), dir);\n        }\n    }\n    /**\n     * Renders the text using the given DOM nodes.\n     */\n    redraw() {\n        if (this.visible &&\n            this.checkBounds() &&\n            this.cacheEnabled &&\n            this.lastValue === this.value &&\n            (isNode(this.value) || this.dialect === DIALECT.STRICTHTML)) {\n            if (this.node.nodeName === 'DIV') {\n                this.redrawHtmlShape();\n                this.updateBoundingBox();\n            }\n            else {\n                const canvas = this.createCanvas();\n                if (canvas) {\n                    // Specifies if events should be handled\n                    canvas.pointerEvents = this.pointerEvents;\n                    this.paint(canvas, true);\n                    this.destroyCanvas(canvas);\n                    this.updateBoundingBox();\n                }\n            }\n        }\n        else {\n            super.redraw();\n            if (isNode(this.value) || this.dialect === DIALECT.STRICTHTML) {\n                this.lastValue = this.value;\n            }\n            else {\n                this.lastValue = null;\n            }\n        }\n    }\n    /**\n     * Resets all styles.\n     */\n    resetStyles() {\n        super.resetStyles();\n        this.color = 'black';\n        this.align = ALIGN.CENTER;\n        this.valign = ALIGN.MIDDLE;\n        this.family = DEFAULT_FONTFAMILY;\n        this.size = DEFAULT_FONTSIZE;\n        this.fontStyle = DEFAULT_FONTSTYLE;\n        this.spacing = 2;\n        this.spacingTop = 2;\n        this.spacingRight = 2;\n        this.spacingBottom = 2;\n        this.spacingLeft = 2;\n        this.horizontal = true;\n        this.background = NONE;\n        this.border = NONE;\n        this.textDirection = DEFAULT_TEXT_DIRECTION;\n        this.margin = null;\n    }\n    /**\n     * Extends mxShape to update the text styles.\n     *\n     * @param state <CellState> of the corresponding cell.\n     */\n    apply(state) {\n        const old = this.spacing;\n        super.apply(state);\n        if (this.style) {\n            this.fontStyle = this.style.fontStyle ?? this.fontStyle;\n            this.family = this.style.fontFamily ?? this.family;\n            this.size = this.style.fontSize ?? this.size;\n            this.color = this.style.fontColor ?? this.color;\n            this.align = this.style.align ?? this.align;\n            this.valign = this.style.verticalAlign ?? this.valign;\n            this.spacing = this.style.spacing ?? this.spacing;\n            this.spacingTop = (this.style.spacingTop ?? this.spacingTop - old) + this.spacing;\n            this.spacingRight =\n                (this.style.spacingRight ?? this.spacingRight - old) + this.spacing;\n            this.spacingBottom =\n                (this.style.spacingBottom ?? this.spacingBottom - old) + this.spacing;\n            this.spacingLeft =\n                (this.style.spacingLeft ?? this.spacingLeft - old) + this.spacing;\n            this.horizontal = this.style.horizontal ?? this.horizontal;\n            this.background = this.style.labelBackgroundColor ?? this.background;\n            this.border = this.style.labelBorderColor ?? this.border;\n            this.textDirection = this.style.textDirection ?? DEFAULT_TEXT_DIRECTION;\n            this.opacity = this.style.textOpacity ?? 100;\n            this.updateMargin();\n        }\n        this.flipV = false;\n        this.flipH = false;\n    }\n    /**\n     * Used to determine the automatic text direction. Returns\n     * {@link Constants#TEXT_DIRECTION_LTR} or {@link Constants#TEXT_DIRECTION_RTL}\n     * depending on the contents of <value>. This is not invoked for HTML, wrapped\n     * content or if <value> is a DOM node.\n     */\n    getAutoDirection() {\n        // Looks for strong (directional) characters\n        const tmp = /[A-Za-z\\u05d0-\\u065f\\u066a-\\u06ef\\u06fa-\\u07ff\\ufb1d-\\ufdff\\ufe70-\\ufefc]/.exec(String(this.value));\n        // Returns the direction defined by the character\n        return tmp && tmp.length > 0 && tmp[0] > 'z'\n            ? TEXT_DIRECTION.RTL\n            : TEXT_DIRECTION.LTR;\n    }\n    /**\n     * Returns the node that contains the rendered input.\n     */\n    getContentNode() {\n        let result = this.node;\n        if (result) {\n            // Rendered with no foreignObject\n            if (!result.ownerSVGElement) {\n                // @ts-ignore\n                result = this.node.firstChild.firstChild;\n            }\n            else {\n                // Innermost DIV that contains the actual content\n                // @ts-ignore\n                result = result.firstChild.firstChild.firstChild.firstChild.firstChild;\n            }\n        }\n        return result;\n    }\n    /**\n     * Updates the <boundingBox> for this shape using the given node and position.\n     */\n    updateBoundingBox() {\n        let { node } = this;\n        this.boundingBox = this.bounds.clone();\n        const rot = this.getTextRotation();\n        const h = this.style?.labelPosition ?? ALIGN.CENTER;\n        const v = this.style?.verticalLabelPosition ?? ALIGN.MIDDLE;\n        if (!this.ignoreStringSize &&\n            node &&\n            this.overflow !== 'fill' &&\n            (!this.clipped ||\n                !this.ignoreClippedStringSize ||\n                h !== ALIGN.CENTER ||\n                v !== ALIGN.MIDDLE)) {\n            let ow = null;\n            let oh = null;\n            if (node.firstChild &&\n                node.firstChild.firstChild &&\n                node.firstChild.firstChild.nodeName === 'foreignObject') {\n                // Uses second inner DIV for font metrics\n                // @ts-ignore\n                node = node.firstChild.firstChild.firstChild.firstChild;\n                // @ts-ignore\n                oh = node.offsetHeight * this.scale;\n                if (this.overflow === 'width') {\n                    ow = this.boundingBox.width;\n                }\n                else {\n                    // @ts-ignore\n                    ow = node.offsetWidth * this.scale;\n                }\n            }\n            else {\n                try {\n                    const b = node.getBBox();\n                    // Workaround for bounding box of empty string\n                    if (typeof this.value === 'string' && trim(this.value)?.length === 0) {\n                        this.boundingBox = null;\n                    }\n                    else if (b.width === 0 && b.height === 0) {\n                        this.boundingBox = null;\n                    }\n                    else {\n                        this.boundingBox = new Rectangle(b.x, b.y, b.width, b.height);\n                    }\n                    return;\n                }\n                catch (e) {\n                    // Ignores NS_ERROR_FAILURE in FF if container display is none.\n                }\n            }\n            if (ow && oh) {\n                this.boundingBox = new Rectangle(this.bounds.x, this.bounds.y, ow, oh);\n            }\n        }\n        if (this.boundingBox) {\n            const margin = this.margin;\n            if (rot !== 0) {\n                // Accounts for pre-rotated x and y\n                const bbox = (getBoundingBox(new Rectangle(margin.x * this.boundingBox.width, margin.y * this.boundingBox.height, this.boundingBox.width, this.boundingBox.height), rot, new Point(0, 0)));\n                this.unrotatedBoundingBox = Rectangle.fromRectangle(this.boundingBox);\n                this.unrotatedBoundingBox.x += margin.x * this.unrotatedBoundingBox.width;\n                this.unrotatedBoundingBox.y += margin.y * this.unrotatedBoundingBox.height;\n                this.boundingBox.x += bbox.x;\n                this.boundingBox.y += bbox.y;\n                this.boundingBox.width = bbox.width;\n                this.boundingBox.height = bbox.height;\n            }\n            else {\n                this.boundingBox.x += margin.x * this.boundingBox.width;\n                this.boundingBox.y += margin.y * this.boundingBox.height;\n                this.unrotatedBoundingBox = null;\n            }\n        }\n    }\n    /**\n     * Returns 0 to avoid using rotation in the canvas via updateTransform.\n     */\n    getShapeRotation() {\n        return 0;\n    }\n    /**\n     * Returns the rotation for the text label of the corresponding shape.\n     */\n    getTextRotation() {\n        return this.state && this.state.shape ? this.state.shape.getTextRotation() : 0;\n    }\n    /**\n     * Inverts the bounds if {@link Shape#isBoundsInverted} returns true or if the\n     * horizontal style is false.\n     */\n    isPaintBoundsInverted() {\n        return !this.horizontal && !!this.state && this.state.cell.isVertex();\n    }\n    /**\n     * Sets the state of the canvas for drawing the shape.\n     */\n    configureCanvas(c, x, y, w, h) {\n        super.configureCanvas(c, x, y, w, h);\n        c.setFontColor(this.color);\n        c.setFontBackgroundColor(this.background);\n        c.setFontBorderColor(this.border);\n        c.setFontFamily(this.family);\n        c.setFontSize(this.size);\n        c.setFontStyle(this.fontStyle);\n    }\n    /**\n     * Private helper function to create SVG elements\n     */\n    getHtmlValue() {\n        let val = this.value;\n        if (this.dialect !== DIALECT.STRICTHTML) {\n            // @ts-ignore\n            val = htmlEntities(val, false);\n        }\n        // Handles trailing newlines to make sure they are visible in rendering output\n        val = replaceTrailingNewlines(val, '<div><br></div>');\n        val = this.replaceLinefeeds ? val.replace(/\\n/g, '<br/>') : val;\n        return val;\n    }\n    /**\n     * Private helper function to create SVG elements\n     */\n    getTextCss() {\n        const lh = ABSOLUTE_LINE_HEIGHT ? `${this.size * LINE_HEIGHT}px` : LINE_HEIGHT;\n        let css = `display: inline-block; font-size: ${this.size}px; ` +\n            `font-family: ${this.family}; color: ${this.color}; line-height: ${lh}; pointer-events: ${this.pointerEvents ? 'all' : 'none'}; `;\n        matchBinaryMask(this.fontStyle, FONT.BOLD) && (css += 'font-weight: bold; ');\n        matchBinaryMask(this.fontStyle, FONT.ITALIC) && (css += 'font-style: italic; ');\n        const txtDecor = [];\n        matchBinaryMask(this.fontStyle, FONT.UNDERLINE) && txtDecor.push('underline');\n        matchBinaryMask(this.fontStyle, FONT.STRIKETHROUGH) && txtDecor.push('line-through');\n        txtDecor.length > 0 && (css += `text-decoration: ${txtDecor.join(' ')}; `);\n        return css;\n    }\n    /**\n     * Updates the HTML node(s) to reflect the latest bounds and scale.\n     */\n    redrawHtmlShape() {\n        const w = Math.max(0, Math.round(this.bounds.width / this.scale));\n        const h = Math.max(0, Math.round(this.bounds.height / this.scale));\n        const flex = `position: absolute; left: ${Math.round(this.bounds.x)}px; ` +\n            `top: ${Math.round(this.bounds.y)}px; pointer-events: none; `;\n        const block = this.getTextCss();\n        const margin = this.margin;\n        const node = this.node;\n        SvgCanvas2D.createCss(w + 2, h, this.align, this.valign, this.wrap, this.overflow, this.clipped, this.background !== NONE ? htmlEntities(this.background, true) : null, this.border !== NONE ? htmlEntities(this.border, true) : null, flex, block, this.scale, (dx, dy, flex, item, block, ofl) => {\n            const r = this.getTextRotation();\n            let tr = (this.scale !== 1 ? `scale(${this.scale}) ` : '') +\n                (r !== 0 ? `rotate(${r}deg) ` : '') +\n                (margin.x !== 0 || margin.y !== 0\n                    ? `translate(${margin.x * 100}%,${margin.y * 100}%)`\n                    : '');\n            if (tr !== '') {\n                tr = `transform-origin: 0 0; transform: ${tr}; `;\n            }\n            if (ofl === '') {\n                flex += item;\n                item = `display:inline-block; min-width: 100%; ${tr}`;\n            }\n            else {\n                item += tr;\n                if (Client.IS_SF) {\n                    item += '-webkit-clip-path: content-box;';\n                }\n            }\n            if (this.opacity < 100) {\n                block += `opacity: ${this.opacity / 100}; `;\n            }\n            node.setAttribute('style', flex);\n            const html = isNode(this.value)\n                ? // @ts-ignore\n                    this.value.outerHTML\n                : this.getHtmlValue();\n            if (!node.firstChild) {\n                node.innerHTML = `<div><div>${html}</div></div>`;\n            }\n            // @ts-ignore\n            node.firstChild.firstChild.setAttribute('style', block);\n            // @ts-ignore\n            node.firstChild.setAttribute('style', item);\n        });\n    }\n    /**\n     * Sets the inner HTML of the given element to the <value>.\n     */\n    updateInnerHtml(elt) {\n        if (isNode(this.value)) {\n            // @ts-ignore\n            elt.innerHTML = this.value.outerHTML;\n        }\n        else {\n            let val = this.value;\n            if (this.dialect !== DIALECT.STRICTHTML) {\n                // LATER: Can be cached in updateValue\n                val = htmlEntities(val, false);\n            }\n            // Handles trailing newlines to make sure they are visible in rendering output\n            val = replaceTrailingNewlines(val, '<div>&nbsp;</div>');\n            val = this.replaceLinefeeds ? val.replace(/\\n/g, '<br/>') : val;\n            val = `<div style=\"display:inline-block;_display:inline;\">${val}</div>`;\n            elt.innerHTML = val;\n        }\n    }\n    /**\n     * Updates the HTML node(s) to reflect the latest bounds and scale.\n     */\n    updateValue() {\n        const node = this.node;\n        if (isNode(this.value)) {\n            node.innerHTML = '';\n            node.appendChild(this.value);\n        }\n        else {\n            let val = this.value;\n            if (this.dialect !== DIALECT.STRICTHTML) {\n                val = htmlEntities(val, false);\n            }\n            // Handles trailing newlines to make sure they are visible in rendering output\n            val = replaceTrailingNewlines(val, '<div><br></div>');\n            val = this.replaceLinefeeds ? val.replace(/\\n/g, '<br/>') : val;\n            const bg = this.background !== NONE ? this.background : null;\n            const bd = this.border !== NONE ? this.border : null;\n            if (this.overflow === 'fill' || this.overflow === 'width') {\n                if (bg) {\n                    node.style.backgroundColor = bg;\n                }\n                if (bd) {\n                    node.style.border = `1px solid ${bd}`;\n                }\n            }\n            else {\n                let css = '';\n                if (bg) {\n                    css += `background-color:${htmlEntities(bg, true)};`;\n                }\n                if (bd) {\n                    css += `border:1px solid ${htmlEntities(bd, true)};`;\n                }\n                // Wrapper DIV for background, zoom needed for inline in quirks\n                // and to measure wrapped font sizes in all browsers\n                // FIXME: Background size in quirks mode for wrapped text\n                const lh = ABSOLUTE_LINE_HEIGHT ? `${this.size * LINE_HEIGHT}px` : LINE_HEIGHT;\n                val =\n                    `<div style=\"zoom:1;${css}display:inline-block;_display:inline;text-decoration:inherit;` +\n                        `padding-bottom:1px;padding-right:1px;line-height:${lh}\">${val}</div>`;\n            }\n            node.innerHTML = val;\n            // Sets text direction\n            const divs = node.getElementsByTagName('div');\n            if (divs.length > 0) {\n                let dir = this.textDirection;\n                if (dir === TEXT_DIRECTION.AUTO && this.dialect !== DIALECT.STRICTHTML) {\n                    dir = this.getAutoDirection();\n                }\n                if (dir === TEXT_DIRECTION.LTR || dir === TEXT_DIRECTION.RTL) {\n                    divs[divs.length - 1].setAttribute('dir', dir);\n                }\n                else {\n                    divs[divs.length - 1].removeAttribute('dir');\n                }\n            }\n        }\n    }\n    /**\n     * Updates the HTML node(s) to reflect the latest bounds and scale.\n     */\n    updateFont(node) {\n        const { style } = node;\n        // @ts-ignore\n        style.lineHeight = ABSOLUTE_LINE_HEIGHT\n            ? `${this.size * LINE_HEIGHT}px`\n            : LINE_HEIGHT;\n        style.fontSize = `${this.size}px`;\n        style.fontFamily = this.family;\n        style.verticalAlign = 'top';\n        style.color = this.color;\n        matchBinaryMask(this.fontStyle, FONT.BOLD)\n            ? (style.fontWeight = 'bold')\n            : (style.fontWeight = '');\n        matchBinaryMask(this.fontStyle, FONT.ITALIC)\n            ? (style.fontStyle = 'italic')\n            : (style.fontStyle = '');\n        const txtDecor = [];\n        matchBinaryMask(this.fontStyle, FONT.UNDERLINE) && txtDecor.push('underline');\n        matchBinaryMask(this.fontStyle, FONT.STRIKETHROUGH) && txtDecor.push('line-through');\n        txtDecor.length > 0 && (style.textDecoration = txtDecor.join(' '));\n        if (this.align === ALIGN.CENTER) {\n            style.textAlign = 'center';\n        }\n        else if (this.align === ALIGN.RIGHT) {\n            style.textAlign = 'right';\n        }\n        else {\n            style.textAlign = 'left';\n        }\n    }\n    /**\n     * Updates the HTML node(s) to reflect the latest bounds and scale.\n     */\n    updateSize(node, enableWrap = false) {\n        const w = Math.max(0, Math.round(this.bounds.width / this.scale));\n        const h = Math.max(0, Math.round(this.bounds.height / this.scale));\n        const { style } = node;\n        // NOTE: Do not use maxWidth here because wrapping will\n        // go wrong if the cell is outside of the viewable area\n        if (this.clipped) {\n            style.overflow = 'hidden';\n            style.maxHeight = `${h}px`;\n            style.maxWidth = `${w}px`;\n        }\n        else if (this.overflow === 'fill') {\n            style.width = `${w + 1}px`;\n            style.height = `${h + 1}px`;\n            style.overflow = 'hidden';\n        }\n        else if (this.overflow === 'width') {\n            style.width = `${w + 1}px`;\n            style.maxHeight = `${h + 1}px`;\n            style.overflow = 'hidden';\n        }\n        if (this.wrap && w > 0) {\n            style.wordWrap = WORD_WRAP;\n            style.whiteSpace = 'normal';\n            style.width = `${w}px`;\n            if (enableWrap && this.overflow !== 'fill' && this.overflow !== 'width') {\n                let sizeDiv = node;\n                if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName === 'DIV') {\n                    // @ts-ignore\n                    sizeDiv = sizeDiv.firstChild;\n                    if (node.style.wordWrap === 'break-word') {\n                        sizeDiv.style.width = '100%';\n                    }\n                }\n                let tmp = sizeDiv.offsetWidth;\n                // Workaround for text measuring in hidden containers\n                if (tmp === 0) {\n                    const prev = node.parentNode;\n                    node.style.visibility = 'hidden';\n                    document.body.appendChild(node);\n                    tmp = sizeDiv.offsetWidth;\n                    node.style.visibility = '';\n                    prev.appendChild(node);\n                }\n                tmp += 3;\n                if (this.clipped) {\n                    tmp = Math.min(tmp, w);\n                }\n                style.width = `${tmp}px`;\n            }\n        }\n        else {\n            style.whiteSpace = 'nowrap';\n        }\n    }\n    /**\n     * Returns the spacing as an {@link Point}.\n     */\n    updateMargin() {\n        this.margin = getAlignmentAsPoint(this.align, this.valign);\n    }\n    /**\n     * Returns the spacing as an {@link Point}.\n     */\n    getSpacing() {\n        let dx = 0;\n        let dy = 0;\n        if (this.align === ALIGN.CENTER) {\n            dx = (this.spacingLeft - this.spacingRight) / 2;\n        }\n        else if (this.align === ALIGN.RIGHT) {\n            dx = -this.spacingRight - this.baseSpacingRight;\n        }\n        else {\n            dx = this.spacingLeft + this.baseSpacingLeft;\n        }\n        if (this.valign === ALIGN.MIDDLE) {\n            dy = (this.spacingTop - this.spacingBottom) / 2;\n        }\n        else if (this.valign === ALIGN.BOTTOM) {\n            dy = -this.spacingBottom - this.baseSpacingBottom;\n        }\n        else {\n            dy = this.spacingTop + this.baseSpacingTop;\n        }\n        return new Point(dx, dy);\n    }\n}\nexport default TextShape;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}