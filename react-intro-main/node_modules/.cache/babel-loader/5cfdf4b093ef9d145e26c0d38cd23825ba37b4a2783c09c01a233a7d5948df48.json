{"ast":null,"code":"var _EventProfiling, _LeakageMonitor;\nimport { onUnexpectedError } from './errors.js';\nimport { createSingleCallFunction } from './functional.js';\nimport { combinedDisposable, Disposable, DisposableStore, toDisposable } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { StopWatch } from './stopwatch.js';\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a listener is GC'ed without having been disposed. This is a LEAK.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableListenerGCedWarning = false;\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableDisposeWithListenerWarning = false;\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableSnapshotPotentialLeakWarning = false;\nexport var Event;\n(function (Event) {\n  Event.None = () => Disposable.None;\n  function _addLeakageTraceLogic(options) {\n    if (_enableSnapshotPotentialLeakWarning) {\n      const {\n        onDidAddListener: origListenerDidAdd\n      } = options;\n      const stack = Stacktrace.create();\n      let count = 0;\n      options.onDidAddListener = () => {\n        if (++count === 2) {\n          console.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\n          stack.print();\n        }\n        origListenerDidAdd === null || origListenerDidAdd === void 0 || origListenerDidAdd();\n      };\n    }\n  }\n  /**\n   * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared\n   * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a\n   * result of merging events and to try prevent race conditions that could arise when using related deferred and\n   * non-deferred events.\n   *\n   * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work\n   * (eg. latency of keypress to text rendered).\n   *\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   *\n   * @param event The event source for the new event.\n   * @param disposable A disposable store to add the new EventEmitter to.\n   */\n  function defer(event, disposable) {\n    return debounce(event, () => void 0, 0, undefined, true, undefined, disposable);\n  }\n  Event.defer = defer;\n  /**\n   * Given an event, returns another event which only fires once.\n   *\n   * @param event The event source for the new event.\n   */\n  function once(event) {\n    return function (listener) {\n      let thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let disposables = arguments.length > 2 ? arguments[2] : undefined;\n      // we need this, in case the event fires during the listener call\n      let didFire = false;\n      let result = undefined;\n      result = event(e => {\n        if (didFire) {\n          return;\n        } else if (result) {\n          result.dispose();\n        } else {\n          didFire = true;\n        }\n        return listener.call(thisArgs, e);\n      }, null, disposables);\n      if (didFire) {\n        result.dispose();\n      }\n      return result;\n    };\n  }\n  Event.once = once;\n  /**\n   * Given an event, returns another event which only fires once, and only when the condition is met.\n   *\n   * @param event The event source for the new event.\n   */\n  function onceIf(event, condition) {\n    return Event.once(Event.filter(event, condition));\n  }\n  Event.onceIf = onceIf;\n  /**\n   * Maps an event of one type into an event of another type using a mapping function, similar to how\n   * `Array.prototype.map` works.\n   *\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   *\n   * @param event The event source for the new event.\n   * @param map The mapping function.\n   * @param disposable A disposable store to add the new EventEmitter to.\n   */\n  function map(event, map, disposable) {\n    return snapshot(function (listener) {\n      let thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return event(i => listener.call(thisArgs, map(i)), null, disposables);\n    }, disposable);\n  }\n  Event.map = map;\n  /**\n   * Wraps an event in another event that performs some function on the event object before firing.\n   *\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   *\n   * @param event The event source for the new event.\n   * @param each The function to perform on the event object.\n   * @param disposable A disposable store to add the new EventEmitter to.\n   */\n  function forEach(event, each, disposable) {\n    return snapshot(function (listener) {\n      let thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return event(i => {\n        each(i);\n        listener.call(thisArgs, i);\n      }, null, disposables);\n    }, disposable);\n  }\n  Event.forEach = forEach;\n  function filter(event, filter, disposable) {\n    return snapshot(function (listener) {\n      let thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return event(e => filter(e) && listener.call(thisArgs, e), null, disposables);\n    }, disposable);\n  }\n  Event.filter = filter;\n  /**\n   * Given an event, returns the same event but typed as `Event<void>`.\n   */\n  function signal(event) {\n    return event;\n  }\n  Event.signal = signal;\n  function any() {\n    for (var _len = arguments.length, events = new Array(_len), _key = 0; _key < _len; _key++) {\n      events[_key] = arguments[_key];\n    }\n    return function (listener) {\n      let thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let disposables = arguments.length > 2 ? arguments[2] : undefined;\n      const disposable = combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e))));\n      return addAndReturnDisposable(disposable, disposables);\n    };\n  }\n  Event.any = any;\n  /**\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   */\n  function reduce(event, merge, initial, disposable) {\n    let output = initial;\n    return map(event, e => {\n      output = merge(output, e);\n      return output;\n    }, disposable);\n  }\n  Event.reduce = reduce;\n  function snapshot(event, disposable) {\n    let listener;\n    const options = {\n      onWillAddFirstListener() {\n        listener = event(emitter.fire, emitter);\n      },\n      onDidRemoveLastListener() {\n        var _listener;\n        (_listener = listener) === null || _listener === void 0 || _listener.dispose();\n      }\n    };\n    if (!disposable) {\n      _addLeakageTraceLogic(options);\n    }\n    const emitter = new Emitter(options);\n    disposable === null || disposable === void 0 || disposable.add(emitter);\n    return emitter.event;\n  }\n  /**\n   * Adds the IDisposable to the store if it's set, and returns it. Useful to\n   * Event function implementation.\n   */\n  function addAndReturnDisposable(d, store) {\n    if (store instanceof Array) {\n      store.push(d);\n    } else if (store) {\n      store.add(d);\n    }\n    return d;\n  }\n  function debounce(event, merge) {\n    let delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n    let leading = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let flushOnListenerRemove = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    let leakWarningThreshold = arguments.length > 5 ? arguments[5] : undefined;\n    let disposable = arguments.length > 6 ? arguments[6] : undefined;\n    let subscription;\n    let output = undefined;\n    let handle = undefined;\n    let numDebouncedCalls = 0;\n    let doFire;\n    const options = {\n      leakWarningThreshold,\n      onWillAddFirstListener() {\n        subscription = event(cur => {\n          numDebouncedCalls++;\n          output = merge(output, cur);\n          if (leading && !handle) {\n            emitter.fire(output);\n            output = undefined;\n          }\n          doFire = () => {\n            const _output = output;\n            output = undefined;\n            handle = undefined;\n            if (!leading || numDebouncedCalls > 1) {\n              emitter.fire(_output);\n            }\n            numDebouncedCalls = 0;\n          };\n          if (typeof delay === 'number') {\n            clearTimeout(handle);\n            handle = setTimeout(doFire, delay);\n          } else {\n            if (handle === undefined) {\n              handle = 0;\n              queueMicrotask(doFire);\n            }\n          }\n        });\n      },\n      onWillRemoveListener() {\n        if (flushOnListenerRemove && numDebouncedCalls > 0) {\n          var _doFire;\n          (_doFire = doFire) === null || _doFire === void 0 || _doFire();\n        }\n      },\n      onDidRemoveLastListener() {\n        doFire = undefined;\n        subscription.dispose();\n      }\n    };\n    if (!disposable) {\n      _addLeakageTraceLogic(options);\n    }\n    const emitter = new Emitter(options);\n    disposable === null || disposable === void 0 || disposable.add(emitter);\n    return emitter.event;\n  }\n  Event.debounce = debounce;\n  /**\n   * Debounces an event, firing after some delay (default=0) with an array of all event original objects.\n   *\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   */\n  function accumulate(event) {\n    let delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let disposable = arguments.length > 2 ? arguments[2] : undefined;\n    return Event.debounce(event, (last, e) => {\n      if (!last) {\n        return [e];\n      }\n      last.push(e);\n      return last;\n    }, delay, undefined, true, undefined, disposable);\n  }\n  Event.accumulate = accumulate;\n  /**\n   * Filters an event such that some condition is _not_ met more than once in a row, effectively ensuring duplicate\n   * event objects from different sources do not fire the same event object.\n   *\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   *\n   * @param event The event source for the new event.\n   * @param equals The equality condition.\n   * @param disposable A disposable store to add the new EventEmitter to.\n   *\n   * @example\n   * ```\n   * // Fire only one time when a single window is opened or focused\n   * Event.latch(Event.any(onDidOpenWindow, onDidFocusWindow))\n   * ```\n   */\n  function latch(event) {\n    let equals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (a, b) => a === b;\n    let disposable = arguments.length > 2 ? arguments[2] : undefined;\n    let firstCall = true;\n    let cache;\n    return filter(event, value => {\n      const shouldEmit = firstCall || !equals(value, cache);\n      firstCall = false;\n      cache = value;\n      return shouldEmit;\n    }, disposable);\n  }\n  Event.latch = latch;\n  /**\n   * Splits an event whose parameter is a union type into 2 separate events for each type in the union.\n   *\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   *\n   * @example\n   * ```\n   * const event = new EventEmitter<number | undefined>().event;\n   * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);\n   * ```\n   *\n   * @param event The event source for the new event.\n   * @param isT A function that determines what event is of the first type.\n   * @param disposable A disposable store to add the new EventEmitter to.\n   */\n  function split(event, isT, disposable) {\n    return [Event.filter(event, isT, disposable), Event.filter(event, e => !isT(e), disposable)];\n  }\n  Event.split = split;\n  /**\n   * Buffers an event until it has a listener attached.\n   *\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   *\n   * @param event The event source for the new event.\n   * @param flushAfterTimeout Determines whether to flush the buffer after a timeout immediately or after a\n   * `setTimeout` when the first event listener is added.\n   * @param _buffer Internal: A source event array used for tests.\n   *\n   * @example\n   * ```\n   * // Start accumulating events, when the first listener is attached, flush\n   * // the event after a timeout such that multiple listeners attached before\n   * // the timeout would receive the event\n   * this.onInstallExtension = Event.buffer(service.onInstallExtension, true);\n   * ```\n   */\n  function buffer(event) {\n    let flushAfterTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let _buffer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let disposable = arguments.length > 3 ? arguments[3] : undefined;\n    let buffer = _buffer.slice();\n    let listener = event(e => {\n      if (buffer) {\n        buffer.push(e);\n      } else {\n        emitter.fire(e);\n      }\n    });\n    if (disposable) {\n      disposable.add(listener);\n    }\n    const flush = () => {\n      var _buffer2;\n      (_buffer2 = buffer) === null || _buffer2 === void 0 || _buffer2.forEach(e => emitter.fire(e));\n      buffer = null;\n    };\n    const emitter = new Emitter({\n      onWillAddFirstListener() {\n        if (!listener) {\n          listener = event(e => emitter.fire(e));\n          if (disposable) {\n            disposable.add(listener);\n          }\n        }\n      },\n      onDidAddFirstListener() {\n        if (buffer) {\n          if (flushAfterTimeout) {\n            setTimeout(flush);\n          } else {\n            flush();\n          }\n        }\n      },\n      onDidRemoveLastListener() {\n        if (listener) {\n          listener.dispose();\n        }\n        listener = null;\n      }\n    });\n    if (disposable) {\n      disposable.add(emitter);\n    }\n    return emitter.event;\n  }\n  Event.buffer = buffer;\n  /**\n   * Wraps the event in an {@link IChainableEvent}, allowing a more functional programming style.\n   *\n   * @example\n   * ```\n   * // Normal\n   * const onEnterPressNormal = Event.filter(\n   *   Event.map(onKeyPress.event, e => new StandardKeyboardEvent(e)),\n   *   e.keyCode === KeyCode.Enter\n   * ).event;\n   *\n   * // Using chain\n   * const onEnterPressChain = Event.chain(onKeyPress.event, $ => $\n   *   .map(e => new StandardKeyboardEvent(e))\n   *   .filter(e => e.keyCode === KeyCode.Enter)\n   * );\n   * ```\n   */\n  function chain(event, sythensize) {\n    const fn = (listener, thisArgs, disposables) => {\n      const cs = sythensize(new ChainableSynthesis());\n      return event(function (value) {\n        const result = cs.evaluate(value);\n        if (result !== HaltChainable) {\n          listener.call(thisArgs, result);\n        }\n      }, undefined, disposables);\n    };\n    return fn;\n  }\n  Event.chain = chain;\n  const HaltChainable = Symbol('HaltChainable');\n  class ChainableSynthesis {\n    constructor() {\n      this.steps = [];\n    }\n    map(fn) {\n      this.steps.push(fn);\n      return this;\n    }\n    forEach(fn) {\n      this.steps.push(v => {\n        fn(v);\n        return v;\n      });\n      return this;\n    }\n    filter(fn) {\n      this.steps.push(v => fn(v) ? v : HaltChainable);\n      return this;\n    }\n    reduce(merge, initial) {\n      let last = initial;\n      this.steps.push(v => {\n        last = merge(last, v);\n        return last;\n      });\n      return this;\n    }\n    latch() {\n      let equals = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (a, b) => a === b;\n      let firstCall = true;\n      let cache;\n      this.steps.push(value => {\n        const shouldEmit = firstCall || !equals(value, cache);\n        firstCall = false;\n        cache = value;\n        return shouldEmit ? value : HaltChainable;\n      });\n      return this;\n    }\n    evaluate(value) {\n      for (const step of this.steps) {\n        value = step(value);\n        if (value === HaltChainable) {\n          break;\n        }\n      }\n      return value;\n    }\n  }\n  /**\n   * Creates an {@link Event} from a node event emitter.\n   */\n  function fromNodeEventEmitter(emitter, eventName) {\n    let map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : id => id;\n    const fn = function () {\n      return result.fire(map(...arguments));\n    };\n    const onFirstListenerAdd = () => emitter.on(eventName, fn);\n    const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n    const result = new Emitter({\n      onWillAddFirstListener: onFirstListenerAdd,\n      onDidRemoveLastListener: onLastListenerRemove\n    });\n    return result.event;\n  }\n  Event.fromNodeEventEmitter = fromNodeEventEmitter;\n  /**\n   * Creates an {@link Event} from a DOM event emitter.\n   */\n  function fromDOMEventEmitter(emitter, eventName) {\n    let map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : id => id;\n    const fn = function () {\n      return result.fire(map(...arguments));\n    };\n    const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n    const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n    const result = new Emitter({\n      onWillAddFirstListener: onFirstListenerAdd,\n      onDidRemoveLastListener: onLastListenerRemove\n    });\n    return result.event;\n  }\n  Event.fromDOMEventEmitter = fromDOMEventEmitter;\n  /**\n   * Creates a promise out of an event, using the {@link Event.once} helper.\n   */\n  function toPromise(event) {\n    return new Promise(resolve => once(event)(resolve));\n  }\n  Event.toPromise = toPromise;\n  /**\n   * Creates an event out of a promise that fires once when the promise is\n   * resolved with the result of the promise or `undefined`.\n   */\n  function fromPromise(promise) {\n    const result = new Emitter();\n    promise.then(res => {\n      result.fire(res);\n    }, () => {\n      result.fire(undefined);\n    }).finally(() => {\n      result.dispose();\n    });\n    return result.event;\n  }\n  Event.fromPromise = fromPromise;\n  /**\n   * A convenience function for forwarding an event to another emitter which\n   * improves readability.\n   *\n   * This is similar to {@link Relay} but allows instantiating and forwarding\n   * on a single line and also allows for multiple source events.\n   * @param from The event to forward.\n   * @param to The emitter to forward the event to.\n   * @example\n   * Event.forward(event, emitter);\n   * // equivalent to\n   * event(e => emitter.fire(e));\n   * // equivalent to\n   * event(emitter.fire, emitter);\n   */\n  function forward(from, to) {\n    return from(e => to.fire(e));\n  }\n  Event.forward = forward;\n  function runAndSubscribe(event, handler, initial) {\n    handler(initial);\n    return event(e => handler(e));\n  }\n  Event.runAndSubscribe = runAndSubscribe;\n  class EmitterObserver {\n    constructor(_observable, store) {\n      this._observable = _observable;\n      this._counter = 0;\n      this._hasChanged = false;\n      const options = {\n        onWillAddFirstListener: () => {\n          _observable.addObserver(this);\n          // Communicate to the observable that we received its current value and would like to be notified about future changes.\n          this._observable.reportChanges();\n        },\n        onDidRemoveLastListener: () => {\n          _observable.removeObserver(this);\n        }\n      };\n      if (!store) {\n        _addLeakageTraceLogic(options);\n      }\n      this.emitter = new Emitter(options);\n      if (store) {\n        store.add(this.emitter);\n      }\n    }\n    beginUpdate(_observable) {\n      // assert(_observable === this.obs);\n      this._counter++;\n    }\n    handlePossibleChange(_observable) {\n      // assert(_observable === this.obs);\n    }\n    handleChange(_observable, _change) {\n      // assert(_observable === this.obs);\n      this._hasChanged = true;\n    }\n    endUpdate(_observable) {\n      // assert(_observable === this.obs);\n      this._counter--;\n      if (this._counter === 0) {\n        this._observable.reportChanges();\n        if (this._hasChanged) {\n          this._hasChanged = false;\n          this.emitter.fire(this._observable.get());\n        }\n      }\n    }\n  }\n  /**\n   * Creates an event emitter that is fired when the observable changes.\n   * Each listeners subscribes to the emitter.\n   */\n  function fromObservable(obs, store) {\n    const observer = new EmitterObserver(obs, store);\n    return observer.emitter.event;\n  }\n  Event.fromObservable = fromObservable;\n  /**\n   * Each listener is attached to the observable directly.\n   */\n  function fromObservableLight(observable) {\n    return (listener, thisArgs, disposables) => {\n      let count = 0;\n      let didChange = false;\n      const observer = {\n        beginUpdate() {\n          count++;\n        },\n        endUpdate() {\n          count--;\n          if (count === 0) {\n            observable.reportChanges();\n            if (didChange) {\n              didChange = false;\n              listener.call(thisArgs);\n            }\n          }\n        },\n        handlePossibleChange() {\n          // noop\n        },\n        handleChange() {\n          didChange = true;\n        }\n      };\n      observable.addObserver(observer);\n      observable.reportChanges();\n      const disposable = {\n        dispose() {\n          observable.removeObserver(observer);\n        }\n      };\n      if (disposables instanceof DisposableStore) {\n        disposables.add(disposable);\n      } else if (Array.isArray(disposables)) {\n        disposables.push(disposable);\n      }\n      return disposable;\n    };\n  }\n  Event.fromObservableLight = fromObservableLight;\n})(Event || (Event = {}));\nexport class EventProfiling {\n  constructor(name) {\n    this.listenerCount = 0;\n    this.invocationCount = 0;\n    this.elapsedOverall = 0;\n    this.durations = [];\n    this.name = \"\".concat(name, \"_\").concat(EventProfiling._idPool++);\n    EventProfiling.all.add(this);\n  }\n  start(listenerCount) {\n    this._stopWatch = new StopWatch();\n    this.listenerCount = listenerCount;\n  }\n  stop() {\n    if (this._stopWatch) {\n      const elapsed = this._stopWatch.elapsed();\n      this.durations.push(elapsed);\n      this.elapsedOverall += elapsed;\n      this.invocationCount += 1;\n      this._stopWatch = undefined;\n    }\n  }\n}\n_EventProfiling = EventProfiling;\n_EventProfiling.all = new Set();\n_EventProfiling._idPool = 0;\nlet _globalLeakWarningThreshold = -1;\nclass LeakageMonitor {\n  constructor(_errorHandler, threshold) {\n    let name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (LeakageMonitor._idPool++).toString(16).padStart(3, '0');\n    this._errorHandler = _errorHandler;\n    this.threshold = threshold;\n    this.name = name;\n    this._warnCountdown = 0;\n  }\n  dispose() {\n    var _this$_stacks;\n    (_this$_stacks = this._stacks) === null || _this$_stacks === void 0 || _this$_stacks.clear();\n  }\n  check(stack, listenerCount) {\n    const threshold = this.threshold;\n    if (threshold <= 0 || listenerCount < threshold) {\n      return undefined;\n    }\n    if (!this._stacks) {\n      this._stacks = new Map();\n    }\n    const count = this._stacks.get(stack.value) || 0;\n    this._stacks.set(stack.value, count + 1);\n    this._warnCountdown -= 1;\n    if (this._warnCountdown <= 0) {\n      // only warn on first exceed and then every time the limit\n      // is exceeded by 50% again\n      this._warnCountdown = threshold * 0.5;\n      const [topStack, topCount] = this.getMostFrequentStack();\n      const message = \"[\".concat(this.name, \"] potential listener LEAK detected, having \").concat(listenerCount, \" listeners already. MOST frequent listener (\").concat(topCount, \"):\");\n      console.warn(message);\n      console.warn(topStack);\n      const error = new ListenerLeakError(message, topStack);\n      this._errorHandler(error);\n    }\n    return () => {\n      const count = this._stacks.get(stack.value) || 0;\n      this._stacks.set(stack.value, count - 1);\n    };\n  }\n  getMostFrequentStack() {\n    if (!this._stacks) {\n      return undefined;\n    }\n    let topStack;\n    let topCount = 0;\n    for (const [stack, count] of this._stacks) {\n      if (!topStack || topCount < count) {\n        topStack = [stack, count];\n        topCount = count;\n      }\n    }\n    return topStack;\n  }\n}\n_LeakageMonitor = LeakageMonitor;\n_LeakageMonitor._idPool = 1;\nclass Stacktrace {\n  static create() {\n    var _err$stack;\n    const err = new Error();\n    return new Stacktrace((_err$stack = err.stack) !== null && _err$stack !== void 0 ? _err$stack : '');\n  }\n  constructor(value) {\n    this.value = value;\n  }\n  print() {\n    console.warn(this.value.split('\\n').slice(2).join('\\n'));\n  }\n}\n// error that is logged when going over the configured listener threshold\nexport class ListenerLeakError extends Error {\n  constructor(message, stack) {\n    super(message);\n    this.name = 'ListenerLeakError';\n    this.stack = stack;\n  }\n}\n// SEVERE error that is logged when having gone way over the configured listener\n// threshold so that the emitter refuses to accept more listeners\nexport class ListenerRefusalError extends Error {\n  constructor(message, stack) {\n    super(message);\n    this.name = 'ListenerRefusalError';\n    this.stack = stack;\n  }\n}\nclass UniqueContainer {\n  constructor(value) {\n    this.value = value;\n  }\n}\nconst compactionThreshold = 2;\nconst forEachListener = (listeners, fn) => {\n  if (listeners instanceof UniqueContainer) {\n    fn(listeners);\n  } else {\n    for (let i = 0; i < listeners.length; i++) {\n      const l = listeners[i];\n      if (l) {\n        fn(l);\n      }\n    }\n  }\n};\nlet _listenerFinalizers;\nif (_enableListenerGCedWarning) {\n  const leaks = [];\n  setInterval(() => {\n    if (leaks.length === 0) {\n      return;\n    }\n    console.warn('[LEAKING LISTENERS] GC\\'ed these listeners that were NOT yet disposed:');\n    console.warn(leaks.join('\\n'));\n    leaks.length = 0;\n  }, 3000);\n  _listenerFinalizers = new FinalizationRegistry(heldValue => {\n    if (typeof heldValue === 'string') {\n      leaks.push(heldValue);\n    }\n  });\n}\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n    class Document {\n\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n        public onDidChange = this._onDidChange.event;\n\n        // getter-style\n        // get onDidChange(): Event<(value:string)=>any> {\n        // \treturn this._onDidChange.event;\n        // }\n\n        private _doIt() {\n            //...\n            this._onDidChange.fire(value);\n        }\n    }\n */\nexport class Emitter {\n  constructor(options) {\n    var _this$_options, _options$onListenerEr, _this$_options$leakWa, _this$_options2, _this$_options3, _this$_options4;\n    this._size = 0;\n    this._options = options;\n    this._leakageMon = _globalLeakWarningThreshold > 0 || (_this$_options = this._options) !== null && _this$_options !== void 0 && _this$_options.leakWarningThreshold ? new LeakageMonitor((_options$onListenerEr = options === null || options === void 0 ? void 0 : options.onListenerError) !== null && _options$onListenerEr !== void 0 ? _options$onListenerEr : onUnexpectedError, (_this$_options$leakWa = (_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.leakWarningThreshold) !== null && _this$_options$leakWa !== void 0 ? _this$_options$leakWa : _globalLeakWarningThreshold) : undefined;\n    this._perfMon = (_this$_options3 = this._options) !== null && _this$_options3 !== void 0 && _this$_options3._profName ? new EventProfiling(this._options._profName) : undefined;\n    this._deliveryQueue = (_this$_options4 = this._options) === null || _this$_options4 === void 0 ? void 0 : _this$_options4.deliveryQueue;\n  }\n  dispose() {\n    if (!this._disposed) {\n      var _this$_deliveryQueue, _this$_options5, _this$_options5$onDid, _this$_leakageMon;\n      this._disposed = true;\n      // It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n      // alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n      // unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n      // the following programming pattern is very popular:\n      //\n      // const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n      // this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n      // ...later...\n      // this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n      if (((_this$_deliveryQueue = this._deliveryQueue) === null || _this$_deliveryQueue === void 0 ? void 0 : _this$_deliveryQueue.current) === this) {\n        this._deliveryQueue.reset();\n      }\n      if (this._listeners) {\n        if (_enableDisposeWithListenerWarning) {\n          const listeners = this._listeners;\n          queueMicrotask(() => {\n            forEachListener(listeners, l => {\n              var _l$stack;\n              return (_l$stack = l.stack) === null || _l$stack === void 0 ? void 0 : _l$stack.print();\n            });\n          });\n        }\n        this._listeners = undefined;\n        this._size = 0;\n      }\n      (_this$_options5 = this._options) === null || _this$_options5 === void 0 || (_this$_options5$onDid = _this$_options5.onDidRemoveLastListener) === null || _this$_options5$onDid === void 0 || _this$_options5$onDid.call(_this$_options5);\n      (_this$_leakageMon = this._leakageMon) === null || _this$_leakageMon === void 0 || _this$_leakageMon.dispose();\n    }\n  }\n  /**\n   * For the public to allow to subscribe\n   * to events from this Emitter\n   */\n  get event() {\n    var _this$_event;\n    (_this$_event = this._event) !== null && _this$_event !== void 0 ? _this$_event : this._event = (callback, thisArgs, disposables) => {\n      if (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {\n        var _this$_leakageMon$get, _this$_options6;\n        const message = \"[\".concat(this._leakageMon.name, \"] REFUSES to accept new listeners because it exceeded its threshold by far (\").concat(this._size, \" vs \").concat(this._leakageMon.threshold, \")\");\n        console.warn(message);\n        const tuple = (_this$_leakageMon$get = this._leakageMon.getMostFrequentStack()) !== null && _this$_leakageMon$get !== void 0 ? _this$_leakageMon$get : ['UNKNOWN stack', -1];\n        const error = new ListenerRefusalError(\"\".concat(message, \". HINT: Stack shows most frequent listener (\").concat(tuple[1], \"-times)\"), tuple[0]);\n        const errorHandler = ((_this$_options6 = this._options) === null || _this$_options6 === void 0 ? void 0 : _this$_options6.onListenerError) || onUnexpectedError;\n        errorHandler(error);\n        return Disposable.None;\n      }\n      if (this._disposed) {\n        // todo: should we warn if a listener is added to a disposed emitter? This happens often\n        return Disposable.None;\n      }\n      if (thisArgs) {\n        callback = callback.bind(thisArgs);\n      }\n      const contained = new UniqueContainer(callback);\n      let removeMonitor;\n      let stack;\n      if (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {\n        // check and record this emitter for potential leakage\n        contained.stack = Stacktrace.create();\n        removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);\n      }\n      if (_enableDisposeWithListenerWarning) {\n        contained.stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();\n      }\n      if (!this._listeners) {\n        var _this$_options7, _this$_options7$onWil, _this$_options8, _this$_options8$onDid;\n        (_this$_options7 = this._options) === null || _this$_options7 === void 0 || (_this$_options7$onWil = _this$_options7.onWillAddFirstListener) === null || _this$_options7$onWil === void 0 || _this$_options7$onWil.call(_this$_options7, this);\n        this._listeners = contained;\n        (_this$_options8 = this._options) === null || _this$_options8 === void 0 || (_this$_options8$onDid = _this$_options8.onDidAddFirstListener) === null || _this$_options8$onDid === void 0 || _this$_options8$onDid.call(_this$_options8, this);\n      } else if (this._listeners instanceof UniqueContainer) {\n        var _this$_deliveryQueue2;\n        (_this$_deliveryQueue2 = this._deliveryQueue) !== null && _this$_deliveryQueue2 !== void 0 ? _this$_deliveryQueue2 : this._deliveryQueue = new EventDeliveryQueuePrivate();\n        this._listeners = [this._listeners, contained];\n      } else {\n        this._listeners.push(contained);\n      }\n      this._size++;\n      const result = toDisposable(() => {\n        var _listenerFinalizers2, _removeMonitor;\n        (_listenerFinalizers2 = _listenerFinalizers) === null || _listenerFinalizers2 === void 0 || _listenerFinalizers2.unregister(result);\n        (_removeMonitor = removeMonitor) === null || _removeMonitor === void 0 || _removeMonitor();\n        this._removeListener(contained);\n      });\n      if (disposables instanceof DisposableStore) {\n        disposables.add(result);\n      } else if (Array.isArray(disposables)) {\n        disposables.push(result);\n      }\n      if (_listenerFinalizers) {\n        var _match$;\n        const stack = new Error().stack.split('\\n').slice(2, 3).join('\\n').trim();\n        const match = /(file:|vscode-file:\\/\\/vscode-app)?(\\/[^:]*:\\d+:\\d+)/.exec(stack);\n        _listenerFinalizers.register(result, (_match$ = match === null || match === void 0 ? void 0 : match[2]) !== null && _match$ !== void 0 ? _match$ : stack, result);\n      }\n      return result;\n    };\n    return this._event;\n  }\n  _removeListener(listener) {\n    var _this$_options9, _this$_options9$onWil;\n    (_this$_options9 = this._options) === null || _this$_options9 === void 0 || (_this$_options9$onWil = _this$_options9.onWillRemoveListener) === null || _this$_options9$onWil === void 0 || _this$_options9$onWil.call(_this$_options9, this);\n    if (!this._listeners) {\n      return; // expected if a listener gets disposed\n    }\n    if (this._size === 1) {\n      var _this$_options10, _this$_options10$onDi;\n      this._listeners = undefined;\n      (_this$_options10 = this._options) === null || _this$_options10 === void 0 || (_this$_options10$onDi = _this$_options10.onDidRemoveLastListener) === null || _this$_options10$onDi === void 0 || _this$_options10$onDi.call(_this$_options10, this);\n      this._size = 0;\n      return;\n    }\n    // size > 1 which requires that listeners be a list:\n    const listeners = this._listeners;\n    const index = listeners.indexOf(listener);\n    if (index === -1) {\n      console.log('disposed?', this._disposed);\n      console.log('size?', this._size);\n      console.log('arr?', JSON.stringify(this._listeners));\n      throw new Error('Attempted to dispose unknown listener');\n    }\n    this._size--;\n    listeners[index] = undefined;\n    const adjustDeliveryQueue = this._deliveryQueue.current === this;\n    if (this._size * compactionThreshold <= listeners.length) {\n      let n = 0;\n      for (let i = 0; i < listeners.length; i++) {\n        if (listeners[i]) {\n          listeners[n++] = listeners[i];\n        } else if (adjustDeliveryQueue) {\n          this._deliveryQueue.end--;\n          if (n < this._deliveryQueue.i) {\n            this._deliveryQueue.i--;\n          }\n        }\n      }\n      listeners.length = n;\n    }\n  }\n  _deliver(listener, value) {\n    var _this$_options11;\n    if (!listener) {\n      return;\n    }\n    const errorHandler = ((_this$_options11 = this._options) === null || _this$_options11 === void 0 ? void 0 : _this$_options11.onListenerError) || onUnexpectedError;\n    if (!errorHandler) {\n      listener.value(value);\n      return;\n    }\n    try {\n      listener.value(value);\n    } catch (e) {\n      errorHandler(e);\n    }\n  }\n  /** Delivers items in the queue. Assumes the queue is ready to go. */\n  _deliverQueue(dq) {\n    const listeners = dq.current._listeners;\n    while (dq.i < dq.end) {\n      // important: dq.i is incremented before calling deliver() because it might reenter deliverQueue()\n      this._deliver(listeners[dq.i++], dq.value);\n    }\n    dq.reset();\n  }\n  /**\n   * To be kept private to fire an event to\n   * subscribers\n   */\n  fire(event) {\n    var _this$_deliveryQueue3, _this$_perfMon2, _this$_perfMon3;\n    if ((_this$_deliveryQueue3 = this._deliveryQueue) !== null && _this$_deliveryQueue3 !== void 0 && _this$_deliveryQueue3.current) {\n      var _this$_perfMon;\n      this._deliverQueue(this._deliveryQueue);\n      (_this$_perfMon = this._perfMon) === null || _this$_perfMon === void 0 || _this$_perfMon.stop(); // last fire() will have starting perfmon, stop it before starting the next dispatch\n    }\n    (_this$_perfMon2 = this._perfMon) === null || _this$_perfMon2 === void 0 || _this$_perfMon2.start(this._size);\n    if (!this._listeners) {\n      // no-op\n    } else if (this._listeners instanceof UniqueContainer) {\n      this._deliver(this._listeners, event);\n    } else {\n      const dq = this._deliveryQueue;\n      dq.enqueue(this, event, this._listeners.length);\n      this._deliverQueue(dq);\n    }\n    (_this$_perfMon3 = this._perfMon) === null || _this$_perfMon3 === void 0 || _this$_perfMon3.stop();\n  }\n  hasListeners() {\n    return this._size > 0;\n  }\n}\nexport const createEventDeliveryQueue = () => new EventDeliveryQueuePrivate();\nclass EventDeliveryQueuePrivate {\n  constructor() {\n    /**\n     * Index in current's listener list.\n     */\n    this.i = -1;\n    /**\n     * The last index in the listener's list to deliver.\n     */\n    this.end = 0;\n  }\n  enqueue(emitter, value, end) {\n    this.i = 0;\n    this.end = end;\n    this.current = emitter;\n    this.value = value;\n  }\n  reset() {\n    this.i = this.end; // force any current emission loop to stop, mainly for during dispose\n    this.current = undefined;\n    this.value = undefined;\n  }\n}\nexport class PauseableEmitter extends Emitter {\n  constructor(options) {\n    super(options);\n    this._isPaused = 0;\n    this._eventQueue = new LinkedList();\n    this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n  }\n  pause() {\n    this._isPaused++;\n  }\n  resume() {\n    if (this._isPaused !== 0 && --this._isPaused === 0) {\n      if (this._mergeFn) {\n        // use the merge function to create a single composite\n        // event. make a copy in case firing pauses this emitter\n        if (this._eventQueue.size > 0) {\n          const events = Array.from(this._eventQueue);\n          this._eventQueue.clear();\n          super.fire(this._mergeFn(events));\n        }\n      } else {\n        // no merging, fire each event individually and test\n        // that this emitter isn't paused halfway through\n        while (!this._isPaused && this._eventQueue.size !== 0) {\n          super.fire(this._eventQueue.shift());\n        }\n      }\n    }\n  }\n  fire(event) {\n    if (this._size) {\n      if (this._isPaused !== 0) {\n        this._eventQueue.push(event);\n      } else {\n        super.fire(event);\n      }\n    }\n  }\n}\nexport class DebounceEmitter extends PauseableEmitter {\n  constructor(options) {\n    var _options$delay;\n    super(options);\n    this._delay = (_options$delay = options.delay) !== null && _options$delay !== void 0 ? _options$delay : 100;\n  }\n  fire(event) {\n    if (!this._handle) {\n      this.pause();\n      this._handle = setTimeout(() => {\n        this._handle = undefined;\n        this.resume();\n      }, this._delay);\n    }\n    super.fire(event);\n  }\n}\n/**\n * An emitter which queue all events and then process them at the\n * end of the event loop.\n */\nexport class MicrotaskEmitter extends Emitter {\n  constructor(options) {\n    super(options);\n    this._queuedEvents = [];\n    this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n  }\n  fire(event) {\n    if (!this.hasListeners()) {\n      return;\n    }\n    this._queuedEvents.push(event);\n    if (this._queuedEvents.length === 1) {\n      queueMicrotask(() => {\n        if (this._mergeFn) {\n          super.fire(this._mergeFn(this._queuedEvents));\n        } else {\n          this._queuedEvents.forEach(e => super.fire(e));\n        }\n        this._queuedEvents = [];\n      });\n    }\n  }\n}\n/**\n * An event emitter that multiplexes many events into a single event.\n *\n * @example Listen to the `onData` event of all `Thing`s, dynamically adding and removing `Thing`s\n * to the multiplexer as needed.\n *\n * ```typescript\n * const anythingDataMultiplexer = new EventMultiplexer<{ data: string }>();\n *\n * const thingListeners = DisposableMap<Thing, IDisposable>();\n *\n * thingService.onDidAddThing(thing => {\n *   thingListeners.set(thing, anythingDataMultiplexer.add(thing.onData);\n * });\n * thingService.onDidRemoveThing(thing => {\n *   thingListeners.deleteAndDispose(thing);\n * });\n *\n * anythingDataMultiplexer.event(e => {\n *   console.log('Something fired data ' + e.data)\n * });\n * ```\n */\nexport class EventMultiplexer {\n  constructor() {\n    this.hasListeners = false;\n    this.events = [];\n    this.emitter = new Emitter({\n      onWillAddFirstListener: () => this.onFirstListenerAdd(),\n      onDidRemoveLastListener: () => this.onLastListenerRemove()\n    });\n  }\n  get event() {\n    return this.emitter.event;\n  }\n  add(event) {\n    const e = {\n      event: event,\n      listener: null\n    };\n    this.events.push(e);\n    if (this.hasListeners) {\n      this.hook(e);\n    }\n    const dispose = () => {\n      if (this.hasListeners) {\n        this.unhook(e);\n      }\n      const idx = this.events.indexOf(e);\n      this.events.splice(idx, 1);\n    };\n    return toDisposable(createSingleCallFunction(dispose));\n  }\n  onFirstListenerAdd() {\n    this.hasListeners = true;\n    this.events.forEach(e => this.hook(e));\n  }\n  onLastListenerRemove() {\n    this.hasListeners = false;\n    this.events.forEach(e => this.unhook(e));\n  }\n  hook(e) {\n    e.listener = e.event(r => this.emitter.fire(r));\n  }\n  unhook(e) {\n    var _e$listener;\n    (_e$listener = e.listener) === null || _e$listener === void 0 || _e$listener.dispose();\n    e.listener = null;\n  }\n  dispose() {\n    this.emitter.dispose();\n    for (const e of this.events) {\n      var _e$listener2;\n      (_e$listener2 = e.listener) === null || _e$listener2 === void 0 || _e$listener2.dispose();\n    }\n    this.events = [];\n  }\n}\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n  constructor() {\n    this.data = [];\n  }\n  wrapEvent(event, reduce, initial) {\n    return (listener, thisArgs, disposables) => {\n      return event(i => {\n        var _reduceData$items;\n        const data = this.data[this.data.length - 1];\n        // Non-reduce scenario\n        if (!reduce) {\n          // Buffering case\n          if (data) {\n            data.buffers.push(() => listener.call(thisArgs, i));\n          } else {\n            // Not buffering case\n            listener.call(thisArgs, i);\n          }\n          return;\n        }\n        // Reduce scenario\n        const reduceData = data;\n        // Not buffering case\n        if (!reduceData) {\n          // TODO: Is there a way to cache this reduce call for all listeners?\n          listener.call(thisArgs, reduce(initial, i));\n          return;\n        }\n        // Buffering case\n        (_reduceData$items = reduceData.items) !== null && _reduceData$items !== void 0 ? _reduceData$items : reduceData.items = [];\n        reduceData.items.push(i);\n        if (reduceData.buffers.length === 0) {\n          // Include a single buffered function that will reduce all events when we're done buffering events\n          data.buffers.push(() => {\n            var _reduceData$reducedRe;\n            // cache the reduced result so that the value can be shared across all listeners\n            (_reduceData$reducedRe = reduceData.reducedResult) !== null && _reduceData$reducedRe !== void 0 ? _reduceData$reducedRe : reduceData.reducedResult = initial ? reduceData.items.reduce(reduce, initial) : reduceData.items.reduce(reduce);\n            listener.call(thisArgs, reduceData.reducedResult);\n          });\n        }\n      }, undefined, disposables);\n    };\n  }\n  bufferEvents(fn) {\n    const data = {\n      buffers: new Array()\n    };\n    this.data.push(data);\n    const r = fn();\n    this.data.pop();\n    data.buffers.forEach(flush => flush());\n    return r;\n  }\n}\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay {\n  constructor() {\n    this.listening = false;\n    this.inputEvent = Event.None;\n    this.inputEventListener = Disposable.None;\n    this.emitter = new Emitter({\n      onDidAddFirstListener: () => {\n        this.listening = true;\n        this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n      },\n      onDidRemoveLastListener: () => {\n        this.listening = false;\n        this.inputEventListener.dispose();\n      }\n    });\n    this.event = this.emitter.event;\n  }\n  set input(event) {\n    this.inputEvent = event;\n    if (this.listening) {\n      this.inputEventListener.dispose();\n      this.inputEventListener = event(this.emitter.fire, this.emitter);\n    }\n  }\n  dispose() {\n    this.inputEventListener.dispose();\n    this.emitter.dispose();\n  }\n}","map":{"version":3,"names":["onUnexpectedError","createSingleCallFunction","combinedDisposable","Disposable","DisposableStore","toDisposable","LinkedList","StopWatch","_enableListenerGCedWarning","_enableDisposeWithListenerWarning","_enableSnapshotPotentialLeakWarning","Event","None","_addLeakageTraceLogic","options","onDidAddListener","origListenerDidAdd","stack","Stacktrace","create","count","console","warn","print","defer","event","disposable","debounce","undefined","once","listener","thisArgs","arguments","length","disposables","didFire","result","e","dispose","call","onceIf","condition","filter","map","snapshot","i","forEach","each","signal","any","_len","events","Array","_key","addAndReturnDisposable","reduce","merge","initial","output","onWillAddFirstListener","emitter","fire","onDidRemoveLastListener","_listener","Emitter","add","d","store","push","delay","leading","flushOnListenerRemove","leakWarningThreshold","subscription","handle","numDebouncedCalls","doFire","cur","_output","clearTimeout","setTimeout","queueMicrotask","onWillRemoveListener","_doFire","accumulate","last","latch","equals","a","b","firstCall","cache","value","shouldEmit","split","isT","buffer","flushAfterTimeout","_buffer","slice","flush","_buffer2","onDidAddFirstListener","chain","sythensize","fn","cs","ChainableSynthesis","evaluate","HaltChainable","Symbol","constructor","steps","v","step","fromNodeEventEmitter","eventName","id","onFirstListenerAdd","on","onLastListenerRemove","removeListener","fromDOMEventEmitter","addEventListener","removeEventListener","toPromise","Promise","resolve","fromPromise","promise","then","res","finally","forward","from","to","runAndSubscribe","handler","EmitterObserver","_observable","_counter","_hasChanged","addObserver","reportChanges","removeObserver","beginUpdate","handlePossibleChange","handleChange","_change","endUpdate","get","fromObservable","obs","observer","fromObservableLight","observable","didChange","isArray","EventProfiling","name","listenerCount","invocationCount","elapsedOverall","durations","concat","_idPool","all","start","_stopWatch","stop","elapsed","_EventProfiling","Set","_globalLeakWarningThreshold","LeakageMonitor","_errorHandler","threshold","toString","padStart","_warnCountdown","_this$_stacks","_stacks","clear","check","Map","set","topStack","topCount","getMostFrequentStack","message","error","ListenerLeakError","_LeakageMonitor","_err$stack","err","Error","join","ListenerRefusalError","UniqueContainer","compactionThreshold","forEachListener","listeners","l","_listenerFinalizers","leaks","setInterval","FinalizationRegistry","heldValue","_this$_options","_options$onListenerEr","_this$_options$leakWa","_this$_options2","_this$_options3","_this$_options4","_size","_options","_leakageMon","onListenerError","_perfMon","_profName","_deliveryQueue","deliveryQueue","_disposed","_this$_deliveryQueue","_this$_options5","_this$_options5$onDid","_this$_leakageMon","current","reset","_listeners","_l$stack","_this$_event","_event","callback","_this$_leakageMon$get","_this$_options6","tuple","errorHandler","bind","contained","removeMonitor","Math","ceil","_this$_options7","_this$_options7$onWil","_this$_options8","_this$_options8$onDid","_this$_deliveryQueue2","EventDeliveryQueuePrivate","_listenerFinalizers2","_removeMonitor","unregister","_removeListener","_match$","trim","match","exec","register","_this$_options9","_this$_options9$onWil","_this$_options10","_this$_options10$onDi","index","indexOf","log","JSON","stringify","adjustDeliveryQueue","n","end","_deliver","_this$_options11","_deliverQueue","dq","_this$_deliveryQueue3","_this$_perfMon2","_this$_perfMon3","_this$_perfMon","enqueue","hasListeners","createEventDeliveryQueue","PauseableEmitter","_isPaused","_eventQueue","_mergeFn","pause","resume","size","shift","DebounceEmitter","_options$delay","_delay","_handle","MicrotaskEmitter","_queuedEvents","EventMultiplexer","hook","unhook","idx","splice","r","_e$listener","_e$listener2","EventBufferer","data","wrapEvent","_reduceData$items","buffers","reduceData","items","_reduceData$reducedRe","reducedResult","bufferEvents","pop","Relay","listening","inputEvent","inputEventListener","input"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/base/common/event.js"],"sourcesContent":["import { onUnexpectedError } from './errors.js';\nimport { createSingleCallFunction } from './functional.js';\nimport { combinedDisposable, Disposable, DisposableStore, toDisposable } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { StopWatch } from './stopwatch.js';\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a listener is GC'ed without having been disposed. This is a LEAK.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableListenerGCedWarning = false;\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableDisposeWithListenerWarning = false;\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableSnapshotPotentialLeakWarning = false;\nexport var Event;\n(function (Event) {\n    Event.None = () => Disposable.None;\n    function _addLeakageTraceLogic(options) {\n        if (_enableSnapshotPotentialLeakWarning) {\n            const { onDidAddListener: origListenerDidAdd } = options;\n            const stack = Stacktrace.create();\n            let count = 0;\n            options.onDidAddListener = () => {\n                if (++count === 2) {\n                    console.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\n                    stack.print();\n                }\n                origListenerDidAdd?.();\n            };\n        }\n    }\n    /**\n     * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared\n     * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a\n     * result of merging events and to try prevent race conditions that could arise when using related deferred and\n     * non-deferred events.\n     *\n     * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work\n     * (eg. latency of keypress to text rendered).\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function defer(event, disposable) {\n        return debounce(event, () => void 0, 0, undefined, true, undefined, disposable);\n    }\n    Event.defer = defer;\n    /**\n     * Given an event, returns another event which only fires once.\n     *\n     * @param event The event source for the new event.\n     */\n    function once(event) {\n        return (listener, thisArgs = null, disposables) => {\n            // we need this, in case the event fires during the listener call\n            let didFire = false;\n            let result = undefined;\n            result = event(e => {\n                if (didFire) {\n                    return;\n                }\n                else if (result) {\n                    result.dispose();\n                }\n                else {\n                    didFire = true;\n                }\n                return listener.call(thisArgs, e);\n            }, null, disposables);\n            if (didFire) {\n                result.dispose();\n            }\n            return result;\n        };\n    }\n    Event.once = once;\n    /**\n     * Given an event, returns another event which only fires once, and only when the condition is met.\n     *\n     * @param event The event source for the new event.\n     */\n    function onceIf(event, condition) {\n        return Event.once(Event.filter(event, condition));\n    }\n    Event.onceIf = onceIf;\n    /**\n     * Maps an event of one type into an event of another type using a mapping function, similar to how\n     * `Array.prototype.map` works.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param map The mapping function.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function map(event, map, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);\n    }\n    Event.map = map;\n    /**\n     * Wraps an event in another event that performs some function on the event object before firing.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param each The function to perform on the event object.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function forEach(event, each, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables), disposable);\n    }\n    Event.forEach = forEach;\n    function filter(event, filter, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);\n    }\n    Event.filter = filter;\n    /**\n     * Given an event, returns the same event but typed as `Event<void>`.\n     */\n    function signal(event) {\n        return event;\n    }\n    Event.signal = signal;\n    function any(...events) {\n        return (listener, thisArgs = null, disposables) => {\n            const disposable = combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e))));\n            return addAndReturnDisposable(disposable, disposables);\n        };\n    }\n    Event.any = any;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function reduce(event, merge, initial, disposable) {\n        let output = initial;\n        return map(event, e => {\n            output = merge(output, e);\n            return output;\n        }, disposable);\n    }\n    Event.reduce = reduce;\n    function snapshot(event, disposable) {\n        let listener;\n        const options = {\n            onWillAddFirstListener() {\n                listener = event(emitter.fire, emitter);\n            },\n            onDidRemoveLastListener() {\n                listener?.dispose();\n            }\n        };\n        if (!disposable) {\n            _addLeakageTraceLogic(options);\n        }\n        const emitter = new Emitter(options);\n        disposable?.add(emitter);\n        return emitter.event;\n    }\n    /**\n     * Adds the IDisposable to the store if it's set, and returns it. Useful to\n     * Event function implementation.\n     */\n    function addAndReturnDisposable(d, store) {\n        if (store instanceof Array) {\n            store.push(d);\n        }\n        else if (store) {\n            store.add(d);\n        }\n        return d;\n    }\n    function debounce(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {\n        let subscription;\n        let output = undefined;\n        let handle = undefined;\n        let numDebouncedCalls = 0;\n        let doFire;\n        const options = {\n            leakWarningThreshold,\n            onWillAddFirstListener() {\n                subscription = event(cur => {\n                    numDebouncedCalls++;\n                    output = merge(output, cur);\n                    if (leading && !handle) {\n                        emitter.fire(output);\n                        output = undefined;\n                    }\n                    doFire = () => {\n                        const _output = output;\n                        output = undefined;\n                        handle = undefined;\n                        if (!leading || numDebouncedCalls > 1) {\n                            emitter.fire(_output);\n                        }\n                        numDebouncedCalls = 0;\n                    };\n                    if (typeof delay === 'number') {\n                        clearTimeout(handle);\n                        handle = setTimeout(doFire, delay);\n                    }\n                    else {\n                        if (handle === undefined) {\n                            handle = 0;\n                            queueMicrotask(doFire);\n                        }\n                    }\n                });\n            },\n            onWillRemoveListener() {\n                if (flushOnListenerRemove && numDebouncedCalls > 0) {\n                    doFire?.();\n                }\n            },\n            onDidRemoveLastListener() {\n                doFire = undefined;\n                subscription.dispose();\n            }\n        };\n        if (!disposable) {\n            _addLeakageTraceLogic(options);\n        }\n        const emitter = new Emitter(options);\n        disposable?.add(emitter);\n        return emitter.event;\n    }\n    Event.debounce = debounce;\n    /**\n     * Debounces an event, firing after some delay (default=0) with an array of all event original objects.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function accumulate(event, delay = 0, disposable) {\n        return Event.debounce(event, (last, e) => {\n            if (!last) {\n                return [e];\n            }\n            last.push(e);\n            return last;\n        }, delay, undefined, true, undefined, disposable);\n    }\n    Event.accumulate = accumulate;\n    /**\n     * Filters an event such that some condition is _not_ met more than once in a row, effectively ensuring duplicate\n     * event objects from different sources do not fire the same event object.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param equals The equality condition.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     *\n     * @example\n     * ```\n     * // Fire only one time when a single window is opened or focused\n     * Event.latch(Event.any(onDidOpenWindow, onDidFocusWindow))\n     * ```\n     */\n    function latch(event, equals = (a, b) => a === b, disposable) {\n        let firstCall = true;\n        let cache;\n        return filter(event, value => {\n            const shouldEmit = firstCall || !equals(value, cache);\n            firstCall = false;\n            cache = value;\n            return shouldEmit;\n        }, disposable);\n    }\n    Event.latch = latch;\n    /**\n     * Splits an event whose parameter is a union type into 2 separate events for each type in the union.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @example\n     * ```\n     * const event = new EventEmitter<number | undefined>().event;\n     * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);\n     * ```\n     *\n     * @param event The event source for the new event.\n     * @param isT A function that determines what event is of the first type.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function split(event, isT, disposable) {\n        return [\n            Event.filter(event, isT, disposable),\n            Event.filter(event, e => !isT(e), disposable),\n        ];\n    }\n    Event.split = split;\n    /**\n     * Buffers an event until it has a listener attached.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param flushAfterTimeout Determines whether to flush the buffer after a timeout immediately or after a\n     * `setTimeout` when the first event listener is added.\n     * @param _buffer Internal: A source event array used for tests.\n     *\n     * @example\n     * ```\n     * // Start accumulating events, when the first listener is attached, flush\n     * // the event after a timeout such that multiple listeners attached before\n     * // the timeout would receive the event\n     * this.onInstallExtension = Event.buffer(service.onInstallExtension, true);\n     * ```\n     */\n    function buffer(event, flushAfterTimeout = false, _buffer = [], disposable) {\n        let buffer = _buffer.slice();\n        let listener = event(e => {\n            if (buffer) {\n                buffer.push(e);\n            }\n            else {\n                emitter.fire(e);\n            }\n        });\n        if (disposable) {\n            disposable.add(listener);\n        }\n        const flush = () => {\n            buffer?.forEach(e => emitter.fire(e));\n            buffer = null;\n        };\n        const emitter = new Emitter({\n            onWillAddFirstListener() {\n                if (!listener) {\n                    listener = event(e => emitter.fire(e));\n                    if (disposable) {\n                        disposable.add(listener);\n                    }\n                }\n            },\n            onDidAddFirstListener() {\n                if (buffer) {\n                    if (flushAfterTimeout) {\n                        setTimeout(flush);\n                    }\n                    else {\n                        flush();\n                    }\n                }\n            },\n            onDidRemoveLastListener() {\n                if (listener) {\n                    listener.dispose();\n                }\n                listener = null;\n            }\n        });\n        if (disposable) {\n            disposable.add(emitter);\n        }\n        return emitter.event;\n    }\n    Event.buffer = buffer;\n    /**\n     * Wraps the event in an {@link IChainableEvent}, allowing a more functional programming style.\n     *\n     * @example\n     * ```\n     * // Normal\n     * const onEnterPressNormal = Event.filter(\n     *   Event.map(onKeyPress.event, e => new StandardKeyboardEvent(e)),\n     *   e.keyCode === KeyCode.Enter\n     * ).event;\n     *\n     * // Using chain\n     * const onEnterPressChain = Event.chain(onKeyPress.event, $ => $\n     *   .map(e => new StandardKeyboardEvent(e))\n     *   .filter(e => e.keyCode === KeyCode.Enter)\n     * );\n     * ```\n     */\n    function chain(event, sythensize) {\n        const fn = (listener, thisArgs, disposables) => {\n            const cs = sythensize(new ChainableSynthesis());\n            return event(function (value) {\n                const result = cs.evaluate(value);\n                if (result !== HaltChainable) {\n                    listener.call(thisArgs, result);\n                }\n            }, undefined, disposables);\n        };\n        return fn;\n    }\n    Event.chain = chain;\n    const HaltChainable = Symbol('HaltChainable');\n    class ChainableSynthesis {\n        constructor() {\n            this.steps = [];\n        }\n        map(fn) {\n            this.steps.push(fn);\n            return this;\n        }\n        forEach(fn) {\n            this.steps.push(v => {\n                fn(v);\n                return v;\n            });\n            return this;\n        }\n        filter(fn) {\n            this.steps.push(v => fn(v) ? v : HaltChainable);\n            return this;\n        }\n        reduce(merge, initial) {\n            let last = initial;\n            this.steps.push(v => {\n                last = merge(last, v);\n                return last;\n            });\n            return this;\n        }\n        latch(equals = (a, b) => a === b) {\n            let firstCall = true;\n            let cache;\n            this.steps.push(value => {\n                const shouldEmit = firstCall || !equals(value, cache);\n                firstCall = false;\n                cache = value;\n                return shouldEmit ? value : HaltChainable;\n            });\n            return this;\n        }\n        evaluate(value) {\n            for (const step of this.steps) {\n                value = step(value);\n                if (value === HaltChainable) {\n                    break;\n                }\n            }\n            return value;\n        }\n    }\n    /**\n     * Creates an {@link Event} from a node event emitter.\n     */\n    function fromNodeEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.on(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromNodeEventEmitter = fromNodeEventEmitter;\n    /**\n     * Creates an {@link Event} from a DOM event emitter.\n     */\n    function fromDOMEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromDOMEventEmitter = fromDOMEventEmitter;\n    /**\n     * Creates a promise out of an event, using the {@link Event.once} helper.\n     */\n    function toPromise(event) {\n        return new Promise(resolve => once(event)(resolve));\n    }\n    Event.toPromise = toPromise;\n    /**\n     * Creates an event out of a promise that fires once when the promise is\n     * resolved with the result of the promise or `undefined`.\n     */\n    function fromPromise(promise) {\n        const result = new Emitter();\n        promise.then(res => {\n            result.fire(res);\n        }, () => {\n            result.fire(undefined);\n        }).finally(() => {\n            result.dispose();\n        });\n        return result.event;\n    }\n    Event.fromPromise = fromPromise;\n    /**\n     * A convenience function for forwarding an event to another emitter which\n     * improves readability.\n     *\n     * This is similar to {@link Relay} but allows instantiating and forwarding\n     * on a single line and also allows for multiple source events.\n     * @param from The event to forward.\n     * @param to The emitter to forward the event to.\n     * @example\n     * Event.forward(event, emitter);\n     * // equivalent to\n     * event(e => emitter.fire(e));\n     * // equivalent to\n     * event(emitter.fire, emitter);\n     */\n    function forward(from, to) {\n        return from(e => to.fire(e));\n    }\n    Event.forward = forward;\n    function runAndSubscribe(event, handler, initial) {\n        handler(initial);\n        return event(e => handler(e));\n    }\n    Event.runAndSubscribe = runAndSubscribe;\n    class EmitterObserver {\n        constructor(_observable, store) {\n            this._observable = _observable;\n            this._counter = 0;\n            this._hasChanged = false;\n            const options = {\n                onWillAddFirstListener: () => {\n                    _observable.addObserver(this);\n                    // Communicate to the observable that we received its current value and would like to be notified about future changes.\n                    this._observable.reportChanges();\n                },\n                onDidRemoveLastListener: () => {\n                    _observable.removeObserver(this);\n                }\n            };\n            if (!store) {\n                _addLeakageTraceLogic(options);\n            }\n            this.emitter = new Emitter(options);\n            if (store) {\n                store.add(this.emitter);\n            }\n        }\n        beginUpdate(_observable) {\n            // assert(_observable === this.obs);\n            this._counter++;\n        }\n        handlePossibleChange(_observable) {\n            // assert(_observable === this.obs);\n        }\n        handleChange(_observable, _change) {\n            // assert(_observable === this.obs);\n            this._hasChanged = true;\n        }\n        endUpdate(_observable) {\n            // assert(_observable === this.obs);\n            this._counter--;\n            if (this._counter === 0) {\n                this._observable.reportChanges();\n                if (this._hasChanged) {\n                    this._hasChanged = false;\n                    this.emitter.fire(this._observable.get());\n                }\n            }\n        }\n    }\n    /**\n     * Creates an event emitter that is fired when the observable changes.\n     * Each listeners subscribes to the emitter.\n     */\n    function fromObservable(obs, store) {\n        const observer = new EmitterObserver(obs, store);\n        return observer.emitter.event;\n    }\n    Event.fromObservable = fromObservable;\n    /**\n     * Each listener is attached to the observable directly.\n     */\n    function fromObservableLight(observable) {\n        return (listener, thisArgs, disposables) => {\n            let count = 0;\n            let didChange = false;\n            const observer = {\n                beginUpdate() {\n                    count++;\n                },\n                endUpdate() {\n                    count--;\n                    if (count === 0) {\n                        observable.reportChanges();\n                        if (didChange) {\n                            didChange = false;\n                            listener.call(thisArgs);\n                        }\n                    }\n                },\n                handlePossibleChange() {\n                    // noop\n                },\n                handleChange() {\n                    didChange = true;\n                }\n            };\n            observable.addObserver(observer);\n            observable.reportChanges();\n            const disposable = {\n                dispose() {\n                    observable.removeObserver(observer);\n                }\n            };\n            if (disposables instanceof DisposableStore) {\n                disposables.add(disposable);\n            }\n            else if (Array.isArray(disposables)) {\n                disposables.push(disposable);\n            }\n            return disposable;\n        };\n    }\n    Event.fromObservableLight = fromObservableLight;\n})(Event || (Event = {}));\nexport class EventProfiling {\n    static { this.all = new Set(); }\n    static { this._idPool = 0; }\n    constructor(name) {\n        this.listenerCount = 0;\n        this.invocationCount = 0;\n        this.elapsedOverall = 0;\n        this.durations = [];\n        this.name = `${name}_${EventProfiling._idPool++}`;\n        EventProfiling.all.add(this);\n    }\n    start(listenerCount) {\n        this._stopWatch = new StopWatch();\n        this.listenerCount = listenerCount;\n    }\n    stop() {\n        if (this._stopWatch) {\n            const elapsed = this._stopWatch.elapsed();\n            this.durations.push(elapsed);\n            this.elapsedOverall += elapsed;\n            this.invocationCount += 1;\n            this._stopWatch = undefined;\n        }\n    }\n}\nlet _globalLeakWarningThreshold = -1;\nclass LeakageMonitor {\n    static { this._idPool = 1; }\n    constructor(_errorHandler, threshold, name = (LeakageMonitor._idPool++).toString(16).padStart(3, '0')) {\n        this._errorHandler = _errorHandler;\n        this.threshold = threshold;\n        this.name = name;\n        this._warnCountdown = 0;\n    }\n    dispose() {\n        this._stacks?.clear();\n    }\n    check(stack, listenerCount) {\n        const threshold = this.threshold;\n        if (threshold <= 0 || listenerCount < threshold) {\n            return undefined;\n        }\n        if (!this._stacks) {\n            this._stacks = new Map();\n        }\n        const count = (this._stacks.get(stack.value) || 0);\n        this._stacks.set(stack.value, count + 1);\n        this._warnCountdown -= 1;\n        if (this._warnCountdown <= 0) {\n            // only warn on first exceed and then every time the limit\n            // is exceeded by 50% again\n            this._warnCountdown = threshold * 0.5;\n            const [topStack, topCount] = this.getMostFrequentStack();\n            const message = `[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`;\n            console.warn(message);\n            console.warn(topStack);\n            const error = new ListenerLeakError(message, topStack);\n            this._errorHandler(error);\n        }\n        return () => {\n            const count = (this._stacks.get(stack.value) || 0);\n            this._stacks.set(stack.value, count - 1);\n        };\n    }\n    getMostFrequentStack() {\n        if (!this._stacks) {\n            return undefined;\n        }\n        let topStack;\n        let topCount = 0;\n        for (const [stack, count] of this._stacks) {\n            if (!topStack || topCount < count) {\n                topStack = [stack, count];\n                topCount = count;\n            }\n        }\n        return topStack;\n    }\n}\nclass Stacktrace {\n    static create() {\n        const err = new Error();\n        return new Stacktrace(err.stack ?? '');\n    }\n    constructor(value) {\n        this.value = value;\n    }\n    print() {\n        console.warn(this.value.split('\\n').slice(2).join('\\n'));\n    }\n}\n// error that is logged when going over the configured listener threshold\nexport class ListenerLeakError extends Error {\n    constructor(message, stack) {\n        super(message);\n        this.name = 'ListenerLeakError';\n        this.stack = stack;\n    }\n}\n// SEVERE error that is logged when having gone way over the configured listener\n// threshold so that the emitter refuses to accept more listeners\nexport class ListenerRefusalError extends Error {\n    constructor(message, stack) {\n        super(message);\n        this.name = 'ListenerRefusalError';\n        this.stack = stack;\n    }\n}\nclass UniqueContainer {\n    constructor(value) {\n        this.value = value;\n    }\n}\nconst compactionThreshold = 2;\nconst forEachListener = (listeners, fn) => {\n    if (listeners instanceof UniqueContainer) {\n        fn(listeners);\n    }\n    else {\n        for (let i = 0; i < listeners.length; i++) {\n            const l = listeners[i];\n            if (l) {\n                fn(l);\n            }\n        }\n    }\n};\nlet _listenerFinalizers;\nif (_enableListenerGCedWarning) {\n    const leaks = [];\n    setInterval(() => {\n        if (leaks.length === 0) {\n            return;\n        }\n        console.warn('[LEAKING LISTENERS] GC\\'ed these listeners that were NOT yet disposed:');\n        console.warn(leaks.join('\\n'));\n        leaks.length = 0;\n    }, 3000);\n    _listenerFinalizers = new FinalizationRegistry(heldValue => {\n        if (typeof heldValue === 'string') {\n            leaks.push(heldValue);\n        }\n    });\n}\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n    class Document {\n\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n        public onDidChange = this._onDidChange.event;\n\n        // getter-style\n        // get onDidChange(): Event<(value:string)=>any> {\n        // \treturn this._onDidChange.event;\n        // }\n\n        private _doIt() {\n            //...\n            this._onDidChange.fire(value);\n        }\n    }\n */\nexport class Emitter {\n    constructor(options) {\n        this._size = 0;\n        this._options = options;\n        this._leakageMon = (_globalLeakWarningThreshold > 0 || this._options?.leakWarningThreshold)\n            ? new LeakageMonitor(options?.onListenerError ?? onUnexpectedError, this._options?.leakWarningThreshold ?? _globalLeakWarningThreshold) :\n            undefined;\n        this._perfMon = this._options?._profName ? new EventProfiling(this._options._profName) : undefined;\n        this._deliveryQueue = this._options?.deliveryQueue;\n    }\n    dispose() {\n        if (!this._disposed) {\n            this._disposed = true;\n            // It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n            // alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n            // unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n            // the following programming pattern is very popular:\n            //\n            // const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n            // this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n            // ...later...\n            // this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n            if (this._deliveryQueue?.current === this) {\n                this._deliveryQueue.reset();\n            }\n            if (this._listeners) {\n                if (_enableDisposeWithListenerWarning) {\n                    const listeners = this._listeners;\n                    queueMicrotask(() => {\n                        forEachListener(listeners, l => l.stack?.print());\n                    });\n                }\n                this._listeners = undefined;\n                this._size = 0;\n            }\n            this._options?.onDidRemoveLastListener?.();\n            this._leakageMon?.dispose();\n        }\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n    get event() {\n        this._event ??= (callback, thisArgs, disposables) => {\n            if (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {\n                const message = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;\n                console.warn(message);\n                const tuple = this._leakageMon.getMostFrequentStack() ?? ['UNKNOWN stack', -1];\n                const error = new ListenerRefusalError(`${message}. HINT: Stack shows most frequent listener (${tuple[1]}-times)`, tuple[0]);\n                const errorHandler = this._options?.onListenerError || onUnexpectedError;\n                errorHandler(error);\n                return Disposable.None;\n            }\n            if (this._disposed) {\n                // todo: should we warn if a listener is added to a disposed emitter? This happens often\n                return Disposable.None;\n            }\n            if (thisArgs) {\n                callback = callback.bind(thisArgs);\n            }\n            const contained = new UniqueContainer(callback);\n            let removeMonitor;\n            let stack;\n            if (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {\n                // check and record this emitter for potential leakage\n                contained.stack = Stacktrace.create();\n                removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);\n            }\n            if (_enableDisposeWithListenerWarning) {\n                contained.stack = stack ?? Stacktrace.create();\n            }\n            if (!this._listeners) {\n                this._options?.onWillAddFirstListener?.(this);\n                this._listeners = contained;\n                this._options?.onDidAddFirstListener?.(this);\n            }\n            else if (this._listeners instanceof UniqueContainer) {\n                this._deliveryQueue ??= new EventDeliveryQueuePrivate();\n                this._listeners = [this._listeners, contained];\n            }\n            else {\n                this._listeners.push(contained);\n            }\n            this._size++;\n            const result = toDisposable(() => {\n                _listenerFinalizers?.unregister(result);\n                removeMonitor?.();\n                this._removeListener(contained);\n            });\n            if (disposables instanceof DisposableStore) {\n                disposables.add(result);\n            }\n            else if (Array.isArray(disposables)) {\n                disposables.push(result);\n            }\n            if (_listenerFinalizers) {\n                const stack = new Error().stack.split('\\n').slice(2, 3).join('\\n').trim();\n                const match = /(file:|vscode-file:\\/\\/vscode-app)?(\\/[^:]*:\\d+:\\d+)/.exec(stack);\n                _listenerFinalizers.register(result, match?.[2] ?? stack, result);\n            }\n            return result;\n        };\n        return this._event;\n    }\n    _removeListener(listener) {\n        this._options?.onWillRemoveListener?.(this);\n        if (!this._listeners) {\n            return; // expected if a listener gets disposed\n        }\n        if (this._size === 1) {\n            this._listeners = undefined;\n            this._options?.onDidRemoveLastListener?.(this);\n            this._size = 0;\n            return;\n        }\n        // size > 1 which requires that listeners be a list:\n        const listeners = this._listeners;\n        const index = listeners.indexOf(listener);\n        if (index === -1) {\n            console.log('disposed?', this._disposed);\n            console.log('size?', this._size);\n            console.log('arr?', JSON.stringify(this._listeners));\n            throw new Error('Attempted to dispose unknown listener');\n        }\n        this._size--;\n        listeners[index] = undefined;\n        const adjustDeliveryQueue = this._deliveryQueue.current === this;\n        if (this._size * compactionThreshold <= listeners.length) {\n            let n = 0;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listeners[i]) {\n                    listeners[n++] = listeners[i];\n                }\n                else if (adjustDeliveryQueue) {\n                    this._deliveryQueue.end--;\n                    if (n < this._deliveryQueue.i) {\n                        this._deliveryQueue.i--;\n                    }\n                }\n            }\n            listeners.length = n;\n        }\n    }\n    _deliver(listener, value) {\n        if (!listener) {\n            return;\n        }\n        const errorHandler = this._options?.onListenerError || onUnexpectedError;\n        if (!errorHandler) {\n            listener.value(value);\n            return;\n        }\n        try {\n            listener.value(value);\n        }\n        catch (e) {\n            errorHandler(e);\n        }\n    }\n    /** Delivers items in the queue. Assumes the queue is ready to go. */\n    _deliverQueue(dq) {\n        const listeners = dq.current._listeners;\n        while (dq.i < dq.end) {\n            // important: dq.i is incremented before calling deliver() because it might reenter deliverQueue()\n            this._deliver(listeners[dq.i++], dq.value);\n        }\n        dq.reset();\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    fire(event) {\n        if (this._deliveryQueue?.current) {\n            this._deliverQueue(this._deliveryQueue);\n            this._perfMon?.stop(); // last fire() will have starting perfmon, stop it before starting the next dispatch\n        }\n        this._perfMon?.start(this._size);\n        if (!this._listeners) {\n            // no-op\n        }\n        else if (this._listeners instanceof UniqueContainer) {\n            this._deliver(this._listeners, event);\n        }\n        else {\n            const dq = this._deliveryQueue;\n            dq.enqueue(this, event, this._listeners.length);\n            this._deliverQueue(dq);\n        }\n        this._perfMon?.stop();\n    }\n    hasListeners() {\n        return this._size > 0;\n    }\n}\nexport const createEventDeliveryQueue = () => new EventDeliveryQueuePrivate();\nclass EventDeliveryQueuePrivate {\n    constructor() {\n        /**\n         * Index in current's listener list.\n         */\n        this.i = -1;\n        /**\n         * The last index in the listener's list to deliver.\n         */\n        this.end = 0;\n    }\n    enqueue(emitter, value, end) {\n        this.i = 0;\n        this.end = end;\n        this.current = emitter;\n        this.value = value;\n    }\n    reset() {\n        this.i = this.end; // force any current emission loop to stop, mainly for during dispose\n        this.current = undefined;\n        this.value = undefined;\n    }\n}\nexport class PauseableEmitter extends Emitter {\n    constructor(options) {\n        super(options);\n        this._isPaused = 0;\n        this._eventQueue = new LinkedList();\n        this._mergeFn = options?.merge;\n    }\n    pause() {\n        this._isPaused++;\n    }\n    resume() {\n        if (this._isPaused !== 0 && --this._isPaused === 0) {\n            if (this._mergeFn) {\n                // use the merge function to create a single composite\n                // event. make a copy in case firing pauses this emitter\n                if (this._eventQueue.size > 0) {\n                    const events = Array.from(this._eventQueue);\n                    this._eventQueue.clear();\n                    super.fire(this._mergeFn(events));\n                }\n            }\n            else {\n                // no merging, fire each event individually and test\n                // that this emitter isn't paused halfway through\n                while (!this._isPaused && this._eventQueue.size !== 0) {\n                    super.fire(this._eventQueue.shift());\n                }\n            }\n        }\n    }\n    fire(event) {\n        if (this._size) {\n            if (this._isPaused !== 0) {\n                this._eventQueue.push(event);\n            }\n            else {\n                super.fire(event);\n            }\n        }\n    }\n}\nexport class DebounceEmitter extends PauseableEmitter {\n    constructor(options) {\n        super(options);\n        this._delay = options.delay ?? 100;\n    }\n    fire(event) {\n        if (!this._handle) {\n            this.pause();\n            this._handle = setTimeout(() => {\n                this._handle = undefined;\n                this.resume();\n            }, this._delay);\n        }\n        super.fire(event);\n    }\n}\n/**\n * An emitter which queue all events and then process them at the\n * end of the event loop.\n */\nexport class MicrotaskEmitter extends Emitter {\n    constructor(options) {\n        super(options);\n        this._queuedEvents = [];\n        this._mergeFn = options?.merge;\n    }\n    fire(event) {\n        if (!this.hasListeners()) {\n            return;\n        }\n        this._queuedEvents.push(event);\n        if (this._queuedEvents.length === 1) {\n            queueMicrotask(() => {\n                if (this._mergeFn) {\n                    super.fire(this._mergeFn(this._queuedEvents));\n                }\n                else {\n                    this._queuedEvents.forEach(e => super.fire(e));\n                }\n                this._queuedEvents = [];\n            });\n        }\n    }\n}\n/**\n * An event emitter that multiplexes many events into a single event.\n *\n * @example Listen to the `onData` event of all `Thing`s, dynamically adding and removing `Thing`s\n * to the multiplexer as needed.\n *\n * ```typescript\n * const anythingDataMultiplexer = new EventMultiplexer<{ data: string }>();\n *\n * const thingListeners = DisposableMap<Thing, IDisposable>();\n *\n * thingService.onDidAddThing(thing => {\n *   thingListeners.set(thing, anythingDataMultiplexer.add(thing.onData);\n * });\n * thingService.onDidRemoveThing(thing => {\n *   thingListeners.deleteAndDispose(thing);\n * });\n *\n * anythingDataMultiplexer.event(e => {\n *   console.log('Something fired data ' + e.data)\n * });\n * ```\n */\nexport class EventMultiplexer {\n    constructor() {\n        this.hasListeners = false;\n        this.events = [];\n        this.emitter = new Emitter({\n            onWillAddFirstListener: () => this.onFirstListenerAdd(),\n            onDidRemoveLastListener: () => this.onLastListenerRemove()\n        });\n    }\n    get event() {\n        return this.emitter.event;\n    }\n    add(event) {\n        const e = { event: event, listener: null };\n        this.events.push(e);\n        if (this.hasListeners) {\n            this.hook(e);\n        }\n        const dispose = () => {\n            if (this.hasListeners) {\n                this.unhook(e);\n            }\n            const idx = this.events.indexOf(e);\n            this.events.splice(idx, 1);\n        };\n        return toDisposable(createSingleCallFunction(dispose));\n    }\n    onFirstListenerAdd() {\n        this.hasListeners = true;\n        this.events.forEach(e => this.hook(e));\n    }\n    onLastListenerRemove() {\n        this.hasListeners = false;\n        this.events.forEach(e => this.unhook(e));\n    }\n    hook(e) {\n        e.listener = e.event(r => this.emitter.fire(r));\n    }\n    unhook(e) {\n        e.listener?.dispose();\n        e.listener = null;\n    }\n    dispose() {\n        this.emitter.dispose();\n        for (const e of this.events) {\n            e.listener?.dispose();\n        }\n        this.events = [];\n    }\n}\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n    constructor() {\n        this.data = [];\n    }\n    wrapEvent(event, reduce, initial) {\n        return (listener, thisArgs, disposables) => {\n            return event(i => {\n                const data = this.data[this.data.length - 1];\n                // Non-reduce scenario\n                if (!reduce) {\n                    // Buffering case\n                    if (data) {\n                        data.buffers.push(() => listener.call(thisArgs, i));\n                    }\n                    else {\n                        // Not buffering case\n                        listener.call(thisArgs, i);\n                    }\n                    return;\n                }\n                // Reduce scenario\n                const reduceData = data;\n                // Not buffering case\n                if (!reduceData) {\n                    // TODO: Is there a way to cache this reduce call for all listeners?\n                    listener.call(thisArgs, reduce(initial, i));\n                    return;\n                }\n                // Buffering case\n                reduceData.items ??= [];\n                reduceData.items.push(i);\n                if (reduceData.buffers.length === 0) {\n                    // Include a single buffered function that will reduce all events when we're done buffering events\n                    data.buffers.push(() => {\n                        // cache the reduced result so that the value can be shared across all listeners\n                        reduceData.reducedResult ??= initial\n                            ? reduceData.items.reduce(reduce, initial)\n                            : reduceData.items.reduce(reduce);\n                        listener.call(thisArgs, reduceData.reducedResult);\n                    });\n                }\n            }, undefined, disposables);\n        };\n    }\n    bufferEvents(fn) {\n        const data = { buffers: new Array() };\n        this.data.push(data);\n        const r = fn();\n        this.data.pop();\n        data.buffers.forEach(flush => flush());\n        return r;\n    }\n}\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay {\n    constructor() {\n        this.listening = false;\n        this.inputEvent = Event.None;\n        this.inputEventListener = Disposable.None;\n        this.emitter = new Emitter({\n            onDidAddFirstListener: () => {\n                this.listening = true;\n                this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n            },\n            onDidRemoveLastListener: () => {\n                this.listening = false;\n                this.inputEventListener.dispose();\n            }\n        });\n        this.event = this.emitter.event;\n    }\n    set input(event) {\n        this.inputEvent = event;\n        if (this.listening) {\n            this.inputEventListener.dispose();\n            this.inputEventListener = event(this.emitter.fire, this.emitter);\n        }\n    }\n    dispose() {\n        this.inputEventListener.dispose();\n        this.emitter.dispose();\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}