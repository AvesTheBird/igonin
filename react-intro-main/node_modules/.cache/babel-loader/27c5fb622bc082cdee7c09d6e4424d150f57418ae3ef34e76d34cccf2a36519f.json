{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { DIRECTION, DIRECTION_MASK } from './Constants';\nimport Point from '../view/geometry/Point';\nimport Rectangle from '../view/geometry/Rectangle';\nimport { getValue, isNullish } from './Utils';\n/**\n * Converts the given degree to radians.\n */\nexport const toRadians = deg => {\n  return Math.PI * deg / 180;\n};\n/**\n * Converts the given radians to degree.\n */\nexport const toDegree = rad => {\n  return rad * 180 / Math.PI;\n};\n/**\n * Converts the given arc to a series of curves.\n */\nexport const arcToCurves = (x0, y0, r1, r2, angle, largeArcFlag, sweepFlag, x, y) => {\n  x -= x0;\n  y -= y0;\n  if (r1 === 0 || r2 === 0) {\n    return [];\n  }\n  const fS = sweepFlag;\n  const psai = angle;\n  r1 = Math.abs(r1);\n  r2 = Math.abs(r2);\n  const ctx = -x / 2;\n  const cty = -y / 2;\n  const cpsi = Math.cos(psai * Math.PI / 180);\n  const spsi = Math.sin(psai * Math.PI / 180);\n  const rxd = cpsi * ctx + spsi * cty;\n  const ryd = -1 * spsi * ctx + cpsi * cty;\n  const rxdd = rxd * rxd;\n  const rydd = ryd * ryd;\n  const r1x = r1 * r1;\n  const r2y = r2 * r2;\n  const lamda = rxdd / r1x + rydd / r2y;\n  let sds;\n  if (lamda > 1) {\n    r1 = Math.sqrt(lamda) * r1;\n    r2 = Math.sqrt(lamda) * r2;\n    sds = 0;\n  } else {\n    let seif = 1;\n    if (largeArcFlag === fS) {\n      seif = -1;\n    }\n    sds = seif * Math.sqrt((r1x * r2y - r1x * rydd - r2y * rxdd) / (r1x * rydd + r2y * rxdd));\n  }\n  const txd = sds * r1 * ryd / r2;\n  const tyd = -1 * sds * r2 * rxd / r1;\n  const tx = cpsi * txd - spsi * tyd + x / 2;\n  const ty = spsi * txd + cpsi * tyd + y / 2;\n  let rad = Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1) - Math.atan2(0, 1);\n  let s1 = rad >= 0 ? rad : 2 * Math.PI + rad;\n  rad = Math.atan2((-ryd - tyd) / r2, (-rxd - txd) / r1) - Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1);\n  let dr = rad >= 0 ? rad : 2 * Math.PI + rad;\n  if (!fS && dr > 0) {\n    dr -= 2 * Math.PI;\n  } else if (fS && dr < 0) {\n    dr += 2 * Math.PI;\n  }\n  const sse = dr * 2 / Math.PI;\n  const seg = Math.ceil(sse < 0 ? -1 * sse : sse);\n  const segr = dr / seg;\n  const t = 8 / 3 * Math.sin(segr / 4) * Math.sin(segr / 4) / Math.sin(segr / 2);\n  const cpsir1 = cpsi * r1;\n  const cpsir2 = cpsi * r2;\n  const spsir1 = spsi * r1;\n  const spsir2 = spsi * r2;\n  let mc = Math.cos(s1);\n  let ms = Math.sin(s1);\n  let x2 = -t * (cpsir1 * ms + spsir2 * mc);\n  let y2 = -t * (spsir1 * ms - cpsir2 * mc);\n  let x3 = 0;\n  let y3 = 0;\n  const result = [];\n  for (let n = 0; n < seg; ++n) {\n    s1 += segr;\n    mc = Math.cos(s1);\n    ms = Math.sin(s1);\n    x3 = cpsir1 * mc - spsir2 * ms + tx;\n    y3 = spsir1 * mc + cpsir2 * ms + ty;\n    const dx = -t * (cpsir1 * ms + spsir2 * mc);\n    const dy = -t * (spsir1 * ms - cpsir2 * mc);\n    // CurveTo updates x0, y0 so need to restore it\n    const index = n * 6;\n    result[index] = Number(x2 + x0);\n    result[index + 1] = Number(y2 + y0);\n    result[index + 2] = Number(x3 - dx + x0);\n    result[index + 3] = Number(y3 - dy + y0);\n    result[index + 4] = Number(x3 + x0);\n    result[index + 5] = Number(y3 + y0);\n    x2 = x3 + dx;\n    y2 = y3 + dy;\n  }\n  return result;\n};\n/**\n * Returns the bounding box for the rotated rectangle.\n *\n * @param rect {@link Rectangle} to be rotated.\n * @param angle Number that represents the angle (in degrees).\n * @param cx Optional {@link Point} that represents the rotation center. If no\n * rotation center is given then the center of rect is used.\n */\nexport const getBoundingBox = (rect, rotation, cx = null) => {\n  let result = null;\n  if (rect && rotation !== 0) {\n    const rad = toRadians(rotation);\n    const cos = Math.cos(rad);\n    const sin = Math.sin(rad);\n    cx = cx != null ? cx : new Point(rect.x + rect.width / 2, rect.y + rect.height / 2);\n    let p1 = new Point(rect.x, rect.y);\n    let p2 = new Point(rect.x + rect.width, rect.y);\n    let p3 = new Point(p2.x, rect.y + rect.height);\n    let p4 = new Point(rect.x, p3.y);\n    p1 = getRotatedPoint(p1, cos, sin, cx);\n    p2 = getRotatedPoint(p2, cos, sin, cx);\n    p3 = getRotatedPoint(p3, cos, sin, cx);\n    p4 = getRotatedPoint(p4, cos, sin, cx);\n    result = new Rectangle(p1.x, p1.y, 0, 0);\n    result.add(new Rectangle(p2.x, p2.y, 0, 0));\n    result.add(new Rectangle(p3.x, p3.y, 0, 0));\n    result.add(new Rectangle(p4.x, p4.y, 0, 0));\n  }\n  return result;\n};\n/**\n * Rotates the given point by the given cos and sin.\n */\nexport const getRotatedPoint = (pt, cos, sin, c = new Point()) => {\n  const x = pt.x - c.x;\n  const y = pt.y - c.y;\n  const x1 = x * cos - y * sin;\n  const y1 = y * cos + x * sin;\n  return new Point(x1 + c.x, y1 + c.y);\n};\n/**\n * Returns an integer mask of the port constraints of the given map\n *\n * @param terminal {@link CelState} that represents the terminal.\n * @param edge {@link CelState} that represents the edge.\n * @param source Boolean that specifies if the terminal is the source terminal.\n * @param defaultValue Default value to be returned if no port constraint is defined in the terminal.\n * @return the mask of port constraint directions\n */\nexport const getPortConstraints = (terminal, edge, source, defaultValue) => {\n  const value = getValue(terminal.style, 'portConstraint', getValue(edge.style, source ? 'sourcePortConstraint' : 'targetPortConstraint', null));\n  if (isNullish(value)) {\n    return defaultValue;\n  }\n  const directions = value.toString();\n  let returnValue = DIRECTION_MASK.NONE;\n  const constraintRotationEnabled = terminal.style.portConstraintRotation ?? false;\n  let rotation = 0;\n  if (constraintRotationEnabled) {\n    rotation = terminal.style.rotation ?? 0;\n  }\n  let quad = 0;\n  if (rotation > 45) {\n    quad = 1;\n    if (rotation >= 135) {\n      quad = 2;\n    }\n  } else if (rotation < -45) {\n    quad = 3;\n    if (rotation <= -135) {\n      quad = 2;\n    }\n  }\n  if (directions.indexOf(DIRECTION.NORTH) >= 0) {\n    switch (quad) {\n      case 0:\n        returnValue |= DIRECTION_MASK.NORTH;\n        break;\n      case 1:\n        returnValue |= DIRECTION_MASK.EAST;\n        break;\n      case 2:\n        returnValue |= DIRECTION_MASK.SOUTH;\n        break;\n      case 3:\n        returnValue |= DIRECTION_MASK.WEST;\n        break;\n    }\n  }\n  if (directions.indexOf(DIRECTION.WEST) >= 0) {\n    switch (quad) {\n      case 0:\n        returnValue |= DIRECTION_MASK.WEST;\n        break;\n      case 1:\n        returnValue |= DIRECTION_MASK.NORTH;\n        break;\n      case 2:\n        returnValue |= DIRECTION_MASK.EAST;\n        break;\n      case 3:\n        returnValue |= DIRECTION_MASK.SOUTH;\n        break;\n    }\n  }\n  if (directions.indexOf(DIRECTION.SOUTH) >= 0) {\n    switch (quad) {\n      case 0:\n        returnValue |= DIRECTION_MASK.SOUTH;\n        break;\n      case 1:\n        returnValue |= DIRECTION_MASK.WEST;\n        break;\n      case 2:\n        returnValue |= DIRECTION_MASK.NORTH;\n        break;\n      case 3:\n        returnValue |= DIRECTION_MASK.EAST;\n        break;\n    }\n  }\n  if (directions.indexOf(DIRECTION.EAST) >= 0) {\n    switch (quad) {\n      case 0:\n        returnValue |= DIRECTION_MASK.EAST;\n        break;\n      case 1:\n        returnValue |= DIRECTION_MASK.SOUTH;\n        break;\n      case 2:\n        returnValue |= DIRECTION_MASK.WEST;\n        break;\n      case 3:\n        returnValue |= DIRECTION_MASK.NORTH;\n        break;\n    }\n  }\n  return returnValue;\n};\n/**\n * Reverse the port constraint bitmask. For example, north | east\n * becomes south | west\n */\nexport const reversePortConstraints = constraint => {\n  let result = 0;\n  result = (constraint & DIRECTION_MASK.WEST) << 3;\n  result |= (constraint & DIRECTION_MASK.NORTH) << 1;\n  result |= (constraint & DIRECTION_MASK.SOUTH) >> 1;\n  result |= (constraint & DIRECTION_MASK.EAST) >> 3;\n  return result;\n};\n/**\n * Finds the index of the nearest segment on the given cell state for\n * the specified coordinate pair.\n */\nexport const findNearestSegment = (state, x, y) => {\n  let index = -1;\n  if (state.absolutePoints.length > 0) {\n    let last = state.absolutePoints[0];\n    let min = null;\n    for (let i = 1; i < state.absolutePoints.length; i += 1) {\n      const current = state.absolutePoints[i];\n      if (!last || !current) continue;\n      const dist = ptSegDistSq(last.x, last.y, current.x, current.y, x, y);\n      if (min == null || dist < min) {\n        min = dist;\n        index = i - 1;\n      }\n      last = current;\n    }\n  }\n  return index;\n};\n/**\n * Adds the given margins to the given rectangle and rotates and flips the\n * rectangle according to the respective styles in style.\n */\nexport const getDirectedBounds = (rect, m, style, flipH, flipV) => {\n  const d = getValue(style, 'direction', DIRECTION.EAST);\n  flipH = flipH != null ? flipH : getValue(style, 'flipH', false);\n  flipV = flipV != null ? flipV : getValue(style, 'flipV', false);\n  m.x = Math.round(Math.max(0, Math.min(rect.width, m.x)));\n  m.y = Math.round(Math.max(0, Math.min(rect.height, m.y)));\n  m.width = Math.round(Math.max(0, Math.min(rect.width, m.width)));\n  m.height = Math.round(Math.max(0, Math.min(rect.height, m.height)));\n  if (flipV && (d === DIRECTION.SOUTH || d === DIRECTION.NORTH) || flipH && (d === DIRECTION.EAST || d === DIRECTION.WEST)) {\n    const tmp = m.x;\n    m.x = m.width;\n    m.width = tmp;\n  }\n  if (flipH && (d === DIRECTION.SOUTH || d === DIRECTION.NORTH) || flipV && (d === DIRECTION.EAST || d === DIRECTION.WEST)) {\n    const tmp = m.y;\n    m.y = m.height;\n    m.height = tmp;\n  }\n  const m2 = Rectangle.fromRectangle(m);\n  if (d === DIRECTION.SOUTH) {\n    m2.y = m.x;\n    m2.x = m.height;\n    m2.width = m.y;\n    m2.height = m.width;\n  } else if (d === DIRECTION.WEST) {\n    m2.y = m.height;\n    m2.x = m.width;\n    m2.width = m.x;\n    m2.height = m.y;\n  } else if (d === DIRECTION.NORTH) {\n    m2.y = m.width;\n    m2.x = m.y;\n    m2.width = m.height;\n    m2.height = m.x;\n  }\n  return new Rectangle(rect.x + m2.x, rect.y + m2.y, rect.width - m2.width - m2.x, rect.height - m2.height - m2.y);\n};\n/**\n * Returns the intersection between the polygon defined by the array of\n * points and the line between center and point.\n */\nexport const getPerimeterPoint = (pts, center, point) => {\n  let min = null;\n  for (let i = 0; i < pts.length - 1; i += 1) {\n    const pt = intersection(pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y, center.x, center.y, point.x, point.y);\n    if (pt != null) {\n      const dx = point.x - pt.x;\n      const dy = point.y - pt.y;\n      const ip = {\n        p: pt,\n        distSq: dy * dy + dx * dx\n      };\n      if (ip != null && (min == null || min.distSq > ip.distSq)) {\n        min = ip;\n      }\n    }\n  }\n  return min != null ? min.p : null;\n};\n/**\n * Returns true if the given rectangle intersects the given segment.\n *\n * @param bounds {@link Rectangle} that represents the rectangle.\n * @param p1 {@link Point} that represents the first point of the segment.\n * @param p2 {@link Point} that represents the second point of the segment.\n */\nexport const rectangleIntersectsSegment = (bounds, p1, p2) => {\n  const top = bounds.y;\n  const left = bounds.x;\n  const bottom = top + bounds.height;\n  const right = left + bounds.width;\n  // Find min and max X for the segment\n  let minX = p1.x;\n  let maxX = p2.x;\n  if (p1.x > p2.x) {\n    minX = p2.x;\n    maxX = p1.x;\n  }\n  // Find the intersection of the segment's and rectangle's x-projections\n  if (maxX > right) {\n    maxX = right;\n  }\n  if (minX < left) {\n    minX = left;\n  }\n  if (minX > maxX) {\n    // If their projections do not intersect return false\n    return false;\n  }\n  // Find corresponding min and max Y for min and max X we found before\n  let minY = p1.y;\n  let maxY = p2.y;\n  const dx = p2.x - p1.x;\n  if (Math.abs(dx) > 0.0000001) {\n    const a = (p2.y - p1.y) / dx;\n    const b = p1.y - a * p1.x;\n    minY = a * minX + b;\n    maxY = a * maxX + b;\n  }\n  if (minY > maxY) {\n    const tmp = maxY;\n    maxY = minY;\n    minY = tmp;\n  }\n  // Find the intersection of the segment's and rectangle's y-projections\n  if (maxY > bottom) {\n    maxY = bottom;\n  }\n  if (minY < top) {\n    minY = top;\n  }\n  if (minY > maxY) {\n    // If Y-projections do not intersect return false\n    return false;\n  }\n  return true;\n};\n/**\n * Returns true if the specified point (x, y) is contained in the given rectangle.\n *\n * @param bounds {@link Rectangle} that represents the area.\n * @param x X-coordinate of the point.\n * @param y Y-coordinate of the point.\n */\nexport const contains = (bounds, x, y) => {\n  return bounds.x <= x && bounds.x + bounds.width >= x && bounds.y <= y && bounds.y + bounds.height >= y;\n};\n/**\n * Returns true if the two rectangles intersect.\n *\n * @param a {@link Rectangle} to be checked for intersection.\n * @param b {@link Rectangle} to be checked for intersection.\n */\nexport const intersects = (a, b) => {\n  let tw = a.width;\n  let th = a.height;\n  let rw = b.width;\n  let rh = b.height;\n  if (rw <= 0 || rh <= 0 || tw <= 0 || th <= 0) {\n    return false;\n  }\n  const tx = a.x;\n  const ty = a.y;\n  const rx = b.x;\n  const ry = b.y;\n  rw += rx;\n  rh += ry;\n  tw += tx;\n  th += ty;\n  return (rw < rx || rw > tx) && (rh < ry || rh > ty) && (tw < tx || tw > rx) && (th < ty || th > ry);\n};\n/**\n * Returns true if the state and the hotspot intersect.\n *\n * @param state <CellState>\n * @param x X-coordinate.\n * @param y Y-coordinate.\n * @param hotspot Optional size of the hostpot.\n * @param min Optional min size of the hostpot.\n * @param max Optional max size of the hostpot.\n */\nexport const intersectsHotspot = (state, x, y, hotspot, min, max) => {\n  hotspot = hotspot != null ? hotspot : 1;\n  min = min != null ? min : 0;\n  max = max != null ? max : 0;\n  if (hotspot > 0) {\n    let cx = state.getCenterX();\n    let cy = state.getCenterY();\n    let w = state.width;\n    let h = state.height;\n    const start = getValue(state.style, 'startSize') * state.view.scale;\n    if (start > 0) {\n      if (getValue(state.style, 'horizontal', true)) {\n        cy = state.y + start / 2;\n        h = start;\n      } else {\n        cx = state.x + start / 2;\n        w = start;\n      }\n    }\n    w = Math.max(min, w * hotspot);\n    h = Math.max(min, h * hotspot);\n    if (max > 0) {\n      w = Math.min(w, max);\n      h = Math.min(h, max);\n    }\n    const rect = new Rectangle(cx - w / 2, cy - h / 2, w, h);\n    const alpha = toRadians(getValue(state.style, 'rotation') || 0);\n    if (alpha != 0) {\n      const cos = Math.cos(-alpha);\n      const sin = Math.sin(-alpha);\n      const cx = new Point(state.getCenterX(), state.getCenterY());\n      const pt = getRotatedPoint(new Point(x, y), cos, sin, cx);\n      x = pt.x;\n      y = pt.y;\n    }\n    return contains(rect, x, y);\n  }\n  return true;\n};\n/**\n * Returns true if the specified value is numeric, that is, if it is not\n * null, not an empty string, not a HEX number and isNaN returns false.\n *\n * @param n String representing the possibly numeric value.\n */\nexport const isNumeric = n => {\n  return !Number.isNaN(parseFloat(n)) && isFinite(+n) && (typeof n !== 'string' || n.toLowerCase().indexOf('0x') < 0);\n};\n/**\n * Returns true if the given value is an valid integer number.\n *\n * @param n String representing the possibly numeric value.\n */\nexport const isInteger = n => {\n  return String(parseInt(n)) === String(n);\n};\n/**\n * Returns the remainder of division of n by m. You should use this instead\n * of the built-in operation as the built-in operation does not properly\n * handle negative numbers.\n */\nexport const mod = (n, m) => {\n  return (n % m + m) % m;\n};\n/**\n * Returns the intersection of two lines as an {@link Point}.\n *\n * @param x0 X-coordinate of the first line's startpoint.\n * @param y0 X-coordinate of the first line's startpoint.\n * @param x1 X-coordinate of the first line's endpoint.\n * @param y1 Y-coordinate of the first line's endpoint.\n * @param x2 X-coordinate of the second line's startpoint.\n * @param y2 Y-coordinate of the second line's startpoint.\n * @param x3 X-coordinate of the second line's endpoint.\n * @param y3 Y-coordinate of the second line's endpoint.\n */\nexport const intersection = (x0, y0, x1, y1, x2, y2, x3, y3) => {\n  const denom = (y3 - y2) * (x1 - x0) - (x3 - x2) * (y1 - y0);\n  const nume_a = (x3 - x2) * (y0 - y2) - (y3 - y2) * (x0 - x2);\n  const nume_b = (x1 - x0) * (y0 - y2) - (y1 - y0) * (x0 - x2);\n  const ua = nume_a / denom;\n  const ub = nume_b / denom;\n  if (ua >= 0.0 && ua <= 1.0 && ub >= 0.0 && ub <= 1.0) {\n    // Get the intersection point\n    const x = x0 + ua * (x1 - x0);\n    const y = y0 + ua * (y1 - y0);\n    return new Point(x, y);\n  }\n  // No intersection\n  return null;\n};\n/**\n * Returns the square distance between a segment and a point. To get the\n * distance between a point and a line (with infinite length) use\n * {@link Utils#ptLineDist}.\n *\n * @param x1 X-coordinate of the startpoint of the segment.\n * @param y1 Y-coordinate of the startpoint of the segment.\n * @param x2 X-coordinate of the endpoint of the segment.\n * @param y2 Y-coordinate of the endpoint of the segment.\n * @param px X-coordinate of the point.\n * @param py Y-coordinate of the point.\n */\nexport const ptSegDistSq = (x1, y1, x2, y2, px, py) => {\n  x2 -= x1;\n  y2 -= y1;\n  px -= x1;\n  py -= y1;\n  let dotprod = px * x2 + py * y2;\n  let projlenSq;\n  if (dotprod <= 0.0) {\n    projlenSq = 0.0;\n  } else {\n    px = x2 - px;\n    py = y2 - py;\n    dotprod = px * x2 + py * y2;\n    if (dotprod <= 0.0) {\n      projlenSq = 0.0;\n    } else {\n      projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);\n    }\n  }\n  let lenSq = px * px + py * py - projlenSq;\n  if (lenSq < 0) {\n    lenSq = 0;\n  }\n  return lenSq;\n};\n/**\n * Returns the distance between a line defined by two points and a point.\n * To get the distance between a point and a segment (with a specific\n * length) use {@link Utils#ptSeqDistSq}.\n *\n * @param x1 X-coordinate of point 1 of the line.\n * @param y1 Y-coordinate of point 1 of the line.\n * @param x2 X-coordinate of point 1 of the line.\n * @param y2 Y-coordinate of point 1 of the line.\n * @param px X-coordinate of the point.\n * @param py Y-coordinate of the point.\n */\nexport const ptLineDist = (x1, y1, x2, y2, px, py) => {\n  return Math.abs((y2 - y1) * px - (x2 - x1) * py + x2 * y1 - y2 * x1) / Math.sqrt((y2 - y1) * (y2 - y1) + (x2 - x1) * (x2 - x1));\n};\n/**\n * Returns 1 if the given point on the right side of the segment, 0 if its\n * on the segment, and -1 if the point is on the left side of the segment.\n *\n * @param x1 X-coordinate of the startpoint of the segment.\n * @param y1 Y-coordinate of the startpoint of the segment.\n * @param x2 X-coordinate of the endpoint of the segment.\n * @param y2 Y-coordinate of the endpoint of the segment.\n * @param px X-coordinate of the point.\n * @param py Y-coordinate of the point.\n */\nexport const relativeCcw = (x1, y1, x2, y2, px, py) => {\n  x2 -= x1;\n  y2 -= y1;\n  px -= x1;\n  py -= y1;\n  let ccw = px * y2 - py * x2;\n  if (ccw == 0.0) {\n    ccw = px * x2 + py * y2;\n    if (ccw > 0.0) {\n      px -= x2;\n      py -= y2;\n      ccw = px * x2 + py * y2;\n      if (ccw < 0.0) {\n        ccw = 0.0;\n      }\n    }\n  }\n  return ccw < 0.0 ? -1 : ccw > 0.0 ? 1 : 0;\n};","map":{"version":3,"names":["DIRECTION","DIRECTION_MASK","Point","Rectangle","getValue","isNullish","toRadians","deg","Math","PI","toDegree","rad","arcToCurves","x0","y0","r1","r2","angle","largeArcFlag","sweepFlag","x","y","fS","psai","abs","ctx","cty","cpsi","cos","spsi","sin","rxd","ryd","rxdd","rydd","r1x","r2y","lamda","sds","sqrt","seif","txd","tyd","tx","ty","atan2","s1","dr","sse","seg","ceil","segr","t","cpsir1","cpsir2","spsir1","spsir2","mc","ms","x2","y2","x3","y3","result","n","dx","dy","index","Number","getBoundingBox","rect","rotation","cx","width","height","p1","p2","p3","p4","getRotatedPoint","add","pt","c","x1","y1","getPortConstraints","terminal","edge","source","defaultValue","value","style","directions","toString","returnValue","NONE","constraintRotationEnabled","portConstraintRotation","quad","indexOf","NORTH","EAST","SOUTH","WEST","reversePortConstraints","constraint","findNearestSegment","state","absolutePoints","length","last","min","i","current","dist","ptSegDistSq","getDirectedBounds","m","flipH","flipV","d","round","max","tmp","m2","fromRectangle","getPerimeterPoint","pts","center","point","intersection","ip","p","distSq","rectangleIntersectsSegment","bounds","top","left","bottom","right","minX","maxX","minY","maxY","a","b","contains","intersects","tw","th","rw","rh","rx","ry","intersectsHotspot","hotspot","getCenterX","cy","getCenterY","w","h","start","view","scale","alpha","isNumeric","isNaN","parseFloat","isFinite","toLowerCase","isInteger","String","parseInt","mod","denom","nume_a","nume_b","ua","ub","px","py","dotprod","projlenSq","lenSq","ptLineDist","relativeCcw","ccw"],"sources":["D:/OSPanel/domains/old/react/react-intro/node_modules/@maxgraph/core/dist/util/mathUtils.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { DIRECTION, DIRECTION_MASK } from './Constants';\nimport Point from '../view/geometry/Point';\nimport Rectangle from '../view/geometry/Rectangle';\nimport { getValue, isNullish } from './Utils';\n/**\n * Converts the given degree to radians.\n */\nexport const toRadians = (deg) => {\n    return (Math.PI * deg) / 180;\n};\n/**\n * Converts the given radians to degree.\n */\nexport const toDegree = (rad) => {\n    return (rad * 180) / Math.PI;\n};\n/**\n * Converts the given arc to a series of curves.\n */\nexport const arcToCurves = (x0, y0, r1, r2, angle, largeArcFlag, sweepFlag, x, y) => {\n    x -= x0;\n    y -= y0;\n    if (r1 === 0 || r2 === 0) {\n        return [];\n    }\n    const fS = sweepFlag;\n    const psai = angle;\n    r1 = Math.abs(r1);\n    r2 = Math.abs(r2);\n    const ctx = -x / 2;\n    const cty = -y / 2;\n    const cpsi = Math.cos((psai * Math.PI) / 180);\n    const spsi = Math.sin((psai * Math.PI) / 180);\n    const rxd = cpsi * ctx + spsi * cty;\n    const ryd = -1 * spsi * ctx + cpsi * cty;\n    const rxdd = rxd * rxd;\n    const rydd = ryd * ryd;\n    const r1x = r1 * r1;\n    const r2y = r2 * r2;\n    const lamda = rxdd / r1x + rydd / r2y;\n    let sds;\n    if (lamda > 1) {\n        r1 = Math.sqrt(lamda) * r1;\n        r2 = Math.sqrt(lamda) * r2;\n        sds = 0;\n    }\n    else {\n        let seif = 1;\n        if (largeArcFlag === fS) {\n            seif = -1;\n        }\n        sds =\n            seif * Math.sqrt((r1x * r2y - r1x * rydd - r2y * rxdd) / (r1x * rydd + r2y * rxdd));\n    }\n    const txd = (sds * r1 * ryd) / r2;\n    const tyd = (-1 * sds * r2 * rxd) / r1;\n    const tx = cpsi * txd - spsi * tyd + x / 2;\n    const ty = spsi * txd + cpsi * tyd + y / 2;\n    let rad = Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1) - Math.atan2(0, 1);\n    let s1 = rad >= 0 ? rad : 2 * Math.PI + rad;\n    rad =\n        Math.atan2((-ryd - tyd) / r2, (-rxd - txd) / r1) -\n            Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1);\n    let dr = rad >= 0 ? rad : 2 * Math.PI + rad;\n    if (!fS && dr > 0) {\n        dr -= 2 * Math.PI;\n    }\n    else if (fS && dr < 0) {\n        dr += 2 * Math.PI;\n    }\n    const sse = (dr * 2) / Math.PI;\n    const seg = Math.ceil(sse < 0 ? -1 * sse : sse);\n    const segr = dr / seg;\n    const t = ((8 / 3) * Math.sin(segr / 4) * Math.sin(segr / 4)) / Math.sin(segr / 2);\n    const cpsir1 = cpsi * r1;\n    const cpsir2 = cpsi * r2;\n    const spsir1 = spsi * r1;\n    const spsir2 = spsi * r2;\n    let mc = Math.cos(s1);\n    let ms = Math.sin(s1);\n    let x2 = -t * (cpsir1 * ms + spsir2 * mc);\n    let y2 = -t * (spsir1 * ms - cpsir2 * mc);\n    let x3 = 0;\n    let y3 = 0;\n    const result = [];\n    for (let n = 0; n < seg; ++n) {\n        s1 += segr;\n        mc = Math.cos(s1);\n        ms = Math.sin(s1);\n        x3 = cpsir1 * mc - spsir2 * ms + tx;\n        y3 = spsir1 * mc + cpsir2 * ms + ty;\n        const dx = -t * (cpsir1 * ms + spsir2 * mc);\n        const dy = -t * (spsir1 * ms - cpsir2 * mc);\n        // CurveTo updates x0, y0 so need to restore it\n        const index = n * 6;\n        result[index] = Number(x2 + x0);\n        result[index + 1] = Number(y2 + y0);\n        result[index + 2] = Number(x3 - dx + x0);\n        result[index + 3] = Number(y3 - dy + y0);\n        result[index + 4] = Number(x3 + x0);\n        result[index + 5] = Number(y3 + y0);\n        x2 = x3 + dx;\n        y2 = y3 + dy;\n    }\n    return result;\n};\n/**\n * Returns the bounding box for the rotated rectangle.\n *\n * @param rect {@link Rectangle} to be rotated.\n * @param angle Number that represents the angle (in degrees).\n * @param cx Optional {@link Point} that represents the rotation center. If no\n * rotation center is given then the center of rect is used.\n */\nexport const getBoundingBox = (rect, rotation, cx = null) => {\n    let result = null;\n    if (rect && rotation !== 0) {\n        const rad = toRadians(rotation);\n        const cos = Math.cos(rad);\n        const sin = Math.sin(rad);\n        cx = cx != null ? cx : new Point(rect.x + rect.width / 2, rect.y + rect.height / 2);\n        let p1 = new Point(rect.x, rect.y);\n        let p2 = new Point(rect.x + rect.width, rect.y);\n        let p3 = new Point(p2.x, rect.y + rect.height);\n        let p4 = new Point(rect.x, p3.y);\n        p1 = getRotatedPoint(p1, cos, sin, cx);\n        p2 = getRotatedPoint(p2, cos, sin, cx);\n        p3 = getRotatedPoint(p3, cos, sin, cx);\n        p4 = getRotatedPoint(p4, cos, sin, cx);\n        result = new Rectangle(p1.x, p1.y, 0, 0);\n        result.add(new Rectangle(p2.x, p2.y, 0, 0));\n        result.add(new Rectangle(p3.x, p3.y, 0, 0));\n        result.add(new Rectangle(p4.x, p4.y, 0, 0));\n    }\n    return result;\n};\n/**\n * Rotates the given point by the given cos and sin.\n */\nexport const getRotatedPoint = (pt, cos, sin, c = new Point()) => {\n    const x = pt.x - c.x;\n    const y = pt.y - c.y;\n    const x1 = x * cos - y * sin;\n    const y1 = y * cos + x * sin;\n    return new Point(x1 + c.x, y1 + c.y);\n};\n/**\n * Returns an integer mask of the port constraints of the given map\n *\n * @param terminal {@link CelState} that represents the terminal.\n * @param edge {@link CelState} that represents the edge.\n * @param source Boolean that specifies if the terminal is the source terminal.\n * @param defaultValue Default value to be returned if no port constraint is defined in the terminal.\n * @return the mask of port constraint directions\n */\nexport const getPortConstraints = (terminal, edge, source, defaultValue) => {\n    const value = getValue(terminal.style, 'portConstraint', getValue(edge.style, source ? 'sourcePortConstraint' : 'targetPortConstraint', null));\n    if (isNullish(value)) {\n        return defaultValue;\n    }\n    const directions = value.toString();\n    let returnValue = DIRECTION_MASK.NONE;\n    const constraintRotationEnabled = terminal.style.portConstraintRotation ?? false;\n    let rotation = 0;\n    if (constraintRotationEnabled) {\n        rotation = terminal.style.rotation ?? 0;\n    }\n    let quad = 0;\n    if (rotation > 45) {\n        quad = 1;\n        if (rotation >= 135) {\n            quad = 2;\n        }\n    }\n    else if (rotation < -45) {\n        quad = 3;\n        if (rotation <= -135) {\n            quad = 2;\n        }\n    }\n    if (directions.indexOf(DIRECTION.NORTH) >= 0) {\n        switch (quad) {\n            case 0:\n                returnValue |= DIRECTION_MASK.NORTH;\n                break;\n            case 1:\n                returnValue |= DIRECTION_MASK.EAST;\n                break;\n            case 2:\n                returnValue |= DIRECTION_MASK.SOUTH;\n                break;\n            case 3:\n                returnValue |= DIRECTION_MASK.WEST;\n                break;\n        }\n    }\n    if (directions.indexOf(DIRECTION.WEST) >= 0) {\n        switch (quad) {\n            case 0:\n                returnValue |= DIRECTION_MASK.WEST;\n                break;\n            case 1:\n                returnValue |= DIRECTION_MASK.NORTH;\n                break;\n            case 2:\n                returnValue |= DIRECTION_MASK.EAST;\n                break;\n            case 3:\n                returnValue |= DIRECTION_MASK.SOUTH;\n                break;\n        }\n    }\n    if (directions.indexOf(DIRECTION.SOUTH) >= 0) {\n        switch (quad) {\n            case 0:\n                returnValue |= DIRECTION_MASK.SOUTH;\n                break;\n            case 1:\n                returnValue |= DIRECTION_MASK.WEST;\n                break;\n            case 2:\n                returnValue |= DIRECTION_MASK.NORTH;\n                break;\n            case 3:\n                returnValue |= DIRECTION_MASK.EAST;\n                break;\n        }\n    }\n    if (directions.indexOf(DIRECTION.EAST) >= 0) {\n        switch (quad) {\n            case 0:\n                returnValue |= DIRECTION_MASK.EAST;\n                break;\n            case 1:\n                returnValue |= DIRECTION_MASK.SOUTH;\n                break;\n            case 2:\n                returnValue |= DIRECTION_MASK.WEST;\n                break;\n            case 3:\n                returnValue |= DIRECTION_MASK.NORTH;\n                break;\n        }\n    }\n    return returnValue;\n};\n/**\n * Reverse the port constraint bitmask. For example, north | east\n * becomes south | west\n */\nexport const reversePortConstraints = (constraint) => {\n    let result = 0;\n    result = (constraint & DIRECTION_MASK.WEST) << 3;\n    result |= (constraint & DIRECTION_MASK.NORTH) << 1;\n    result |= (constraint & DIRECTION_MASK.SOUTH) >> 1;\n    result |= (constraint & DIRECTION_MASK.EAST) >> 3;\n    return result;\n};\n/**\n * Finds the index of the nearest segment on the given cell state for\n * the specified coordinate pair.\n */\nexport const findNearestSegment = (state, x, y) => {\n    let index = -1;\n    if (state.absolutePoints.length > 0) {\n        let last = state.absolutePoints[0];\n        let min = null;\n        for (let i = 1; i < state.absolutePoints.length; i += 1) {\n            const current = state.absolutePoints[i];\n            if (!last || !current)\n                continue;\n            const dist = ptSegDistSq(last.x, last.y, current.x, current.y, x, y);\n            if (min == null || dist < min) {\n                min = dist;\n                index = i - 1;\n            }\n            last = current;\n        }\n    }\n    return index;\n};\n/**\n * Adds the given margins to the given rectangle and rotates and flips the\n * rectangle according to the respective styles in style.\n */\nexport const getDirectedBounds = (rect, m, style, flipH, flipV) => {\n    const d = getValue(style, 'direction', DIRECTION.EAST);\n    flipH = flipH != null ? flipH : getValue(style, 'flipH', false);\n    flipV = flipV != null ? flipV : getValue(style, 'flipV', false);\n    m.x = Math.round(Math.max(0, Math.min(rect.width, m.x)));\n    m.y = Math.round(Math.max(0, Math.min(rect.height, m.y)));\n    m.width = Math.round(Math.max(0, Math.min(rect.width, m.width)));\n    m.height = Math.round(Math.max(0, Math.min(rect.height, m.height)));\n    if ((flipV && (d === DIRECTION.SOUTH || d === DIRECTION.NORTH)) ||\n        (flipH && (d === DIRECTION.EAST || d === DIRECTION.WEST))) {\n        const tmp = m.x;\n        m.x = m.width;\n        m.width = tmp;\n    }\n    if ((flipH && (d === DIRECTION.SOUTH || d === DIRECTION.NORTH)) ||\n        (flipV && (d === DIRECTION.EAST || d === DIRECTION.WEST))) {\n        const tmp = m.y;\n        m.y = m.height;\n        m.height = tmp;\n    }\n    const m2 = Rectangle.fromRectangle(m);\n    if (d === DIRECTION.SOUTH) {\n        m2.y = m.x;\n        m2.x = m.height;\n        m2.width = m.y;\n        m2.height = m.width;\n    }\n    else if (d === DIRECTION.WEST) {\n        m2.y = m.height;\n        m2.x = m.width;\n        m2.width = m.x;\n        m2.height = m.y;\n    }\n    else if (d === DIRECTION.NORTH) {\n        m2.y = m.width;\n        m2.x = m.y;\n        m2.width = m.height;\n        m2.height = m.x;\n    }\n    return new Rectangle(rect.x + m2.x, rect.y + m2.y, rect.width - m2.width - m2.x, rect.height - m2.height - m2.y);\n};\n/**\n * Returns the intersection between the polygon defined by the array of\n * points and the line between center and point.\n */\nexport const getPerimeterPoint = (pts, center, point) => {\n    let min = null;\n    for (let i = 0; i < pts.length - 1; i += 1) {\n        const pt = intersection(pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y, center.x, center.y, point.x, point.y);\n        if (pt != null) {\n            const dx = point.x - pt.x;\n            const dy = point.y - pt.y;\n            const ip = { p: pt, distSq: dy * dy + dx * dx };\n            if (ip != null && (min == null || min.distSq > ip.distSq)) {\n                min = ip;\n            }\n        }\n    }\n    return min != null ? min.p : null;\n};\n/**\n * Returns true if the given rectangle intersects the given segment.\n *\n * @param bounds {@link Rectangle} that represents the rectangle.\n * @param p1 {@link Point} that represents the first point of the segment.\n * @param p2 {@link Point} that represents the second point of the segment.\n */\nexport const rectangleIntersectsSegment = (bounds, p1, p2) => {\n    const top = bounds.y;\n    const left = bounds.x;\n    const bottom = top + bounds.height;\n    const right = left + bounds.width;\n    // Find min and max X for the segment\n    let minX = p1.x;\n    let maxX = p2.x;\n    if (p1.x > p2.x) {\n        minX = p2.x;\n        maxX = p1.x;\n    }\n    // Find the intersection of the segment's and rectangle's x-projections\n    if (maxX > right) {\n        maxX = right;\n    }\n    if (minX < left) {\n        minX = left;\n    }\n    if (minX > maxX) {\n        // If their projections do not intersect return false\n        return false;\n    }\n    // Find corresponding min and max Y for min and max X we found before\n    let minY = p1.y;\n    let maxY = p2.y;\n    const dx = p2.x - p1.x;\n    if (Math.abs(dx) > 0.0000001) {\n        const a = (p2.y - p1.y) / dx;\n        const b = p1.y - a * p1.x;\n        minY = a * minX + b;\n        maxY = a * maxX + b;\n    }\n    if (minY > maxY) {\n        const tmp = maxY;\n        maxY = minY;\n        minY = tmp;\n    }\n    // Find the intersection of the segment's and rectangle's y-projections\n    if (maxY > bottom) {\n        maxY = bottom;\n    }\n    if (minY < top) {\n        minY = top;\n    }\n    if (minY > maxY) {\n        // If Y-projections do not intersect return false\n        return false;\n    }\n    return true;\n};\n/**\n * Returns true if the specified point (x, y) is contained in the given rectangle.\n *\n * @param bounds {@link Rectangle} that represents the area.\n * @param x X-coordinate of the point.\n * @param y Y-coordinate of the point.\n */\nexport const contains = (bounds, x, y) => {\n    return (bounds.x <= x &&\n        bounds.x + bounds.width >= x &&\n        bounds.y <= y &&\n        bounds.y + bounds.height >= y);\n};\n/**\n * Returns true if the two rectangles intersect.\n *\n * @param a {@link Rectangle} to be checked for intersection.\n * @param b {@link Rectangle} to be checked for intersection.\n */\nexport const intersects = (a, b) => {\n    let tw = a.width;\n    let th = a.height;\n    let rw = b.width;\n    let rh = b.height;\n    if (rw <= 0 || rh <= 0 || tw <= 0 || th <= 0) {\n        return false;\n    }\n    const tx = a.x;\n    const ty = a.y;\n    const rx = b.x;\n    const ry = b.y;\n    rw += rx;\n    rh += ry;\n    tw += tx;\n    th += ty;\n    return ((rw < rx || rw > tx) &&\n        (rh < ry || rh > ty) &&\n        (tw < tx || tw > rx) &&\n        (th < ty || th > ry));\n};\n/**\n * Returns true if the state and the hotspot intersect.\n *\n * @param state <CellState>\n * @param x X-coordinate.\n * @param y Y-coordinate.\n * @param hotspot Optional size of the hostpot.\n * @param min Optional min size of the hostpot.\n * @param max Optional max size of the hostpot.\n */\nexport const intersectsHotspot = (state, x, y, hotspot, min, max) => {\n    hotspot = hotspot != null ? hotspot : 1;\n    min = min != null ? min : 0;\n    max = max != null ? max : 0;\n    if (hotspot > 0) {\n        let cx = state.getCenterX();\n        let cy = state.getCenterY();\n        let w = state.width;\n        let h = state.height;\n        const start = getValue(state.style, 'startSize') * state.view.scale;\n        if (start > 0) {\n            if (getValue(state.style, 'horizontal', true)) {\n                cy = state.y + start / 2;\n                h = start;\n            }\n            else {\n                cx = state.x + start / 2;\n                w = start;\n            }\n        }\n        w = Math.max(min, w * hotspot);\n        h = Math.max(min, h * hotspot);\n        if (max > 0) {\n            w = Math.min(w, max);\n            h = Math.min(h, max);\n        }\n        const rect = new Rectangle(cx - w / 2, cy - h / 2, w, h);\n        const alpha = toRadians(getValue(state.style, 'rotation') || 0);\n        if (alpha != 0) {\n            const cos = Math.cos(-alpha);\n            const sin = Math.sin(-alpha);\n            const cx = new Point(state.getCenterX(), state.getCenterY());\n            const pt = getRotatedPoint(new Point(x, y), cos, sin, cx);\n            x = pt.x;\n            y = pt.y;\n        }\n        return contains(rect, x, y);\n    }\n    return true;\n};\n/**\n * Returns true if the specified value is numeric, that is, if it is not\n * null, not an empty string, not a HEX number and isNaN returns false.\n *\n * @param n String representing the possibly numeric value.\n */\nexport const isNumeric = (n) => {\n    return (!Number.isNaN(parseFloat(n)) &&\n        isFinite(+n) &&\n        (typeof n !== 'string' || n.toLowerCase().indexOf('0x') < 0));\n};\n/**\n * Returns true if the given value is an valid integer number.\n *\n * @param n String representing the possibly numeric value.\n */\nexport const isInteger = (n) => {\n    return String(parseInt(n)) === String(n);\n};\n/**\n * Returns the remainder of division of n by m. You should use this instead\n * of the built-in operation as the built-in operation does not properly\n * handle negative numbers.\n */\nexport const mod = (n, m) => {\n    return ((n % m) + m) % m;\n};\n/**\n * Returns the intersection of two lines as an {@link Point}.\n *\n * @param x0 X-coordinate of the first line's startpoint.\n * @param y0 X-coordinate of the first line's startpoint.\n * @param x1 X-coordinate of the first line's endpoint.\n * @param y1 Y-coordinate of the first line's endpoint.\n * @param x2 X-coordinate of the second line's startpoint.\n * @param y2 Y-coordinate of the second line's startpoint.\n * @param x3 X-coordinate of the second line's endpoint.\n * @param y3 Y-coordinate of the second line's endpoint.\n */\nexport const intersection = (x0, y0, x1, y1, x2, y2, x3, y3) => {\n    const denom = (y3 - y2) * (x1 - x0) - (x3 - x2) * (y1 - y0);\n    const nume_a = (x3 - x2) * (y0 - y2) - (y3 - y2) * (x0 - x2);\n    const nume_b = (x1 - x0) * (y0 - y2) - (y1 - y0) * (x0 - x2);\n    const ua = nume_a / denom;\n    const ub = nume_b / denom;\n    if (ua >= 0.0 && ua <= 1.0 && ub >= 0.0 && ub <= 1.0) {\n        // Get the intersection point\n        const x = x0 + ua * (x1 - x0);\n        const y = y0 + ua * (y1 - y0);\n        return new Point(x, y);\n    }\n    // No intersection\n    return null;\n};\n/**\n * Returns the square distance between a segment and a point. To get the\n * distance between a point and a line (with infinite length) use\n * {@link Utils#ptLineDist}.\n *\n * @param x1 X-coordinate of the startpoint of the segment.\n * @param y1 Y-coordinate of the startpoint of the segment.\n * @param x2 X-coordinate of the endpoint of the segment.\n * @param y2 Y-coordinate of the endpoint of the segment.\n * @param px X-coordinate of the point.\n * @param py Y-coordinate of the point.\n */\nexport const ptSegDistSq = (x1, y1, x2, y2, px, py) => {\n    x2 -= x1;\n    y2 -= y1;\n    px -= x1;\n    py -= y1;\n    let dotprod = px * x2 + py * y2;\n    let projlenSq;\n    if (dotprod <= 0.0) {\n        projlenSq = 0.0;\n    }\n    else {\n        px = x2 - px;\n        py = y2 - py;\n        dotprod = px * x2 + py * y2;\n        if (dotprod <= 0.0) {\n            projlenSq = 0.0;\n        }\n        else {\n            projlenSq = (dotprod * dotprod) / (x2 * x2 + y2 * y2);\n        }\n    }\n    let lenSq = px * px + py * py - projlenSq;\n    if (lenSq < 0) {\n        lenSq = 0;\n    }\n    return lenSq;\n};\n/**\n * Returns the distance between a line defined by two points and a point.\n * To get the distance between a point and a segment (with a specific\n * length) use {@link Utils#ptSeqDistSq}.\n *\n * @param x1 X-coordinate of point 1 of the line.\n * @param y1 Y-coordinate of point 1 of the line.\n * @param x2 X-coordinate of point 1 of the line.\n * @param y2 Y-coordinate of point 1 of the line.\n * @param px X-coordinate of the point.\n * @param py Y-coordinate of the point.\n */\nexport const ptLineDist = (x1, y1, x2, y2, px, py) => {\n    return (Math.abs((y2 - y1) * px - (x2 - x1) * py + x2 * y1 - y2 * x1) /\n        Math.sqrt((y2 - y1) * (y2 - y1) + (x2 - x1) * (x2 - x1)));\n};\n/**\n * Returns 1 if the given point on the right side of the segment, 0 if its\n * on the segment, and -1 if the point is on the left side of the segment.\n *\n * @param x1 X-coordinate of the startpoint of the segment.\n * @param y1 Y-coordinate of the startpoint of the segment.\n * @param x2 X-coordinate of the endpoint of the segment.\n * @param y2 Y-coordinate of the endpoint of the segment.\n * @param px X-coordinate of the point.\n * @param py Y-coordinate of the point.\n */\nexport const relativeCcw = (x1, y1, x2, y2, px, py) => {\n    x2 -= x1;\n    y2 -= y1;\n    px -= x1;\n    py -= y1;\n    let ccw = px * y2 - py * x2;\n    if (ccw == 0.0) {\n        ccw = px * x2 + py * y2;\n        if (ccw > 0.0) {\n            px -= x2;\n            py -= y2;\n            ccw = px * x2 + py * y2;\n            if (ccw < 0.0) {\n                ccw = 0.0;\n            }\n        }\n    }\n    return ccw < 0.0 ? -1 : ccw > 0.0 ? 1 : 0;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}