{"ast":null,"code":"var _TextAreaState;\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../../common/core/range.js';\nexport const _debugComposition = false;\nexport class TextAreaState {\n  constructor(value, /** the offset where selection starts inside `value` */\n  selectionStart, /** the offset where selection ends inside `value` */\n  selectionEnd, /** the editor range in the view coordinate system that matches the selection inside `value` */\n  selection, /** the visible line count (wrapped, not necessarily matching \\n characters) for the text in `value` before `selectionStart` */\n  newlineCountBeforeSelection) {\n    this.value = value;\n    this.selectionStart = selectionStart;\n    this.selectionEnd = selectionEnd;\n    this.selection = selection;\n    this.newlineCountBeforeSelection = newlineCountBeforeSelection;\n  }\n  toString() {\n    return \"[ <\".concat(this.value, \">, selectionStart: \").concat(this.selectionStart, \", selectionEnd: \").concat(this.selectionEnd, \"]\");\n  }\n  static readFromTextArea(textArea, previousState) {\n    const value = textArea.getValue();\n    const selectionStart = textArea.getSelectionStart();\n    const selectionEnd = textArea.getSelectionEnd();\n    let newlineCountBeforeSelection = undefined;\n    if (previousState) {\n      const valueBeforeSelectionStart = value.substring(0, selectionStart);\n      const previousValueBeforeSelectionStart = previousState.value.substring(0, previousState.selectionStart);\n      if (valueBeforeSelectionStart === previousValueBeforeSelectionStart) {\n        newlineCountBeforeSelection = previousState.newlineCountBeforeSelection;\n      }\n    }\n    return new TextAreaState(value, selectionStart, selectionEnd, null, newlineCountBeforeSelection);\n  }\n  collapseSelection() {\n    if (this.selectionStart === this.value.length) {\n      return this;\n    }\n    return new TextAreaState(this.value, this.value.length, this.value.length, null, undefined);\n  }\n  writeToTextArea(reason, textArea, select) {\n    if (_debugComposition) {\n      console.log(\"writeToTextArea \".concat(reason, \": \").concat(this.toString()));\n    }\n    textArea.setValue(reason, this.value);\n    if (select) {\n      textArea.setSelectionRange(reason, this.selectionStart, this.selectionEnd);\n    }\n  }\n  deduceEditorPosition(offset) {\n    var _this$selection$getEn2, _this$selection4;\n    if (offset <= this.selectionStart) {\n      var _this$selection$getSt, _this$selection;\n      const str = this.value.substring(offset, this.selectionStart);\n      return this._finishDeduceEditorPosition((_this$selection$getSt = (_this$selection = this.selection) === null || _this$selection === void 0 ? void 0 : _this$selection.getStartPosition()) !== null && _this$selection$getSt !== void 0 ? _this$selection$getSt : null, str, -1);\n    }\n    if (offset >= this.selectionEnd) {\n      var _this$selection$getEn, _this$selection2;\n      const str = this.value.substring(this.selectionEnd, offset);\n      return this._finishDeduceEditorPosition((_this$selection$getEn = (_this$selection2 = this.selection) === null || _this$selection2 === void 0 ? void 0 : _this$selection2.getEndPosition()) !== null && _this$selection$getEn !== void 0 ? _this$selection$getEn : null, str, 1);\n    }\n    const str1 = this.value.substring(this.selectionStart, offset);\n    if (str1.indexOf(String.fromCharCode(8230)) === -1) {\n      var _this$selection$getSt2, _this$selection3;\n      return this._finishDeduceEditorPosition((_this$selection$getSt2 = (_this$selection3 = this.selection) === null || _this$selection3 === void 0 ? void 0 : _this$selection3.getStartPosition()) !== null && _this$selection$getSt2 !== void 0 ? _this$selection$getSt2 : null, str1, 1);\n    }\n    const str2 = this.value.substring(offset, this.selectionEnd);\n    return this._finishDeduceEditorPosition((_this$selection$getEn2 = (_this$selection4 = this.selection) === null || _this$selection4 === void 0 ? void 0 : _this$selection4.getEndPosition()) !== null && _this$selection$getEn2 !== void 0 ? _this$selection$getEn2 : null, str2, -1);\n  }\n  _finishDeduceEditorPosition(anchor, deltaText, signum) {\n    let lineFeedCnt = 0;\n    let lastLineFeedIndex = -1;\n    while ((lastLineFeedIndex = deltaText.indexOf('\\n', lastLineFeedIndex + 1)) !== -1) {\n      lineFeedCnt++;\n    }\n    return [anchor, signum * deltaText.length, lineFeedCnt];\n  }\n  static deduceInput(previousState, currentState, couldBeEmojiInput) {\n    if (!previousState) {\n      // This is the EMPTY state\n      return {\n        text: '',\n        replacePrevCharCnt: 0,\n        replaceNextCharCnt: 0,\n        positionDelta: 0\n      };\n    }\n    if (_debugComposition) {\n      console.log('------------------------deduceInput');\n      console.log(\"PREVIOUS STATE: \".concat(previousState.toString()));\n      console.log(\"CURRENT STATE: \".concat(currentState.toString()));\n    }\n    const prefixLength = Math.min(strings.commonPrefixLength(previousState.value, currentState.value), previousState.selectionStart, currentState.selectionStart);\n    const suffixLength = Math.min(strings.commonSuffixLength(previousState.value, currentState.value), previousState.value.length - previousState.selectionEnd, currentState.value.length - currentState.selectionEnd);\n    const previousValue = previousState.value.substring(prefixLength, previousState.value.length - suffixLength);\n    const currentValue = currentState.value.substring(prefixLength, currentState.value.length - suffixLength);\n    const previousSelectionStart = previousState.selectionStart - prefixLength;\n    const previousSelectionEnd = previousState.selectionEnd - prefixLength;\n    const currentSelectionStart = currentState.selectionStart - prefixLength;\n    const currentSelectionEnd = currentState.selectionEnd - prefixLength;\n    if (_debugComposition) {\n      console.log(\"AFTER DIFFING PREVIOUS STATE: <\".concat(previousValue, \">, selectionStart: \").concat(previousSelectionStart, \", selectionEnd: \").concat(previousSelectionEnd));\n      console.log(\"AFTER DIFFING CURRENT STATE: <\".concat(currentValue, \">, selectionStart: \").concat(currentSelectionStart, \", selectionEnd: \").concat(currentSelectionEnd));\n    }\n    if (currentSelectionStart === currentSelectionEnd) {\n      // no current selection\n      const replacePreviousCharacters = previousState.selectionStart - prefixLength;\n      if (_debugComposition) {\n        console.log(\"REMOVE PREVIOUS: \".concat(replacePreviousCharacters, \" chars\"));\n      }\n      return {\n        text: currentValue,\n        replacePrevCharCnt: replacePreviousCharacters,\n        replaceNextCharCnt: 0,\n        positionDelta: 0\n      };\n    }\n    // there is a current selection => composition case\n    const replacePreviousCharacters = previousSelectionEnd - previousSelectionStart;\n    return {\n      text: currentValue,\n      replacePrevCharCnt: replacePreviousCharacters,\n      replaceNextCharCnt: 0,\n      positionDelta: 0\n    };\n  }\n  static deduceAndroidCompositionInput(previousState, currentState) {\n    if (!previousState) {\n      // This is the EMPTY state\n      return {\n        text: '',\n        replacePrevCharCnt: 0,\n        replaceNextCharCnt: 0,\n        positionDelta: 0\n      };\n    }\n    if (_debugComposition) {\n      console.log('------------------------deduceAndroidCompositionInput');\n      console.log(\"PREVIOUS STATE: \".concat(previousState.toString()));\n      console.log(\"CURRENT STATE: \".concat(currentState.toString()));\n    }\n    if (previousState.value === currentState.value) {\n      return {\n        text: '',\n        replacePrevCharCnt: 0,\n        replaceNextCharCnt: 0,\n        positionDelta: currentState.selectionEnd - previousState.selectionEnd\n      };\n    }\n    const prefixLength = Math.min(strings.commonPrefixLength(previousState.value, currentState.value), previousState.selectionEnd);\n    const suffixLength = Math.min(strings.commonSuffixLength(previousState.value, currentState.value), previousState.value.length - previousState.selectionEnd);\n    const previousValue = previousState.value.substring(prefixLength, previousState.value.length - suffixLength);\n    const currentValue = currentState.value.substring(prefixLength, currentState.value.length - suffixLength);\n    const previousSelectionStart = previousState.selectionStart - prefixLength;\n    const previousSelectionEnd = previousState.selectionEnd - prefixLength;\n    const currentSelectionStart = currentState.selectionStart - prefixLength;\n    const currentSelectionEnd = currentState.selectionEnd - prefixLength;\n    if (_debugComposition) {\n      console.log(\"AFTER DIFFING PREVIOUS STATE: <\".concat(previousValue, \">, selectionStart: \").concat(previousSelectionStart, \", selectionEnd: \").concat(previousSelectionEnd));\n      console.log(\"AFTER DIFFING CURRENT STATE: <\".concat(currentValue, \">, selectionStart: \").concat(currentSelectionStart, \", selectionEnd: \").concat(currentSelectionEnd));\n    }\n    return {\n      text: currentValue,\n      replacePrevCharCnt: previousSelectionEnd,\n      replaceNextCharCnt: previousValue.length - previousSelectionEnd,\n      positionDelta: currentSelectionEnd - currentValue.length\n    };\n  }\n}\n_TextAreaState = TextAreaState;\n_TextAreaState.EMPTY = new _TextAreaState('', 0, 0, null, undefined);\nexport class PagedScreenReaderStrategy {\n  static _getPageOfLine(lineNumber, linesPerPage) {\n    return Math.floor((lineNumber - 1) / linesPerPage);\n  }\n  static _getRangeForPage(page, linesPerPage) {\n    const offset = page * linesPerPage;\n    const startLineNumber = offset + 1;\n    const endLineNumber = offset + linesPerPage;\n    return new Range(startLineNumber, 1, endLineNumber + 1, 1);\n  }\n  static fromEditorSelection(model, selection, linesPerPage, trimLongText) {\n    // Chromium handles very poorly text even of a few thousand chars\n    // Cut text to avoid stalling the entire UI\n    const LIMIT_CHARS = 500;\n    const selectionStartPage = PagedScreenReaderStrategy._getPageOfLine(selection.startLineNumber, linesPerPage);\n    const selectionStartPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionStartPage, linesPerPage);\n    const selectionEndPage = PagedScreenReaderStrategy._getPageOfLine(selection.endLineNumber, linesPerPage);\n    const selectionEndPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionEndPage, linesPerPage);\n    let pretextRange = selectionStartPageRange.intersectRanges(new Range(1, 1, selection.startLineNumber, selection.startColumn));\n    if (trimLongText && model.getValueLengthInRange(pretextRange, 1 /* EndOfLinePreference.LF */) > LIMIT_CHARS) {\n      const pretextStart = model.modifyPosition(pretextRange.getEndPosition(), -LIMIT_CHARS);\n      pretextRange = Range.fromPositions(pretextStart, pretextRange.getEndPosition());\n    }\n    const pretext = model.getValueInRange(pretextRange, 1 /* EndOfLinePreference.LF */);\n    const lastLine = model.getLineCount();\n    const lastLineMaxColumn = model.getLineMaxColumn(lastLine);\n    let posttextRange = selectionEndPageRange.intersectRanges(new Range(selection.endLineNumber, selection.endColumn, lastLine, lastLineMaxColumn));\n    if (trimLongText && model.getValueLengthInRange(posttextRange, 1 /* EndOfLinePreference.LF */) > LIMIT_CHARS) {\n      const posttextEnd = model.modifyPosition(posttextRange.getStartPosition(), LIMIT_CHARS);\n      posttextRange = Range.fromPositions(posttextRange.getStartPosition(), posttextEnd);\n    }\n    const posttext = model.getValueInRange(posttextRange, 1 /* EndOfLinePreference.LF */);\n    let text;\n    if (selectionStartPage === selectionEndPage || selectionStartPage + 1 === selectionEndPage) {\n      // take full selection\n      text = model.getValueInRange(selection, 1 /* EndOfLinePreference.LF */);\n    } else {\n      const selectionRange1 = selectionStartPageRange.intersectRanges(selection);\n      const selectionRange2 = selectionEndPageRange.intersectRanges(selection);\n      text = model.getValueInRange(selectionRange1, 1 /* EndOfLinePreference.LF */) + String.fromCharCode(8230) + model.getValueInRange(selectionRange2, 1 /* EndOfLinePreference.LF */);\n    }\n    if (trimLongText && text.length > 2 * LIMIT_CHARS) {\n      text = text.substring(0, LIMIT_CHARS) + String.fromCharCode(8230) + text.substring(text.length - LIMIT_CHARS, text.length);\n    }\n    return new TextAreaState(pretext + text + posttext, pretext.length, pretext.length + text.length, selection, pretextRange.endLineNumber - pretextRange.startLineNumber);\n  }\n}","map":{"version":3,"names":["strings","Range","_debugComposition","TextAreaState","constructor","value","selectionStart","selectionEnd","selection","newlineCountBeforeSelection","toString","concat","readFromTextArea","textArea","previousState","getValue","getSelectionStart","getSelectionEnd","undefined","valueBeforeSelectionStart","substring","previousValueBeforeSelectionStart","collapseSelection","length","writeToTextArea","reason","select","console","log","setValue","setSelectionRange","deduceEditorPosition","offset","_this$selection$getEn2","_this$selection4","_this$selection$getSt","_this$selection","str","_finishDeduceEditorPosition","getStartPosition","_this$selection$getEn","_this$selection2","getEndPosition","str1","indexOf","String","fromCharCode","_this$selection$getSt2","_this$selection3","str2","anchor","deltaText","signum","lineFeedCnt","lastLineFeedIndex","deduceInput","currentState","couldBeEmojiInput","text","replacePrevCharCnt","replaceNextCharCnt","positionDelta","prefixLength","Math","min","commonPrefixLength","suffixLength","commonSuffixLength","previousValue","currentValue","previousSelectionStart","previousSelectionEnd","currentSelectionStart","currentSelectionEnd","replacePreviousCharacters","deduceAndroidCompositionInput","_TextAreaState","EMPTY","PagedScreenReaderStrategy","_getPageOfLine","lineNumber","linesPerPage","floor","_getRangeForPage","page","startLineNumber","endLineNumber","fromEditorSelection","model","trimLongText","LIMIT_CHARS","selectionStartPage","selectionStartPageRange","selectionEndPage","selectionEndPageRange","pretextRange","intersectRanges","startColumn","getValueLengthInRange","pretextStart","modifyPosition","fromPositions","pretext","getValueInRange","lastLine","getLineCount","lastLineMaxColumn","getLineMaxColumn","posttextRange","endColumn","posttextEnd","posttext","selectionRange1","selectionRange2"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaState.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../../common/core/range.js';\nexport const _debugComposition = false;\nexport class TextAreaState {\n    static { this.EMPTY = new TextAreaState('', 0, 0, null, undefined); }\n    constructor(value, \n    /** the offset where selection starts inside `value` */\n    selectionStart, \n    /** the offset where selection ends inside `value` */\n    selectionEnd, \n    /** the editor range in the view coordinate system that matches the selection inside `value` */\n    selection, \n    /** the visible line count (wrapped, not necessarily matching \\n characters) for the text in `value` before `selectionStart` */\n    newlineCountBeforeSelection) {\n        this.value = value;\n        this.selectionStart = selectionStart;\n        this.selectionEnd = selectionEnd;\n        this.selection = selection;\n        this.newlineCountBeforeSelection = newlineCountBeforeSelection;\n    }\n    toString() {\n        return `[ <${this.value}>, selectionStart: ${this.selectionStart}, selectionEnd: ${this.selectionEnd}]`;\n    }\n    static readFromTextArea(textArea, previousState) {\n        const value = textArea.getValue();\n        const selectionStart = textArea.getSelectionStart();\n        const selectionEnd = textArea.getSelectionEnd();\n        let newlineCountBeforeSelection = undefined;\n        if (previousState) {\n            const valueBeforeSelectionStart = value.substring(0, selectionStart);\n            const previousValueBeforeSelectionStart = previousState.value.substring(0, previousState.selectionStart);\n            if (valueBeforeSelectionStart === previousValueBeforeSelectionStart) {\n                newlineCountBeforeSelection = previousState.newlineCountBeforeSelection;\n            }\n        }\n        return new TextAreaState(value, selectionStart, selectionEnd, null, newlineCountBeforeSelection);\n    }\n    collapseSelection() {\n        if (this.selectionStart === this.value.length) {\n            return this;\n        }\n        return new TextAreaState(this.value, this.value.length, this.value.length, null, undefined);\n    }\n    writeToTextArea(reason, textArea, select) {\n        if (_debugComposition) {\n            console.log(`writeToTextArea ${reason}: ${this.toString()}`);\n        }\n        textArea.setValue(reason, this.value);\n        if (select) {\n            textArea.setSelectionRange(reason, this.selectionStart, this.selectionEnd);\n        }\n    }\n    deduceEditorPosition(offset) {\n        if (offset <= this.selectionStart) {\n            const str = this.value.substring(offset, this.selectionStart);\n            return this._finishDeduceEditorPosition(this.selection?.getStartPosition() ?? null, str, -1);\n        }\n        if (offset >= this.selectionEnd) {\n            const str = this.value.substring(this.selectionEnd, offset);\n            return this._finishDeduceEditorPosition(this.selection?.getEndPosition() ?? null, str, 1);\n        }\n        const str1 = this.value.substring(this.selectionStart, offset);\n        if (str1.indexOf(String.fromCharCode(8230)) === -1) {\n            return this._finishDeduceEditorPosition(this.selection?.getStartPosition() ?? null, str1, 1);\n        }\n        const str2 = this.value.substring(offset, this.selectionEnd);\n        return this._finishDeduceEditorPosition(this.selection?.getEndPosition() ?? null, str2, -1);\n    }\n    _finishDeduceEditorPosition(anchor, deltaText, signum) {\n        let lineFeedCnt = 0;\n        let lastLineFeedIndex = -1;\n        while ((lastLineFeedIndex = deltaText.indexOf('\\n', lastLineFeedIndex + 1)) !== -1) {\n            lineFeedCnt++;\n        }\n        return [anchor, signum * deltaText.length, lineFeedCnt];\n    }\n    static deduceInput(previousState, currentState, couldBeEmojiInput) {\n        if (!previousState) {\n            // This is the EMPTY state\n            return {\n                text: '',\n                replacePrevCharCnt: 0,\n                replaceNextCharCnt: 0,\n                positionDelta: 0\n            };\n        }\n        if (_debugComposition) {\n            console.log('------------------------deduceInput');\n            console.log(`PREVIOUS STATE: ${previousState.toString()}`);\n            console.log(`CURRENT STATE: ${currentState.toString()}`);\n        }\n        const prefixLength = Math.min(strings.commonPrefixLength(previousState.value, currentState.value), previousState.selectionStart, currentState.selectionStart);\n        const suffixLength = Math.min(strings.commonSuffixLength(previousState.value, currentState.value), previousState.value.length - previousState.selectionEnd, currentState.value.length - currentState.selectionEnd);\n        const previousValue = previousState.value.substring(prefixLength, previousState.value.length - suffixLength);\n        const currentValue = currentState.value.substring(prefixLength, currentState.value.length - suffixLength);\n        const previousSelectionStart = previousState.selectionStart - prefixLength;\n        const previousSelectionEnd = previousState.selectionEnd - prefixLength;\n        const currentSelectionStart = currentState.selectionStart - prefixLength;\n        const currentSelectionEnd = currentState.selectionEnd - prefixLength;\n        if (_debugComposition) {\n            console.log(`AFTER DIFFING PREVIOUS STATE: <${previousValue}>, selectionStart: ${previousSelectionStart}, selectionEnd: ${previousSelectionEnd}`);\n            console.log(`AFTER DIFFING CURRENT STATE: <${currentValue}>, selectionStart: ${currentSelectionStart}, selectionEnd: ${currentSelectionEnd}`);\n        }\n        if (currentSelectionStart === currentSelectionEnd) {\n            // no current selection\n            const replacePreviousCharacters = (previousState.selectionStart - prefixLength);\n            if (_debugComposition) {\n                console.log(`REMOVE PREVIOUS: ${replacePreviousCharacters} chars`);\n            }\n            return {\n                text: currentValue,\n                replacePrevCharCnt: replacePreviousCharacters,\n                replaceNextCharCnt: 0,\n                positionDelta: 0\n            };\n        }\n        // there is a current selection => composition case\n        const replacePreviousCharacters = previousSelectionEnd - previousSelectionStart;\n        return {\n            text: currentValue,\n            replacePrevCharCnt: replacePreviousCharacters,\n            replaceNextCharCnt: 0,\n            positionDelta: 0\n        };\n    }\n    static deduceAndroidCompositionInput(previousState, currentState) {\n        if (!previousState) {\n            // This is the EMPTY state\n            return {\n                text: '',\n                replacePrevCharCnt: 0,\n                replaceNextCharCnt: 0,\n                positionDelta: 0\n            };\n        }\n        if (_debugComposition) {\n            console.log('------------------------deduceAndroidCompositionInput');\n            console.log(`PREVIOUS STATE: ${previousState.toString()}`);\n            console.log(`CURRENT STATE: ${currentState.toString()}`);\n        }\n        if (previousState.value === currentState.value) {\n            return {\n                text: '',\n                replacePrevCharCnt: 0,\n                replaceNextCharCnt: 0,\n                positionDelta: currentState.selectionEnd - previousState.selectionEnd\n            };\n        }\n        const prefixLength = Math.min(strings.commonPrefixLength(previousState.value, currentState.value), previousState.selectionEnd);\n        const suffixLength = Math.min(strings.commonSuffixLength(previousState.value, currentState.value), previousState.value.length - previousState.selectionEnd);\n        const previousValue = previousState.value.substring(prefixLength, previousState.value.length - suffixLength);\n        const currentValue = currentState.value.substring(prefixLength, currentState.value.length - suffixLength);\n        const previousSelectionStart = previousState.selectionStart - prefixLength;\n        const previousSelectionEnd = previousState.selectionEnd - prefixLength;\n        const currentSelectionStart = currentState.selectionStart - prefixLength;\n        const currentSelectionEnd = currentState.selectionEnd - prefixLength;\n        if (_debugComposition) {\n            console.log(`AFTER DIFFING PREVIOUS STATE: <${previousValue}>, selectionStart: ${previousSelectionStart}, selectionEnd: ${previousSelectionEnd}`);\n            console.log(`AFTER DIFFING CURRENT STATE: <${currentValue}>, selectionStart: ${currentSelectionStart}, selectionEnd: ${currentSelectionEnd}`);\n        }\n        return {\n            text: currentValue,\n            replacePrevCharCnt: previousSelectionEnd,\n            replaceNextCharCnt: previousValue.length - previousSelectionEnd,\n            positionDelta: currentSelectionEnd - currentValue.length\n        };\n    }\n}\nexport class PagedScreenReaderStrategy {\n    static _getPageOfLine(lineNumber, linesPerPage) {\n        return Math.floor((lineNumber - 1) / linesPerPage);\n    }\n    static _getRangeForPage(page, linesPerPage) {\n        const offset = page * linesPerPage;\n        const startLineNumber = offset + 1;\n        const endLineNumber = offset + linesPerPage;\n        return new Range(startLineNumber, 1, endLineNumber + 1, 1);\n    }\n    static fromEditorSelection(model, selection, linesPerPage, trimLongText) {\n        // Chromium handles very poorly text even of a few thousand chars\n        // Cut text to avoid stalling the entire UI\n        const LIMIT_CHARS = 500;\n        const selectionStartPage = PagedScreenReaderStrategy._getPageOfLine(selection.startLineNumber, linesPerPage);\n        const selectionStartPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionStartPage, linesPerPage);\n        const selectionEndPage = PagedScreenReaderStrategy._getPageOfLine(selection.endLineNumber, linesPerPage);\n        const selectionEndPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionEndPage, linesPerPage);\n        let pretextRange = selectionStartPageRange.intersectRanges(new Range(1, 1, selection.startLineNumber, selection.startColumn));\n        if (trimLongText && model.getValueLengthInRange(pretextRange, 1 /* EndOfLinePreference.LF */) > LIMIT_CHARS) {\n            const pretextStart = model.modifyPosition(pretextRange.getEndPosition(), -LIMIT_CHARS);\n            pretextRange = Range.fromPositions(pretextStart, pretextRange.getEndPosition());\n        }\n        const pretext = model.getValueInRange(pretextRange, 1 /* EndOfLinePreference.LF */);\n        const lastLine = model.getLineCount();\n        const lastLineMaxColumn = model.getLineMaxColumn(lastLine);\n        let posttextRange = selectionEndPageRange.intersectRanges(new Range(selection.endLineNumber, selection.endColumn, lastLine, lastLineMaxColumn));\n        if (trimLongText && model.getValueLengthInRange(posttextRange, 1 /* EndOfLinePreference.LF */) > LIMIT_CHARS) {\n            const posttextEnd = model.modifyPosition(posttextRange.getStartPosition(), LIMIT_CHARS);\n            posttextRange = Range.fromPositions(posttextRange.getStartPosition(), posttextEnd);\n        }\n        const posttext = model.getValueInRange(posttextRange, 1 /* EndOfLinePreference.LF */);\n        let text;\n        if (selectionStartPage === selectionEndPage || selectionStartPage + 1 === selectionEndPage) {\n            // take full selection\n            text = model.getValueInRange(selection, 1 /* EndOfLinePreference.LF */);\n        }\n        else {\n            const selectionRange1 = selectionStartPageRange.intersectRanges(selection);\n            const selectionRange2 = selectionEndPageRange.intersectRanges(selection);\n            text = (model.getValueInRange(selectionRange1, 1 /* EndOfLinePreference.LF */)\n                + String.fromCharCode(8230)\n                + model.getValueInRange(selectionRange2, 1 /* EndOfLinePreference.LF */));\n        }\n        if (trimLongText && text.length > 2 * LIMIT_CHARS) {\n            text = text.substring(0, LIMIT_CHARS) + String.fromCharCode(8230) + text.substring(text.length - LIMIT_CHARS, text.length);\n        }\n        return new TextAreaState(pretext + text + posttext, pretext.length, pretext.length + text.length, selection, pretextRange.endLineNumber - pretextRange.startLineNumber);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}