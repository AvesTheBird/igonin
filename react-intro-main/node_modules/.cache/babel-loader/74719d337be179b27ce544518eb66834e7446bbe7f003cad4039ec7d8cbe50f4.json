{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from '../geometry/Rectangle';\nimport GraphLayout from './GraphLayout';\n/**\n * Extends {@link GraphLayout} for partitioning the parent cell vertically or\n * horizontally by filling the complete area with the child cells. A horizontal\n * layout partitions the height of the given parent whereas a a non-horizontal\n * layout partitions the width. If the parent is a layer (that is, a child of\n * the root node), then the current graph size is partitioned. The children do\n * not need to be connected for this layout to work.\n *\n * Example:\n *\n * ```javascript\n * var layout = new mxPartitionLayout(graph, true, 10, 20);\n * layout.execute(graph.getDefaultParent());\n * ```\n * @class\n */\nclass PartitionLayout extends GraphLayout {\n  constructor(graph, horizontal = true, spacing = 0, border = 0) {\n    super(graph);\n    /**\n     * Boolean that specifies if vertices should be resized. Default is true.\n     */\n    this.resizeVertices = true;\n    this.horizontal = horizontal != null ? horizontal : true;\n    this.spacing = spacing || 0;\n    this.border = border || 0;\n  }\n  /**\n   * Returns <horizontal>.\n   */\n  isHorizontal() {\n    return this.horizontal;\n  }\n  /**\n   * Implements {@link GraphLayout.moveCell}.\n   *\n   * @param {mxCell} cell\n   * @param {number} x\n   * @param {number} y\n   * @memberof mxPartitionLayout\n   */\n  moveCell(cell, x, y) {\n    const model = this.graph.getDataModel();\n    const parent = cell.getParent();\n    if (cell != null && parent != null) {\n      let i = 0;\n      let last = 0;\n      const childCount = parent.getChildCount();\n      // Finds index of the closest swimlane\n      // TODO: Take into account the orientation\n      for (i = 0; i < childCount; i += 1) {\n        const child = parent.getChildAt(i);\n        const bounds = this.getVertexBounds(child);\n        if (bounds != null) {\n          const tmp = bounds.x + bounds.width / 2;\n          if (last < x && tmp > x) {\n            break;\n          }\n          last = tmp;\n        }\n      }\n      // Changes child order in parent\n      let idx = parent.getIndex(cell);\n      idx = Math.max(0, i - (i > idx ? 1 : 0));\n      model.add(parent, cell, idx);\n    }\n  }\n  /**\n   * Implements {@link GraphLayout#execute}. All children where <isVertexIgnored>\n   * returns false and <isVertexMovable> returns true are modified.\n   */\n  execute(parent) {\n    const horizontal = this.isHorizontal();\n    const model = this.graph.getDataModel();\n    let pgeo = parent.getGeometry();\n    // Handles special case where the parent is either a layer with no\n    // geometry or the current root of the view in which case the size\n    // of the graph's container will be used.\n    if (this.graph.container != null && (pgeo == null && model.isLayer(parent) || parent === this.graph.getView().currentRoot)) {\n      const width = this.graph.container.offsetWidth - 1;\n      const height = this.graph.container.offsetHeight - 1;\n      pgeo = new Rectangle(0, 0, width, height);\n    }\n    if (pgeo != null) {\n      const children = [];\n      const childCount = parent.getChildCount();\n      for (let i = 0; i < childCount; i += 1) {\n        const child = parent.getChildAt(i);\n        if (!this.isVertexIgnored(child) && this.isVertexMovable(child)) {\n          children.push(child);\n        }\n      }\n      const n = children.length;\n      if (n > 0) {\n        let x0 = this.border;\n        let y0 = this.border;\n        let other = horizontal ? pgeo.height : pgeo.width;\n        other -= 2 * this.border;\n        const size = this.graph.isSwimlane(parent) ? this.graph.getStartSize(parent) : new Rectangle();\n        other -= horizontal ? size.height : size.width;\n        x0 += size.width;\n        y0 += size.height;\n        const tmp = this.border + (n - 1) * this.spacing;\n        const value = horizontal ? (pgeo.width - x0 - tmp) / n : (pgeo.height - y0 - tmp) / n;\n        // Avoids negative values, that is values where the sum of the\n        // spacing plus the border is larger then the available space\n        if (value > 0) {\n          model.beginUpdate();\n          try {\n            for (let i = 0; i < n; i += 1) {\n              const child = children[i];\n              let geo = child.getGeometry();\n              if (geo != null) {\n                geo = geo.clone();\n                geo.x = x0;\n                geo.y = y0;\n                if (horizontal) {\n                  if (this.resizeVertices) {\n                    geo.width = value;\n                    geo.height = other;\n                  }\n                  x0 += value + this.spacing;\n                } else {\n                  if (this.resizeVertices) {\n                    geo.height = value;\n                    geo.width = other;\n                  }\n                  y0 += value + this.spacing;\n                }\n                model.setGeometry(child, geo);\n              }\n            }\n          } finally {\n            model.endUpdate();\n          }\n        }\n      }\n    }\n  }\n}\nexport default PartitionLayout;","map":{"version":3,"names":["Rectangle","GraphLayout","PartitionLayout","constructor","graph","horizontal","spacing","border","resizeVertices","isHorizontal","moveCell","cell","x","y","model","getDataModel","parent","getParent","i","last","childCount","getChildCount","child","getChildAt","bounds","getVertexBounds","tmp","width","idx","getIndex","Math","max","add","execute","pgeo","getGeometry","container","isLayer","getView","currentRoot","offsetWidth","height","offsetHeight","children","isVertexIgnored","isVertexMovable","push","n","length","x0","y0","other","size","isSwimlane","getStartSize","value","beginUpdate","geo","clone","setGeometry","endUpdate"],"sources":["D:/ospanel/domains/проекты open server/old/react/react-intro-main/node_modules/@maxgraph/core/dist/view/layout/PartitionLayout.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from '../geometry/Rectangle';\nimport GraphLayout from './GraphLayout';\n/**\n * Extends {@link GraphLayout} for partitioning the parent cell vertically or\n * horizontally by filling the complete area with the child cells. A horizontal\n * layout partitions the height of the given parent whereas a a non-horizontal\n * layout partitions the width. If the parent is a layer (that is, a child of\n * the root node), then the current graph size is partitioned. The children do\n * not need to be connected for this layout to work.\n *\n * Example:\n *\n * ```javascript\n * var layout = new mxPartitionLayout(graph, true, 10, 20);\n * layout.execute(graph.getDefaultParent());\n * ```\n * @class\n */\nclass PartitionLayout extends GraphLayout {\n    constructor(graph, horizontal = true, spacing = 0, border = 0) {\n        super(graph);\n        /**\n         * Boolean that specifies if vertices should be resized. Default is true.\n         */\n        this.resizeVertices = true;\n        this.horizontal = horizontal != null ? horizontal : true;\n        this.spacing = spacing || 0;\n        this.border = border || 0;\n    }\n    /**\n     * Returns <horizontal>.\n     */\n    isHorizontal() {\n        return this.horizontal;\n    }\n    /**\n     * Implements {@link GraphLayout.moveCell}.\n     *\n     * @param {mxCell} cell\n     * @param {number} x\n     * @param {number} y\n     * @memberof mxPartitionLayout\n     */\n    moveCell(cell, x, y) {\n        const model = this.graph.getDataModel();\n        const parent = cell.getParent();\n        if (cell != null && parent != null) {\n            let i = 0;\n            let last = 0;\n            const childCount = parent.getChildCount();\n            // Finds index of the closest swimlane\n            // TODO: Take into account the orientation\n            for (i = 0; i < childCount; i += 1) {\n                const child = parent.getChildAt(i);\n                const bounds = this.getVertexBounds(child);\n                if (bounds != null) {\n                    const tmp = bounds.x + bounds.width / 2;\n                    if (last < x && tmp > x) {\n                        break;\n                    }\n                    last = tmp;\n                }\n            }\n            // Changes child order in parent\n            let idx = parent.getIndex(cell);\n            idx = Math.max(0, i - (i > idx ? 1 : 0));\n            model.add(parent, cell, idx);\n        }\n    }\n    /**\n     * Implements {@link GraphLayout#execute}. All children where <isVertexIgnored>\n     * returns false and <isVertexMovable> returns true are modified.\n     */\n    execute(parent) {\n        const horizontal = this.isHorizontal();\n        const model = this.graph.getDataModel();\n        let pgeo = parent.getGeometry();\n        // Handles special case where the parent is either a layer with no\n        // geometry or the current root of the view in which case the size\n        // of the graph's container will be used.\n        if (this.graph.container != null &&\n            ((pgeo == null && model.isLayer(parent)) ||\n                parent === this.graph.getView().currentRoot)) {\n            const width = this.graph.container.offsetWidth - 1;\n            const height = this.graph.container.offsetHeight - 1;\n            pgeo = new Rectangle(0, 0, width, height);\n        }\n        if (pgeo != null) {\n            const children = [];\n            const childCount = parent.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                const child = parent.getChildAt(i);\n                if (!this.isVertexIgnored(child) && this.isVertexMovable(child)) {\n                    children.push(child);\n                }\n            }\n            const n = children.length;\n            if (n > 0) {\n                let x0 = this.border;\n                let y0 = this.border;\n                let other = horizontal ? pgeo.height : pgeo.width;\n                other -= 2 * this.border;\n                const size = this.graph.isSwimlane(parent)\n                    ? this.graph.getStartSize(parent)\n                    : new Rectangle();\n                other -= horizontal ? size.height : size.width;\n                x0 += size.width;\n                y0 += size.height;\n                const tmp = this.border + (n - 1) * this.spacing;\n                const value = horizontal\n                    ? (pgeo.width - x0 - tmp) / n\n                    : (pgeo.height - y0 - tmp) / n;\n                // Avoids negative values, that is values where the sum of the\n                // spacing plus the border is larger then the available space\n                if (value > 0) {\n                    model.beginUpdate();\n                    try {\n                        for (let i = 0; i < n; i += 1) {\n                            const child = children[i];\n                            let geo = child.getGeometry();\n                            if (geo != null) {\n                                geo = geo.clone();\n                                geo.x = x0;\n                                geo.y = y0;\n                                if (horizontal) {\n                                    if (this.resizeVertices) {\n                                        geo.width = value;\n                                        geo.height = other;\n                                    }\n                                    x0 += value + this.spacing;\n                                }\n                                else {\n                                    if (this.resizeVertices) {\n                                        geo.height = value;\n                                        geo.width = other;\n                                    }\n                                    y0 += value + this.spacing;\n                                }\n                                model.setGeometry(child, geo);\n                            }\n                        }\n                    }\n                    finally {\n                        model.endUpdate();\n                    }\n                }\n            }\n        }\n    }\n}\nexport default PartitionLayout;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,SAAS,MAAM,uBAAuB;AAC7C,OAAOC,WAAW,MAAM,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,eAAe,SAASD,WAAW,CAAC;EACtCE,WAAWA,CAACC,KAAK,EAAEC,UAAU,GAAG,IAAI,EAAEC,OAAO,GAAG,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAE;IAC3D,KAAK,CAACH,KAAK,CAAC;IACZ;AACR;AACA;IACQ,IAAI,CAACI,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACH,UAAU,GAAGA,UAAU,IAAI,IAAI,GAAGA,UAAU,GAAG,IAAI;IACxD,IAAI,CAACC,OAAO,GAAGA,OAAO,IAAI,CAAC;IAC3B,IAAI,CAACC,MAAM,GAAGA,MAAM,IAAI,CAAC;EAC7B;EACA;AACJ;AACA;EACIE,YAAYA,CAAA,EAAG;IACX,OAAO,IAAI,CAACJ,UAAU;EAC1B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIK,QAAQA,CAACC,IAAI,EAAEC,CAAC,EAAEC,CAAC,EAAE;IACjB,MAAMC,KAAK,GAAG,IAAI,CAACV,KAAK,CAACW,YAAY,CAAC,CAAC;IACvC,MAAMC,MAAM,GAAGL,IAAI,CAACM,SAAS,CAAC,CAAC;IAC/B,IAAIN,IAAI,IAAI,IAAI,IAAIK,MAAM,IAAI,IAAI,EAAE;MAChC,IAAIE,CAAC,GAAG,CAAC;MACT,IAAIC,IAAI,GAAG,CAAC;MACZ,MAAMC,UAAU,GAAGJ,MAAM,CAACK,aAAa,CAAC,CAAC;MACzC;MACA;MACA,KAAKH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,UAAU,EAAEF,CAAC,IAAI,CAAC,EAAE;QAChC,MAAMI,KAAK,GAAGN,MAAM,CAACO,UAAU,CAACL,CAAC,CAAC;QAClC,MAAMM,MAAM,GAAG,IAAI,CAACC,eAAe,CAACH,KAAK,CAAC;QAC1C,IAAIE,MAAM,IAAI,IAAI,EAAE;UAChB,MAAME,GAAG,GAAGF,MAAM,CAACZ,CAAC,GAAGY,MAAM,CAACG,KAAK,GAAG,CAAC;UACvC,IAAIR,IAAI,GAAGP,CAAC,IAAIc,GAAG,GAAGd,CAAC,EAAE;YACrB;UACJ;UACAO,IAAI,GAAGO,GAAG;QACd;MACJ;MACA;MACA,IAAIE,GAAG,GAAGZ,MAAM,CAACa,QAAQ,CAAClB,IAAI,CAAC;MAC/BiB,GAAG,GAAGE,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEb,CAAC,IAAIA,CAAC,GAAGU,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;MACxCd,KAAK,CAACkB,GAAG,CAAChB,MAAM,EAAEL,IAAI,EAAEiB,GAAG,CAAC;IAChC;EACJ;EACA;AACJ;AACA;AACA;EACIK,OAAOA,CAACjB,MAAM,EAAE;IACZ,MAAMX,UAAU,GAAG,IAAI,CAACI,YAAY,CAAC,CAAC;IACtC,MAAMK,KAAK,GAAG,IAAI,CAACV,KAAK,CAACW,YAAY,CAAC,CAAC;IACvC,IAAImB,IAAI,GAAGlB,MAAM,CAACmB,WAAW,CAAC,CAAC;IAC/B;IACA;IACA;IACA,IAAI,IAAI,CAAC/B,KAAK,CAACgC,SAAS,IAAI,IAAI,KAC1BF,IAAI,IAAI,IAAI,IAAIpB,KAAK,CAACuB,OAAO,CAACrB,MAAM,CAAC,IACnCA,MAAM,KAAK,IAAI,CAACZ,KAAK,CAACkC,OAAO,CAAC,CAAC,CAACC,WAAW,CAAC,EAAE;MAClD,MAAMZ,KAAK,GAAG,IAAI,CAACvB,KAAK,CAACgC,SAAS,CAACI,WAAW,GAAG,CAAC;MAClD,MAAMC,MAAM,GAAG,IAAI,CAACrC,KAAK,CAACgC,SAAS,CAACM,YAAY,GAAG,CAAC;MACpDR,IAAI,GAAG,IAAIlC,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE2B,KAAK,EAAEc,MAAM,CAAC;IAC7C;IACA,IAAIP,IAAI,IAAI,IAAI,EAAE;MACd,MAAMS,QAAQ,GAAG,EAAE;MACnB,MAAMvB,UAAU,GAAGJ,MAAM,CAACK,aAAa,CAAC,CAAC;MACzC,KAAK,IAAIH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,UAAU,EAAEF,CAAC,IAAI,CAAC,EAAE;QACpC,MAAMI,KAAK,GAAGN,MAAM,CAACO,UAAU,CAACL,CAAC,CAAC;QAClC,IAAI,CAAC,IAAI,CAAC0B,eAAe,CAACtB,KAAK,CAAC,IAAI,IAAI,CAACuB,eAAe,CAACvB,KAAK,CAAC,EAAE;UAC7DqB,QAAQ,CAACG,IAAI,CAACxB,KAAK,CAAC;QACxB;MACJ;MACA,MAAMyB,CAAC,GAAGJ,QAAQ,CAACK,MAAM;MACzB,IAAID,CAAC,GAAG,CAAC,EAAE;QACP,IAAIE,EAAE,GAAG,IAAI,CAAC1C,MAAM;QACpB,IAAI2C,EAAE,GAAG,IAAI,CAAC3C,MAAM;QACpB,IAAI4C,KAAK,GAAG9C,UAAU,GAAG6B,IAAI,CAACO,MAAM,GAAGP,IAAI,CAACP,KAAK;QACjDwB,KAAK,IAAI,CAAC,GAAG,IAAI,CAAC5C,MAAM;QACxB,MAAM6C,IAAI,GAAG,IAAI,CAAChD,KAAK,CAACiD,UAAU,CAACrC,MAAM,CAAC,GACpC,IAAI,CAACZ,KAAK,CAACkD,YAAY,CAACtC,MAAM,CAAC,GAC/B,IAAIhB,SAAS,CAAC,CAAC;QACrBmD,KAAK,IAAI9C,UAAU,GAAG+C,IAAI,CAACX,MAAM,GAAGW,IAAI,CAACzB,KAAK;QAC9CsB,EAAE,IAAIG,IAAI,CAACzB,KAAK;QAChBuB,EAAE,IAAIE,IAAI,CAACX,MAAM;QACjB,MAAMf,GAAG,GAAG,IAAI,CAACnB,MAAM,GAAG,CAACwC,CAAC,GAAG,CAAC,IAAI,IAAI,CAACzC,OAAO;QAChD,MAAMiD,KAAK,GAAGlD,UAAU,GAClB,CAAC6B,IAAI,CAACP,KAAK,GAAGsB,EAAE,GAAGvB,GAAG,IAAIqB,CAAC,GAC3B,CAACb,IAAI,CAACO,MAAM,GAAGS,EAAE,GAAGxB,GAAG,IAAIqB,CAAC;QAClC;QACA;QACA,IAAIQ,KAAK,GAAG,CAAC,EAAE;UACXzC,KAAK,CAAC0C,WAAW,CAAC,CAAC;UACnB,IAAI;YACA,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6B,CAAC,EAAE7B,CAAC,IAAI,CAAC,EAAE;cAC3B,MAAMI,KAAK,GAAGqB,QAAQ,CAACzB,CAAC,CAAC;cACzB,IAAIuC,GAAG,GAAGnC,KAAK,CAACa,WAAW,CAAC,CAAC;cAC7B,IAAIsB,GAAG,IAAI,IAAI,EAAE;gBACbA,GAAG,GAAGA,GAAG,CAACC,KAAK,CAAC,CAAC;gBACjBD,GAAG,CAAC7C,CAAC,GAAGqC,EAAE;gBACVQ,GAAG,CAAC5C,CAAC,GAAGqC,EAAE;gBACV,IAAI7C,UAAU,EAAE;kBACZ,IAAI,IAAI,CAACG,cAAc,EAAE;oBACrBiD,GAAG,CAAC9B,KAAK,GAAG4B,KAAK;oBACjBE,GAAG,CAAChB,MAAM,GAAGU,KAAK;kBACtB;kBACAF,EAAE,IAAIM,KAAK,GAAG,IAAI,CAACjD,OAAO;gBAC9B,CAAC,MACI;kBACD,IAAI,IAAI,CAACE,cAAc,EAAE;oBACrBiD,GAAG,CAAChB,MAAM,GAAGc,KAAK;oBAClBE,GAAG,CAAC9B,KAAK,GAAGwB,KAAK;kBACrB;kBACAD,EAAE,IAAIK,KAAK,GAAG,IAAI,CAACjD,OAAO;gBAC9B;gBACAQ,KAAK,CAAC6C,WAAW,CAACrC,KAAK,EAAEmC,GAAG,CAAC;cACjC;YACJ;UACJ,CAAC,SACO;YACJ3C,KAAK,CAAC8C,SAAS,CAAC,CAAC;UACrB;QACJ;MACJ;IACJ;EACJ;AACJ;AACA,eAAe1D,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}