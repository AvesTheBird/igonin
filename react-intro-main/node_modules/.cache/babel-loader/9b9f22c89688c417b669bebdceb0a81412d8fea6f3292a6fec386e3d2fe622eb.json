{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar WordHighlighter_1, WordHighlighterContribution_1;\nimport * as nls from '../../../../nls.js';\nimport { alert } from '../../../../base/browser/ui/aria/aria.js';\nimport { createCancelablePromise, Delayer, first } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { onUnexpectedError, onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { isDiffEditor } from '../../../browser/editorBrowser.js';\nimport { EditorAction, registerEditorAction, registerEditorContribution, registerModelAndPositionCommand } from '../../../browser/editorExtensions.js';\nimport { ICodeEditorService } from '../../../browser/services/codeEditorService.js';\nimport { Range } from '../../../common/core/range.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { shouldSynchronizeModel } from '../../../common/model.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { getHighlightDecorationOptions } from './highlightDecorations.js';\nimport { IContextKeyService, RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { matchesScheme, Schemas } from '../../../../base/common/network.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { score } from '../../../common/languageSelector.js';\nimport { isEqual } from '../../../../base/common/resources.js';\nimport { TextualMultiDocumentHighlightFeature } from './textualHighlightProvider.js';\nimport { registerEditorFeature } from '../../../common/editorFeatures.js';\nconst ctxHasWordHighlights = new RawContextKey('hasWordHighlights', false);\nexport function getOccurrencesAtPosition(registry, model, position, token) {\n  const orderedByScore = registry.ordered(model);\n  // in order of score ask the occurrences provider\n  // until someone response with a good result\n  // (good = non undefined and non null value)\n  // (result of size == 0 is valid, no highlights is a valid/expected result -- not a signal to fall back to other providers)\n  return first(orderedByScore.map(provider => () => {\n    return Promise.resolve(provider.provideDocumentHighlights(model, position, token)).then(undefined, onUnexpectedExternalError);\n  }), result => result !== undefined && result !== null).then(result => {\n    if (result) {\n      const map = new ResourceMap();\n      map.set(model.uri, result);\n      return map;\n    }\n    return new ResourceMap();\n  });\n}\nexport function getOccurrencesAcrossMultipleModels(registry, model, position, wordSeparators, token, otherModels) {\n  const orderedByScore = registry.ordered(model);\n  // in order of score ask the occurrences provider\n  // until someone response with a good result\n  // (good = non undefined and non null ResourceMap)\n  // (result of size == 0 is valid, no highlights is a valid/expected result -- not a signal to fall back to other providers)\n  return first(orderedByScore.map(provider => () => {\n    const filteredModels = otherModels.filter(otherModel => {\n      return shouldSynchronizeModel(otherModel);\n    }).filter(otherModel => {\n      return score(provider.selector, otherModel.uri, otherModel.getLanguageId(), true, undefined, undefined) > 0;\n    });\n    return Promise.resolve(provider.provideMultiDocumentHighlights(model, position, filteredModels, token)).then(undefined, onUnexpectedExternalError);\n  }), result => result !== undefined && result !== null);\n}\nclass OccurenceAtPositionRequest {\n  constructor(_model, _selection, _wordSeparators) {\n    this._model = _model;\n    this._selection = _selection;\n    this._wordSeparators = _wordSeparators;\n    this._wordRange = this._getCurrentWordRange(_model, _selection);\n    this._result = null;\n  }\n  get result() {\n    if (!this._result) {\n      this._result = createCancelablePromise(token => this._compute(this._model, this._selection, this._wordSeparators, token));\n    }\n    return this._result;\n  }\n  _getCurrentWordRange(model, selection) {\n    const word = model.getWordAtPosition(selection.getPosition());\n    if (word) {\n      return new Range(selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);\n    }\n    return null;\n  }\n  isValid(model, selection, decorations) {\n    const lineNumber = selection.startLineNumber;\n    const startColumn = selection.startColumn;\n    const endColumn = selection.endColumn;\n    const currentWordRange = this._getCurrentWordRange(model, selection);\n    let requestIsValid = Boolean(this._wordRange && this._wordRange.equalsRange(currentWordRange));\n    // Even if we are on a different word, if that word is in the decorations ranges, the request is still valid\n    // (Same symbol)\n    for (let i = 0, len = decorations.length; !requestIsValid && i < len; i++) {\n      const range = decorations.getRange(i);\n      if (range && range.startLineNumber === lineNumber) {\n        if (range.startColumn <= startColumn && range.endColumn >= endColumn) {\n          requestIsValid = true;\n        }\n      }\n    }\n    return requestIsValid;\n  }\n  cancel() {\n    this.result.cancel();\n  }\n}\nclass SemanticOccurenceAtPositionRequest extends OccurenceAtPositionRequest {\n  constructor(model, selection, wordSeparators, providers) {\n    super(model, selection, wordSeparators);\n    this._providers = providers;\n  }\n  _compute(model, selection, wordSeparators, token) {\n    return getOccurrencesAtPosition(this._providers, model, selection.getPosition(), token).then(value => {\n      if (!value) {\n        return new ResourceMap();\n      }\n      return value;\n    });\n  }\n}\nclass MultiModelOccurenceRequest extends OccurenceAtPositionRequest {\n  constructor(model, selection, wordSeparators, providers, otherModels) {\n    super(model, selection, wordSeparators);\n    this._providers = providers;\n    this._otherModels = otherModels;\n  }\n  _compute(model, selection, wordSeparators, token) {\n    return getOccurrencesAcrossMultipleModels(this._providers, model, selection.getPosition(), wordSeparators, token, this._otherModels).then(value => {\n      if (!value) {\n        return new ResourceMap();\n      }\n      return value;\n    });\n  }\n}\nfunction computeOccurencesAtPosition(registry, model, selection, word, wordSeparators) {\n  return new SemanticOccurenceAtPositionRequest(model, selection, wordSeparators, registry);\n}\nfunction computeOccurencesMultiModel(registry, model, selection, word, wordSeparators, otherModels) {\n  return new MultiModelOccurenceRequest(model, selection, wordSeparators, registry, otherModels);\n}\nregisterModelAndPositionCommand('_executeDocumentHighlights', async (accessor, model, position) => {\n  const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n  const map = await getOccurrencesAtPosition(languageFeaturesService.documentHighlightProvider, model, position, CancellationToken.None);\n  return map?.get(model.uri);\n});\nlet WordHighlighter = class WordHighlighter {\n  static {\n    WordHighlighter_1 = this;\n  }\n  static {\n    this.storedDecorationIDs = new ResourceMap();\n  }\n  static {\n    this.query = null;\n  }\n  constructor(editor, providers, multiProviders, contextKeyService, codeEditorService) {\n    this.toUnhook = new DisposableStore();\n    this.workerRequestTokenId = 0;\n    this.workerRequestCompleted = false;\n    this.workerRequestValue = new ResourceMap();\n    this.lastCursorPositionChangeTime = 0;\n    this.renderDecorationsTimer = -1;\n    this.runDelayer = this.toUnhook.add(new Delayer(50));\n    this.editor = editor;\n    this.providers = providers;\n    this.multiDocumentProviders = multiProviders;\n    this.codeEditorService = codeEditorService;\n    this._hasWordHighlights = ctxHasWordHighlights.bindTo(contextKeyService);\n    this._ignorePositionChangeEvent = false;\n    this.occurrencesHighlight = this.editor.getOption(81 /* EditorOption.occurrencesHighlight */);\n    this.model = this.editor.getModel();\n    this.toUnhook.add(editor.onDidChangeCursorPosition(e => {\n      if (this._ignorePositionChangeEvent) {\n        // We are changing the position => ignore this event\n        return;\n      }\n      if (this.occurrencesHighlight === 'off') {\n        // Early exit if nothing needs to be done!\n        // Leave some form of early exit check here if you wish to continue being a cursor position change listener ;)\n        return;\n      }\n      this.runDelayer.trigger(() => {\n        this._onPositionChanged(e);\n      });\n    }));\n    this.toUnhook.add(editor.onDidFocusEditorText(e => {\n      if (this.occurrencesHighlight === 'off') {\n        // Early exit if nothing needs to be done\n        return;\n      }\n      if (!this.workerRequest) {\n        this.runDelayer.trigger(() => {\n          this._run();\n        });\n      }\n    }));\n    this.toUnhook.add(editor.onDidChangeModelContent(e => {\n      if (!matchesScheme(this.model.uri, 'output')) {\n        this._stopAll();\n      }\n    }));\n    this.toUnhook.add(editor.onDidChangeModel(e => {\n      if (!e.newModelUrl && e.oldModelUrl) {\n        this._stopSingular();\n      } else {\n        if (WordHighlighter_1.query) {\n          this._run();\n        }\n      }\n    }));\n    this.toUnhook.add(editor.onDidChangeConfiguration(e => {\n      const newValue = this.editor.getOption(81 /* EditorOption.occurrencesHighlight */);\n      if (this.occurrencesHighlight !== newValue) {\n        this.occurrencesHighlight = newValue;\n        switch (newValue) {\n          case 'off':\n            this._stopAll();\n            break;\n          case 'singleFile':\n            this._stopAll(WordHighlighter_1.query?.modelInfo?.model);\n            break;\n          case 'multiFile':\n            if (WordHighlighter_1.query) {\n              this._run(true);\n            }\n            break;\n          default:\n            console.warn('Unknown occurrencesHighlight setting value:', newValue);\n            break;\n        }\n      }\n    }));\n    this.decorations = this.editor.createDecorationsCollection();\n    this.workerRequestTokenId = 0;\n    this.workerRequest = null;\n    this.workerRequestCompleted = false;\n    this.lastCursorPositionChangeTime = 0;\n    this.renderDecorationsTimer = -1;\n    // if there is a query already, highlight off that query\n    if (WordHighlighter_1.query) {\n      this._run();\n    }\n  }\n  hasDecorations() {\n    return this.decorations.length > 0;\n  }\n  restore() {\n    if (this.occurrencesHighlight === 'off') {\n      return;\n    }\n    this.runDelayer.cancel();\n    this._run();\n  }\n  _getSortedHighlights() {\n    return this.decorations.getRanges().sort(Range.compareRangesUsingStarts);\n  }\n  moveNext() {\n    const highlights = this._getSortedHighlights();\n    const index = highlights.findIndex(range => range.containsPosition(this.editor.getPosition()));\n    const newIndex = (index + 1) % highlights.length;\n    const dest = highlights[newIndex];\n    try {\n      this._ignorePositionChangeEvent = true;\n      this.editor.setPosition(dest.getStartPosition());\n      this.editor.revealRangeInCenterIfOutsideViewport(dest);\n      const word = this._getWord();\n      if (word) {\n        const lineContent = this.editor.getModel().getLineContent(dest.startLineNumber);\n        alert(`${lineContent}, ${newIndex + 1} of ${highlights.length} for '${word.word}'`);\n      }\n    } finally {\n      this._ignorePositionChangeEvent = false;\n    }\n  }\n  moveBack() {\n    const highlights = this._getSortedHighlights();\n    const index = highlights.findIndex(range => range.containsPosition(this.editor.getPosition()));\n    const newIndex = (index - 1 + highlights.length) % highlights.length;\n    const dest = highlights[newIndex];\n    try {\n      this._ignorePositionChangeEvent = true;\n      this.editor.setPosition(dest.getStartPosition());\n      this.editor.revealRangeInCenterIfOutsideViewport(dest);\n      const word = this._getWord();\n      if (word) {\n        const lineContent = this.editor.getModel().getLineContent(dest.startLineNumber);\n        alert(`${lineContent}, ${newIndex + 1} of ${highlights.length} for '${word.word}'`);\n      }\n    } finally {\n      this._ignorePositionChangeEvent = false;\n    }\n  }\n  _removeSingleDecorations() {\n    // return if no model\n    if (!this.editor.hasModel()) {\n      return;\n    }\n    const currentDecorationIDs = WordHighlighter_1.storedDecorationIDs.get(this.editor.getModel().uri);\n    if (!currentDecorationIDs) {\n      return;\n    }\n    this.editor.removeDecorations(currentDecorationIDs);\n    WordHighlighter_1.storedDecorationIDs.delete(this.editor.getModel().uri);\n    if (this.decorations.length > 0) {\n      this.decorations.clear();\n      this._hasWordHighlights.set(false);\n    }\n  }\n  _removeAllDecorations(preservedModel) {\n    const currentEditors = this.codeEditorService.listCodeEditors();\n    const deleteURI = [];\n    // iterate over editors and store models in currentModels\n    for (const editor of currentEditors) {\n      if (!editor.hasModel() || isEqual(editor.getModel().uri, preservedModel?.uri)) {\n        continue;\n      }\n      const currentDecorationIDs = WordHighlighter_1.storedDecorationIDs.get(editor.getModel().uri);\n      if (!currentDecorationIDs) {\n        continue;\n      }\n      editor.removeDecorations(currentDecorationIDs);\n      deleteURI.push(editor.getModel().uri);\n      const editorHighlighterContrib = WordHighlighterContribution.get(editor);\n      if (!editorHighlighterContrib?.wordHighlighter) {\n        continue;\n      }\n      if (editorHighlighterContrib.wordHighlighter.decorations.length > 0) {\n        editorHighlighterContrib.wordHighlighter.decorations.clear();\n        editorHighlighterContrib.wordHighlighter.workerRequest = null;\n        editorHighlighterContrib.wordHighlighter._hasWordHighlights.set(false);\n      }\n    }\n    for (const uri of deleteURI) {\n      WordHighlighter_1.storedDecorationIDs.delete(uri);\n    }\n  }\n  _stopSingular() {\n    // Remove any existing decorations + a possible query, and re - run to update decorations\n    this._removeSingleDecorations();\n    if (this.editor.hasTextFocus()) {\n      if (this.editor.getModel()?.uri.scheme !== Schemas.vscodeNotebookCell && WordHighlighter_1.query?.modelInfo?.model.uri.scheme !== Schemas.vscodeNotebookCell) {\n        // clear query if focused non-nb editor\n        WordHighlighter_1.query = null;\n        this._run(); // TODO: @Yoyokrazy -- investigate why we need a full rerun here. likely addressed a case/patch in the first iteration of this feature\n      } else {\n        // remove modelInfo to account for nb cell being disposed\n        if (WordHighlighter_1.query?.modelInfo) {\n          WordHighlighter_1.query.modelInfo = null;\n        }\n      }\n    }\n    // Cancel any renderDecorationsTimer\n    if (this.renderDecorationsTimer !== -1) {\n      clearTimeout(this.renderDecorationsTimer);\n      this.renderDecorationsTimer = -1;\n    }\n    // Cancel any worker request\n    if (this.workerRequest !== null) {\n      this.workerRequest.cancel();\n      this.workerRequest = null;\n    }\n    // Invalidate any worker request callback\n    if (!this.workerRequestCompleted) {\n      this.workerRequestTokenId++;\n      this.workerRequestCompleted = true;\n    }\n  }\n  _stopAll(preservedModel) {\n    // Remove any existing decorations\n    // TODO: @Yoyokrazy -- this triggers as notebooks scroll, causing highlights to disappear momentarily.\n    // maybe a nb type check?\n    this._removeAllDecorations(preservedModel);\n    // Cancel any renderDecorationsTimer\n    if (this.renderDecorationsTimer !== -1) {\n      clearTimeout(this.renderDecorationsTimer);\n      this.renderDecorationsTimer = -1;\n    }\n    // Cancel any worker request\n    if (this.workerRequest !== null) {\n      this.workerRequest.cancel();\n      this.workerRequest = null;\n    }\n    // Invalidate any worker request callback\n    if (!this.workerRequestCompleted) {\n      this.workerRequestTokenId++;\n      this.workerRequestCompleted = true;\n    }\n  }\n  _onPositionChanged(e) {\n    // disabled\n    if (this.occurrencesHighlight === 'off') {\n      this._stopAll();\n      return;\n    }\n    // ignore typing & other\n    // need to check if the model is a notebook cell, should not stop if nb\n    if (e.reason !== 3 /* CursorChangeReason.Explicit */ && this.editor.getModel()?.uri.scheme !== Schemas.vscodeNotebookCell) {\n      this._stopAll();\n      return;\n    }\n    this._run();\n  }\n  _getWord() {\n    const editorSelection = this.editor.getSelection();\n    const lineNumber = editorSelection.startLineNumber;\n    const startColumn = editorSelection.startColumn;\n    if (this.model.isDisposed()) {\n      return null;\n    }\n    return this.model.getWordAtPosition({\n      lineNumber: lineNumber,\n      column: startColumn\n    });\n  }\n  getOtherModelsToHighlight(model) {\n    if (!model) {\n      return [];\n    }\n    // notebook case\n    const isNotebookEditor = model.uri.scheme === Schemas.vscodeNotebookCell;\n    if (isNotebookEditor) {\n      const currentModels = [];\n      const currentEditors = this.codeEditorService.listCodeEditors();\n      for (const editor of currentEditors) {\n        const tempModel = editor.getModel();\n        if (tempModel && tempModel !== model && tempModel.uri.scheme === Schemas.vscodeNotebookCell) {\n          currentModels.push(tempModel);\n        }\n      }\n      return currentModels;\n    }\n    // inline case\n    // ? current works when highlighting outside of an inline diff, highlighting in.\n    // ? broken when highlighting within a diff editor. highlighting the main editor does not work\n    // ? editor group service could be useful here\n    const currentModels = [];\n    const currentEditors = this.codeEditorService.listCodeEditors();\n    for (const editor of currentEditors) {\n      if (!isDiffEditor(editor)) {\n        continue;\n      }\n      const diffModel = editor.getModel();\n      if (!diffModel) {\n        continue;\n      }\n      if (model === diffModel.modified) {\n        // embedded inline chat diff would pass this, allowing highlights\n        //? currentModels.push(diffModel.original);\n        currentModels.push(diffModel.modified);\n      }\n    }\n    if (currentModels.length) {\n      // no matching editors have been found\n      return currentModels;\n    }\n    // multi-doc OFF\n    if (this.occurrencesHighlight === 'singleFile') {\n      return [];\n    }\n    // multi-doc ON\n    for (const editor of currentEditors) {\n      const tempModel = editor.getModel();\n      const isValidModel = tempModel && tempModel !== model;\n      if (isValidModel) {\n        currentModels.push(tempModel);\n      }\n    }\n    return currentModels;\n  }\n  _run(multiFileConfigChange) {\n    let workerRequestIsValid;\n    const hasTextFocus = this.editor.hasTextFocus();\n    if (!hasTextFocus) {\n      // new nb cell scrolled in, didChangeModel fires\n      if (!WordHighlighter_1.query) {\n        // no previous query, nothing to highlight off of\n        this._stopAll();\n        return;\n      }\n    } else {\n      // has text focus\n      const editorSelection = this.editor.getSelection();\n      // ignore multiline selection\n      if (!editorSelection || editorSelection.startLineNumber !== editorSelection.endLineNumber) {\n        WordHighlighter_1.query = null;\n        this._stopAll();\n        return;\n      }\n      const startColumn = editorSelection.startColumn;\n      const endColumn = editorSelection.endColumn;\n      const word = this._getWord();\n      // The selection must be inside a word or surround one word at most\n      if (!word || word.startColumn > startColumn || word.endColumn < endColumn) {\n        // no previous query, nothing to highlight\n        WordHighlighter_1.query = null;\n        this._stopAll();\n        return;\n      }\n      // All the effort below is trying to achieve this:\n      // - when cursor is moved to a word, trigger immediately a findOccurrences request\n      // - 250ms later after the last cursor move event, render the occurrences\n      // - no flickering!\n      workerRequestIsValid = this.workerRequest && this.workerRequest.isValid(this.model, editorSelection, this.decorations);\n      WordHighlighter_1.query = {\n        modelInfo: {\n          model: this.model,\n          selection: editorSelection\n        },\n        word: word\n      };\n    }\n    // There are 4 cases:\n    // a) old workerRequest is valid & completed, renderDecorationsTimer fired\n    // b) old workerRequest is valid & completed, renderDecorationsTimer not fired\n    // c) old workerRequest is valid, but not completed\n    // d) old workerRequest is not valid\n    // For a) no action is needed\n    // For c), member 'lastCursorPositionChangeTime' will be used when installing the timer so no action is needed\n    this.lastCursorPositionChangeTime = new Date().getTime();\n    if (workerRequestIsValid) {\n      if (this.workerRequestCompleted && this.renderDecorationsTimer !== -1) {\n        // case b)\n        // Delay the firing of renderDecorationsTimer by an extra 250 ms\n        clearTimeout(this.renderDecorationsTimer);\n        this.renderDecorationsTimer = -1;\n        this._beginRenderDecorations();\n      }\n    } else if (isEqual(this.editor.getModel().uri, WordHighlighter_1.query.modelInfo?.model.uri)) {\n      // only trigger new worker requests from the primary model that initiated the query\n      // case d)\n      // check if the new queried word is contained in the range of a stored decoration for this model\n      if (!multiFileConfigChange) {\n        const currentModelDecorationRanges = this.decorations.getRanges();\n        for (const storedRange of currentModelDecorationRanges) {\n          if (storedRange.containsPosition(this.editor.getPosition())) {\n            return;\n          }\n        }\n      }\n      // stop all previous actions if new word is highlighted\n      // if we trigger the run off a setting change -> multifile highlighting, we do not want to remove decorations from this model\n      this._stopAll(multiFileConfigChange ? this.model : undefined);\n      const myRequestId = ++this.workerRequestTokenId;\n      this.workerRequestCompleted = false;\n      const otherModelsToHighlight = this.getOtherModelsToHighlight(this.editor.getModel());\n      // when reaching here, there are two possible states.\n      // \t\t1) we have text focus, and a valid query was updated.\n      // \t\t2) we do not have text focus, and a valid query is cached.\n      // the query will ALWAYS have the correct data for the current highlight request, so it can always be passed to the workerRequest safely\n      if (!WordHighlighter_1.query || !WordHighlighter_1.query.modelInfo || WordHighlighter_1.query.modelInfo.model.isDisposed()) {\n        return;\n      }\n      this.workerRequest = this.computeWithModel(WordHighlighter_1.query.modelInfo.model, WordHighlighter_1.query.modelInfo.selection, WordHighlighter_1.query.word, otherModelsToHighlight);\n      this.workerRequest?.result.then(data => {\n        if (myRequestId === this.workerRequestTokenId) {\n          this.workerRequestCompleted = true;\n          this.workerRequestValue = data || [];\n          this._beginRenderDecorations();\n        }\n      }, onUnexpectedError);\n    }\n  }\n  computeWithModel(model, selection, word, otherModels) {\n    if (!otherModels.length) {\n      return computeOccurencesAtPosition(this.providers, model, selection, word, this.editor.getOption(132 /* EditorOption.wordSeparators */));\n    } else {\n      return computeOccurencesMultiModel(this.multiDocumentProviders, model, selection, word, this.editor.getOption(132 /* EditorOption.wordSeparators */), otherModels);\n    }\n  }\n  _beginRenderDecorations() {\n    const currentTime = new Date().getTime();\n    const minimumRenderTime = this.lastCursorPositionChangeTime + 250;\n    if (currentTime >= minimumRenderTime) {\n      // Synchronous\n      this.renderDecorationsTimer = -1;\n      this.renderDecorations();\n    } else {\n      // Asynchronous\n      this.renderDecorationsTimer = setTimeout(() => {\n        this.renderDecorations();\n      }, minimumRenderTime - currentTime);\n    }\n  }\n  renderDecorations() {\n    this.renderDecorationsTimer = -1;\n    // create new loop, iterate over current editors using this.codeEditorService.listCodeEditors(),\n    // if the URI of that codeEditor is in the map, then add the decorations to the decorations array\n    // then set the decorations for the editor\n    const currentEditors = this.codeEditorService.listCodeEditors();\n    for (const editor of currentEditors) {\n      const editorHighlighterContrib = WordHighlighterContribution.get(editor);\n      if (!editorHighlighterContrib) {\n        continue;\n      }\n      const newDecorations = [];\n      const uri = editor.getModel()?.uri;\n      if (uri && this.workerRequestValue.has(uri)) {\n        const oldDecorationIDs = WordHighlighter_1.storedDecorationIDs.get(uri);\n        const newDocumentHighlights = this.workerRequestValue.get(uri);\n        if (newDocumentHighlights) {\n          for (const highlight of newDocumentHighlights) {\n            if (!highlight.range) {\n              continue;\n            }\n            newDecorations.push({\n              range: highlight.range,\n              options: getHighlightDecorationOptions(highlight.kind)\n            });\n          }\n        }\n        let newDecorationIDs = [];\n        editor.changeDecorations(changeAccessor => {\n          newDecorationIDs = changeAccessor.deltaDecorations(oldDecorationIDs ?? [], newDecorations);\n        });\n        WordHighlighter_1.storedDecorationIDs = WordHighlighter_1.storedDecorationIDs.set(uri, newDecorationIDs);\n        if (newDecorations.length > 0) {\n          editorHighlighterContrib.wordHighlighter?.decorations.set(newDecorations);\n          editorHighlighterContrib.wordHighlighter?._hasWordHighlights.set(true);\n        }\n      }\n    }\n  }\n  dispose() {\n    this._stopSingular();\n    this.toUnhook.dispose();\n  }\n};\nWordHighlighter = WordHighlighter_1 = __decorate([__param(4, ICodeEditorService)], WordHighlighter);\nlet WordHighlighterContribution = class WordHighlighterContribution extends Disposable {\n  static {\n    WordHighlighterContribution_1 = this;\n  }\n  static {\n    this.ID = 'editor.contrib.wordHighlighter';\n  }\n  static get(editor) {\n    return editor.getContribution(WordHighlighterContribution_1.ID);\n  }\n  constructor(editor, contextKeyService, languageFeaturesService, codeEditorService) {\n    super();\n    this._wordHighlighter = null;\n    const createWordHighlighterIfPossible = () => {\n      if (editor.hasModel() && !editor.getModel().isTooLargeForTokenization()) {\n        this._wordHighlighter = new WordHighlighter(editor, languageFeaturesService.documentHighlightProvider, languageFeaturesService.multiDocumentHighlightProvider, contextKeyService, codeEditorService);\n      }\n    };\n    this._register(editor.onDidChangeModel(e => {\n      if (this._wordHighlighter) {\n        this._wordHighlighter.dispose();\n        this._wordHighlighter = null;\n      }\n      createWordHighlighterIfPossible();\n    }));\n    createWordHighlighterIfPossible();\n  }\n  get wordHighlighter() {\n    return this._wordHighlighter;\n  }\n  saveViewState() {\n    if (this._wordHighlighter && this._wordHighlighter.hasDecorations()) {\n      return true;\n    }\n    return false;\n  }\n  moveNext() {\n    this._wordHighlighter?.moveNext();\n  }\n  moveBack() {\n    this._wordHighlighter?.moveBack();\n  }\n  restoreViewState(state) {\n    if (this._wordHighlighter && state) {\n      this._wordHighlighter.restore();\n    }\n  }\n  dispose() {\n    if (this._wordHighlighter) {\n      this._wordHighlighter.dispose();\n      this._wordHighlighter = null;\n    }\n    super.dispose();\n  }\n};\nWordHighlighterContribution = WordHighlighterContribution_1 = __decorate([__param(1, IContextKeyService), __param(2, ILanguageFeaturesService), __param(3, ICodeEditorService)], WordHighlighterContribution);\nexport { WordHighlighterContribution };\nclass WordHighlightNavigationAction extends EditorAction {\n  constructor(next, opts) {\n    super(opts);\n    this._isNext = next;\n  }\n  run(accessor, editor) {\n    const controller = WordHighlighterContribution.get(editor);\n    if (!controller) {\n      return;\n    }\n    if (this._isNext) {\n      controller.moveNext();\n    } else {\n      controller.moveBack();\n    }\n  }\n}\nclass NextWordHighlightAction extends WordHighlightNavigationAction {\n  constructor() {\n    super(true, {\n      id: 'editor.action.wordHighlight.next',\n      label: nls.localize('wordHighlight.next.label', \"Go to Next Symbol Highlight\"),\n      alias: 'Go to Next Symbol Highlight',\n      precondition: ctxHasWordHighlights,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: 65 /* KeyCode.F7 */,\n        weight: 100 /* KeybindingWeight.EditorContrib */\n      }\n    });\n  }\n}\nclass PrevWordHighlightAction extends WordHighlightNavigationAction {\n  constructor() {\n    super(false, {\n      id: 'editor.action.wordHighlight.prev',\n      label: nls.localize('wordHighlight.previous.label', \"Go to Previous Symbol Highlight\"),\n      alias: 'Go to Previous Symbol Highlight',\n      precondition: ctxHasWordHighlights,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: 1024 /* KeyMod.Shift */ | 65 /* KeyCode.F7 */,\n        weight: 100 /* KeybindingWeight.EditorContrib */\n      }\n    });\n  }\n}\nclass TriggerWordHighlightAction extends EditorAction {\n  constructor() {\n    super({\n      id: 'editor.action.wordHighlight.trigger',\n      label: nls.localize('wordHighlight.trigger.label', \"Trigger Symbol Highlight\"),\n      alias: 'Trigger Symbol Highlight',\n      precondition: undefined,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: 0,\n        weight: 100 /* KeybindingWeight.EditorContrib */\n      }\n    });\n  }\n  run(accessor, editor, args) {\n    const controller = WordHighlighterContribution.get(editor);\n    if (!controller) {\n      return;\n    }\n    controller.restoreViewState(true);\n  }\n}\nregisterEditorContribution(WordHighlighterContribution.ID, WordHighlighterContribution, 0 /* EditorContributionInstantiation.Eager */); // eager because it uses `saveViewState`/`restoreViewState`\nregisterEditorAction(NextWordHighlightAction);\nregisterEditorAction(PrevWordHighlightAction);\nregisterEditorAction(TriggerWordHighlightAction);\nregisterEditorFeature(TextualMultiDocumentHighlightFeature);","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","WordHighlighter_1","WordHighlighterContribution_1","nls","alert","createCancelablePromise","Delayer","first","CancellationToken","onUnexpectedError","onUnexpectedExternalError","Disposable","DisposableStore","isDiffEditor","EditorAction","registerEditorAction","registerEditorContribution","registerModelAndPositionCommand","ICodeEditorService","Range","EditorContextKeys","shouldSynchronizeModel","ILanguageFeaturesService","getHighlightDecorationOptions","IContextKeyService","RawContextKey","matchesScheme","Schemas","ResourceMap","score","isEqual","TextualMultiDocumentHighlightFeature","registerEditorFeature","ctxHasWordHighlights","getOccurrencesAtPosition","registry","model","position","token","orderedByScore","ordered","map","provider","Promise","resolve","provideDocumentHighlights","then","undefined","result","set","uri","getOccurrencesAcrossMultipleModels","wordSeparators","otherModels","filteredModels","filter","otherModel","selector","getLanguageId","provideMultiDocumentHighlights","OccurenceAtPositionRequest","constructor","_model","_selection","_wordSeparators","_wordRange","_getCurrentWordRange","_result","_compute","selection","word","getWordAtPosition","getPosition","startLineNumber","startColumn","endColumn","isValid","decorations","lineNumber","currentWordRange","requestIsValid","Boolean","equalsRange","len","range","getRange","cancel","SemanticOccurenceAtPositionRequest","providers","_providers","value","MultiModelOccurenceRequest","_otherModels","computeOccurencesAtPosition","computeOccurencesMultiModel","accessor","languageFeaturesService","get","documentHighlightProvider","None","WordHighlighter","storedDecorationIDs","query","editor","multiProviders","contextKeyService","codeEditorService","toUnhook","workerRequestTokenId","workerRequestCompleted","workerRequestValue","lastCursorPositionChangeTime","renderDecorationsTimer","runDelayer","add","multiDocumentProviders","_hasWordHighlights","bindTo","_ignorePositionChangeEvent","occurrencesHighlight","getOption","getModel","onDidChangeCursorPosition","e","trigger","_onPositionChanged","onDidFocusEditorText","workerRequest","_run","onDidChangeModelContent","_stopAll","onDidChangeModel","newModelUrl","oldModelUrl","_stopSingular","onDidChangeConfiguration","newValue","modelInfo","console","warn","createDecorationsCollection","hasDecorations","restore","_getSortedHighlights","getRanges","sort","compareRangesUsingStarts","moveNext","highlights","index","findIndex","containsPosition","newIndex","dest","setPosition","getStartPosition","revealRangeInCenterIfOutsideViewport","_getWord","lineContent","getLineContent","moveBack","_removeSingleDecorations","hasModel","currentDecorationIDs","removeDecorations","delete","clear","_removeAllDecorations","preservedModel","currentEditors","listCodeEditors","deleteURI","push","editorHighlighterContrib","WordHighlighterContribution","wordHighlighter","hasTextFocus","scheme","vscodeNotebookCell","clearTimeout","reason","editorSelection","getSelection","isDisposed","column","getOtherModelsToHighlight","isNotebookEditor","currentModels","tempModel","diffModel","modified","isValidModel","multiFileConfigChange","workerRequestIsValid","endLineNumber","Date","getTime","_beginRenderDecorations","currentModelDecorationRanges","storedRange","myRequestId","otherModelsToHighlight","computeWithModel","data","currentTime","minimumRenderTime","renderDecorations","setTimeout","newDecorations","has","oldDecorationIDs","newDocumentHighlights","highlight","options","kind","newDecorationIDs","changeDecorations","changeAccessor","deltaDecorations","dispose","ID","getContribution","_wordHighlighter","createWordHighlighterIfPossible","isTooLargeForTokenization","multiDocumentHighlightProvider","_register","saveViewState","restoreViewState","state","WordHighlightNavigationAction","next","opts","_isNext","run","controller","NextWordHighlightAction","id","label","localize","alias","precondition","kbOpts","kbExpr","editorTextFocus","primary","weight","PrevWordHighlightAction","TriggerWordHighlightAction","args"],"sources":["D:/ospanel/domains/проекты open server/old/react/react-intro-main/node_modules/monaco-editor/esm/vs/editor/contrib/wordHighlighter/browser/wordHighlighter.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar WordHighlighter_1, WordHighlighterContribution_1;\nimport * as nls from '../../../../nls.js';\nimport { alert } from '../../../../base/browser/ui/aria/aria.js';\nimport { createCancelablePromise, Delayer, first } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { onUnexpectedError, onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { isDiffEditor } from '../../../browser/editorBrowser.js';\nimport { EditorAction, registerEditorAction, registerEditorContribution, registerModelAndPositionCommand } from '../../../browser/editorExtensions.js';\nimport { ICodeEditorService } from '../../../browser/services/codeEditorService.js';\nimport { Range } from '../../../common/core/range.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { shouldSynchronizeModel } from '../../../common/model.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { getHighlightDecorationOptions } from './highlightDecorations.js';\nimport { IContextKeyService, RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { matchesScheme, Schemas } from '../../../../base/common/network.js';\nimport { ResourceMap } from '../../../../base/common/map.js';\nimport { score } from '../../../common/languageSelector.js';\nimport { isEqual } from '../../../../base/common/resources.js';\nimport { TextualMultiDocumentHighlightFeature } from './textualHighlightProvider.js';\nimport { registerEditorFeature } from '../../../common/editorFeatures.js';\nconst ctxHasWordHighlights = new RawContextKey('hasWordHighlights', false);\nexport function getOccurrencesAtPosition(registry, model, position, token) {\n    const orderedByScore = registry.ordered(model);\n    // in order of score ask the occurrences provider\n    // until someone response with a good result\n    // (good = non undefined and non null value)\n    // (result of size == 0 is valid, no highlights is a valid/expected result -- not a signal to fall back to other providers)\n    return first(orderedByScore.map(provider => () => {\n        return Promise.resolve(provider.provideDocumentHighlights(model, position, token))\n            .then(undefined, onUnexpectedExternalError);\n    }), (result) => result !== undefined && result !== null).then(result => {\n        if (result) {\n            const map = new ResourceMap();\n            map.set(model.uri, result);\n            return map;\n        }\n        return new ResourceMap();\n    });\n}\nexport function getOccurrencesAcrossMultipleModels(registry, model, position, wordSeparators, token, otherModels) {\n    const orderedByScore = registry.ordered(model);\n    // in order of score ask the occurrences provider\n    // until someone response with a good result\n    // (good = non undefined and non null ResourceMap)\n    // (result of size == 0 is valid, no highlights is a valid/expected result -- not a signal to fall back to other providers)\n    return first(orderedByScore.map(provider => () => {\n        const filteredModels = otherModels.filter(otherModel => {\n            return shouldSynchronizeModel(otherModel);\n        }).filter(otherModel => {\n            return score(provider.selector, otherModel.uri, otherModel.getLanguageId(), true, undefined, undefined) > 0;\n        });\n        return Promise.resolve(provider.provideMultiDocumentHighlights(model, position, filteredModels, token))\n            .then(undefined, onUnexpectedExternalError);\n    }), (result) => result !== undefined && result !== null);\n}\nclass OccurenceAtPositionRequest {\n    constructor(_model, _selection, _wordSeparators) {\n        this._model = _model;\n        this._selection = _selection;\n        this._wordSeparators = _wordSeparators;\n        this._wordRange = this._getCurrentWordRange(_model, _selection);\n        this._result = null;\n    }\n    get result() {\n        if (!this._result) {\n            this._result = createCancelablePromise(token => this._compute(this._model, this._selection, this._wordSeparators, token));\n        }\n        return this._result;\n    }\n    _getCurrentWordRange(model, selection) {\n        const word = model.getWordAtPosition(selection.getPosition());\n        if (word) {\n            return new Range(selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);\n        }\n        return null;\n    }\n    isValid(model, selection, decorations) {\n        const lineNumber = selection.startLineNumber;\n        const startColumn = selection.startColumn;\n        const endColumn = selection.endColumn;\n        const currentWordRange = this._getCurrentWordRange(model, selection);\n        let requestIsValid = Boolean(this._wordRange && this._wordRange.equalsRange(currentWordRange));\n        // Even if we are on a different word, if that word is in the decorations ranges, the request is still valid\n        // (Same symbol)\n        for (let i = 0, len = decorations.length; !requestIsValid && i < len; i++) {\n            const range = decorations.getRange(i);\n            if (range && range.startLineNumber === lineNumber) {\n                if (range.startColumn <= startColumn && range.endColumn >= endColumn) {\n                    requestIsValid = true;\n                }\n            }\n        }\n        return requestIsValid;\n    }\n    cancel() {\n        this.result.cancel();\n    }\n}\nclass SemanticOccurenceAtPositionRequest extends OccurenceAtPositionRequest {\n    constructor(model, selection, wordSeparators, providers) {\n        super(model, selection, wordSeparators);\n        this._providers = providers;\n    }\n    _compute(model, selection, wordSeparators, token) {\n        return getOccurrencesAtPosition(this._providers, model, selection.getPosition(), token).then(value => {\n            if (!value) {\n                return new ResourceMap();\n            }\n            return value;\n        });\n    }\n}\nclass MultiModelOccurenceRequest extends OccurenceAtPositionRequest {\n    constructor(model, selection, wordSeparators, providers, otherModels) {\n        super(model, selection, wordSeparators);\n        this._providers = providers;\n        this._otherModels = otherModels;\n    }\n    _compute(model, selection, wordSeparators, token) {\n        return getOccurrencesAcrossMultipleModels(this._providers, model, selection.getPosition(), wordSeparators, token, this._otherModels).then(value => {\n            if (!value) {\n                return new ResourceMap();\n            }\n            return value;\n        });\n    }\n}\nfunction computeOccurencesAtPosition(registry, model, selection, word, wordSeparators) {\n    return new SemanticOccurenceAtPositionRequest(model, selection, wordSeparators, registry);\n}\nfunction computeOccurencesMultiModel(registry, model, selection, word, wordSeparators, otherModels) {\n    return new MultiModelOccurenceRequest(model, selection, wordSeparators, registry, otherModels);\n}\nregisterModelAndPositionCommand('_executeDocumentHighlights', async (accessor, model, position) => {\n    const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n    const map = await getOccurrencesAtPosition(languageFeaturesService.documentHighlightProvider, model, position, CancellationToken.None);\n    return map?.get(model.uri);\n});\nlet WordHighlighter = class WordHighlighter {\n    static { WordHighlighter_1 = this; }\n    static { this.storedDecorationIDs = new ResourceMap(); }\n    static { this.query = null; }\n    constructor(editor, providers, multiProviders, contextKeyService, codeEditorService) {\n        this.toUnhook = new DisposableStore();\n        this.workerRequestTokenId = 0;\n        this.workerRequestCompleted = false;\n        this.workerRequestValue = new ResourceMap();\n        this.lastCursorPositionChangeTime = 0;\n        this.renderDecorationsTimer = -1;\n        this.runDelayer = this.toUnhook.add(new Delayer(50));\n        this.editor = editor;\n        this.providers = providers;\n        this.multiDocumentProviders = multiProviders;\n        this.codeEditorService = codeEditorService;\n        this._hasWordHighlights = ctxHasWordHighlights.bindTo(contextKeyService);\n        this._ignorePositionChangeEvent = false;\n        this.occurrencesHighlight = this.editor.getOption(81 /* EditorOption.occurrencesHighlight */);\n        this.model = this.editor.getModel();\n        this.toUnhook.add(editor.onDidChangeCursorPosition((e) => {\n            if (this._ignorePositionChangeEvent) {\n                // We are changing the position => ignore this event\n                return;\n            }\n            if (this.occurrencesHighlight === 'off') {\n                // Early exit if nothing needs to be done!\n                // Leave some form of early exit check here if you wish to continue being a cursor position change listener ;)\n                return;\n            }\n            this.runDelayer.trigger(() => { this._onPositionChanged(e); });\n        }));\n        this.toUnhook.add(editor.onDidFocusEditorText((e) => {\n            if (this.occurrencesHighlight === 'off') {\n                // Early exit if nothing needs to be done\n                return;\n            }\n            if (!this.workerRequest) {\n                this.runDelayer.trigger(() => { this._run(); });\n            }\n        }));\n        this.toUnhook.add(editor.onDidChangeModelContent((e) => {\n            if (!matchesScheme(this.model.uri, 'output')) {\n                this._stopAll();\n            }\n        }));\n        this.toUnhook.add(editor.onDidChangeModel((e) => {\n            if (!e.newModelUrl && e.oldModelUrl) {\n                this._stopSingular();\n            }\n            else {\n                if (WordHighlighter_1.query) {\n                    this._run();\n                }\n            }\n        }));\n        this.toUnhook.add(editor.onDidChangeConfiguration((e) => {\n            const newValue = this.editor.getOption(81 /* EditorOption.occurrencesHighlight */);\n            if (this.occurrencesHighlight !== newValue) {\n                this.occurrencesHighlight = newValue;\n                switch (newValue) {\n                    case 'off':\n                        this._stopAll();\n                        break;\n                    case 'singleFile':\n                        this._stopAll(WordHighlighter_1.query?.modelInfo?.model);\n                        break;\n                    case 'multiFile':\n                        if (WordHighlighter_1.query) {\n                            this._run(true);\n                        }\n                        break;\n                    default:\n                        console.warn('Unknown occurrencesHighlight setting value:', newValue);\n                        break;\n                }\n            }\n        }));\n        this.decorations = this.editor.createDecorationsCollection();\n        this.workerRequestTokenId = 0;\n        this.workerRequest = null;\n        this.workerRequestCompleted = false;\n        this.lastCursorPositionChangeTime = 0;\n        this.renderDecorationsTimer = -1;\n        // if there is a query already, highlight off that query\n        if (WordHighlighter_1.query) {\n            this._run();\n        }\n    }\n    hasDecorations() {\n        return (this.decorations.length > 0);\n    }\n    restore() {\n        if (this.occurrencesHighlight === 'off') {\n            return;\n        }\n        this.runDelayer.cancel();\n        this._run();\n    }\n    _getSortedHighlights() {\n        return (this.decorations.getRanges()\n            .sort(Range.compareRangesUsingStarts));\n    }\n    moveNext() {\n        const highlights = this._getSortedHighlights();\n        const index = highlights.findIndex((range) => range.containsPosition(this.editor.getPosition()));\n        const newIndex = ((index + 1) % highlights.length);\n        const dest = highlights[newIndex];\n        try {\n            this._ignorePositionChangeEvent = true;\n            this.editor.setPosition(dest.getStartPosition());\n            this.editor.revealRangeInCenterIfOutsideViewport(dest);\n            const word = this._getWord();\n            if (word) {\n                const lineContent = this.editor.getModel().getLineContent(dest.startLineNumber);\n                alert(`${lineContent}, ${newIndex + 1} of ${highlights.length} for '${word.word}'`);\n            }\n        }\n        finally {\n            this._ignorePositionChangeEvent = false;\n        }\n    }\n    moveBack() {\n        const highlights = this._getSortedHighlights();\n        const index = highlights.findIndex((range) => range.containsPosition(this.editor.getPosition()));\n        const newIndex = ((index - 1 + highlights.length) % highlights.length);\n        const dest = highlights[newIndex];\n        try {\n            this._ignorePositionChangeEvent = true;\n            this.editor.setPosition(dest.getStartPosition());\n            this.editor.revealRangeInCenterIfOutsideViewport(dest);\n            const word = this._getWord();\n            if (word) {\n                const lineContent = this.editor.getModel().getLineContent(dest.startLineNumber);\n                alert(`${lineContent}, ${newIndex + 1} of ${highlights.length} for '${word.word}'`);\n            }\n        }\n        finally {\n            this._ignorePositionChangeEvent = false;\n        }\n    }\n    _removeSingleDecorations() {\n        // return if no model\n        if (!this.editor.hasModel()) {\n            return;\n        }\n        const currentDecorationIDs = WordHighlighter_1.storedDecorationIDs.get(this.editor.getModel().uri);\n        if (!currentDecorationIDs) {\n            return;\n        }\n        this.editor.removeDecorations(currentDecorationIDs);\n        WordHighlighter_1.storedDecorationIDs.delete(this.editor.getModel().uri);\n        if (this.decorations.length > 0) {\n            this.decorations.clear();\n            this._hasWordHighlights.set(false);\n        }\n    }\n    _removeAllDecorations(preservedModel) {\n        const currentEditors = this.codeEditorService.listCodeEditors();\n        const deleteURI = [];\n        // iterate over editors and store models in currentModels\n        for (const editor of currentEditors) {\n            if (!editor.hasModel() || isEqual(editor.getModel().uri, preservedModel?.uri)) {\n                continue;\n            }\n            const currentDecorationIDs = WordHighlighter_1.storedDecorationIDs.get(editor.getModel().uri);\n            if (!currentDecorationIDs) {\n                continue;\n            }\n            editor.removeDecorations(currentDecorationIDs);\n            deleteURI.push(editor.getModel().uri);\n            const editorHighlighterContrib = WordHighlighterContribution.get(editor);\n            if (!editorHighlighterContrib?.wordHighlighter) {\n                continue;\n            }\n            if (editorHighlighterContrib.wordHighlighter.decorations.length > 0) {\n                editorHighlighterContrib.wordHighlighter.decorations.clear();\n                editorHighlighterContrib.wordHighlighter.workerRequest = null;\n                editorHighlighterContrib.wordHighlighter._hasWordHighlights.set(false);\n            }\n        }\n        for (const uri of deleteURI) {\n            WordHighlighter_1.storedDecorationIDs.delete(uri);\n        }\n    }\n    _stopSingular() {\n        // Remove any existing decorations + a possible query, and re - run to update decorations\n        this._removeSingleDecorations();\n        if (this.editor.hasTextFocus()) {\n            if (this.editor.getModel()?.uri.scheme !== Schemas.vscodeNotebookCell && WordHighlighter_1.query?.modelInfo?.model.uri.scheme !== Schemas.vscodeNotebookCell) { // clear query if focused non-nb editor\n                WordHighlighter_1.query = null;\n                this._run(); // TODO: @Yoyokrazy -- investigate why we need a full rerun here. likely addressed a case/patch in the first iteration of this feature\n            }\n            else { // remove modelInfo to account for nb cell being disposed\n                if (WordHighlighter_1.query?.modelInfo) {\n                    WordHighlighter_1.query.modelInfo = null;\n                }\n            }\n        }\n        // Cancel any renderDecorationsTimer\n        if (this.renderDecorationsTimer !== -1) {\n            clearTimeout(this.renderDecorationsTimer);\n            this.renderDecorationsTimer = -1;\n        }\n        // Cancel any worker request\n        if (this.workerRequest !== null) {\n            this.workerRequest.cancel();\n            this.workerRequest = null;\n        }\n        // Invalidate any worker request callback\n        if (!this.workerRequestCompleted) {\n            this.workerRequestTokenId++;\n            this.workerRequestCompleted = true;\n        }\n    }\n    _stopAll(preservedModel) {\n        // Remove any existing decorations\n        // TODO: @Yoyokrazy -- this triggers as notebooks scroll, causing highlights to disappear momentarily.\n        // maybe a nb type check?\n        this._removeAllDecorations(preservedModel);\n        // Cancel any renderDecorationsTimer\n        if (this.renderDecorationsTimer !== -1) {\n            clearTimeout(this.renderDecorationsTimer);\n            this.renderDecorationsTimer = -1;\n        }\n        // Cancel any worker request\n        if (this.workerRequest !== null) {\n            this.workerRequest.cancel();\n            this.workerRequest = null;\n        }\n        // Invalidate any worker request callback\n        if (!this.workerRequestCompleted) {\n            this.workerRequestTokenId++;\n            this.workerRequestCompleted = true;\n        }\n    }\n    _onPositionChanged(e) {\n        // disabled\n        if (this.occurrencesHighlight === 'off') {\n            this._stopAll();\n            return;\n        }\n        // ignore typing & other\n        // need to check if the model is a notebook cell, should not stop if nb\n        if (e.reason !== 3 /* CursorChangeReason.Explicit */ && this.editor.getModel()?.uri.scheme !== Schemas.vscodeNotebookCell) {\n            this._stopAll();\n            return;\n        }\n        this._run();\n    }\n    _getWord() {\n        const editorSelection = this.editor.getSelection();\n        const lineNumber = editorSelection.startLineNumber;\n        const startColumn = editorSelection.startColumn;\n        if (this.model.isDisposed()) {\n            return null;\n        }\n        return this.model.getWordAtPosition({\n            lineNumber: lineNumber,\n            column: startColumn\n        });\n    }\n    getOtherModelsToHighlight(model) {\n        if (!model) {\n            return [];\n        }\n        // notebook case\n        const isNotebookEditor = model.uri.scheme === Schemas.vscodeNotebookCell;\n        if (isNotebookEditor) {\n            const currentModels = [];\n            const currentEditors = this.codeEditorService.listCodeEditors();\n            for (const editor of currentEditors) {\n                const tempModel = editor.getModel();\n                if (tempModel && tempModel !== model && tempModel.uri.scheme === Schemas.vscodeNotebookCell) {\n                    currentModels.push(tempModel);\n                }\n            }\n            return currentModels;\n        }\n        // inline case\n        // ? current works when highlighting outside of an inline diff, highlighting in.\n        // ? broken when highlighting within a diff editor. highlighting the main editor does not work\n        // ? editor group service could be useful here\n        const currentModels = [];\n        const currentEditors = this.codeEditorService.listCodeEditors();\n        for (const editor of currentEditors) {\n            if (!isDiffEditor(editor)) {\n                continue;\n            }\n            const diffModel = editor.getModel();\n            if (!diffModel) {\n                continue;\n            }\n            if (model === diffModel.modified) { // embedded inline chat diff would pass this, allowing highlights\n                //? currentModels.push(diffModel.original);\n                currentModels.push(diffModel.modified);\n            }\n        }\n        if (currentModels.length) { // no matching editors have been found\n            return currentModels;\n        }\n        // multi-doc OFF\n        if (this.occurrencesHighlight === 'singleFile') {\n            return [];\n        }\n        // multi-doc ON\n        for (const editor of currentEditors) {\n            const tempModel = editor.getModel();\n            const isValidModel = tempModel && tempModel !== model;\n            if (isValidModel) {\n                currentModels.push(tempModel);\n            }\n        }\n        return currentModels;\n    }\n    _run(multiFileConfigChange) {\n        let workerRequestIsValid;\n        const hasTextFocus = this.editor.hasTextFocus();\n        if (!hasTextFocus) { // new nb cell scrolled in, didChangeModel fires\n            if (!WordHighlighter_1.query) { // no previous query, nothing to highlight off of\n                this._stopAll();\n                return;\n            }\n        }\n        else { // has text focus\n            const editorSelection = this.editor.getSelection();\n            // ignore multiline selection\n            if (!editorSelection || editorSelection.startLineNumber !== editorSelection.endLineNumber) {\n                WordHighlighter_1.query = null;\n                this._stopAll();\n                return;\n            }\n            const startColumn = editorSelection.startColumn;\n            const endColumn = editorSelection.endColumn;\n            const word = this._getWord();\n            // The selection must be inside a word or surround one word at most\n            if (!word || word.startColumn > startColumn || word.endColumn < endColumn) {\n                // no previous query, nothing to highlight\n                WordHighlighter_1.query = null;\n                this._stopAll();\n                return;\n            }\n            // All the effort below is trying to achieve this:\n            // - when cursor is moved to a word, trigger immediately a findOccurrences request\n            // - 250ms later after the last cursor move event, render the occurrences\n            // - no flickering!\n            workerRequestIsValid = (this.workerRequest && this.workerRequest.isValid(this.model, editorSelection, this.decorations));\n            WordHighlighter_1.query = {\n                modelInfo: {\n                    model: this.model,\n                    selection: editorSelection,\n                },\n                word: word\n            };\n        }\n        // There are 4 cases:\n        // a) old workerRequest is valid & completed, renderDecorationsTimer fired\n        // b) old workerRequest is valid & completed, renderDecorationsTimer not fired\n        // c) old workerRequest is valid, but not completed\n        // d) old workerRequest is not valid\n        // For a) no action is needed\n        // For c), member 'lastCursorPositionChangeTime' will be used when installing the timer so no action is needed\n        this.lastCursorPositionChangeTime = (new Date()).getTime();\n        if (workerRequestIsValid) {\n            if (this.workerRequestCompleted && this.renderDecorationsTimer !== -1) {\n                // case b)\n                // Delay the firing of renderDecorationsTimer by an extra 250 ms\n                clearTimeout(this.renderDecorationsTimer);\n                this.renderDecorationsTimer = -1;\n                this._beginRenderDecorations();\n            }\n        }\n        else if (isEqual(this.editor.getModel().uri, WordHighlighter_1.query.modelInfo?.model.uri)) { // only trigger new worker requests from the primary model that initiated the query\n            // case d)\n            // check if the new queried word is contained in the range of a stored decoration for this model\n            if (!multiFileConfigChange) {\n                const currentModelDecorationRanges = this.decorations.getRanges();\n                for (const storedRange of currentModelDecorationRanges) {\n                    if (storedRange.containsPosition(this.editor.getPosition())) {\n                        return;\n                    }\n                }\n            }\n            // stop all previous actions if new word is highlighted\n            // if we trigger the run off a setting change -> multifile highlighting, we do not want to remove decorations from this model\n            this._stopAll(multiFileConfigChange ? this.model : undefined);\n            const myRequestId = ++this.workerRequestTokenId;\n            this.workerRequestCompleted = false;\n            const otherModelsToHighlight = this.getOtherModelsToHighlight(this.editor.getModel());\n            // when reaching here, there are two possible states.\n            // \t\t1) we have text focus, and a valid query was updated.\n            // \t\t2) we do not have text focus, and a valid query is cached.\n            // the query will ALWAYS have the correct data for the current highlight request, so it can always be passed to the workerRequest safely\n            if (!WordHighlighter_1.query || !WordHighlighter_1.query.modelInfo || WordHighlighter_1.query.modelInfo.model.isDisposed()) {\n                return;\n            }\n            this.workerRequest = this.computeWithModel(WordHighlighter_1.query.modelInfo.model, WordHighlighter_1.query.modelInfo.selection, WordHighlighter_1.query.word, otherModelsToHighlight);\n            this.workerRequest?.result.then(data => {\n                if (myRequestId === this.workerRequestTokenId) {\n                    this.workerRequestCompleted = true;\n                    this.workerRequestValue = data || [];\n                    this._beginRenderDecorations();\n                }\n            }, onUnexpectedError);\n        }\n    }\n    computeWithModel(model, selection, word, otherModels) {\n        if (!otherModels.length) {\n            return computeOccurencesAtPosition(this.providers, model, selection, word, this.editor.getOption(132 /* EditorOption.wordSeparators */));\n        }\n        else {\n            return computeOccurencesMultiModel(this.multiDocumentProviders, model, selection, word, this.editor.getOption(132 /* EditorOption.wordSeparators */), otherModels);\n        }\n    }\n    _beginRenderDecorations() {\n        const currentTime = (new Date()).getTime();\n        const minimumRenderTime = this.lastCursorPositionChangeTime + 250;\n        if (currentTime >= minimumRenderTime) {\n            // Synchronous\n            this.renderDecorationsTimer = -1;\n            this.renderDecorations();\n        }\n        else {\n            // Asynchronous\n            this.renderDecorationsTimer = setTimeout(() => {\n                this.renderDecorations();\n            }, (minimumRenderTime - currentTime));\n        }\n    }\n    renderDecorations() {\n        this.renderDecorationsTimer = -1;\n        // create new loop, iterate over current editors using this.codeEditorService.listCodeEditors(),\n        // if the URI of that codeEditor is in the map, then add the decorations to the decorations array\n        // then set the decorations for the editor\n        const currentEditors = this.codeEditorService.listCodeEditors();\n        for (const editor of currentEditors) {\n            const editorHighlighterContrib = WordHighlighterContribution.get(editor);\n            if (!editorHighlighterContrib) {\n                continue;\n            }\n            const newDecorations = [];\n            const uri = editor.getModel()?.uri;\n            if (uri && this.workerRequestValue.has(uri)) {\n                const oldDecorationIDs = WordHighlighter_1.storedDecorationIDs.get(uri);\n                const newDocumentHighlights = this.workerRequestValue.get(uri);\n                if (newDocumentHighlights) {\n                    for (const highlight of newDocumentHighlights) {\n                        if (!highlight.range) {\n                            continue;\n                        }\n                        newDecorations.push({\n                            range: highlight.range,\n                            options: getHighlightDecorationOptions(highlight.kind)\n                        });\n                    }\n                }\n                let newDecorationIDs = [];\n                editor.changeDecorations((changeAccessor) => {\n                    newDecorationIDs = changeAccessor.deltaDecorations(oldDecorationIDs ?? [], newDecorations);\n                });\n                WordHighlighter_1.storedDecorationIDs = WordHighlighter_1.storedDecorationIDs.set(uri, newDecorationIDs);\n                if (newDecorations.length > 0) {\n                    editorHighlighterContrib.wordHighlighter?.decorations.set(newDecorations);\n                    editorHighlighterContrib.wordHighlighter?._hasWordHighlights.set(true);\n                }\n            }\n        }\n    }\n    dispose() {\n        this._stopSingular();\n        this.toUnhook.dispose();\n    }\n};\nWordHighlighter = WordHighlighter_1 = __decorate([\n    __param(4, ICodeEditorService)\n], WordHighlighter);\nlet WordHighlighterContribution = class WordHighlighterContribution extends Disposable {\n    static { WordHighlighterContribution_1 = this; }\n    static { this.ID = 'editor.contrib.wordHighlighter'; }\n    static get(editor) {\n        return editor.getContribution(WordHighlighterContribution_1.ID);\n    }\n    constructor(editor, contextKeyService, languageFeaturesService, codeEditorService) {\n        super();\n        this._wordHighlighter = null;\n        const createWordHighlighterIfPossible = () => {\n            if (editor.hasModel() && !editor.getModel().isTooLargeForTokenization()) {\n                this._wordHighlighter = new WordHighlighter(editor, languageFeaturesService.documentHighlightProvider, languageFeaturesService.multiDocumentHighlightProvider, contextKeyService, codeEditorService);\n            }\n        };\n        this._register(editor.onDidChangeModel((e) => {\n            if (this._wordHighlighter) {\n                this._wordHighlighter.dispose();\n                this._wordHighlighter = null;\n            }\n            createWordHighlighterIfPossible();\n        }));\n        createWordHighlighterIfPossible();\n    }\n    get wordHighlighter() {\n        return this._wordHighlighter;\n    }\n    saveViewState() {\n        if (this._wordHighlighter && this._wordHighlighter.hasDecorations()) {\n            return true;\n        }\n        return false;\n    }\n    moveNext() {\n        this._wordHighlighter?.moveNext();\n    }\n    moveBack() {\n        this._wordHighlighter?.moveBack();\n    }\n    restoreViewState(state) {\n        if (this._wordHighlighter && state) {\n            this._wordHighlighter.restore();\n        }\n    }\n    dispose() {\n        if (this._wordHighlighter) {\n            this._wordHighlighter.dispose();\n            this._wordHighlighter = null;\n        }\n        super.dispose();\n    }\n};\nWordHighlighterContribution = WordHighlighterContribution_1 = __decorate([\n    __param(1, IContextKeyService),\n    __param(2, ILanguageFeaturesService),\n    __param(3, ICodeEditorService)\n], WordHighlighterContribution);\nexport { WordHighlighterContribution };\nclass WordHighlightNavigationAction extends EditorAction {\n    constructor(next, opts) {\n        super(opts);\n        this._isNext = next;\n    }\n    run(accessor, editor) {\n        const controller = WordHighlighterContribution.get(editor);\n        if (!controller) {\n            return;\n        }\n        if (this._isNext) {\n            controller.moveNext();\n        }\n        else {\n            controller.moveBack();\n        }\n    }\n}\nclass NextWordHighlightAction extends WordHighlightNavigationAction {\n    constructor() {\n        super(true, {\n            id: 'editor.action.wordHighlight.next',\n            label: nls.localize('wordHighlight.next.label', \"Go to Next Symbol Highlight\"),\n            alias: 'Go to Next Symbol Highlight',\n            precondition: ctxHasWordHighlights,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 65 /* KeyCode.F7 */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n}\nclass PrevWordHighlightAction extends WordHighlightNavigationAction {\n    constructor() {\n        super(false, {\n            id: 'editor.action.wordHighlight.prev',\n            label: nls.localize('wordHighlight.previous.label', \"Go to Previous Symbol Highlight\"),\n            alias: 'Go to Previous Symbol Highlight',\n            precondition: ctxHasWordHighlights,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 1024 /* KeyMod.Shift */ | 65 /* KeyCode.F7 */,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n}\nclass TriggerWordHighlightAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.wordHighlight.trigger',\n            label: nls.localize('wordHighlight.trigger.label', \"Trigger Symbol Highlight\"),\n            alias: 'Trigger Symbol Highlight',\n            precondition: undefined,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 0,\n                weight: 100 /* KeybindingWeight.EditorContrib */\n            }\n        });\n    }\n    run(accessor, editor, args) {\n        const controller = WordHighlighterContribution.get(editor);\n        if (!controller) {\n            return;\n        }\n        controller.restoreViewState(true);\n    }\n}\nregisterEditorContribution(WordHighlighterContribution.ID, WordHighlighterContribution, 0 /* EditorContributionInstantiation.Eager */); // eager because it uses `saveViewState`/`restoreViewState`\nregisterEditorAction(NextWordHighlightAction);\nregisterEditorAction(PrevWordHighlightAction);\nregisterEditorAction(TriggerWordHighlightAction);\nregisterEditorFeature(TextualMultiDocumentHighlightFeature);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}