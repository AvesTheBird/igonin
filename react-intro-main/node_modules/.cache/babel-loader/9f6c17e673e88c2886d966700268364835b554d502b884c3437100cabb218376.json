{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn } from '../assert.js';\nimport { DisposableStore, markAsDisposed, toDisposable, trackDisposable } from '../lifecycle.js';\nimport { DebugNameData } from './debugName.js';\nimport { getLogger } from './logging.js';\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorun(fn) {\n  return new AutorunObserver(new DebugNameData(undefined, undefined, fn), fn, undefined, undefined);\n}\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorunOpts(options, fn) {\n  var _options$debugReferen;\n  return new AutorunObserver(new DebugNameData(options.owner, options.debugName, (_options$debugReferen = options.debugReferenceFn) !== null && _options$debugReferen !== void 0 ? _options$debugReferen : fn), fn, undefined, undefined);\n}\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The run function is given the last change summary.\n * The change summary is discarded after the run function was called.\n *\n * @see autorun\n */\nexport function autorunHandleChanges(options, fn) {\n  var _options$debugReferen2;\n  return new AutorunObserver(new DebugNameData(options.owner, options.debugName, (_options$debugReferen2 = options.debugReferenceFn) !== null && _options$debugReferen2 !== void 0 ? _options$debugReferen2 : fn), fn, options.createEmptyChangeSummary, options.handleChange);\n}\n/**\n * @see autorunHandleChanges (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStoreHandleChanges(options, fn) {\n  var _options$debugReferen3;\n  const store = new DisposableStore();\n  const disposable = autorunHandleChanges({\n    owner: options.owner,\n    debugName: options.debugName,\n    debugReferenceFn: (_options$debugReferen3 = options.debugReferenceFn) !== null && _options$debugReferen3 !== void 0 ? _options$debugReferen3 : fn,\n    createEmptyChangeSummary: options.createEmptyChangeSummary,\n    handleChange: options.handleChange\n  }, (reader, changeSummary) => {\n    store.clear();\n    fn(reader, changeSummary, store);\n  });\n  return toDisposable(() => {\n    disposable.dispose();\n    store.dispose();\n  });\n}\n/**\n * @see autorun (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStore(fn) {\n  const store = new DisposableStore();\n  const disposable = autorunOpts({\n    owner: undefined,\n    debugName: undefined,\n    debugReferenceFn: fn\n  }, reader => {\n    store.clear();\n    fn(reader, store);\n  });\n  return toDisposable(() => {\n    disposable.dispose();\n    store.dispose();\n  });\n}\nexport class AutorunObserver {\n  get debugName() {\n    var _this$_debugNameData$;\n    return (_this$_debugNameData$ = this._debugNameData.getDebugName(this)) !== null && _this$_debugNameData$ !== void 0 ? _this$_debugNameData$ : '(anonymous)';\n  }\n  constructor(_debugNameData, _runFn, createChangeSummary, _handleChange) {\n    var _this$createChangeSum, _getLogger;\n    this._debugNameData = _debugNameData;\n    this._runFn = _runFn;\n    this.createChangeSummary = createChangeSummary;\n    this._handleChange = _handleChange;\n    this.state = 2 /* AutorunState.stale */;\n    this.updateCount = 0;\n    this.disposed = false;\n    this.dependencies = new Set();\n    this.dependenciesToBeRemoved = new Set();\n    this.changeSummary = (_this$createChangeSum = this.createChangeSummary) === null || _this$createChangeSum === void 0 ? void 0 : _this$createChangeSum.call(this);\n    (_getLogger = getLogger()) === null || _getLogger === void 0 || _getLogger.handleAutorunCreated(this);\n    this._runIfNeeded();\n    trackDisposable(this);\n  }\n  dispose() {\n    this.disposed = true;\n    for (const o of this.dependencies) {\n      o.removeObserver(this);\n    }\n    this.dependencies.clear();\n    markAsDisposed(this);\n  }\n  _runIfNeeded() {\n    if (this.state === 3 /* AutorunState.upToDate */) {\n      return;\n    }\n    const emptySet = this.dependenciesToBeRemoved;\n    this.dependenciesToBeRemoved = this.dependencies;\n    this.dependencies = emptySet;\n    this.state = 3 /* AutorunState.upToDate */;\n    const isDisposed = this.disposed;\n    try {\n      if (!isDisposed) {\n        var _getLogger2, _this$createChangeSum2;\n        (_getLogger2 = getLogger()) === null || _getLogger2 === void 0 || _getLogger2.handleAutorunTriggered(this);\n        const changeSummary = this.changeSummary;\n        this.changeSummary = (_this$createChangeSum2 = this.createChangeSummary) === null || _this$createChangeSum2 === void 0 ? void 0 : _this$createChangeSum2.call(this);\n        this._runFn(this, changeSummary);\n      }\n    } finally {\n      if (!isDisposed) {\n        var _getLogger3;\n        (_getLogger3 = getLogger()) === null || _getLogger3 === void 0 || _getLogger3.handleAutorunFinished(this);\n      }\n      // We don't want our observed observables to think that they are (not even temporarily) not being observed.\n      // Thus, we only unsubscribe from observables that are definitely not read anymore.\n      for (const o of this.dependenciesToBeRemoved) {\n        o.removeObserver(this);\n      }\n      this.dependenciesToBeRemoved.clear();\n    }\n  }\n  toString() {\n    return \"Autorun<\".concat(this.debugName, \">\");\n  }\n  // IObserver implementation\n  beginUpdate() {\n    if (this.state === 3 /* AutorunState.upToDate */) {\n      this.state = 1 /* AutorunState.dependenciesMightHaveChanged */;\n    }\n    this.updateCount++;\n  }\n  endUpdate() {\n    if (this.updateCount === 1) {\n      do {\n        if (this.state === 1 /* AutorunState.dependenciesMightHaveChanged */) {\n          this.state = 3 /* AutorunState.upToDate */;\n          for (const d of this.dependencies) {\n            d.reportChanges();\n            if (this.state === 2 /* AutorunState.stale */) {\n              // The other dependencies will refresh on demand\n              break;\n            }\n          }\n        }\n        this._runIfNeeded();\n      } while (this.state !== 3 /* AutorunState.upToDate */);\n    }\n    this.updateCount--;\n    assertFn(() => this.updateCount >= 0);\n  }\n  handlePossibleChange(observable) {\n    if (this.state === 3 /* AutorunState.upToDate */ && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n      this.state = 1 /* AutorunState.dependenciesMightHaveChanged */;\n    }\n  }\n  handleChange(observable, change) {\n    if (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n      const shouldReact = this._handleChange ? this._handleChange({\n        changedObservable: observable,\n        change,\n        didChange: o => o === observable\n      }, this.changeSummary) : true;\n      if (shouldReact) {\n        this.state = 2 /* AutorunState.stale */;\n      }\n    }\n  }\n  // IReader implementation\n  readObservable(observable) {\n    // In case the run action disposes the autorun\n    if (this.disposed) {\n      return observable.get();\n    }\n    observable.addObserver(this);\n    const value = observable.get();\n    this.dependencies.add(observable);\n    this.dependenciesToBeRemoved.delete(observable);\n    return value;\n  }\n}\n(function (autorun) {\n  autorun.Observer = AutorunObserver;\n})(autorun || (autorun = {}));","map":{"version":3,"names":["assertFn","DisposableStore","markAsDisposed","toDisposable","trackDisposable","DebugNameData","getLogger","autorun","fn","AutorunObserver","undefined","autorunOpts","options","_options$debugReferen","owner","debugName","debugReferenceFn","autorunHandleChanges","_options$debugReferen2","createEmptyChangeSummary","handleChange","autorunWithStoreHandleChanges","_options$debugReferen3","store","disposable","reader","changeSummary","clear","dispose","autorunWithStore","_this$_debugNameData$","_debugNameData","getDebugName","constructor","_runFn","createChangeSummary","_handleChange","_this$createChangeSum","_getLogger","state","updateCount","disposed","dependencies","Set","dependenciesToBeRemoved","call","handleAutorunCreated","_runIfNeeded","o","removeObserver","emptySet","isDisposed","_getLogger2","_this$createChangeSum2","handleAutorunTriggered","_getLogger3","handleAutorunFinished","toString","concat","beginUpdate","endUpdate","d","reportChanges","handlePossibleChange","observable","has","change","shouldReact","changedObservable","didChange","readObservable","get","addObserver","value","add","delete","Observer"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/base/common/observableInternal/autorun.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn } from '../assert.js';\nimport { DisposableStore, markAsDisposed, toDisposable, trackDisposable } from '../lifecycle.js';\nimport { DebugNameData } from './debugName.js';\nimport { getLogger } from './logging.js';\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorun(fn) {\n    return new AutorunObserver(new DebugNameData(undefined, undefined, fn), fn, undefined, undefined);\n}\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorunOpts(options, fn) {\n    return new AutorunObserver(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn), fn, undefined, undefined);\n}\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The run function is given the last change summary.\n * The change summary is discarded after the run function was called.\n *\n * @see autorun\n */\nexport function autorunHandleChanges(options, fn) {\n    return new AutorunObserver(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn), fn, options.createEmptyChangeSummary, options.handleChange);\n}\n/**\n * @see autorunHandleChanges (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStoreHandleChanges(options, fn) {\n    const store = new DisposableStore();\n    const disposable = autorunHandleChanges({\n        owner: options.owner,\n        debugName: options.debugName,\n        debugReferenceFn: options.debugReferenceFn ?? fn,\n        createEmptyChangeSummary: options.createEmptyChangeSummary,\n        handleChange: options.handleChange,\n    }, (reader, changeSummary) => {\n        store.clear();\n        fn(reader, changeSummary, store);\n    });\n    return toDisposable(() => {\n        disposable.dispose();\n        store.dispose();\n    });\n}\n/**\n * @see autorun (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStore(fn) {\n    const store = new DisposableStore();\n    const disposable = autorunOpts({\n        owner: undefined,\n        debugName: undefined,\n        debugReferenceFn: fn,\n    }, reader => {\n        store.clear();\n        fn(reader, store);\n    });\n    return toDisposable(() => {\n        disposable.dispose();\n        store.dispose();\n    });\n}\nexport class AutorunObserver {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? '(anonymous)';\n    }\n    constructor(_debugNameData, _runFn, createChangeSummary, _handleChange) {\n        this._debugNameData = _debugNameData;\n        this._runFn = _runFn;\n        this.createChangeSummary = createChangeSummary;\n        this._handleChange = _handleChange;\n        this.state = 2 /* AutorunState.stale */;\n        this.updateCount = 0;\n        this.disposed = false;\n        this.dependencies = new Set();\n        this.dependenciesToBeRemoved = new Set();\n        this.changeSummary = this.createChangeSummary?.();\n        getLogger()?.handleAutorunCreated(this);\n        this._runIfNeeded();\n        trackDisposable(this);\n    }\n    dispose() {\n        this.disposed = true;\n        for (const o of this.dependencies) {\n            o.removeObserver(this);\n        }\n        this.dependencies.clear();\n        markAsDisposed(this);\n    }\n    _runIfNeeded() {\n        if (this.state === 3 /* AutorunState.upToDate */) {\n            return;\n        }\n        const emptySet = this.dependenciesToBeRemoved;\n        this.dependenciesToBeRemoved = this.dependencies;\n        this.dependencies = emptySet;\n        this.state = 3 /* AutorunState.upToDate */;\n        const isDisposed = this.disposed;\n        try {\n            if (!isDisposed) {\n                getLogger()?.handleAutorunTriggered(this);\n                const changeSummary = this.changeSummary;\n                this.changeSummary = this.createChangeSummary?.();\n                this._runFn(this, changeSummary);\n            }\n        }\n        finally {\n            if (!isDisposed) {\n                getLogger()?.handleAutorunFinished(this);\n            }\n            // We don't want our observed observables to think that they are (not even temporarily) not being observed.\n            // Thus, we only unsubscribe from observables that are definitely not read anymore.\n            for (const o of this.dependenciesToBeRemoved) {\n                o.removeObserver(this);\n            }\n            this.dependenciesToBeRemoved.clear();\n        }\n    }\n    toString() {\n        return `Autorun<${this.debugName}>`;\n    }\n    // IObserver implementation\n    beginUpdate() {\n        if (this.state === 3 /* AutorunState.upToDate */) {\n            this.state = 1 /* AutorunState.dependenciesMightHaveChanged */;\n        }\n        this.updateCount++;\n    }\n    endUpdate() {\n        if (this.updateCount === 1) {\n            do {\n                if (this.state === 1 /* AutorunState.dependenciesMightHaveChanged */) {\n                    this.state = 3 /* AutorunState.upToDate */;\n                    for (const d of this.dependencies) {\n                        d.reportChanges();\n                        if (this.state === 2 /* AutorunState.stale */) {\n                            // The other dependencies will refresh on demand\n                            break;\n                        }\n                    }\n                }\n                this._runIfNeeded();\n            } while (this.state !== 3 /* AutorunState.upToDate */);\n        }\n        this.updateCount--;\n        assertFn(() => this.updateCount >= 0);\n    }\n    handlePossibleChange(observable) {\n        if (this.state === 3 /* AutorunState.upToDate */ && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            this.state = 1 /* AutorunState.dependenciesMightHaveChanged */;\n        }\n    }\n    handleChange(observable, change) {\n        if (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            const shouldReact = this._handleChange ? this._handleChange({\n                changedObservable: observable,\n                change,\n                didChange: (o) => o === observable,\n            }, this.changeSummary) : true;\n            if (shouldReact) {\n                this.state = 2 /* AutorunState.stale */;\n            }\n        }\n    }\n    // IReader implementation\n    readObservable(observable) {\n        // In case the run action disposes the autorun\n        if (this.disposed) {\n            return observable.get();\n        }\n        observable.addObserver(this);\n        const value = observable.get();\n        this.dependencies.add(observable);\n        this.dependenciesToBeRemoved.delete(observable);\n        return value;\n    }\n}\n(function (autorun) {\n    autorun.Observer = AutorunObserver;\n})(autorun || (autorun = {}));\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,QAAQ,QAAQ,cAAc;AACvC,SAASC,eAAe,EAAEC,cAAc,EAAEC,YAAY,EAAEC,eAAe,QAAQ,iBAAiB;AAChG,SAASC,aAAa,QAAQ,gBAAgB;AAC9C,SAASC,SAAS,QAAQ,cAAc;AACxC;AACA;AACA;AACA;AACA,OAAO,SAASC,OAAOA,CAACC,EAAE,EAAE;EACxB,OAAO,IAAIC,eAAe,CAAC,IAAIJ,aAAa,CAACK,SAAS,EAAEA,SAAS,EAAEF,EAAE,CAAC,EAAEA,EAAE,EAAEE,SAAS,EAAEA,SAAS,CAAC;AACrG;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,WAAWA,CAACC,OAAO,EAAEJ,EAAE,EAAE;EAAA,IAAAK,qBAAA;EACrC,OAAO,IAAIJ,eAAe,CAAC,IAAIJ,aAAa,CAACO,OAAO,CAACE,KAAK,EAAEF,OAAO,CAACG,SAAS,GAAAF,qBAAA,GAAED,OAAO,CAACI,gBAAgB,cAAAH,qBAAA,cAAAA,qBAAA,GAAIL,EAAE,CAAC,EAAEA,EAAE,EAAEE,SAAS,EAAEA,SAAS,CAAC;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASO,oBAAoBA,CAACL,OAAO,EAAEJ,EAAE,EAAE;EAAA,IAAAU,sBAAA;EAC9C,OAAO,IAAIT,eAAe,CAAC,IAAIJ,aAAa,CAACO,OAAO,CAACE,KAAK,EAAEF,OAAO,CAACG,SAAS,GAAAG,sBAAA,GAAEN,OAAO,CAACI,gBAAgB,cAAAE,sBAAA,cAAAA,sBAAA,GAAIV,EAAE,CAAC,EAAEA,EAAE,EAAEI,OAAO,CAACO,wBAAwB,EAAEP,OAAO,CAACQ,YAAY,CAAC;AAC/K;AACA;AACA;AACA;AACA,OAAO,SAASC,6BAA6BA,CAACT,OAAO,EAAEJ,EAAE,EAAE;EAAA,IAAAc,sBAAA;EACvD,MAAMC,KAAK,GAAG,IAAItB,eAAe,CAAC,CAAC;EACnC,MAAMuB,UAAU,GAAGP,oBAAoB,CAAC;IACpCH,KAAK,EAAEF,OAAO,CAACE,KAAK;IACpBC,SAAS,EAAEH,OAAO,CAACG,SAAS;IAC5BC,gBAAgB,GAAAM,sBAAA,GAAEV,OAAO,CAACI,gBAAgB,cAAAM,sBAAA,cAAAA,sBAAA,GAAId,EAAE;IAChDW,wBAAwB,EAAEP,OAAO,CAACO,wBAAwB;IAC1DC,YAAY,EAAER,OAAO,CAACQ;EAC1B,CAAC,EAAE,CAACK,MAAM,EAAEC,aAAa,KAAK;IAC1BH,KAAK,CAACI,KAAK,CAAC,CAAC;IACbnB,EAAE,CAACiB,MAAM,EAAEC,aAAa,EAAEH,KAAK,CAAC;EACpC,CAAC,CAAC;EACF,OAAOpB,YAAY,CAAC,MAAM;IACtBqB,UAAU,CAACI,OAAO,CAAC,CAAC;IACpBL,KAAK,CAACK,OAAO,CAAC,CAAC;EACnB,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA,OAAO,SAASC,gBAAgBA,CAACrB,EAAE,EAAE;EACjC,MAAMe,KAAK,GAAG,IAAItB,eAAe,CAAC,CAAC;EACnC,MAAMuB,UAAU,GAAGb,WAAW,CAAC;IAC3BG,KAAK,EAAEJ,SAAS;IAChBK,SAAS,EAAEL,SAAS;IACpBM,gBAAgB,EAAER;EACtB,CAAC,EAAEiB,MAAM,IAAI;IACTF,KAAK,CAACI,KAAK,CAAC,CAAC;IACbnB,EAAE,CAACiB,MAAM,EAAEF,KAAK,CAAC;EACrB,CAAC,CAAC;EACF,OAAOpB,YAAY,CAAC,MAAM;IACtBqB,UAAU,CAACI,OAAO,CAAC,CAAC;IACpBL,KAAK,CAACK,OAAO,CAAC,CAAC;EACnB,CAAC,CAAC;AACN;AACA,OAAO,MAAMnB,eAAe,CAAC;EACzB,IAAIM,SAASA,CAAA,EAAG;IAAA,IAAAe,qBAAA;IACZ,QAAAA,qBAAA,GAAO,IAAI,CAACC,cAAc,CAACC,YAAY,CAAC,IAAI,CAAC,cAAAF,qBAAA,cAAAA,qBAAA,GAAI,aAAa;EAClE;EACAG,WAAWA,CAACF,cAAc,EAAEG,MAAM,EAAEC,mBAAmB,EAAEC,aAAa,EAAE;IAAA,IAAAC,qBAAA,EAAAC,UAAA;IACpE,IAAI,CAACP,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACG,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,mBAAmB,GAAGA,mBAAmB;IAC9C,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACG,KAAK,GAAG,CAAC,CAAC;IACf,IAAI,CAACC,WAAW,GAAG,CAAC;IACpB,IAAI,CAACC,QAAQ,GAAG,KAAK;IACrB,IAAI,CAACC,YAAY,GAAG,IAAIC,GAAG,CAAC,CAAC;IAC7B,IAAI,CAACC,uBAAuB,GAAG,IAAID,GAAG,CAAC,CAAC;IACxC,IAAI,CAACjB,aAAa,IAAAW,qBAAA,GAAG,IAAI,CAACF,mBAAmB,cAAAE,qBAAA,uBAAxBA,qBAAA,CAAAQ,IAAA,KAA2B,CAAC;IACjD,CAAAP,UAAA,GAAAhC,SAAS,CAAC,CAAC,cAAAgC,UAAA,eAAXA,UAAA,CAAaQ,oBAAoB,CAAC,IAAI,CAAC;IACvC,IAAI,CAACC,YAAY,CAAC,CAAC;IACnB3C,eAAe,CAAC,IAAI,CAAC;EACzB;EACAwB,OAAOA,CAAA,EAAG;IACN,IAAI,CAACa,QAAQ,GAAG,IAAI;IACpB,KAAK,MAAMO,CAAC,IAAI,IAAI,CAACN,YAAY,EAAE;MAC/BM,CAAC,CAACC,cAAc,CAAC,IAAI,CAAC;IAC1B;IACA,IAAI,CAACP,YAAY,CAACf,KAAK,CAAC,CAAC;IACzBzB,cAAc,CAAC,IAAI,CAAC;EACxB;EACA6C,YAAYA,CAAA,EAAG;IACX,IAAI,IAAI,CAACR,KAAK,KAAK,CAAC,CAAC,6BAA6B;MAC9C;IACJ;IACA,MAAMW,QAAQ,GAAG,IAAI,CAACN,uBAAuB;IAC7C,IAAI,CAACA,uBAAuB,GAAG,IAAI,CAACF,YAAY;IAChD,IAAI,CAACA,YAAY,GAAGQ,QAAQ;IAC5B,IAAI,CAACX,KAAK,GAAG,CAAC,CAAC;IACf,MAAMY,UAAU,GAAG,IAAI,CAACV,QAAQ;IAChC,IAAI;MACA,IAAI,CAACU,UAAU,EAAE;QAAA,IAAAC,WAAA,EAAAC,sBAAA;QACb,CAAAD,WAAA,GAAA9C,SAAS,CAAC,CAAC,cAAA8C,WAAA,eAAXA,WAAA,CAAaE,sBAAsB,CAAC,IAAI,CAAC;QACzC,MAAM5B,aAAa,GAAG,IAAI,CAACA,aAAa;QACxC,IAAI,CAACA,aAAa,IAAA2B,sBAAA,GAAG,IAAI,CAAClB,mBAAmB,cAAAkB,sBAAA,uBAAxBA,sBAAA,CAAAR,IAAA,KAA2B,CAAC;QACjD,IAAI,CAACX,MAAM,CAAC,IAAI,EAAER,aAAa,CAAC;MACpC;IACJ,CAAC,SACO;MACJ,IAAI,CAACyB,UAAU,EAAE;QAAA,IAAAI,WAAA;QACb,CAAAA,WAAA,GAAAjD,SAAS,CAAC,CAAC,cAAAiD,WAAA,eAAXA,WAAA,CAAaC,qBAAqB,CAAC,IAAI,CAAC;MAC5C;MACA;MACA;MACA,KAAK,MAAMR,CAAC,IAAI,IAAI,CAACJ,uBAAuB,EAAE;QAC1CI,CAAC,CAACC,cAAc,CAAC,IAAI,CAAC;MAC1B;MACA,IAAI,CAACL,uBAAuB,CAACjB,KAAK,CAAC,CAAC;IACxC;EACJ;EACA8B,QAAQA,CAAA,EAAG;IACP,kBAAAC,MAAA,CAAkB,IAAI,CAAC3C,SAAS;EACpC;EACA;EACA4C,WAAWA,CAAA,EAAG;IACV,IAAI,IAAI,CAACpB,KAAK,KAAK,CAAC,CAAC,6BAA6B;MAC9C,IAAI,CAACA,KAAK,GAAG,CAAC,CAAC;IACnB;IACA,IAAI,CAACC,WAAW,EAAE;EACtB;EACAoB,SAASA,CAAA,EAAG;IACR,IAAI,IAAI,CAACpB,WAAW,KAAK,CAAC,EAAE;MACxB,GAAG;QACC,IAAI,IAAI,CAACD,KAAK,KAAK,CAAC,CAAC,iDAAiD;UAClE,IAAI,CAACA,KAAK,GAAG,CAAC,CAAC;UACf,KAAK,MAAMsB,CAAC,IAAI,IAAI,CAACnB,YAAY,EAAE;YAC/BmB,CAAC,CAACC,aAAa,CAAC,CAAC;YACjB,IAAI,IAAI,CAACvB,KAAK,KAAK,CAAC,CAAC,0BAA0B;cAC3C;cACA;YACJ;UACJ;QACJ;QACA,IAAI,CAACQ,YAAY,CAAC,CAAC;MACvB,CAAC,QAAQ,IAAI,CAACR,KAAK,KAAK,CAAC,CAAC;IAC9B;IACA,IAAI,CAACC,WAAW,EAAE;IAClBxC,QAAQ,CAAC,MAAM,IAAI,CAACwC,WAAW,IAAI,CAAC,CAAC;EACzC;EACAuB,oBAAoBA,CAACC,UAAU,EAAE;IAC7B,IAAI,IAAI,CAACzB,KAAK,KAAK,CAAC,CAAC,+BAA+B,IAAI,CAACG,YAAY,CAACuB,GAAG,CAACD,UAAU,CAAC,IAAI,CAAC,IAAI,CAACpB,uBAAuB,CAACqB,GAAG,CAACD,UAAU,CAAC,EAAE;MACpI,IAAI,CAACzB,KAAK,GAAG,CAAC,CAAC;IACnB;EACJ;EACAnB,YAAYA,CAAC4C,UAAU,EAAEE,MAAM,EAAE;IAC7B,IAAI,IAAI,CAACxB,YAAY,CAACuB,GAAG,CAACD,UAAU,CAAC,IAAI,CAAC,IAAI,CAACpB,uBAAuB,CAACqB,GAAG,CAACD,UAAU,CAAC,EAAE;MACpF,MAAMG,WAAW,GAAG,IAAI,CAAC/B,aAAa,GAAG,IAAI,CAACA,aAAa,CAAC;QACxDgC,iBAAiB,EAAEJ,UAAU;QAC7BE,MAAM;QACNG,SAAS,EAAGrB,CAAC,IAAKA,CAAC,KAAKgB;MAC5B,CAAC,EAAE,IAAI,CAACtC,aAAa,CAAC,GAAG,IAAI;MAC7B,IAAIyC,WAAW,EAAE;QACb,IAAI,CAAC5B,KAAK,GAAG,CAAC,CAAC;MACnB;IACJ;EACJ;EACA;EACA+B,cAAcA,CAACN,UAAU,EAAE;IACvB;IACA,IAAI,IAAI,CAACvB,QAAQ,EAAE;MACf,OAAOuB,UAAU,CAACO,GAAG,CAAC,CAAC;IAC3B;IACAP,UAAU,CAACQ,WAAW,CAAC,IAAI,CAAC;IAC5B,MAAMC,KAAK,GAAGT,UAAU,CAACO,GAAG,CAAC,CAAC;IAC9B,IAAI,CAAC7B,YAAY,CAACgC,GAAG,CAACV,UAAU,CAAC;IACjC,IAAI,CAACpB,uBAAuB,CAAC+B,MAAM,CAACX,UAAU,CAAC;IAC/C,OAAOS,KAAK;EAChB;AACJ;AACA,CAAC,UAAUlE,OAAO,EAAE;EAChBA,OAAO,CAACqE,QAAQ,GAAGnE,eAAe;AACtC,CAAC,EAAEF,OAAO,KAAKA,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}