{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from './Rectangle';\nimport { isNotNullish } from '../../util/Utils';\nimport { getBoundingBox, getDirectedBounds, mod } from '../../util/mathUtils';\nimport { DIRECTION, LINE_ARCSIZE, NONE, RECTANGLE_ROUNDING_FACTOR, SHADOW_OFFSET_X, SHADOW_OFFSET_Y } from '../../util/Constants';\nimport Point from './Point';\nimport SvgCanvas2D from '../canvas/SvgCanvas2D';\nimport InternalEvent from '../event/InternalEvent';\nimport Client from '../../Client';\n/**\n * Base class for all shapes.\n * A shape in mxGraph is a separate implementation for SVG, VML and HTML.\n * Which implementation to use is controlled by the dialect property which\n * is assigned from within the mxCellRenderer when the shape is created.\n * The dialect must be assigned for a shape, and it does normally depend on\n * the browser and the configuration of the graph (see mxGraph rendering hint).\n *\n * For each supported shape in SVG and VML, a corresponding shape exists in\n * mxGraph, namely for text, image, rectangle, rhombus, ellipse and polyline.\n * The other shapes are a combination of these shapes (eg. label and swimlane)\n * or they consist of one or more (filled) path objects (eg. actor and cylinder).\n * The HTML implementation is optional but may be required for a HTML-only view\n * of the graph.\n *\n * ### Custom Shapes\n * To extend from this class, the basic code looks as follows.\n * In the special case where the custom shape consists only of one filled region\n * or one filled region and an additional stroke the mxActor and mxCylinder\n * should be subclassed, respectively.\n * ```javascript\n * function CustomShape() { }\n *\n * CustomShape.prototype = new mxShape();\n * CustomShape.prototype.constructor = CustomShape;\n * ```\n * To register a custom shape in an existing graph instance, one must register the\n * shape under a new name in the graphâ€™s cell renderer as follows:\n * ```javascript\n * mxCellRenderer.registerShape('customShape', CustomShape);\n * ```\n * The second argument is the name of the constructor.\n * In order to use the shape you can refer to the given name above in a stylesheet.\n * For example, to change the shape for the default vertex style, the following code\n * is used:\n * ```javascript\n * var style = graph.getStylesheet().getDefaultVertexStyle();\n * style.shape = 'customShape';\n * ```\n */\nclass Shape {\n  constructor() {\n    let stencil = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    // Assigned in mxCellRenderer\n    this.preserveImageAspect = false;\n    this.overlay = null;\n    this.indicator = null;\n    this.indicatorShape = null;\n    // Assigned in mxCellHighlight\n    this.opacity = 100;\n    this.isDashed = false;\n    this.fill = NONE;\n    this.gradient = NONE;\n    this.gradientDirection = DIRECTION.EAST;\n    this.fillOpacity = 100;\n    this.strokeOpacity = 100;\n    this.stroke = NONE;\n    this.strokeWidth = 1;\n    this.spacing = 0;\n    this.startSize = 1;\n    this.endSize = 1;\n    this.startArrow = NONE;\n    this.endArrow = NONE;\n    this.direction = DIRECTION.EAST;\n    this.flipH = false;\n    this.flipV = false;\n    this.isShadow = false;\n    this.isRounded = false;\n    this.rotation = 0;\n    this.cursor = '';\n    this.verticalTextRotation = 0;\n    this.oldGradients = {};\n    this.glass = false;\n    /**\n     * Holds the dialect in which the shape is to be painted.\n     * This can be one of the DIALECT constants in {@link Constants}.\n     */\n    this.dialect = null;\n    /**\n     * Holds the scale in which the shape is being painted.\n     */\n    this.scale = 1;\n    /**\n     * Rendering hint for configuring the canvas.\n     */\n    this.antiAlias = true;\n    /**\n     * Minimum stroke width for SVG output.\n     */\n    this.minSvgStrokeWidth = 1;\n    /**\n     * Holds the {@link Rectangle} that specifies the bounds of this shape.\n     */\n    this.bounds = null;\n    /**\n     * Holds the array of <Point> that specify the points of this shape.\n     */\n    this.points = [];\n    /**\n     * Optional reference to the corresponding <CellState>.\n     */\n    this.state = null;\n    /**\n     * Optional reference to the style of the corresponding <CellState>.\n     */\n    this.style = null;\n    /**\n     * Contains the bounding box of the shape, that is, the smallest rectangle\n     * that includes all pixels of the shape.\n     */\n    this.boundingBox = null;\n    /**\n     * Holds the {@link Stencil} that defines the shape.\n     */\n    this.stencil = null;\n    /**\n     * Event-tolerance for SVG strokes (in px). Default is 8. This is only passed\n     * to the canvas in <createSvgCanvas> if <pointerEvents> is true.\n     */\n    this.svgStrokeTolerance = 8;\n    /**\n     * Specifies if pointer events should be handled. Default is true.\n     */\n    this.pointerEvents = true;\n    this.originalPointerEvents = null;\n    /**\n     * Specifies if pointer events should be handled. Default is true.\n     */\n    this.svgPointerEvents = 'all';\n    /**\n     * Specifies if pointer events outside of shape should be handled. Default\n     * is false.\n     */\n    this.shapePointerEvents = false;\n    /**\n     * Specifies if pointer events outside of stencils should be handled. Default\n     * is false. Set this to true for backwards compatibility with the 1.x branch.\n     */\n    this.stencilPointerEvents = false;\n    /**\n     * Specifies if the shape should be drawn as an outline. This disables all\n     * fill colors and can be used to disable other drawing states that should\n     * not be painted for outlines. Default is false. This should be set before\n     * calling <apply>.\n     */\n    this.outline = false;\n    /**\n     * Specifies if the shape is visible. Default is true.\n     */\n    this.visible = true;\n    /**\n     * Allows to use the SVG bounding box in SVG. Default is false for performance\n     * reasons.\n     */\n    this.useSvgBoundingBox = true;\n    this.image = null;\n    this.imageSrc = null;\n    this.indicatorColor = NONE;\n    this.indicatorStrokeColor = NONE;\n    this.indicatorGradientColor = NONE;\n    this.indicatorDirection = DIRECTION.EAST;\n    this.indicatorImageSrc = null;\n    // `stencil` is not null when instantiated directly,\n    // but can be null when instantiated through a child class.\n    if (stencil) {\n      this.stencil = stencil;\n    }\n    // moved from init()\n    this.node = this.create();\n  }\n  /**\n   * Initializes the shape by creaing the DOM node using <create>\n   * and adding it into the given container.\n   *\n   * @param container DOM node that will contain the shape.\n   */\n  init(container) {\n    if (!this.node.parentNode) {\n      container.appendChild(this.node);\n    }\n  }\n  /**\n   * Sets the styles to their default values.\n   */\n  initStyles() {\n    this.strokeWidth = 1;\n    this.rotation = 0;\n    this.opacity = 100;\n    this.fillOpacity = 100;\n    this.strokeOpacity = 100;\n    this.flipH = false;\n    this.flipV = false;\n  }\n  /**\n   * Returns true if HTML is allowed for this shape. This implementation always\n   * returns false.\n   */\n  isHtmlAllowed() {\n    return false;\n  }\n  /**\n   * Returns 0, or 0.5 if <strokewidth> % 2 == 1.\n   */\n  getSvgScreenOffset() {\n    var _this$strokeWidth;\n    const sw = this.stencil && this.stencil.strokeWidthValue !== 'inherit' ? Number(this.stencil.strokeWidthValue) : (_this$strokeWidth = this.strokeWidth) !== null && _this$strokeWidth !== void 0 ? _this$strokeWidth : 0;\n    return mod(Math.max(1, Math.round(sw * this.scale)), 2) === 1 ? 0.5 : 0;\n  }\n  /**\n   * Creates and returns the DOM node(s) for the shape in\n   * the given container. This implementation invokes\n   * <createSvg>, <createHtml> or <createVml> depending\n   * on the <dialect> and style settings.\n   *\n   * @param container DOM node that will contain the shape.\n   */\n  create() {\n    return document.createElementNS('http://www.w3.org/2000/svg', 'g');\n  }\n  /**\n   * Reconfigures this shape. This will update the colors etc in\n   * addition to the bounds or points.\n   */\n  reconfigure() {\n    this.redraw();\n  }\n  /**\n   * Creates and returns the SVG node(s) to represent this shape.\n   */\n  redraw() {\n    this.updateBoundsFromPoints();\n    if (this.visible && this.checkBounds()) {\n      this.node.style.visibility = 'visible';\n      this.clear();\n      this.redrawShape();\n      this.updateBoundingBox();\n    } else {\n      this.node.style.visibility = 'hidden';\n      this.boundingBox = null;\n    }\n  }\n  /**\n   * Removes all child nodes and resets all CSS.\n   */\n  clear() {\n    while (this.node.lastChild) {\n      this.node.removeChild(this.node.lastChild);\n    }\n  }\n  /**\n   * Updates the bounds based on the points.\n   */\n  updateBoundsFromPoints() {\n    const pts = this.points;\n    if (pts.length > 0 && pts[0]) {\n      this.bounds = new Rectangle(Math.round(pts[0].x), Math.round(pts[0].y), 1, 1);\n      for (const pt of pts) {\n        if (pt) {\n          this.bounds.add(new Rectangle(Math.round(pt.x), Math.round(pt.y), 1, 1));\n        }\n      }\n    }\n  }\n  /**\n   * Returns the {@link Rectangle} for the label bounds of this shape, based on the\n   * given scaled and translated bounds of the shape. This method should not\n   * change the rectangle in-place. This implementation returns the given rect.\n   */\n  getLabelBounds(rect) {\n    var _this$style$direction, _this$style;\n    const d = (_this$style$direction = (_this$style = this.style) === null || _this$style === void 0 ? void 0 : _this$style.direction) !== null && _this$style$direction !== void 0 ? _this$style$direction : DIRECTION.EAST;\n    let bounds = rect.clone();\n    // Normalizes argument for getLabelMargins hook\n    if (d !== DIRECTION.SOUTH && d !== DIRECTION.NORTH && this.state && this.state.text && this.state.text.isPaintBoundsInverted()) {\n      bounds = bounds.clone();\n      [bounds.width, bounds.height] = [bounds.height, bounds.width];\n    }\n    let labelMargins = this.getLabelMargins(bounds);\n    if (labelMargins) {\n      var _this$style$flipH, _this$style2, _this$style$flipV, _this$style3;\n      labelMargins = labelMargins.clone();\n      let flipH = (_this$style$flipH = (_this$style2 = this.style) === null || _this$style2 === void 0 ? void 0 : _this$style2.flipH) !== null && _this$style$flipH !== void 0 ? _this$style$flipH : false;\n      let flipV = (_this$style$flipV = (_this$style3 = this.style) === null || _this$style3 === void 0 ? void 0 : _this$style3.flipV) !== null && _this$style$flipV !== void 0 ? _this$style$flipV : false;\n      // Handles special case for vertical labels\n      if (this.state && this.state.text && this.state.text.isPaintBoundsInverted()) {\n        const tmp = labelMargins.x;\n        labelMargins.x = labelMargins.height;\n        labelMargins.height = labelMargins.width;\n        labelMargins.width = labelMargins.y;\n        labelMargins.y = tmp;\n        [flipH, flipV] = [flipV, flipH];\n      }\n      return getDirectedBounds(rect, labelMargins, this.style, flipH, flipV);\n    }\n    return rect;\n  }\n  /**\n   * Returns the scaled top, left, bottom and right margin to be used for\n   * computing the label bounds as an {@link Rectangle}, where the bottom and right\n   * margin are defined in the width and height of the rectangle, respectively.\n   */\n  getLabelMargins(rect) {\n    return null;\n  }\n  /**\n   * Returns true if the bounds are not null and all of its variables are numeric.\n   */\n  checkBounds() {\n    return !Number.isNaN(this.scale) && Number.isFinite(this.scale) && this.scale > 0 && this.bounds && !Number.isNaN(this.bounds.x) && !Number.isNaN(this.bounds.y) && !Number.isNaN(this.bounds.width) && !Number.isNaN(this.bounds.height) && this.bounds.width > 0 && this.bounds.height > 0;\n  }\n  /**\n   * Updates the SVG or VML shape.\n   */\n  redrawShape() {\n    const canvas = this.createCanvas();\n    if (canvas) {\n      // Specifies if events should be handled\n      canvas.pointerEvents = this.pointerEvents;\n      this.beforePaint(canvas);\n      this.paint(canvas);\n      this.afterPaint(canvas);\n      if (this.node !== canvas.root && canvas.root) {\n        // Forces parsing in IE8 standards mode - slow! avoid\n        this.node.insertAdjacentHTML('beforeend', canvas.root.outerHTML);\n      }\n      this.destroyCanvas(canvas);\n    }\n  }\n  /**\n   * Creates a new canvas for drawing this shape. May return null.\n   */\n  createCanvas() {\n    const canvas = this.createSvgCanvas();\n    if (canvas && this.outline) {\n      canvas.setStrokeWidth(this.strokeWidth);\n      canvas.setStrokeColor(this.stroke);\n      if (this.isDashed) {\n        canvas.setDashed(this.isDashed);\n      }\n      canvas.setStrokeWidth = () => {\n        return;\n      };\n      canvas.setStrokeColor = () => {\n        return;\n      };\n      canvas.setFillColor = () => {\n        return;\n      };\n      canvas.setGradient = () => {\n        return;\n      };\n      canvas.setDashed = () => {\n        return;\n      };\n      canvas.text = () => {\n        return;\n      };\n    }\n    return canvas;\n  }\n  /**\n   * Creates and returns an <mxSvgCanvas2D> for rendering this shape.\n   */\n  createSvgCanvas() {\n    if (!this.node) return null;\n    const canvas = new SvgCanvas2D(this.node, false);\n    canvas.strokeTolerance = this.pointerEvents ? this.svgStrokeTolerance : 0;\n    canvas.pointerEventsValue = this.svgPointerEvents;\n    const off = this.getSvgScreenOffset();\n    if (off !== 0) {\n      this.node.setAttribute('transform', \"translate(\".concat(off, \",\").concat(off, \")\"));\n    } else {\n      this.node.removeAttribute('transform');\n    }\n    canvas.minStrokeWidth = this.minSvgStrokeWidth;\n    if (!this.antiAlias) {\n      // Rounds all numbers in the SVG output to integers\n      canvas.format = value => {\n        return Math.round(value);\n      };\n    }\n    return canvas;\n  }\n  /**\n   * Destroys the given canvas which was used for drawing. This implementation\n   * increments the reference counts on all shared gradients used in the canvas.\n   */\n  destroyCanvas(canvas) {\n    // Manages reference counts\n    if (canvas instanceof SvgCanvas2D) {\n      // Increments ref counts\n      for (const key in canvas.gradients) {\n        const gradient = canvas.gradients[key];\n        if (gradient) {\n          gradient.mxRefCount = (gradient.mxRefCount || 0) + 1;\n        }\n      }\n      this.releaseSvgGradients(this.oldGradients);\n      this.oldGradients = canvas.gradients;\n    }\n  }\n  /**\n   * Invoked before paint is called.\n   */\n  beforePaint(c) {\n    return;\n  }\n  /**\n   * Invokes after paint was called.\n   */\n  afterPaint(c) {\n    return;\n  }\n  /**\n   * Generic rendering code.\n   */\n  paint(c) {\n    let strokeDrawn = false;\n    if (c && this.outline) {\n      const {\n        stroke\n      } = c;\n      c.stroke = function () {\n        strokeDrawn = true;\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        stroke.apply(c, args);\n      };\n      const {\n        fillAndStroke\n      } = c;\n      c.fillAndStroke = function () {\n        strokeDrawn = true;\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        fillAndStroke.apply(c, args);\n      };\n    }\n    // Scale is passed-through to canvas\n    const s = this.scale;\n    const bounds = this.bounds;\n    if (bounds) {\n      let x = bounds.x / s;\n      let y = bounds.y / s;\n      let w = bounds.width / s;\n      let h = bounds.height / s;\n      if (this.isPaintBoundsInverted()) {\n        const t = (w - h) / 2;\n        x += t;\n        y -= t;\n        const tmp = w;\n        w = h;\n        h = tmp;\n      }\n      this.updateTransform(c, x, y, w, h);\n      this.configureCanvas(c, x, y, w, h);\n      // Adds background rectangle to capture events\n      let bg = null;\n      if (!this.stencil && this.points.length === 0 && this.shapePointerEvents || this.stencil && this.stencilPointerEvents) {\n        const bb = this.createBoundingBox();\n        if (bb && this.node) {\n          bg = this.createTransparentSvgRectangle(bb.x, bb.y, bb.width, bb.height);\n          this.node.appendChild(bg);\n        }\n      }\n      if (this.stencil) {\n        this.stencil.drawShape(c, this, x, y, w, h);\n      } else {\n        // Stencils have separate strokewidth\n        c.setStrokeWidth(this.strokeWidth);\n        if (this.points.length > 0) {\n          // Paints edge shape\n          const pts = [];\n          for (let i = 0; i < this.points.length; i += 1) {\n            const p = this.points[i];\n            if (p) {\n              pts.push(new Point(p.x / s, p.y / s));\n            }\n          }\n          this.paintEdgeShape(c, pts);\n        } else {\n          // Paints vertex shape\n          this.paintVertexShape(c, x, y, w, h);\n        }\n      }\n      if (bg && c.state && isNotNullish(c.state.transform)) {\n        bg.setAttribute('transform', c.state.transform);\n      }\n      // Draws highlight rectangle if no stroke was used\n      if (c && this.outline && !strokeDrawn) {\n        c.rect(x, y, w, h);\n        c.stroke();\n      }\n    }\n  }\n  /**\n   * Sets the state of the canvas for drawing the shape.\n   */\n  configureCanvas(c, x, y, w, h) {\n    let dash = null;\n    if (this.style && this.style.dashPattern != null) {\n      dash = this.style.dashPattern;\n    }\n    c.setAlpha(this.opacity / 100);\n    c.setFillAlpha(this.fillOpacity / 100);\n    c.setStrokeAlpha(this.strokeOpacity / 100);\n    // Sets alpha, colors and gradients\n    if (this.isShadow) {\n      c.setShadow(this.isShadow);\n    }\n    // Dash pattern\n    if (this.isDashed) {\n      var _this$style$fixDash, _this$style4;\n      c.setDashed(this.isDashed, (_this$style$fixDash = (_this$style4 = this.style) === null || _this$style4 === void 0 ? void 0 : _this$style4.fixDash) !== null && _this$style$fixDash !== void 0 ? _this$style$fixDash : false);\n    }\n    if (dash) {\n      c.setDashPattern(dash);\n    }\n    if (this.fill !== NONE && this.gradient !== NONE) {\n      const b = this.getGradientBounds(c, x, y, w, h);\n      c.setGradient(this.fill, this.gradient, b.x, b.y, b.width, b.height, this.gradientDirection);\n    } else {\n      c.setFillColor(this.fill);\n    }\n    c.setStrokeColor(this.stroke);\n  }\n  /**\n   * Returns the bounding box for the gradient box for this shape.\n   */\n  getGradientBounds(c, x, y, w, h) {\n    return new Rectangle(x, y, w, h);\n  }\n  /**\n   * Sets the scale and rotation on the given canvas.\n   */\n  updateTransform(c, x, y, w, h) {\n    // NOTE: Currently, scale is implemented in state and canvas. This will\n    // move to canvas in a later version, so that the states are unscaled\n    // and untranslated and do not need an update after zooming or panning.\n    c.scale(this.scale);\n    c.rotate(this.getShapeRotation(), this.flipH, this.flipV, x + w / 2, y + h / 2);\n  }\n  /**\n   * Paints the vertex shape.\n   */\n  paintVertexShape(c, x, y, w, h) {\n    var _this$style$backgroun;\n    this.paintBackground(c, x, y, w, h);\n    if (!this.outline || !this.style || !((_this$style$backgroun = this.style.backgroundOutline) !== null && _this$style$backgroun !== void 0 ? _this$style$backgroun : false)) {\n      c.setShadow(false);\n      this.paintForeground(c, x, y, w, h);\n    }\n  }\n  /**\n   * Hook for subclassers. This implementation is empty.\n   */\n  paintBackground(c, x, y, w, h) {\n    return;\n  }\n  /**\n   * Hook for subclassers. This implementation is empty.\n   */\n  paintForeground(c, x, y, w, h) {\n    return;\n  }\n  /**\n   * Hook for subclassers. This implementation is empty.\n   */\n  paintEdgeShape(c, pts) {\n    return;\n  }\n  /**\n   * Returns the arc size for the given dimension.\n   */\n  getArcSize(w, h) {\n    var _this$style$absoluteA, _this$style5;\n    let r = 0;\n    if ((_this$style$absoluteA = (_this$style5 = this.style) === null || _this$style5 === void 0 ? void 0 : _this$style5.absoluteArcSize) !== null && _this$style$absoluteA !== void 0 ? _this$style$absoluteA : false) {\n      var _this$style$arcSize, _this$style6;\n      r = Math.min(w / 2, Math.min(h / 2, ((_this$style$arcSize = (_this$style6 = this.style) === null || _this$style6 === void 0 ? void 0 : _this$style6.arcSize) !== null && _this$style$arcSize !== void 0 ? _this$style$arcSize : LINE_ARCSIZE) / 2));\n    } else {\n      var _this$style$arcSize2, _this$style7;\n      const f = ((_this$style$arcSize2 = (_this$style7 = this.style) === null || _this$style7 === void 0 ? void 0 : _this$style7.arcSize) !== null && _this$style$arcSize2 !== void 0 ? _this$style$arcSize2 : RECTANGLE_ROUNDING_FACTOR * 100) / 100;\n      r = Math.min(w * f, h * f);\n    }\n    return r;\n  }\n  /**\n   * Paints the glass gradient effect.\n   */\n  paintGlassEffect(c, x, y, w, h, arc) {\n    var _this$strokeWidth2;\n    const sw = Math.ceil(((_this$strokeWidth2 = this.strokeWidth) !== null && _this$strokeWidth2 !== void 0 ? _this$strokeWidth2 : 0) / 2);\n    const size = 0.4;\n    c.setGradient('#ffffff', '#ffffff', x, y, w, h * 0.6, 'south', 0.9, 0.1);\n    c.begin();\n    arc += 2 * sw;\n    if (this.isRounded) {\n      c.moveTo(x - sw + arc, y - sw);\n      c.quadTo(x - sw, y - sw, x - sw, y - sw + arc);\n      c.lineTo(x - sw, y + h * size);\n      c.quadTo(x + w * 0.5, y + h * 0.7, x + w + sw, y + h * size);\n      c.lineTo(x + w + sw, y - sw + arc);\n      c.quadTo(x + w + sw, y - sw, x + w + sw - arc, y - sw);\n    } else {\n      c.moveTo(x - sw, y - sw);\n      c.lineTo(x - sw, y + h * size);\n      c.quadTo(x + w * 0.5, y + h * 0.7, x + w + sw, y + h * size);\n      c.lineTo(x + w + sw, y - sw);\n    }\n    c.close();\n    c.fill();\n  }\n  /**\n   * Paints the given points with rounded corners.\n   */\n  addPoints(c, pts) {\n    let rounded = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let arcSize = arguments.length > 3 ? arguments[3] : undefined;\n    let close = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    let exclude = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];\n    let initialMove = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;\n    if (pts.length > 0) {\n      const pe = pts[pts.length - 1];\n      // Adds virtual waypoint in the center between start and end point\n      if (close && rounded) {\n        pts = pts.slice();\n        const p0 = pts[0];\n        const wp = new Point(pe.x + (p0.x - pe.x) / 2, pe.y + (p0.y - pe.y) / 2);\n        pts.splice(0, 0, wp);\n      }\n      let pt = pts[0];\n      let i = 1;\n      // Draws the line segments\n      if (initialMove) {\n        c.moveTo(pt.x, pt.y);\n      } else {\n        c.lineTo(pt.x, pt.y);\n      }\n      while (i < (close ? pts.length : pts.length - 1)) {\n        let tmp = pts[mod(i, pts.length)];\n        let dx = pt.x - tmp.x;\n        let dy = pt.y - tmp.y;\n        if (rounded && (dx !== 0 || dy !== 0) && exclude.indexOf(i - 1) < 0) {\n          // Draws a line from the last point to the current\n          // point with a spacing of size off the current point\n          // into direction of the last point\n          let dist = Math.sqrt(dx * dx + dy * dy);\n          const nx1 = dx * Math.min(arcSize, dist / 2) / dist;\n          const ny1 = dy * Math.min(arcSize, dist / 2) / dist;\n          const x1 = tmp.x + nx1;\n          const y1 = tmp.y + ny1;\n          c.lineTo(x1, y1);\n          // Draws a curve from the last point to the current\n          // point with a spacing of size off the current point\n          // into direction of the next point\n          let next = pts[mod(i + 1, pts.length)];\n          // Uses next non-overlapping point\n          while (i < pts.length - 2 && Math.round(next.x - tmp.x) === 0 && Math.round(next.y - tmp.y) === 0) {\n            next = pts[mod(i + 2, pts.length)];\n            i++;\n          }\n          dx = next.x - tmp.x;\n          dy = next.y - tmp.y;\n          dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));\n          const nx2 = dx * Math.min(arcSize, dist / 2) / dist;\n          const ny2 = dy * Math.min(arcSize, dist / 2) / dist;\n          const x2 = tmp.x + nx2;\n          const y2 = tmp.y + ny2;\n          c.quadTo(tmp.x, tmp.y, x2, y2);\n          tmp = new Point(x2, y2);\n        } else {\n          c.lineTo(tmp.x, tmp.y);\n        }\n        pt = tmp;\n        i += 1;\n      }\n      if (close) {\n        c.close();\n      } else {\n        c.lineTo(pe.x, pe.y);\n      }\n    }\n  }\n  /**\n   * Resets all styles.\n   */\n  resetStyles() {\n    this.initStyles();\n    this.spacing = 0;\n    this.fill = NONE;\n    this.gradient = NONE;\n    this.gradientDirection = DIRECTION.EAST;\n    this.stroke = NONE;\n    this.startSize = 1;\n    this.endSize = 1;\n    this.startArrow = NONE;\n    this.endArrow = NONE;\n    this.direction = DIRECTION.EAST;\n    this.isShadow = false;\n    this.isDashed = false;\n    this.isRounded = false;\n    this.glass = false;\n  }\n  /**\n   * Applies the style of the given <CellState> to the shape. This\n   * implementation assigns the following styles to local fields:\n   *\n   * - <'fillColor'> => fill\n   * - <'gradientColor'> => gradient\n   * - <'gradientDirection'> => gradientDirection\n   * - <'opacity'> => opacity\n   * - {@link Constants#STYLE_FILL_OPACITY} => fillOpacity\n   * - {@link Constants#STYLE_STROKE_OPACITY} => strokeOpacity\n   * - <'strokeColor'> => stroke\n   * - <'strokeWidth'> => strokewidth\n   * - <'shadow'> => isShadow\n   * - <'dashed'> => isDashed\n   * - <'spacing'> => spacing\n   * - <'startSize'> => startSize\n   * - <'endSize'> => endSize\n   * - <'rounded'> => isRounded\n   * - <'startArrow'> => startArrow\n   * - <'endArrow'> => endArrow\n   * - <'rotation'> => rotation\n   * - <'direction'> => direction\n   * - <'glass'> => glass\n   *\n   * This keeps a reference to the <style>. If you need to keep a reference to\n   * the cell, you can override this method and store a local reference to\n   * state.cell or the <CellState> itself. If <outline> should be true, make\n   * sure to set it before calling this method.\n   *\n   * @param state <CellState> of the corresponding cell.\n   */\n  apply(state) {\n    this.state = state;\n    this.style = state.style;\n    if (this.style) {\n      var _this$style$fillColor, _this$style$gradientC, _this$style$gradientD, _this$style$opacity, _this$style$fillOpaci, _this$style$strokeOpa, _this$style$strokeCol, _this$style$strokeWid, _this$style$spacing, _this$style$startSize, _this$style$endSize, _this$style$startArro, _this$style$endArrow, _this$style$rotation, _this$style$direction2, _this$style$shadow, _this$style$dashed, _this$style$rounded, _this$style$glass;\n      this.fill = (_this$style$fillColor = this.style.fillColor) !== null && _this$style$fillColor !== void 0 ? _this$style$fillColor : this.fill;\n      this.gradient = (_this$style$gradientC = this.style.gradientColor) !== null && _this$style$gradientC !== void 0 ? _this$style$gradientC : this.gradient;\n      this.gradientDirection = (_this$style$gradientD = this.style.gradientDirection) !== null && _this$style$gradientD !== void 0 ? _this$style$gradientD : this.gradientDirection;\n      this.opacity = (_this$style$opacity = this.style.opacity) !== null && _this$style$opacity !== void 0 ? _this$style$opacity : this.opacity;\n      this.fillOpacity = (_this$style$fillOpaci = this.style.fillOpacity) !== null && _this$style$fillOpaci !== void 0 ? _this$style$fillOpaci : this.fillOpacity;\n      this.strokeOpacity = (_this$style$strokeOpa = this.style.strokeOpacity) !== null && _this$style$strokeOpa !== void 0 ? _this$style$strokeOpa : this.strokeOpacity;\n      this.stroke = (_this$style$strokeCol = this.style.strokeColor) !== null && _this$style$strokeCol !== void 0 ? _this$style$strokeCol : this.stroke;\n      this.strokeWidth = (_this$style$strokeWid = this.style.strokeWidth) !== null && _this$style$strokeWid !== void 0 ? _this$style$strokeWid : this.strokeWidth;\n      this.spacing = (_this$style$spacing = this.style.spacing) !== null && _this$style$spacing !== void 0 ? _this$style$spacing : this.spacing;\n      this.startSize = (_this$style$startSize = this.style.startSize) !== null && _this$style$startSize !== void 0 ? _this$style$startSize : this.startSize;\n      this.endSize = (_this$style$endSize = this.style.endSize) !== null && _this$style$endSize !== void 0 ? _this$style$endSize : this.endSize;\n      this.startArrow = (_this$style$startArro = this.style.startArrow) !== null && _this$style$startArro !== void 0 ? _this$style$startArro : this.startArrow;\n      this.endArrow = (_this$style$endArrow = this.style.endArrow) !== null && _this$style$endArrow !== void 0 ? _this$style$endArrow : this.endArrow;\n      this.rotation = (_this$style$rotation = this.style.rotation) !== null && _this$style$rotation !== void 0 ? _this$style$rotation : this.rotation;\n      this.direction = (_this$style$direction2 = this.style.direction) !== null && _this$style$direction2 !== void 0 ? _this$style$direction2 : this.direction;\n      this.flipH = !!this.style.flipH;\n      this.flipV = !!this.style.flipV;\n      if (this.direction === DIRECTION.NORTH || this.direction === DIRECTION.SOUTH) {\n        const tmp = this.flipH;\n        this.flipH = this.flipV;\n        this.flipV = tmp;\n      }\n      this.isShadow = (_this$style$shadow = this.style.shadow) !== null && _this$style$shadow !== void 0 ? _this$style$shadow : this.isShadow;\n      this.isDashed = (_this$style$dashed = this.style.dashed) !== null && _this$style$dashed !== void 0 ? _this$style$dashed : this.isDashed;\n      this.isRounded = (_this$style$rounded = this.style.rounded) !== null && _this$style$rounded !== void 0 ? _this$style$rounded : this.isRounded;\n      this.glass = (_this$style$glass = this.style.glass) !== null && _this$style$glass !== void 0 ? _this$style$glass : this.glass;\n    }\n  }\n  /**\n   * Sets the cursor on the given shape.\n   *\n   * @param cursor The cursor to be used.\n   */\n  setCursor(cursor) {\n    this.cursor = cursor;\n    this.node.style.cursor = cursor;\n  }\n  /**\n   * Returns the current cursor.\n   */\n  getCursor() {\n    return this.cursor;\n  }\n  /**\n   * Hook for subclassers.\n   */\n  isRoundable(c, x, y, w, h) {\n    return false;\n  }\n  /**\n   * Updates the <boundingBox> for this shape using <createBoundingBox> and\n   * <augmentBoundingBox> and stores the result in <boundingBox>.\n   */\n  updateBoundingBox() {\n    // Tries to get bounding box from SVG subsystem\n    // LATER: Use getBoundingClientRect for fallback in VML\n    if (this.useSvgBoundingBox && this.node.ownerSVGElement) {\n      try {\n        const b = this.node.getBBox();\n        if (b.width > 0 && b.height > 0) {\n          var _this$strokeWidth3;\n          this.boundingBox = new Rectangle(b.x, b.y, b.width, b.height);\n          // Adds strokeWidth\n          this.boundingBox.grow(((_this$strokeWidth3 = this.strokeWidth) !== null && _this$strokeWidth3 !== void 0 ? _this$strokeWidth3 : 0) * this.scale / 2);\n          return;\n        }\n      } catch (e) {\n        // fallback to code below\n      }\n    }\n    if (this.bounds) {\n      let bbox = this.createBoundingBox();\n      if (bbox) {\n        this.augmentBoundingBox(bbox);\n        const rot = this.getShapeRotation();\n        if (rot !== 0) {\n          bbox = getBoundingBox(bbox, rot);\n        }\n      }\n      this.boundingBox = bbox;\n    }\n  }\n  /**\n   * Returns a new rectangle that represents the bounding box of the bare shape\n   * with no shadows or strokewidths.\n   */\n  createBoundingBox() {\n    if (!this.bounds) return null;\n    const bb = this.bounds.clone();\n    if (this.stencil && (this.direction === DIRECTION.NORTH || this.direction === DIRECTION.SOUTH) || this.isPaintBoundsInverted()) {\n      bb.rotate90();\n    }\n    return bb;\n  }\n  /**\n   * Augments the bounding box with the strokewidth and shadow offsets.\n   */\n  augmentBoundingBox(bbox) {\n    var _this$strokeWidth4;\n    if (this.isShadow) {\n      bbox.width += Math.ceil(SHADOW_OFFSET_X * this.scale);\n      bbox.height += Math.ceil(SHADOW_OFFSET_Y * this.scale);\n    }\n    // Adds strokeWidth\n    bbox.grow(((_this$strokeWidth4 = this.strokeWidth) !== null && _this$strokeWidth4 !== void 0 ? _this$strokeWidth4 : 0) * this.scale / 2);\n  }\n  /**\n   * Returns true if the bounds should be inverted.\n   */\n  isPaintBoundsInverted() {\n    // Stencil implements inversion via aspect\n    return !this.stencil && (this.direction === DIRECTION.NORTH || this.direction === DIRECTION.SOUTH);\n  }\n  /**\n   * Returns the rotation from the style.\n   */\n  getRotation() {\n    var _this$rotation;\n    return (_this$rotation = this.rotation) !== null && _this$rotation !== void 0 ? _this$rotation : 0;\n  }\n  /**\n   * Returns the rotation for the text label.\n   */\n  getTextRotation() {\n    var _this$style$horizonta, _this$style8;\n    let rot = this.getRotation();\n    if (!((_this$style$horizonta = (_this$style8 = this.style) === null || _this$style8 === void 0 ? void 0 : _this$style8.horizontal) !== null && _this$style$horizonta !== void 0 ? _this$style$horizonta : true)) {\n      rot += this.verticalTextRotation || -90; // WARNING WARNING!!!! ===============================================================================================\n    }\n    return rot;\n  }\n  /**\n   * Returns the actual rotation of the shape.\n   */\n  getShapeRotation() {\n    let rot = this.getRotation();\n    if (this.direction === DIRECTION.NORTH) {\n      rot += 270;\n    } else if (this.direction === DIRECTION.WEST) {\n      rot += 180;\n    } else if (this.direction === DIRECTION.SOUTH) {\n      rot += 90;\n    }\n    return rot;\n  }\n  /**\n   * Adds a transparent rectangle that catches all events.\n   */\n  createTransparentSvgRectangle(x, y, w, h) {\n    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n    rect.setAttribute('x', String(x));\n    rect.setAttribute('y', String(y));\n    rect.setAttribute('width', String(w));\n    rect.setAttribute('height', String(h));\n    rect.setAttribute('fill', NONE);\n    rect.setAttribute('stroke', NONE);\n    rect.setAttribute('pointer-events', 'all');\n    return rect;\n  }\n  redrawHtmlShape() {\n    return;\n  }\n  /**\n   * Sets a transparent background CSS style to catch all events.\n   *\n   * Paints the line shape.\n   */\n  setTransparentBackgroundImage(node) {\n    node.style.backgroundImage = \"url('\".concat(Client.imageBasePath, \"/transparent.gif')\");\n  }\n  /**\n   * Paints the line shape.\n   */\n  releaseSvgGradients(grads) {\n    for (const key in grads) {\n      const gradient = grads[key];\n      if (gradient) {\n        gradient.mxRefCount = (gradient.mxRefCount || 0) - 1;\n        if (gradient.mxRefCount === 0 && gradient.parentNode) {\n          gradient.parentNode.removeChild(gradient);\n        }\n      }\n    }\n  }\n  /**\n   * Destroys the shape by removing it from the DOM and releasing the DOM\n   * node associated with the shape using {@link Event#release}.\n   */\n  destroy() {\n    InternalEvent.release(this.node);\n    if (this.node.parentNode) {\n      this.node.parentNode.removeChild(this.node);\n    }\n    this.node.innerHTML = '';\n    // Decrements refCount and removes unused\n    this.releaseSvgGradients(this.oldGradients);\n    this.oldGradients = {};\n  }\n}\nexport default Shape;","map":{"version":3,"names":["Rectangle","isNotNullish","getBoundingBox","getDirectedBounds","mod","DIRECTION","LINE_ARCSIZE","NONE","RECTANGLE_ROUNDING_FACTOR","SHADOW_OFFSET_X","SHADOW_OFFSET_Y","Point","SvgCanvas2D","InternalEvent","Client","Shape","constructor","stencil","arguments","length","undefined","preserveImageAspect","overlay","indicator","indicatorShape","opacity","isDashed","fill","gradient","gradientDirection","EAST","fillOpacity","strokeOpacity","stroke","strokeWidth","spacing","startSize","endSize","startArrow","endArrow","direction","flipH","flipV","isShadow","isRounded","rotation","cursor","verticalTextRotation","oldGradients","glass","dialect","scale","antiAlias","minSvgStrokeWidth","bounds","points","state","style","boundingBox","svgStrokeTolerance","pointerEvents","originalPointerEvents","svgPointerEvents","shapePointerEvents","stencilPointerEvents","outline","visible","useSvgBoundingBox","image","imageSrc","indicatorColor","indicatorStrokeColor","indicatorGradientColor","indicatorDirection","indicatorImageSrc","node","create","init","container","parentNode","appendChild","initStyles","isHtmlAllowed","getSvgScreenOffset","_this$strokeWidth","sw","strokeWidthValue","Number","Math","max","round","document","createElementNS","reconfigure","redraw","updateBoundsFromPoints","checkBounds","visibility","clear","redrawShape","updateBoundingBox","lastChild","removeChild","pts","x","y","pt","add","getLabelBounds","rect","_this$style$direction","_this$style","d","clone","SOUTH","NORTH","text","isPaintBoundsInverted","width","height","labelMargins","getLabelMargins","_this$style$flipH","_this$style2","_this$style$flipV","_this$style3","tmp","isNaN","isFinite","canvas","createCanvas","beforePaint","paint","afterPaint","root","insertAdjacentHTML","outerHTML","destroyCanvas","createSvgCanvas","setStrokeWidth","setStrokeColor","setDashed","setFillColor","setGradient","strokeTolerance","pointerEventsValue","off","setAttribute","concat","removeAttribute","minStrokeWidth","format","value","key","gradients","mxRefCount","releaseSvgGradients","c","strokeDrawn","_len","args","Array","_key","apply","fillAndStroke","_len2","_key2","s","w","h","t","updateTransform","configureCanvas","bg","bb","createBoundingBox","createTransparentSvgRectangle","drawShape","i","p","push","paintEdgeShape","paintVertexShape","transform","dash","dashPattern","setAlpha","setFillAlpha","setStrokeAlpha","setShadow","_this$style$fixDash","_this$style4","fixDash","setDashPattern","b","getGradientBounds","rotate","getShapeRotation","_this$style$backgroun","paintBackground","backgroundOutline","paintForeground","getArcSize","_this$style$absoluteA","_this$style5","r","absoluteArcSize","_this$style$arcSize","_this$style6","min","arcSize","_this$style$arcSize2","_this$style7","f","paintGlassEffect","arc","_this$strokeWidth2","ceil","size","begin","moveTo","quadTo","lineTo","close","addPoints","rounded","exclude","initialMove","pe","slice","p0","wp","splice","dx","dy","indexOf","dist","sqrt","nx1","ny1","x1","y1","next","nx2","ny2","x2","y2","resetStyles","_this$style$fillColor","_this$style$gradientC","_this$style$gradientD","_this$style$opacity","_this$style$fillOpaci","_this$style$strokeOpa","_this$style$strokeCol","_this$style$strokeWid","_this$style$spacing","_this$style$startSize","_this$style$endSize","_this$style$startArro","_this$style$endArrow","_this$style$rotation","_this$style$direction2","_this$style$shadow","_this$style$dashed","_this$style$rounded","_this$style$glass","fillColor","gradientColor","strokeColor","shadow","dashed","setCursor","getCursor","isRoundable","ownerSVGElement","getBBox","_this$strokeWidth3","grow","e","bbox","augmentBoundingBox","rot","rotate90","_this$strokeWidth4","getRotation","_this$rotation","getTextRotation","_this$style$horizonta","_this$style8","horizontal","WEST","String","redrawHtmlShape","setTransparentBackgroundImage","backgroundImage","imageBasePath","grads","destroy","release","innerHTML"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/@maxgraph/core/dist/view/geometry/Shape.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from './Rectangle';\nimport { isNotNullish } from '../../util/Utils';\nimport { getBoundingBox, getDirectedBounds, mod } from '../../util/mathUtils';\nimport { DIRECTION, LINE_ARCSIZE, NONE, RECTANGLE_ROUNDING_FACTOR, SHADOW_OFFSET_X, SHADOW_OFFSET_Y, } from '../../util/Constants';\nimport Point from './Point';\nimport SvgCanvas2D from '../canvas/SvgCanvas2D';\nimport InternalEvent from '../event/InternalEvent';\nimport Client from '../../Client';\n/**\n * Base class for all shapes.\n * A shape in mxGraph is a separate implementation for SVG, VML and HTML.\n * Which implementation to use is controlled by the dialect property which\n * is assigned from within the mxCellRenderer when the shape is created.\n * The dialect must be assigned for a shape, and it does normally depend on\n * the browser and the configuration of the graph (see mxGraph rendering hint).\n *\n * For each supported shape in SVG and VML, a corresponding shape exists in\n * mxGraph, namely for text, image, rectangle, rhombus, ellipse and polyline.\n * The other shapes are a combination of these shapes (eg. label and swimlane)\n * or they consist of one or more (filled) path objects (eg. actor and cylinder).\n * The HTML implementation is optional but may be required for a HTML-only view\n * of the graph.\n *\n * ### Custom Shapes\n * To extend from this class, the basic code looks as follows.\n * In the special case where the custom shape consists only of one filled region\n * or one filled region and an additional stroke the mxActor and mxCylinder\n * should be subclassed, respectively.\n * ```javascript\n * function CustomShape() { }\n *\n * CustomShape.prototype = new mxShape();\n * CustomShape.prototype.constructor = CustomShape;\n * ```\n * To register a custom shape in an existing graph instance, one must register the\n * shape under a new name in the graphâ€™s cell renderer as follows:\n * ```javascript\n * mxCellRenderer.registerShape('customShape', CustomShape);\n * ```\n * The second argument is the name of the constructor.\n * In order to use the shape you can refer to the given name above in a stylesheet.\n * For example, to change the shape for the default vertex style, the following code\n * is used:\n * ```javascript\n * var style = graph.getStylesheet().getDefaultVertexStyle();\n * style.shape = 'customShape';\n * ```\n */\nclass Shape {\n    constructor(stencil = null) {\n        // Assigned in mxCellRenderer\n        this.preserveImageAspect = false;\n        this.overlay = null;\n        this.indicator = null;\n        this.indicatorShape = null;\n        // Assigned in mxCellHighlight\n        this.opacity = 100;\n        this.isDashed = false;\n        this.fill = NONE;\n        this.gradient = NONE;\n        this.gradientDirection = DIRECTION.EAST;\n        this.fillOpacity = 100;\n        this.strokeOpacity = 100;\n        this.stroke = NONE;\n        this.strokeWidth = 1;\n        this.spacing = 0;\n        this.startSize = 1;\n        this.endSize = 1;\n        this.startArrow = NONE;\n        this.endArrow = NONE;\n        this.direction = DIRECTION.EAST;\n        this.flipH = false;\n        this.flipV = false;\n        this.isShadow = false;\n        this.isRounded = false;\n        this.rotation = 0;\n        this.cursor = '';\n        this.verticalTextRotation = 0;\n        this.oldGradients = {};\n        this.glass = false;\n        /**\n         * Holds the dialect in which the shape is to be painted.\n         * This can be one of the DIALECT constants in {@link Constants}.\n         */\n        this.dialect = null;\n        /**\n         * Holds the scale in which the shape is being painted.\n         */\n        this.scale = 1;\n        /**\n         * Rendering hint for configuring the canvas.\n         */\n        this.antiAlias = true;\n        /**\n         * Minimum stroke width for SVG output.\n         */\n        this.minSvgStrokeWidth = 1;\n        /**\n         * Holds the {@link Rectangle} that specifies the bounds of this shape.\n         */\n        this.bounds = null;\n        /**\n         * Holds the array of <Point> that specify the points of this shape.\n         */\n        this.points = [];\n        /**\n         * Optional reference to the corresponding <CellState>.\n         */\n        this.state = null;\n        /**\n         * Optional reference to the style of the corresponding <CellState>.\n         */\n        this.style = null;\n        /**\n         * Contains the bounding box of the shape, that is, the smallest rectangle\n         * that includes all pixels of the shape.\n         */\n        this.boundingBox = null;\n        /**\n         * Holds the {@link Stencil} that defines the shape.\n         */\n        this.stencil = null;\n        /**\n         * Event-tolerance for SVG strokes (in px). Default is 8. This is only passed\n         * to the canvas in <createSvgCanvas> if <pointerEvents> is true.\n         */\n        this.svgStrokeTolerance = 8;\n        /**\n         * Specifies if pointer events should be handled. Default is true.\n         */\n        this.pointerEvents = true;\n        this.originalPointerEvents = null;\n        /**\n         * Specifies if pointer events should be handled. Default is true.\n         */\n        this.svgPointerEvents = 'all';\n        /**\n         * Specifies if pointer events outside of shape should be handled. Default\n         * is false.\n         */\n        this.shapePointerEvents = false;\n        /**\n         * Specifies if pointer events outside of stencils should be handled. Default\n         * is false. Set this to true for backwards compatibility with the 1.x branch.\n         */\n        this.stencilPointerEvents = false;\n        /**\n         * Specifies if the shape should be drawn as an outline. This disables all\n         * fill colors and can be used to disable other drawing states that should\n         * not be painted for outlines. Default is false. This should be set before\n         * calling <apply>.\n         */\n        this.outline = false;\n        /**\n         * Specifies if the shape is visible. Default is true.\n         */\n        this.visible = true;\n        /**\n         * Allows to use the SVG bounding box in SVG. Default is false for performance\n         * reasons.\n         */\n        this.useSvgBoundingBox = true;\n        this.image = null;\n        this.imageSrc = null;\n        this.indicatorColor = NONE;\n        this.indicatorStrokeColor = NONE;\n        this.indicatorGradientColor = NONE;\n        this.indicatorDirection = DIRECTION.EAST;\n        this.indicatorImageSrc = null;\n        // `stencil` is not null when instantiated directly,\n        // but can be null when instantiated through a child class.\n        if (stencil) {\n            this.stencil = stencil;\n        }\n        // moved from init()\n        this.node = this.create();\n    }\n    /**\n     * Initializes the shape by creaing the DOM node using <create>\n     * and adding it into the given container.\n     *\n     * @param container DOM node that will contain the shape.\n     */\n    init(container) {\n        if (!this.node.parentNode) {\n            container.appendChild(this.node);\n        }\n    }\n    /**\n     * Sets the styles to their default values.\n     */\n    initStyles() {\n        this.strokeWidth = 1;\n        this.rotation = 0;\n        this.opacity = 100;\n        this.fillOpacity = 100;\n        this.strokeOpacity = 100;\n        this.flipH = false;\n        this.flipV = false;\n    }\n    /**\n     * Returns true if HTML is allowed for this shape. This implementation always\n     * returns false.\n     */\n    isHtmlAllowed() {\n        return false;\n    }\n    /**\n     * Returns 0, or 0.5 if <strokewidth> % 2 == 1.\n     */\n    getSvgScreenOffset() {\n        const sw = this.stencil && this.stencil.strokeWidthValue !== 'inherit'\n            ? Number(this.stencil.strokeWidthValue)\n            : this.strokeWidth ?? 0;\n        return mod(Math.max(1, Math.round(sw * this.scale)), 2) === 1 ? 0.5 : 0;\n    }\n    /**\n     * Creates and returns the DOM node(s) for the shape in\n     * the given container. This implementation invokes\n     * <createSvg>, <createHtml> or <createVml> depending\n     * on the <dialect> and style settings.\n     *\n     * @param container DOM node that will contain the shape.\n     */\n    create() {\n        return document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    }\n    /**\n     * Reconfigures this shape. This will update the colors etc in\n     * addition to the bounds or points.\n     */\n    reconfigure() {\n        this.redraw();\n    }\n    /**\n     * Creates and returns the SVG node(s) to represent this shape.\n     */\n    redraw() {\n        this.updateBoundsFromPoints();\n        if (this.visible && this.checkBounds()) {\n            this.node.style.visibility = 'visible';\n            this.clear();\n            this.redrawShape();\n            this.updateBoundingBox();\n        }\n        else {\n            this.node.style.visibility = 'hidden';\n            this.boundingBox = null;\n        }\n    }\n    /**\n     * Removes all child nodes and resets all CSS.\n     */\n    clear() {\n        while (this.node.lastChild) {\n            this.node.removeChild(this.node.lastChild);\n        }\n    }\n    /**\n     * Updates the bounds based on the points.\n     */\n    updateBoundsFromPoints() {\n        const pts = this.points;\n        if (pts.length > 0 && pts[0]) {\n            this.bounds = new Rectangle(Math.round(pts[0].x), Math.round(pts[0].y), 1, 1);\n            for (const pt of pts) {\n                if (pt) {\n                    this.bounds.add(new Rectangle(Math.round(pt.x), Math.round(pt.y), 1, 1));\n                }\n            }\n        }\n    }\n    /**\n     * Returns the {@link Rectangle} for the label bounds of this shape, based on the\n     * given scaled and translated bounds of the shape. This method should not\n     * change the rectangle in-place. This implementation returns the given rect.\n     */\n    getLabelBounds(rect) {\n        const d = this.style?.direction ?? DIRECTION.EAST;\n        let bounds = rect.clone();\n        // Normalizes argument for getLabelMargins hook\n        if (d !== DIRECTION.SOUTH &&\n            d !== DIRECTION.NORTH &&\n            this.state &&\n            this.state.text &&\n            this.state.text.isPaintBoundsInverted()) {\n            bounds = bounds.clone();\n            [bounds.width, bounds.height] = [bounds.height, bounds.width];\n        }\n        let labelMargins = this.getLabelMargins(bounds);\n        if (labelMargins) {\n            labelMargins = labelMargins.clone();\n            let flipH = this.style?.flipH ?? false;\n            let flipV = this.style?.flipV ?? false;\n            // Handles special case for vertical labels\n            if (this.state && this.state.text && this.state.text.isPaintBoundsInverted()) {\n                const tmp = labelMargins.x;\n                labelMargins.x = labelMargins.height;\n                labelMargins.height = labelMargins.width;\n                labelMargins.width = labelMargins.y;\n                labelMargins.y = tmp;\n                [flipH, flipV] = [flipV, flipH];\n            }\n            return getDirectedBounds(rect, labelMargins, this.style, flipH, flipV);\n        }\n        return rect;\n    }\n    /**\n     * Returns the scaled top, left, bottom and right margin to be used for\n     * computing the label bounds as an {@link Rectangle}, where the bottom and right\n     * margin are defined in the width and height of the rectangle, respectively.\n     */\n    getLabelMargins(rect) {\n        return null;\n    }\n    /**\n     * Returns true if the bounds are not null and all of its variables are numeric.\n     */\n    checkBounds() {\n        return (!Number.isNaN(this.scale) &&\n            Number.isFinite(this.scale) &&\n            this.scale > 0 &&\n            this.bounds &&\n            !Number.isNaN(this.bounds.x) &&\n            !Number.isNaN(this.bounds.y) &&\n            !Number.isNaN(this.bounds.width) &&\n            !Number.isNaN(this.bounds.height) &&\n            this.bounds.width > 0 &&\n            this.bounds.height > 0);\n    }\n    /**\n     * Updates the SVG or VML shape.\n     */\n    redrawShape() {\n        const canvas = this.createCanvas();\n        if (canvas) {\n            // Specifies if events should be handled\n            canvas.pointerEvents = this.pointerEvents;\n            this.beforePaint(canvas);\n            this.paint(canvas);\n            this.afterPaint(canvas);\n            if (this.node !== canvas.root && canvas.root) {\n                // Forces parsing in IE8 standards mode - slow! avoid\n                this.node.insertAdjacentHTML('beforeend', canvas.root.outerHTML);\n            }\n            this.destroyCanvas(canvas);\n        }\n    }\n    /**\n     * Creates a new canvas for drawing this shape. May return null.\n     */\n    createCanvas() {\n        const canvas = this.createSvgCanvas();\n        if (canvas && this.outline) {\n            canvas.setStrokeWidth(this.strokeWidth);\n            canvas.setStrokeColor(this.stroke);\n            if (this.isDashed) {\n                canvas.setDashed(this.isDashed);\n            }\n            canvas.setStrokeWidth = () => {\n                return;\n            };\n            canvas.setStrokeColor = () => {\n                return;\n            };\n            canvas.setFillColor = () => {\n                return;\n            };\n            canvas.setGradient = () => {\n                return;\n            };\n            canvas.setDashed = () => {\n                return;\n            };\n            canvas.text = () => {\n                return;\n            };\n        }\n        return canvas;\n    }\n    /**\n     * Creates and returns an <mxSvgCanvas2D> for rendering this shape.\n     */\n    createSvgCanvas() {\n        if (!this.node)\n            return null;\n        const canvas = new SvgCanvas2D(this.node, false);\n        canvas.strokeTolerance = this.pointerEvents ? this.svgStrokeTolerance : 0;\n        canvas.pointerEventsValue = this.svgPointerEvents;\n        const off = this.getSvgScreenOffset();\n        if (off !== 0) {\n            this.node.setAttribute('transform', `translate(${off},${off})`);\n        }\n        else {\n            this.node.removeAttribute('transform');\n        }\n        canvas.minStrokeWidth = this.minSvgStrokeWidth;\n        if (!this.antiAlias) {\n            // Rounds all numbers in the SVG output to integers\n            canvas.format = (value) => {\n                return Math.round(value);\n            };\n        }\n        return canvas;\n    }\n    /**\n     * Destroys the given canvas which was used for drawing. This implementation\n     * increments the reference counts on all shared gradients used in the canvas.\n     */\n    destroyCanvas(canvas) {\n        // Manages reference counts\n        if (canvas instanceof SvgCanvas2D) {\n            // Increments ref counts\n            for (const key in canvas.gradients) {\n                const gradient = canvas.gradients[key];\n                if (gradient) {\n                    gradient.mxRefCount = (gradient.mxRefCount || 0) + 1;\n                }\n            }\n            this.releaseSvgGradients(this.oldGradients);\n            this.oldGradients = canvas.gradients;\n        }\n    }\n    /**\n     * Invoked before paint is called.\n     */\n    beforePaint(c) {\n        return;\n    }\n    /**\n     * Invokes after paint was called.\n     */\n    afterPaint(c) {\n        return;\n    }\n    /**\n     * Generic rendering code.\n     */\n    paint(c) {\n        let strokeDrawn = false;\n        if (c && this.outline) {\n            const { stroke } = c;\n            c.stroke = (...args) => {\n                strokeDrawn = true;\n                stroke.apply(c, args);\n            };\n            const { fillAndStroke } = c;\n            c.fillAndStroke = (...args) => {\n                strokeDrawn = true;\n                fillAndStroke.apply(c, args);\n            };\n        }\n        // Scale is passed-through to canvas\n        const s = this.scale;\n        const bounds = this.bounds;\n        if (bounds) {\n            let x = bounds.x / s;\n            let y = bounds.y / s;\n            let w = bounds.width / s;\n            let h = bounds.height / s;\n            if (this.isPaintBoundsInverted()) {\n                const t = (w - h) / 2;\n                x += t;\n                y -= t;\n                const tmp = w;\n                w = h;\n                h = tmp;\n            }\n            this.updateTransform(c, x, y, w, h);\n            this.configureCanvas(c, x, y, w, h);\n            // Adds background rectangle to capture events\n            let bg = null;\n            if ((!this.stencil && this.points.length === 0 && this.shapePointerEvents) ||\n                (this.stencil && this.stencilPointerEvents)) {\n                const bb = this.createBoundingBox();\n                if (bb && this.node) {\n                    bg = this.createTransparentSvgRectangle(bb.x, bb.y, bb.width, bb.height);\n                    this.node.appendChild(bg);\n                }\n            }\n            if (this.stencil) {\n                this.stencil.drawShape(c, this, x, y, w, h);\n            }\n            else {\n                // Stencils have separate strokewidth\n                c.setStrokeWidth(this.strokeWidth);\n                if (this.points.length > 0) {\n                    // Paints edge shape\n                    const pts = [];\n                    for (let i = 0; i < this.points.length; i += 1) {\n                        const p = this.points[i];\n                        if (p) {\n                            pts.push(new Point(p.x / s, p.y / s));\n                        }\n                    }\n                    this.paintEdgeShape(c, pts);\n                }\n                else {\n                    // Paints vertex shape\n                    this.paintVertexShape(c, x, y, w, h);\n                }\n            }\n            if (bg && c.state && isNotNullish(c.state.transform)) {\n                bg.setAttribute('transform', c.state.transform);\n            }\n            // Draws highlight rectangle if no stroke was used\n            if (c && this.outline && !strokeDrawn) {\n                c.rect(x, y, w, h);\n                c.stroke();\n            }\n        }\n    }\n    /**\n     * Sets the state of the canvas for drawing the shape.\n     */\n    configureCanvas(c, x, y, w, h) {\n        let dash = null;\n        if (this.style && this.style.dashPattern != null) {\n            dash = this.style.dashPattern;\n        }\n        c.setAlpha(this.opacity / 100);\n        c.setFillAlpha(this.fillOpacity / 100);\n        c.setStrokeAlpha(this.strokeOpacity / 100);\n        // Sets alpha, colors and gradients\n        if (this.isShadow) {\n            c.setShadow(this.isShadow);\n        }\n        // Dash pattern\n        if (this.isDashed) {\n            c.setDashed(this.isDashed, this.style?.fixDash ?? false);\n        }\n        if (dash) {\n            c.setDashPattern(dash);\n        }\n        if (this.fill !== NONE && this.gradient !== NONE) {\n            const b = this.getGradientBounds(c, x, y, w, h);\n            c.setGradient(this.fill, this.gradient, b.x, b.y, b.width, b.height, this.gradientDirection);\n        }\n        else {\n            c.setFillColor(this.fill);\n        }\n        c.setStrokeColor(this.stroke);\n    }\n    /**\n     * Returns the bounding box for the gradient box for this shape.\n     */\n    getGradientBounds(c, x, y, w, h) {\n        return new Rectangle(x, y, w, h);\n    }\n    /**\n     * Sets the scale and rotation on the given canvas.\n     */\n    updateTransform(c, x, y, w, h) {\n        // NOTE: Currently, scale is implemented in state and canvas. This will\n        // move to canvas in a later version, so that the states are unscaled\n        // and untranslated and do not need an update after zooming or panning.\n        c.scale(this.scale);\n        c.rotate(this.getShapeRotation(), this.flipH, this.flipV, x + w / 2, y + h / 2);\n    }\n    /**\n     * Paints the vertex shape.\n     */\n    paintVertexShape(c, x, y, w, h) {\n        this.paintBackground(c, x, y, w, h);\n        if (!this.outline || !this.style || !(this.style.backgroundOutline ?? false)) {\n            c.setShadow(false);\n            this.paintForeground(c, x, y, w, h);\n        }\n    }\n    /**\n     * Hook for subclassers. This implementation is empty.\n     */\n    paintBackground(c, x, y, w, h) {\n        return;\n    }\n    /**\n     * Hook for subclassers. This implementation is empty.\n     */\n    paintForeground(c, x, y, w, h) {\n        return;\n    }\n    /**\n     * Hook for subclassers. This implementation is empty.\n     */\n    paintEdgeShape(c, pts) {\n        return;\n    }\n    /**\n     * Returns the arc size for the given dimension.\n     */\n    getArcSize(w, h) {\n        let r = 0;\n        if (this.style?.absoluteArcSize ?? false) {\n            r = Math.min(w / 2, Math.min(h / 2, (this.style?.arcSize ?? LINE_ARCSIZE) / 2));\n        }\n        else {\n            const f = (this.style?.arcSize ?? RECTANGLE_ROUNDING_FACTOR * 100) / 100;\n            r = Math.min(w * f, h * f);\n        }\n        return r;\n    }\n    /**\n     * Paints the glass gradient effect.\n     */\n    paintGlassEffect(c, x, y, w, h, arc) {\n        const sw = Math.ceil((this.strokeWidth ?? 0) / 2);\n        const size = 0.4;\n        c.setGradient('#ffffff', '#ffffff', x, y, w, h * 0.6, 'south', 0.9, 0.1);\n        c.begin();\n        arc += 2 * sw;\n        if (this.isRounded) {\n            c.moveTo(x - sw + arc, y - sw);\n            c.quadTo(x - sw, y - sw, x - sw, y - sw + arc);\n            c.lineTo(x - sw, y + h * size);\n            c.quadTo(x + w * 0.5, y + h * 0.7, x + w + sw, y + h * size);\n            c.lineTo(x + w + sw, y - sw + arc);\n            c.quadTo(x + w + sw, y - sw, x + w + sw - arc, y - sw);\n        }\n        else {\n            c.moveTo(x - sw, y - sw);\n            c.lineTo(x - sw, y + h * size);\n            c.quadTo(x + w * 0.5, y + h * 0.7, x + w + sw, y + h * size);\n            c.lineTo(x + w + sw, y - sw);\n        }\n        c.close();\n        c.fill();\n    }\n    /**\n     * Paints the given points with rounded corners.\n     */\n    addPoints(c, pts, rounded = false, arcSize, close = false, exclude = [], initialMove = true) {\n        if (pts.length > 0) {\n            const pe = pts[pts.length - 1];\n            // Adds virtual waypoint in the center between start and end point\n            if (close && rounded) {\n                pts = pts.slice();\n                const p0 = pts[0];\n                const wp = new Point(pe.x + (p0.x - pe.x) / 2, pe.y + (p0.y - pe.y) / 2);\n                pts.splice(0, 0, wp);\n            }\n            let pt = pts[0];\n            let i = 1;\n            // Draws the line segments\n            if (initialMove) {\n                c.moveTo(pt.x, pt.y);\n            }\n            else {\n                c.lineTo(pt.x, pt.y);\n            }\n            while (i < (close ? pts.length : pts.length - 1)) {\n                let tmp = pts[mod(i, pts.length)];\n                let dx = pt.x - tmp.x;\n                let dy = pt.y - tmp.y;\n                if (rounded && (dx !== 0 || dy !== 0) && exclude.indexOf(i - 1) < 0) {\n                    // Draws a line from the last point to the current\n                    // point with a spacing of size off the current point\n                    // into direction of the last point\n                    let dist = Math.sqrt(dx * dx + dy * dy);\n                    const nx1 = (dx * Math.min(arcSize, dist / 2)) / dist;\n                    const ny1 = (dy * Math.min(arcSize, dist / 2)) / dist;\n                    const x1 = tmp.x + nx1;\n                    const y1 = tmp.y + ny1;\n                    c.lineTo(x1, y1);\n                    // Draws a curve from the last point to the current\n                    // point with a spacing of size off the current point\n                    // into direction of the next point\n                    let next = pts[mod(i + 1, pts.length)];\n                    // Uses next non-overlapping point\n                    while (i < pts.length - 2 &&\n                        Math.round(next.x - tmp.x) === 0 &&\n                        Math.round(next.y - tmp.y) === 0) {\n                        next = pts[mod(i + 2, pts.length)];\n                        i++;\n                    }\n                    dx = next.x - tmp.x;\n                    dy = next.y - tmp.y;\n                    dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));\n                    const nx2 = (dx * Math.min(arcSize, dist / 2)) / dist;\n                    const ny2 = (dy * Math.min(arcSize, dist / 2)) / dist;\n                    const x2 = tmp.x + nx2;\n                    const y2 = tmp.y + ny2;\n                    c.quadTo(tmp.x, tmp.y, x2, y2);\n                    tmp = new Point(x2, y2);\n                }\n                else {\n                    c.lineTo(tmp.x, tmp.y);\n                }\n                pt = tmp;\n                i += 1;\n            }\n            if (close) {\n                c.close();\n            }\n            else {\n                c.lineTo(pe.x, pe.y);\n            }\n        }\n    }\n    /**\n     * Resets all styles.\n     */\n    resetStyles() {\n        this.initStyles();\n        this.spacing = 0;\n        this.fill = NONE;\n        this.gradient = NONE;\n        this.gradientDirection = DIRECTION.EAST;\n        this.stroke = NONE;\n        this.startSize = 1;\n        this.endSize = 1;\n        this.startArrow = NONE;\n        this.endArrow = NONE;\n        this.direction = DIRECTION.EAST;\n        this.isShadow = false;\n        this.isDashed = false;\n        this.isRounded = false;\n        this.glass = false;\n    }\n    /**\n     * Applies the style of the given <CellState> to the shape. This\n     * implementation assigns the following styles to local fields:\n     *\n     * - <'fillColor'> => fill\n     * - <'gradientColor'> => gradient\n     * - <'gradientDirection'> => gradientDirection\n     * - <'opacity'> => opacity\n     * - {@link Constants#STYLE_FILL_OPACITY} => fillOpacity\n     * - {@link Constants#STYLE_STROKE_OPACITY} => strokeOpacity\n     * - <'strokeColor'> => stroke\n     * - <'strokeWidth'> => strokewidth\n     * - <'shadow'> => isShadow\n     * - <'dashed'> => isDashed\n     * - <'spacing'> => spacing\n     * - <'startSize'> => startSize\n     * - <'endSize'> => endSize\n     * - <'rounded'> => isRounded\n     * - <'startArrow'> => startArrow\n     * - <'endArrow'> => endArrow\n     * - <'rotation'> => rotation\n     * - <'direction'> => direction\n     * - <'glass'> => glass\n     *\n     * This keeps a reference to the <style>. If you need to keep a reference to\n     * the cell, you can override this method and store a local reference to\n     * state.cell or the <CellState> itself. If <outline> should be true, make\n     * sure to set it before calling this method.\n     *\n     * @param state <CellState> of the corresponding cell.\n     */\n    apply(state) {\n        this.state = state;\n        this.style = state.style;\n        if (this.style) {\n            this.fill = this.style.fillColor ?? this.fill;\n            this.gradient = this.style.gradientColor ?? this.gradient;\n            this.gradientDirection = this.style.gradientDirection ?? this.gradientDirection;\n            this.opacity = this.style.opacity ?? this.opacity;\n            this.fillOpacity = this.style.fillOpacity ?? this.fillOpacity;\n            this.strokeOpacity = this.style.strokeOpacity ?? this.strokeOpacity;\n            this.stroke = this.style.strokeColor ?? this.stroke;\n            this.strokeWidth = this.style.strokeWidth ?? this.strokeWidth;\n            this.spacing = this.style.spacing ?? this.spacing;\n            this.startSize = this.style.startSize ?? this.startSize;\n            this.endSize = this.style.endSize ?? this.endSize;\n            this.startArrow = this.style.startArrow ?? this.startArrow;\n            this.endArrow = this.style.endArrow ?? this.endArrow;\n            this.rotation = this.style.rotation ?? this.rotation;\n            this.direction = this.style.direction ?? this.direction;\n            this.flipH = !!this.style.flipH;\n            this.flipV = !!this.style.flipV;\n            if (this.direction === DIRECTION.NORTH || this.direction === DIRECTION.SOUTH) {\n                const tmp = this.flipH;\n                this.flipH = this.flipV;\n                this.flipV = tmp;\n            }\n            this.isShadow = this.style.shadow ?? this.isShadow;\n            this.isDashed = this.style.dashed ?? this.isDashed;\n            this.isRounded = this.style.rounded ?? this.isRounded;\n            this.glass = this.style.glass ?? this.glass;\n        }\n    }\n    /**\n     * Sets the cursor on the given shape.\n     *\n     * @param cursor The cursor to be used.\n     */\n    setCursor(cursor) {\n        this.cursor = cursor;\n        this.node.style.cursor = cursor;\n    }\n    /**\n     * Returns the current cursor.\n     */\n    getCursor() {\n        return this.cursor;\n    }\n    /**\n     * Hook for subclassers.\n     */\n    isRoundable(c, x, y, w, h) {\n        return false;\n    }\n    /**\n     * Updates the <boundingBox> for this shape using <createBoundingBox> and\n     * <augmentBoundingBox> and stores the result in <boundingBox>.\n     */\n    updateBoundingBox() {\n        // Tries to get bounding box from SVG subsystem\n        // LATER: Use getBoundingClientRect for fallback in VML\n        if (this.useSvgBoundingBox && this.node.ownerSVGElement) {\n            try {\n                const b = this.node.getBBox();\n                if (b.width > 0 && b.height > 0) {\n                    this.boundingBox = new Rectangle(b.x, b.y, b.width, b.height);\n                    // Adds strokeWidth\n                    this.boundingBox.grow(((this.strokeWidth ?? 0) * this.scale) / 2);\n                    return;\n                }\n            }\n            catch (e) {\n                // fallback to code below\n            }\n        }\n        if (this.bounds) {\n            let bbox = this.createBoundingBox();\n            if (bbox) {\n                this.augmentBoundingBox(bbox);\n                const rot = this.getShapeRotation();\n                if (rot !== 0) {\n                    bbox = getBoundingBox(bbox, rot);\n                }\n            }\n            this.boundingBox = bbox;\n        }\n    }\n    /**\n     * Returns a new rectangle that represents the bounding box of the bare shape\n     * with no shadows or strokewidths.\n     */\n    createBoundingBox() {\n        if (!this.bounds)\n            return null;\n        const bb = this.bounds.clone();\n        if ((this.stencil &&\n            (this.direction === DIRECTION.NORTH || this.direction === DIRECTION.SOUTH)) ||\n            this.isPaintBoundsInverted()) {\n            bb.rotate90();\n        }\n        return bb;\n    }\n    /**\n     * Augments the bounding box with the strokewidth and shadow offsets.\n     */\n    augmentBoundingBox(bbox) {\n        if (this.isShadow) {\n            bbox.width += Math.ceil(SHADOW_OFFSET_X * this.scale);\n            bbox.height += Math.ceil(SHADOW_OFFSET_Y * this.scale);\n        }\n        // Adds strokeWidth\n        bbox.grow(((this.strokeWidth ?? 0) * this.scale) / 2);\n    }\n    /**\n     * Returns true if the bounds should be inverted.\n     */\n    isPaintBoundsInverted() {\n        // Stencil implements inversion via aspect\n        return (!this.stencil &&\n            (this.direction === DIRECTION.NORTH || this.direction === DIRECTION.SOUTH));\n    }\n    /**\n     * Returns the rotation from the style.\n     */\n    getRotation() {\n        return this.rotation ?? 0;\n    }\n    /**\n     * Returns the rotation for the text label.\n     */\n    getTextRotation() {\n        let rot = this.getRotation();\n        if (!(this.style?.horizontal ?? true)) {\n            rot += this.verticalTextRotation || -90; // WARNING WARNING!!!! ===============================================================================================\n        }\n        return rot;\n    }\n    /**\n     * Returns the actual rotation of the shape.\n     */\n    getShapeRotation() {\n        let rot = this.getRotation();\n        if (this.direction === DIRECTION.NORTH) {\n            rot += 270;\n        }\n        else if (this.direction === DIRECTION.WEST) {\n            rot += 180;\n        }\n        else if (this.direction === DIRECTION.SOUTH) {\n            rot += 90;\n        }\n        return rot;\n    }\n    /**\n     * Adds a transparent rectangle that catches all events.\n     */\n    createTransparentSvgRectangle(x, y, w, h) {\n        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n        rect.setAttribute('x', String(x));\n        rect.setAttribute('y', String(y));\n        rect.setAttribute('width', String(w));\n        rect.setAttribute('height', String(h));\n        rect.setAttribute('fill', NONE);\n        rect.setAttribute('stroke', NONE);\n        rect.setAttribute('pointer-events', 'all');\n        return rect;\n    }\n    redrawHtmlShape() {\n        return;\n    }\n    /**\n     * Sets a transparent background CSS style to catch all events.\n     *\n     * Paints the line shape.\n     */\n    setTransparentBackgroundImage(node) {\n        node.style.backgroundImage = `url('${Client.imageBasePath}/transparent.gif')`;\n    }\n    /**\n     * Paints the line shape.\n     */\n    releaseSvgGradients(grads) {\n        for (const key in grads) {\n            const gradient = grads[key];\n            if (gradient) {\n                gradient.mxRefCount = (gradient.mxRefCount || 0) - 1;\n                if (gradient.mxRefCount === 0 && gradient.parentNode) {\n                    gradient.parentNode.removeChild(gradient);\n                }\n            }\n        }\n    }\n    /**\n     * Destroys the shape by removing it from the DOM and releasing the DOM\n     * node associated with the shape using {@link Event#release}.\n     */\n    destroy() {\n        InternalEvent.release(this.node);\n        if (this.node.parentNode) {\n            this.node.parentNode.removeChild(this.node);\n        }\n        this.node.innerHTML = '';\n        // Decrements refCount and removes unused\n        this.releaseSvgGradients(this.oldGradients);\n        this.oldGradients = {};\n    }\n}\nexport default Shape;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}