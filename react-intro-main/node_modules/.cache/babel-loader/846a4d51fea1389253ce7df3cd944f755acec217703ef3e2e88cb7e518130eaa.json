{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport InternalEvent from '../event/InternalEvent';\nimport { fit, getScrollOrigin } from '../../util/styleUtils';\nimport { TOOLTIP_VERTICAL_OFFSET } from '../../util/Constants';\nimport { getSource, isMouseEvent } from '../../util/EventUtils';\nimport { isNode } from '../../util/domUtils';\n/**\n * Graph event handler that displays tooltips.\n *\n * {@link Graph#getTooltip} is used to get the tooltip for a cell or handle.\n *\n * This handler is generally enabled using {@link Graph#setTooltips}.\n */\nclass TooltipHandler {\n  /**\n   * Constructs an event handler that displays tooltips.\n   *\n   * @param graph Reference to the enclosing {@link Graph}.\n   */\n  constructor(graph) {\n    /**\n     * Specifies the zIndex for the tooltip and its shadow.\n     * @default 10005\n     */\n    this.zIndex = 10005;\n    /**\n     * Delay to show the tooltip in milliseconds.\n     * @default 500\n     */\n    this.delay = 500;\n    /**\n     * Specifies if touch and pen events should be ignored.\n     * @default true\n     */\n    this.ignoreTouchEvents = true;\n    /**\n     * Specifies if the tooltip should be hidden if the mouse is moved over the current cell.\n     * @default false\n     */\n    this.hideOnHover = false;\n    /**\n     * `true` if this handler was destroyed using {@link onDestroy}.\n     */\n    this.destroyed = false;\n    this.lastX = 0;\n    this.lastY = 0;\n    this.state = null;\n    this.stateSource = false;\n    this.thread = null;\n    /**\n     * Specifies if events are handled.\n     * @default false\n     */\n    this.enabled = false;\n    this.graph = graph;\n    this.graph.addMouseListener(this);\n    this.div = document.createElement('div');\n    this.div.className = 'mxTooltip';\n    this.div.style.visibility = 'hidden';\n    document.body.appendChild(this.div);\n    InternalEvent.addGestureListeners(this.div, evt => {\n      const source = getSource(evt);\n      // @ts-ignore nodeName may exist\n      if (source && source.nodeName !== 'A') {\n        this.hideTooltip();\n      }\n    });\n    // Hides tooltips and resets tooltip timer if mouse leaves container\n    InternalEvent.addListener(this.graph.getContainer(), 'mouseleave', evt => {\n      if (this.div !== evt.relatedTarget) {\n        this.hide();\n      }\n    });\n  }\n  /**\n   * Returns `true` if events are handled.\n   *\n   * This implementation returns {@link enabled}.\n   */\n  isEnabled() {\n    return this.enabled;\n  }\n  /**\n   * Enables or disables event handling.\n   *\n   * This implementation updates {@link enabled}.\n   */\n  setEnabled(enabled) {\n    this.enabled = enabled;\n  }\n  /**\n   * Returns {@link hideOnHover}.\n   */\n  isHideOnHover() {\n    return this.hideOnHover;\n  }\n  /**\n   * Sets <hideOnHover>.\n   */\n  setHideOnHover(value) {\n    this.hideOnHover = value;\n  }\n  /**\n   * Returns the <CellState> to be used for showing a tooltip for this event.\n   */\n  getStateForEvent(me) {\n    return me.getState();\n  }\n  /**\n   * Handles the event by initiating a rubberband selection. By consuming the\n   * event all subsequent events of the gesture are redirected to this\n   * handler.\n   */\n  mouseDown(sender, me) {\n    this.reset(me, false);\n    this.hideTooltip();\n  }\n  /**\n   * Handles the event by updating the rubberband selection.\n   */\n  mouseMove(sender, me) {\n    if (me.getX() !== this.lastX || me.getY() !== this.lastY) {\n      this.reset(me, true);\n      const state = this.getStateForEvent(me);\n      if (this.isHideOnHover() || state !== this.state || me.getSource() !== this.node && (!this.stateSource || state != null && this.stateSource === (me.isSource(state.shape) || !me.isSource(state.text)))) {\n        this.hideTooltip();\n      }\n    }\n    this.lastX = me.getX();\n    this.lastY = me.getY();\n  }\n  /**\n   * Handles the event by resetting the tooltip timer or hiding the existing\n   * tooltip.\n   */\n  mouseUp(sender, me) {\n    this.reset(me, true);\n    this.hideTooltip();\n  }\n  /**\n   * Resets the timer.\n   */\n  resetTimer() {\n    if (this.thread) {\n      window.clearTimeout(this.thread);\n      this.thread = null;\n    }\n  }\n  /**\n   * Resets and/or restarts the timer to trigger the display of the tooltip.\n   */\n  reset(me, restart, state = null) {\n    if (!this.ignoreTouchEvents || isMouseEvent(me.getEvent())) {\n      this.resetTimer();\n      state = state ?? this.getStateForEvent(me);\n      if (restart && this.isEnabled() && state && this.div.style.visibility === 'hidden') {\n        const node = me.getSource();\n        const x = me.getX();\n        const y = me.getY();\n        const stateSource = me.isSource(state.shape) || me.isSource(state.text);\n        const popupMenuHandler = this.graph.getPlugin('PopupMenuHandler');\n        this.thread = window.setTimeout(() => {\n          if (state && node && !this.graph.isEditing() && popupMenuHandler && !popupMenuHandler.isMenuShowing() && !this.graph.isMouseDown) {\n            // Uses information from inside event cause using the event at\n            // this (delayed) point in time is not possible in IE as it no\n            // longer contains the required information (member not found)\n            const tip = this.graph.getTooltip(state, node, x, y);\n            this.show(tip, x, y);\n            this.state = state;\n            this.node = node;\n            this.stateSource = stateSource;\n          }\n        }, this.delay);\n      }\n    }\n  }\n  /**\n   * Hides the tooltip and resets the timer.\n   */\n  hide() {\n    this.resetTimer();\n    this.hideTooltip();\n  }\n  /**\n   * Hides the tooltip.\n   */\n  hideTooltip() {\n    this.div.style.visibility = 'hidden';\n    this.div.innerHTML = '';\n  }\n  /**\n   * Shows the tooltip for the specified cell and optional index at the\n   * specified location (with a vertical offset of 10 pixels).\n   */\n  show(tip, x, y) {\n    if (!this.destroyed && tip && tip !== '') {\n      const origin = getScrollOrigin();\n      this.div.style.zIndex = String(this.zIndex);\n      this.div.style.left = `${x + origin.x}px`;\n      this.div.style.top = `${y + TOOLTIP_VERTICAL_OFFSET + origin.y}px`;\n      if (!isNode(tip)) {\n        this.div.innerHTML = tip.replace(/\\n/g, '<br>');\n      } else {\n        this.div.innerHTML = '';\n        this.div.appendChild(tip);\n      }\n      this.div.style.visibility = '';\n      fit(this.div);\n    }\n  }\n  /**\n   * Destroys the handler and all its resources and DOM nodes.\n   */\n  onDestroy() {\n    if (!this.destroyed) {\n      this.graph.removeMouseListener(this);\n      InternalEvent.release(this.div);\n      if (this.div.parentNode) {\n        this.div.parentNode.removeChild(this.div);\n      }\n      this.destroyed = true;\n    }\n  }\n}\nTooltipHandler.pluginId = 'TooltipHandler';\nexport default TooltipHandler;","map":{"version":3,"names":["InternalEvent","fit","getScrollOrigin","TOOLTIP_VERTICAL_OFFSET","getSource","isMouseEvent","isNode","TooltipHandler","constructor","graph","zIndex","delay","ignoreTouchEvents","hideOnHover","destroyed","lastX","lastY","state","stateSource","thread","enabled","addMouseListener","div","document","createElement","className","style","visibility","body","appendChild","addGestureListeners","evt","source","nodeName","hideTooltip","addListener","getContainer","relatedTarget","hide","isEnabled","setEnabled","isHideOnHover","setHideOnHover","value","getStateForEvent","me","getState","mouseDown","sender","reset","mouseMove","getX","getY","node","isSource","shape","text","mouseUp","resetTimer","window","clearTimeout","restart","getEvent","x","y","popupMenuHandler","getPlugin","setTimeout","isEditing","isMenuShowing","isMouseDown","tip","getTooltip","show","innerHTML","origin","String","left","top","replace","onDestroy","removeMouseListener","release","parentNode","removeChild","pluginId"],"sources":["D:/ospanel/domains/проекты open server/old/react/react-intro-main/node_modules/@maxgraph/core/dist/view/handler/TooltipHandler.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport InternalEvent from '../event/InternalEvent';\nimport { fit, getScrollOrigin } from '../../util/styleUtils';\nimport { TOOLTIP_VERTICAL_OFFSET } from '../../util/Constants';\nimport { getSource, isMouseEvent } from '../../util/EventUtils';\nimport { isNode } from '../../util/domUtils';\n/**\n * Graph event handler that displays tooltips.\n *\n * {@link Graph#getTooltip} is used to get the tooltip for a cell or handle.\n *\n * This handler is generally enabled using {@link Graph#setTooltips}.\n */\nclass TooltipHandler {\n    /**\n     * Constructs an event handler that displays tooltips.\n     *\n     * @param graph Reference to the enclosing {@link Graph}.\n     */\n    constructor(graph) {\n        /**\n         * Specifies the zIndex for the tooltip and its shadow.\n         * @default 10005\n         */\n        this.zIndex = 10005;\n        /**\n         * Delay to show the tooltip in milliseconds.\n         * @default 500\n         */\n        this.delay = 500;\n        /**\n         * Specifies if touch and pen events should be ignored.\n         * @default true\n         */\n        this.ignoreTouchEvents = true;\n        /**\n         * Specifies if the tooltip should be hidden if the mouse is moved over the current cell.\n         * @default false\n         */\n        this.hideOnHover = false;\n        /**\n         * `true` if this handler was destroyed using {@link onDestroy}.\n         */\n        this.destroyed = false;\n        this.lastX = 0;\n        this.lastY = 0;\n        this.state = null;\n        this.stateSource = false;\n        this.thread = null;\n        /**\n         * Specifies if events are handled.\n         * @default false\n         */\n        this.enabled = false;\n        this.graph = graph;\n        this.graph.addMouseListener(this);\n        this.div = document.createElement('div');\n        this.div.className = 'mxTooltip';\n        this.div.style.visibility = 'hidden';\n        document.body.appendChild(this.div);\n        InternalEvent.addGestureListeners(this.div, (evt) => {\n            const source = getSource(evt);\n            // @ts-ignore nodeName may exist\n            if (source && source.nodeName !== 'A') {\n                this.hideTooltip();\n            }\n        });\n        // Hides tooltips and resets tooltip timer if mouse leaves container\n        InternalEvent.addListener(this.graph.getContainer(), 'mouseleave', (evt) => {\n            if (this.div !== evt.relatedTarget) {\n                this.hide();\n            }\n        });\n    }\n    /**\n     * Returns `true` if events are handled.\n     *\n     * This implementation returns {@link enabled}.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Enables or disables event handling.\n     *\n     * This implementation updates {@link enabled}.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n    }\n    /**\n     * Returns {@link hideOnHover}.\n     */\n    isHideOnHover() {\n        return this.hideOnHover;\n    }\n    /**\n     * Sets <hideOnHover>.\n     */\n    setHideOnHover(value) {\n        this.hideOnHover = value;\n    }\n    /**\n     * Returns the <CellState> to be used for showing a tooltip for this event.\n     */\n    getStateForEvent(me) {\n        return me.getState();\n    }\n    /**\n     * Handles the event by initiating a rubberband selection. By consuming the\n     * event all subsequent events of the gesture are redirected to this\n     * handler.\n     */\n    mouseDown(sender, me) {\n        this.reset(me, false);\n        this.hideTooltip();\n    }\n    /**\n     * Handles the event by updating the rubberband selection.\n     */\n    mouseMove(sender, me) {\n        if (me.getX() !== this.lastX || me.getY() !== this.lastY) {\n            this.reset(me, true);\n            const state = this.getStateForEvent(me);\n            if (this.isHideOnHover() ||\n                state !== this.state ||\n                (me.getSource() !== this.node &&\n                    (!this.stateSource ||\n                        (state != null &&\n                            this.stateSource ===\n                                (me.isSource(state.shape) || !me.isSource(state.text)))))) {\n                this.hideTooltip();\n            }\n        }\n        this.lastX = me.getX();\n        this.lastY = me.getY();\n    }\n    /**\n     * Handles the event by resetting the tooltip timer or hiding the existing\n     * tooltip.\n     */\n    mouseUp(sender, me) {\n        this.reset(me, true);\n        this.hideTooltip();\n    }\n    /**\n     * Resets the timer.\n     */\n    resetTimer() {\n        if (this.thread) {\n            window.clearTimeout(this.thread);\n            this.thread = null;\n        }\n    }\n    /**\n     * Resets and/or restarts the timer to trigger the display of the tooltip.\n     */\n    reset(me, restart, state = null) {\n        if (!this.ignoreTouchEvents || isMouseEvent(me.getEvent())) {\n            this.resetTimer();\n            state = state ?? this.getStateForEvent(me);\n            if (restart &&\n                this.isEnabled() &&\n                state &&\n                this.div.style.visibility === 'hidden') {\n                const node = me.getSource();\n                const x = me.getX();\n                const y = me.getY();\n                const stateSource = me.isSource(state.shape) || me.isSource(state.text);\n                const popupMenuHandler = this.graph.getPlugin('PopupMenuHandler');\n                this.thread = window.setTimeout(() => {\n                    if (state &&\n                        node &&\n                        !this.graph.isEditing() &&\n                        popupMenuHandler &&\n                        !popupMenuHandler.isMenuShowing() &&\n                        !this.graph.isMouseDown) {\n                        // Uses information from inside event cause using the event at\n                        // this (delayed) point in time is not possible in IE as it no\n                        // longer contains the required information (member not found)\n                        const tip = this.graph.getTooltip(state, node, x, y);\n                        this.show(tip, x, y);\n                        this.state = state;\n                        this.node = node;\n                        this.stateSource = stateSource;\n                    }\n                }, this.delay);\n            }\n        }\n    }\n    /**\n     * Hides the tooltip and resets the timer.\n     */\n    hide() {\n        this.resetTimer();\n        this.hideTooltip();\n    }\n    /**\n     * Hides the tooltip.\n     */\n    hideTooltip() {\n        this.div.style.visibility = 'hidden';\n        this.div.innerHTML = '';\n    }\n    /**\n     * Shows the tooltip for the specified cell and optional index at the\n     * specified location (with a vertical offset of 10 pixels).\n     */\n    show(tip, x, y) {\n        if (!this.destroyed && tip && tip !== '') {\n            const origin = getScrollOrigin();\n            this.div.style.zIndex = String(this.zIndex);\n            this.div.style.left = `${x + origin.x}px`;\n            this.div.style.top = `${y + TOOLTIP_VERTICAL_OFFSET + origin.y}px`;\n            if (!isNode(tip)) {\n                this.div.innerHTML = tip.replace(/\\n/g, '<br>');\n            }\n            else {\n                this.div.innerHTML = '';\n                this.div.appendChild(tip);\n            }\n            this.div.style.visibility = '';\n            fit(this.div);\n        }\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes.\n     */\n    onDestroy() {\n        if (!this.destroyed) {\n            this.graph.removeMouseListener(this);\n            InternalEvent.release(this.div);\n            if (this.div.parentNode) {\n                this.div.parentNode.removeChild(this.div);\n            }\n            this.destroyed = true;\n        }\n    }\n}\nTooltipHandler.pluginId = 'TooltipHandler';\nexport default TooltipHandler;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}