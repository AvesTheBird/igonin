{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Client from '../../Client';\nimport InternalEvent from '../event/InternalEvent';\nimport { contains, getRotatedPoint, isNumeric, toRadians } from '../../util/mathUtils';\nimport { convertPoint } from '../../util/styleUtils';\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport mxGuide from '../other/Guide';\nimport Point from '../geometry/Point';\nimport { CURSOR, DIALECT, DROP_TARGET_COLOR, INVALID_CONNECT_TARGET_COLOR, NONE, VALID_COLOR } from '../../util/Constants';\nimport Dictionary from '../../util/Dictionary';\nimport CellHighlight from '../cell/CellHighlight';\nimport Rectangle from '../geometry/Rectangle';\nimport { getClientX, getClientY, isAltDown, isMultiTouchEvent } from '../../util/EventUtils';\n/**\n * Graph event handler that handles selection. Individual cells are handled\n * separately using {@link VertexHandler} or one of the edge handlers. These\n * handlers are created using {@link Graph#createHandler} in\n * {@link GraphSelectionModel#cellAdded}.\n *\n * To avoid the container to scroll a moved cell into view, set {@link scrollOnMove} to `false`.\n *\n * Constructs an event handler that creates handles for the selection cells.\n *\n * @param graph Reference to the enclosing {@link Graph}.\n */\nclass SelectionHandler {\n  constructor(graph) {\n    this.refreshThread = null;\n    /**\n     * Defines the maximum number of cells to paint subhandles\n     * for. Default is 50 for Firefox and 20 for IE. Set this\n     * to 0 if you want an unlimited number of handles to be\n     * displayed. This is only recommended if the number of\n     * cells in the graph is limited to a small number, eg.\n     * 500.\n     */\n    this.maxCells = 50;\n    /**\n     * Specifies if events are handled. Default is true.\n     */\n    this.enabled = true;\n    /**\n     * Specifies if drop targets under the mouse should be enabled. Default is\n     * true.\n     */\n    this.highlightEnabled = true;\n    /**\n     * Specifies if cloning by control-drag is enabled. Default is true.\n     */\n    this.cloneEnabled = true;\n    /**\n     * Specifies if moving is enabled. Default is true.\n     */\n    this.moveEnabled = true;\n    /**\n     * Specifies if other cells should be used for snapping the right, center or\n     * left side of the current selection. Default is false.\n     */\n    this.guidesEnabled = false;\n    /**\n     * Whether the handles of the selection are currently visible.\n     */\n    this.handlesVisible = true;\n    /**\n     * Holds the {@link Guide} instance that is used for alignment.\n     */\n    this.guide = null;\n    /**\n     * Stores the x-coordinate of the current mouse move.\n     */\n    this.currentDx = 0;\n    /**\n     * Stores the y-coordinate of the current mouse move.\n     */\n    this.currentDy = 0;\n    /**\n     * Specifies if a move cursor should be shown if the mouse is over a movable\n     * cell. Default is true.\n     */\n    this.updateCursor = true;\n    /**\n     * Specifies if selecting is enabled. Default is true.\n     */\n    this.selectEnabled = true;\n    /**\n     * Specifies if cells may be moved out of their parents. Default is true.\n     */\n    this.removeCellsFromParent = true;\n    /**\n     * If empty parents should be removed from the model after all child cells\n     * have been moved out. Default is true.\n     */\n    this.removeEmptyParents = false;\n    /**\n     * Specifies if drop events are interpreted as new connections if no other\n     * drop action is defined. Default is false.\n     */\n    this.connectOnDrop = false;\n    /**\n     * Specifies if the view should be scrolled so that a moved cell is visible.\n     * @default true\n     */\n    this.scrollOnMove = true;\n    /**\n     * Specifies the minimum number of pixels for the width and height of a\n     * selection border. Default is 6.\n     */\n    this.minimumSize = 6;\n    /**\n     * Specifies the color of the preview shape. Default is black.\n     */\n    this.previewColor = 'black';\n    /**\n     * Specifies if the graph container should be used for preview. If this is used\n     * then drop target detection relies entirely on {@link Graph#getCellAt} because\n     * the HTML preview does not \"let events through\". Default is false.\n     */\n    this.htmlPreview = false;\n    /**\n     * Reference to the {@link Shape} that represents the preview.\n     */\n    this.shape = null;\n    /**\n     * Specifies if the grid should be scaled. Default is false.\n     */\n    this.scaleGrid = false;\n    /**\n     * Specifies if the bounding box should allow for rotation. Default is true.\n     */\n    this.rotationEnabled = true;\n    /**\n     * Maximum number of cells for which live preview should be used.  Default is 0 which means no live preview.\n     */\n    this.maxLivePreview = 0;\n    /**\n     * Variable allowLivePreview\n     *\n     * If live preview is allowed on this system.  Default is true for systems with SVG support.\n     */\n    this.allowLivePreview = Client.IS_SVG;\n    this.cell = null;\n    this.delayedSelection = false;\n    this.first = null;\n    this.cells = null;\n    this.bounds = null;\n    this.pBounds = null;\n    this.allCells = new Dictionary();\n    this.cellWasClicked = false;\n    this.cloning = false;\n    this.cellCount = 0;\n    this.target = null;\n    this.suspended = false;\n    this.livePreviewActive = false;\n    this.livePreviewUsed = false;\n    this.highlight = null;\n    this.graph = graph;\n    this.graph.addMouseListener(this);\n    // Repaints the handler after autoscroll\n    this.panHandler = () => {\n      if (!this.suspended) {\n        this.updatePreview();\n        this.updateHint();\n      }\n    };\n    this.graph.addListener(InternalEvent.PAN, this.panHandler);\n    // Handles escape keystrokes\n    this.escapeHandler = (sender, evt) => {\n      this.reset();\n    };\n    this.graph.addListener(InternalEvent.ESCAPE, this.escapeHandler);\n    // Updates the preview box for remote changes\n    this.refreshHandler = (sender, evt) => {\n      // Merges multiple pending calls\n      if (this.refreshThread) {\n        window.clearTimeout(this.refreshThread);\n      }\n      // Waits for the states and handlers to be updated\n      this.refreshThread = window.setTimeout(() => {\n        this.refreshThread = null;\n        if (this.first && !this.suspended && this.cells) {\n          // Updates preview with no translate to compute bounding box\n          const dx = this.currentDx;\n          const dy = this.currentDy;\n          this.currentDx = 0;\n          this.currentDy = 0;\n          this.updatePreview();\n          this.bounds = this.graph.getView().getBounds(this.cells);\n          this.pBounds = this.getPreviewBounds(this.cells);\n          if (this.pBounds == null && !this.livePreviewUsed) {\n            this.reset();\n          } else {\n            // Restores translate and updates preview\n            this.currentDx = dx;\n            this.currentDy = dy;\n            this.updatePreview();\n            this.updateHint();\n            if (this.livePreviewUsed) {\n              const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n              // Forces update to ignore last visible state\n              this.setHandlesVisibleForCells(selectionCellsHandler?.getHandledSelectionCells() ?? [], false, true);\n              this.updatePreview();\n            }\n          }\n        }\n      }, 0);\n    };\n    this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.refreshHandler);\n    this.graph.addListener(InternalEvent.REFRESH, this.refreshHandler);\n    this.keyHandler = e => {\n      if (this.graph.container != null && this.graph.container.style.visibility !== 'hidden' && this.first != null && !this.suspended) {\n        const clone = this.graph.isCloneEvent(e) && this.graph.isCellsCloneable() && this.isCloneEnabled();\n        if (clone !== this.cloning) {\n          this.cloning = clone;\n          this.checkPreview();\n          this.updatePreview();\n        }\n      }\n    };\n    if (typeof document !== 'undefined') {\n      InternalEvent.addListener(document, 'keydown', this.keyHandler);\n      InternalEvent.addListener(document, 'keyup', this.keyHandler);\n    }\n  }\n  /**\n   * Returns <enabled>.\n   */\n  isEnabled() {\n    return this.enabled;\n  }\n  /**\n   * Sets <enabled>.\n   */\n  setEnabled(value) {\n    this.enabled = value;\n  }\n  /**\n   * Returns <cloneEnabled>.\n   */\n  isCloneEnabled() {\n    return this.cloneEnabled;\n  }\n  /**\n   * Sets <cloneEnabled>.\n   *\n   * @param value Boolean that specifies the new clone enabled state.\n   */\n  setCloneEnabled(value) {\n    this.cloneEnabled = value;\n  }\n  /**\n   * Returns {@link oveEnabled}.\n   */\n  isMoveEnabled() {\n    return this.moveEnabled;\n  }\n  /**\n   * Sets {@link oveEnabled}.\n   */\n  setMoveEnabled(value) {\n    this.moveEnabled = value;\n  }\n  /**\n   * Returns <selectEnabled>.\n   */\n  isSelectEnabled() {\n    return this.selectEnabled;\n  }\n  /**\n   * Sets <selectEnabled>.\n   */\n  setSelectEnabled(value) {\n    this.selectEnabled = value;\n  }\n  /**\n   * Returns <removeCellsFromParent>.\n   */\n  isRemoveCellsFromParent() {\n    return this.removeCellsFromParent;\n  }\n  /**\n   * Sets <removeCellsFromParent>.\n   */\n  setRemoveCellsFromParent(value) {\n    this.removeCellsFromParent = value;\n  }\n  /**\n   * Returns true if the given cell and parent should propagate\n   * selection state to the parent.\n   */\n  isPropagateSelectionCell(cell, immediate, me) {\n    const parent = cell.getParent();\n    if (immediate) {\n      const geo = cell.isEdge() ? null : cell.getGeometry();\n      return !this.graph.isSiblingSelected(cell) && geo && geo.relative || !this.graph.isSwimlane(parent);\n    }\n    return (!this.graph.isToggleEvent(me.getEvent()) || !this.graph.isSiblingSelected(cell) && !this.graph.isCellSelected(cell) && !this.graph.isSwimlane(parent) || this.graph.isCellSelected(parent)) && (this.graph.isToggleEvent(me.getEvent()) || !this.graph.isCellSelected(parent));\n  }\n  /**\n   * Hook to return initial cell for the given event.\n   */\n  getInitialCellForEvent(me) {\n    let state = me.getState();\n    if ((!this.graph.isToggleEvent(me.getEvent()) || !isAltDown(me.getEvent())) && state && !this.graph.isCellSelected(state.cell)) {\n      let parent = state.cell.getParent();\n      let next = parent ? this.graph.view.getState(parent) : null;\n      while (next && !this.graph.isCellSelected(next.cell) && (next.cell.isVertex() || next.cell.isEdge()) && this.isPropagateSelectionCell(state.cell, true, me)) {\n        state = next;\n        parent = state.cell.getParent();\n        next = parent ? this.graph.view.getState(parent) : null;\n      }\n    }\n    return state ? state.cell : null;\n  }\n  /**\n   * Hook to return true for delayed selections.\n   */\n  isDelayedSelection(cell, me) {\n    let c = cell;\n    const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n    if (!this.graph.isToggleEvent(me.getEvent()) || !isAltDown(me.getEvent())) {\n      while (c) {\n        if (selectionCellsHandler?.isHandled(c)) {\n          const cellEditorHandler = this.graph.getPlugin('CellEditorHandler');\n          return cellEditorHandler?.getEditingCell() !== c;\n        }\n        c = c.getParent();\n      }\n    }\n    return this.graph.isToggleEvent(me.getEvent()) && !isAltDown(me.getEvent());\n  }\n  /**\n   * Implements the delayed selection for the given mouse event.\n   */\n  selectDelayed(me) {\n    const popupMenuHandler = this.graph.getPlugin('PopupMenuHandler');\n    if (!popupMenuHandler || !popupMenuHandler.isPopupTrigger(me)) {\n      let cell = me.getCell();\n      if (cell === null) {\n        cell = this.cell;\n      }\n      if (cell) this.selectCellForEvent(cell, me);\n    }\n  }\n  /**\n   * Selects the given cell for the given {@link MouseEvent}.\n   */\n  selectCellForEvent(cell, me) {\n    const state = this.graph.view.getState(cell);\n    if (state) {\n      if (me.isSource(state.control)) {\n        this.graph.selectCellForEvent(cell, me.getEvent());\n      } else {\n        if (!this.graph.isToggleEvent(me.getEvent()) || !isAltDown(me.getEvent())) {\n          let parent = cell.getParent();\n          while (parent && this.graph.view.getState(parent) && (parent.isVertex() || parent.isEdge()) && this.isPropagateSelectionCell(cell, false, me)) {\n            cell = parent;\n            parent = cell.getParent();\n          }\n        }\n        this.graph.selectCellForEvent(cell, me.getEvent());\n      }\n    }\n    return cell;\n  }\n  /**\n   * Consumes the given mouse event. NOTE: This may be used to enable click\n   * events for links in labels on iOS as follows as consuming the initial\n   * touchStart disables firing the subsequent click evnent on the link.\n   *\n   * <code>\n   * consumeMouseEvent(evtName, me)\n   * {\n   *   var source = mxEvent.getSource(me.getEvent());\n   *\n   *   if (!mxEvent.isTouchEvent(me.getEvent()) || source.nodeName != 'A')\n   *   {\n   *     me.consume();\n   *   }\n   * }\n   * </code>\n   */\n  consumeMouseEvent(evtName, me) {\n    me.consume();\n  }\n  /**\n   * Handles the event by selecing the given cell and creating a handle for\n   * it. By consuming the event all subsequent events of the gesture are\n   * redirected to this handler.\n   */\n  mouseDown(sender, me) {\n    if (!me.isConsumed() && this.isEnabled() && this.graph.isEnabled() && me.getState() && !isMultiTouchEvent(me.getEvent())) {\n      const cell = this.getInitialCellForEvent(me);\n      if (cell) {\n        this.delayedSelection = this.isDelayedSelection(cell, me);\n        this.cell = null;\n        if (this.isSelectEnabled() && !this.delayedSelection) {\n          this.graph.selectCellForEvent(cell, me.getEvent());\n        }\n        if (this.isMoveEnabled()) {\n          const geo = cell.getGeometry();\n          if (geo && this.graph.isCellMovable(cell) && (!cell.isEdge() || this.graph.getSelectionCount() > 1 || geo.points && geo.points.length > 0 || !cell.getTerminal(true) || !cell.getTerminal(false) || this.graph.isAllowDanglingEdges() || this.graph.isCloneEvent(me.getEvent()) && this.graph.isCellsCloneable())) {\n            this.start(cell, me.getX(), me.getY());\n          } else if (this.delayedSelection) {\n            this.cell = cell;\n          }\n          this.cellWasClicked = true;\n          this.consumeMouseEvent(InternalEvent.MOUSE_DOWN, me);\n        }\n      }\n    }\n  }\n  /**\n   * Creates an array of cell states which should be used as guides.\n   */\n  getGuideStates() {\n    const parent = this.graph.getDefaultParent();\n    const filter = cell => {\n      const geo = cell.getGeometry();\n      return !!this.graph.view.getState(cell) && cell.isVertex() && !!geo && !geo.relative;\n    };\n    return this.graph.view.getCellStates(parent.filterDescendants(filter));\n  }\n  /**\n   * Returns the cells to be modified by this handler. This implementation\n   * returns all selection cells that are movable, or the given initial cell if\n   * the given cell is not selected and movable. This handles the case of moving\n   * unselectable or unselected cells.\n   *\n   * @param initialCell <Cell> that triggered this handler.\n   */\n  getCells(initialCell) {\n    if (!this.delayedSelection && this.graph.isCellMovable(initialCell)) {\n      return [initialCell];\n    }\n    return this.graph.getMovableCells(this.graph.getSelectionCells());\n  }\n  /**\n   * Returns the {@link Rectangle} used as the preview bounds for\n   * moving the given cells.\n   */\n  getPreviewBounds(cells) {\n    const bounds = this.getBoundingBox(cells);\n    if (bounds) {\n      // Corrects width and height\n      bounds.width = Math.max(0, bounds.width - 1);\n      bounds.height = Math.max(0, bounds.height - 1);\n      if (bounds.width < this.minimumSize) {\n        const dx = this.minimumSize - bounds.width;\n        bounds.x -= dx / 2;\n        bounds.width = this.minimumSize;\n      } else {\n        bounds.x = Math.round(bounds.x);\n        bounds.width = Math.ceil(bounds.width);\n      }\n      if (bounds.height < this.minimumSize) {\n        const dy = this.minimumSize - bounds.height;\n        bounds.y -= dy / 2;\n        bounds.height = this.minimumSize;\n      } else {\n        bounds.y = Math.round(bounds.y);\n        bounds.height = Math.ceil(bounds.height);\n      }\n    }\n    return bounds;\n  }\n  /**\n   * Returns the union of the {@link CellStates} for the given array of {@link Cells}.\n   * For vertices, this method uses the bounding box of the corresponding shape\n   * if one exists. The bounding box of the corresponding text label and all\n   * controls and overlays are ignored. See also: {@link GraphView#getBounds} and\n   * {@link Graph#getBoundingBox}.\n   *\n   * @param cells Array of {@link Cells} whose bounding box should be returned.\n   */\n  getBoundingBox(cells) {\n    let result = null;\n    if (cells.length > 0) {\n      for (let i = 0; i < cells.length; i += 1) {\n        if (cells[i].isVertex() || cells[i].isEdge()) {\n          const state = this.graph.view.getState(cells[i]);\n          if (state) {\n            let bbox = null;\n            if (cells[i].isVertex() && state.shape && state.shape.boundingBox) {\n              bbox = state.shape.boundingBox;\n            }\n            if (bbox) {\n              if (!result) {\n                result = Rectangle.fromRectangle(bbox);\n              } else {\n                result.add(bbox);\n              }\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n  /**\n   * Creates the shape used to draw the preview for the given bounds.\n   */\n  createPreviewShape(bounds) {\n    const shape = new RectangleShape(bounds, NONE, this.previewColor);\n    shape.isDashed = true;\n    if (this.htmlPreview) {\n      shape.dialect = DIALECT.STRICTHTML;\n      shape.init(this.graph.container);\n    } else {\n      // Makes sure to use either VML or SVG shapes in order to implement\n      // event-transparency on the background area of the rectangle since\n      // HTML shapes do not let mouseevents through even when transparent\n      shape.dialect = DIALECT.SVG;\n      shape.init(this.graph.getView().getOverlayPane());\n      shape.pointerEvents = false;\n      // Workaround for artifacts on iOS\n      if (Client.IS_IOS) {\n        shape.getSvgScreenOffset = () => {\n          return 0;\n        };\n      }\n    }\n    return shape;\n  }\n  createGuide() {\n    return new mxGuide(this.graph, this.getGuideStates());\n  }\n  /**\n   * Starts the handling of the mouse gesture.\n   */\n  start(cell, x, y, cells) {\n    this.cell = cell;\n    this.first = convertPoint(this.graph.container, x, y);\n    this.cells = cells ? cells : this.getCells(this.cell);\n    this.bounds = this.graph.getView().getBounds(this.cells);\n    this.pBounds = this.getPreviewBounds(this.cells);\n    this.cloning = false;\n    this.cellCount = 0;\n    for (let i = 0; i < this.cells.length; i += 1) {\n      this.cellCount += this.addStates(this.cells[i], this.allCells);\n    }\n    if (this.guidesEnabled) {\n      this.guide = this.createGuide();\n      const parent = cell.getParent();\n      const ignore = parent.getChildCount() < 2;\n      // Uses connected states as guides\n      const connected = new Dictionary();\n      const opps = this.graph.getOpposites(this.graph.getEdges(this.cell), this.cell);\n      for (let i = 0; i < opps.length; i += 1) {\n        const state = this.graph.view.getState(opps[i]);\n        if (state && !connected.get(state)) {\n          connected.put(state, true);\n        }\n      }\n      this.guide.isStateIgnored = state => {\n        const p = state.cell.getParent();\n        return !!state.cell && (!this.cloning && !!this.isCellMoving(state.cell) || state.cell !== (this.target || parent) && !ignore && !connected.get(state) && (!this.target || this.target.getChildCount() >= 2) && p !== (this.target || parent));\n      };\n    }\n  }\n  /**\n   * Adds the states for the given cell recursively to the given dictionary.\n   * @param cell\n   * @param dict\n   */\n  addStates(cell, dict) {\n    const state = this.graph.view.getState(cell);\n    let count = 0;\n    if (state && !dict.get(cell)) {\n      dict.put(cell, state);\n      count++;\n      const childCount = cell.getChildCount();\n      for (let i = 0; i < childCount; i += 1) {\n        count += this.addStates(cell.getChildAt(i), dict);\n      }\n    }\n    return count;\n  }\n  /**\n   * Returns true if the given cell is currently being moved.\n   */\n  isCellMoving(cell) {\n    return this.allCells.get(cell);\n  }\n  /**\n   * Returns true if the guides should be used for the given {@link MouseEvent}.\n   * This implementation returns {@link Guide#isEnabledForEvent}.\n   */\n  useGuidesForEvent(me) {\n    return this.guide ? this.guide.isEnabledForEvent(me.getEvent()) && !this.graph.isConstrainedEvent(me.getEvent()) : true;\n  }\n  /**\n   * Snaps the given vector to the grid and returns the given mxPoint instance.\n   */\n  snap(vector) {\n    const scale = this.scaleGrid ? this.graph.view.scale : 1;\n    vector.x = this.graph.snap(vector.x / scale) * scale;\n    vector.y = this.graph.snap(vector.y / scale) * scale;\n    return vector;\n  }\n  /**\n   * Returns an {@link Point} that represents the vector for moving the cells\n   * for the given {@link MouseEvent}.\n   */\n  getDelta(me) {\n    const point = convertPoint(this.graph.container, me.getX(), me.getY());\n    if (!this.first) return new Point();\n    return new Point(point.x - this.first.x - this.graph.getPanDx(), point.y - this.first.y - this.graph.getPanDy());\n  }\n  /**\n   * Hook for subclassers do show details while the handler is active.\n   */\n  updateHint(me) {\n    return;\n  }\n  /**\n   * Hooks for subclassers to hide details when the handler gets inactive.\n   */\n  removeHint() {\n    return;\n  }\n  /**\n   * Hook for rounding the unscaled vector. This uses Math.round.\n   */\n  roundLength(length) {\n    return Math.round(length * 100) / 100;\n  }\n  /**\n   * Returns true if the given cell is a valid drop target.\n   */\n  isValidDropTarget(target, me) {\n    return this.cell ? this.cell.getParent() !== target : false;\n  }\n  /**\n   * Updates the preview if cloning state has changed.\n   */\n  checkPreview() {\n    if (this.livePreviewActive && this.cloning) {\n      this.resetLivePreview();\n      this.livePreviewActive = false;\n    } else if (this.maxLivePreview >= this.cellCount && !this.livePreviewActive && this.allowLivePreview) {\n      if (!this.cloning || !this.livePreviewActive) {\n        this.livePreviewActive = true;\n        this.livePreviewUsed = true;\n      }\n    } else if (!this.livePreviewUsed && !this.shape && this.bounds) {\n      this.shape = this.createPreviewShape(this.bounds);\n    }\n  }\n  /**\n   * Handles the event by highlighting possible drop targets and updating the\n   * preview.\n   */\n  mouseMove(sender, me) {\n    const {\n      graph\n    } = this;\n    if (!me.isConsumed() && graph.isMouseDown && this.cell && this.first && this.bounds && !this.suspended) {\n      // Stops moving if a multi touch event is received\n      if (isMultiTouchEvent(me.getEvent())) {\n        this.reset();\n        return;\n      }\n      let delta = this.getDelta(me);\n      const tol = graph.getEventTolerance();\n      if (this.shape || this.livePreviewActive || Math.abs(delta.x) > tol || Math.abs(delta.y) > tol) {\n        // Highlight is used for highlighting drop targets\n        if (!this.highlight) {\n          this.highlight = new CellHighlight(this.graph, DROP_TARGET_COLOR, 3);\n        }\n        const clone = graph.isCloneEvent(me.getEvent()) && graph.isCellsCloneable() && this.isCloneEnabled();\n        const gridEnabled = graph.isGridEnabledEvent(me.getEvent());\n        const cell = me.getCell();\n        let hideGuide = true;\n        let target = null;\n        this.cloning = clone;\n        if (graph.isDropEnabled() && this.highlightEnabled && this.cells) {\n          // Contains a call to getCellAt to find the cell under the mouse\n          target = graph.getDropTarget(this.cells, me.getEvent(), cell, clone);\n        }\n        let state = target ? graph.getView().getState(target) : null;\n        let highlight = false;\n        if (state && (clone || target && this.isValidDropTarget(target, me))) {\n          if (this.target !== target) {\n            this.target = target;\n            this.setHighlightColor(DROP_TARGET_COLOR);\n          }\n          highlight = true;\n        } else {\n          this.target = null;\n          if (this.connectOnDrop && cell && this.cells && this.cells.length === 1 && cell.isVertex() && cell.isConnectable()) {\n            state = graph.getView().getState(cell);\n            if (state) {\n              const error = graph.getEdgeValidationError(null, this.cell, cell);\n              const color = error === null ? VALID_COLOR : INVALID_CONNECT_TARGET_COLOR;\n              this.setHighlightColor(color);\n              highlight = true;\n            }\n          }\n        }\n        if (state && highlight) {\n          this.highlight.highlight(state);\n        } else {\n          this.highlight.hide();\n        }\n        if (this.guide && this.useGuidesForEvent(me)) {\n          delta = this.guide.move(this.bounds, delta, gridEnabled, clone);\n          hideGuide = false;\n        } else {\n          delta = this.graph.snapDelta(delta, this.bounds, !gridEnabled, false, false);\n        }\n        if (this.guide && hideGuide) {\n          this.guide.hide();\n        }\n        // Constrained movement if shift key is pressed\n        if (graph.isConstrainedEvent(me.getEvent())) {\n          if (Math.abs(delta.x) > Math.abs(delta.y)) {\n            delta.y = 0;\n          } else {\n            delta.x = 0;\n          }\n        }\n        this.checkPreview();\n        if (this.currentDx !== delta.x || this.currentDy !== delta.y) {\n          this.currentDx = delta.x;\n          this.currentDy = delta.y;\n          this.updatePreview();\n        }\n      }\n      this.updateHint(me);\n      this.consumeMouseEvent(InternalEvent.MOUSE_MOVE, me);\n      // Cancels the bubbling of events to the container so\n      // that the droptarget is not reset due to an mouseMove\n      // fired on the container with no associated state.\n      InternalEvent.consume(me.getEvent());\n    } else if ((this.isMoveEnabled() || this.isCloneEnabled()) && this.updateCursor && !me.isConsumed() && (me.getState() || me.sourceState) && !graph.isMouseDown) {\n      let cursor = graph.getCursorForMouseEvent(me);\n      const cell = me.getCell();\n      if (!cursor && cell && graph.isEnabled() && graph.isCellMovable(cell)) {\n        if (cell.isEdge()) {\n          cursor = CURSOR.MOVABLE_EDGE;\n        } else {\n          cursor = CURSOR.MOVABLE_VERTEX;\n        }\n      }\n      // Sets the cursor on the original source state under the mouse\n      // instead of the event source state which can be the parent\n      if (cursor && me.sourceState) {\n        me.sourceState.setCursor(cursor);\n      }\n    }\n  }\n  /**\n   * Updates the bounds of the preview shape.\n   */\n  updatePreview(remote = false) {\n    if (this.livePreviewUsed && !remote) {\n      if (this.cells) {\n        const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n        this.setHandlesVisibleForCells(selectionCellsHandler?.getHandledSelectionCells() ?? [], false);\n        this.updateLivePreview(this.currentDx, this.currentDy);\n      }\n    } else {\n      this.updatePreviewShape();\n    }\n  }\n  /**\n   * Updates the bounds of the preview shape.\n   */\n  updatePreviewShape() {\n    if (this.shape && this.pBounds) {\n      this.shape.bounds = new Rectangle(Math.round(this.pBounds.x + this.currentDx), Math.round(this.pBounds.y + this.currentDy), this.pBounds.width, this.pBounds.height);\n      this.shape.redraw();\n    }\n  }\n  /**\n   * Updates the bounds of the preview shape.\n   */\n  updateLivePreview(dx, dy) {\n    if (!this.suspended) {\n      const states = [];\n      if (this.allCells) {\n        this.allCells.visit((key, state) => {\n          const realState = state ? this.graph.view.getState(state.cell) : null;\n          // Checks if cell was removed or replaced\n          if (realState !== state && state) {\n            state.destroy();\n            if (realState) {\n              this.allCells.put(state.cell, realState);\n            } else {\n              this.allCells.remove(state.cell);\n            }\n            state = realState;\n          }\n          if (state) {\n            // Saves current state\n            const tempState = state.clone();\n            states.push([state, tempState]);\n            // Makes transparent for events to detect drop targets\n            if (state.shape) {\n              if (state.shape.originalPointerEvents === null) {\n                state.shape.originalPointerEvents = state.shape.pointerEvents;\n              }\n              state.shape.pointerEvents = false;\n              if (state.text) {\n                if (state.text.originalPointerEvents === null) {\n                  state.text.originalPointerEvents = state.text.pointerEvents;\n                }\n                state.text.pointerEvents = false;\n              }\n            }\n            // Temporarily changes position\n            if (state.cell.isVertex()) {\n              state.x += dx;\n              state.y += dy;\n              // Draws the live preview\n              if (!this.cloning) {\n                state.view.graph.cellRenderer.redraw(state, true);\n                // Forces redraw of connected edges after all states\n                // have been updated but avoids update of state\n                state.view.invalidate(state.cell);\n                state.invalid = false;\n                // Hides folding icon\n                if (state.control && state.control.node) {\n                  state.control.node.style.visibility = 'hidden';\n                }\n              }\n              // Clone live preview may use text bounds\n              else if (state.text) {\n                state.text.updateBoundingBox();\n                // Fixes preview box for edge labels\n                if (state.text.boundingBox) {\n                  state.text.boundingBox.x += dx;\n                  state.text.boundingBox.y += dy;\n                }\n                if (state.text.unrotatedBoundingBox) {\n                  state.text.unrotatedBoundingBox.x += dx;\n                  state.text.unrotatedBoundingBox.y += dy;\n                }\n              }\n            }\n          }\n        });\n      }\n      // Resets the handler if everything was removed\n      if (states.length === 0) {\n        this.reset();\n      } else {\n        // Redraws connected edges\n        const s = this.graph.view.scale;\n        for (let i = 0; i < states.length; i += 1) {\n          const state = states[i][0];\n          if (state.cell.isEdge()) {\n            const geometry = state.cell.getGeometry();\n            const points = [];\n            if (geometry && geometry.points) {\n              for (let j = 0; j < geometry.points.length; j++) {\n                if (geometry.points[j]) {\n                  points.push(new Point(geometry.points[j].x + dx / s, geometry.points[j].y + dy / s));\n                }\n              }\n            }\n            let source = state.visibleSourceState;\n            let target = state.visibleTargetState;\n            const pts = states[i][1].absolutePoints;\n            if (source == null || !this.isCellMoving(source.cell)) {\n              const pt0 = pts[0];\n              if (pt0) {\n                state.setAbsoluteTerminalPoint(new Point(pt0.x + dx, pt0.y + dy), true);\n                source = null;\n              }\n            } else {\n              state.view.updateFixedTerminalPoint(state, source, true, this.graph.getConnectionConstraint(state, source, true));\n            }\n            if (target == null || !this.isCellMoving(target.cell)) {\n              const ptn = pts[pts.length - 1];\n              if (ptn) {\n                state.setAbsoluteTerminalPoint(new Point(ptn.x + dx, ptn.y + dy), false);\n                target = null;\n              }\n            } else {\n              state.view.updateFixedTerminalPoint(state, target, false, this.graph.getConnectionConstraint(state, target, false));\n            }\n            state.view.updatePoints(state, points, source, target);\n            state.view.updateFloatingTerminalPoints(state, source, target);\n            state.view.updateEdgeLabelOffset(state);\n            state.invalid = false;\n            // Draws the live preview but avoids update of state\n            if (!this.cloning) {\n              state.view.graph.cellRenderer.redraw(state, true);\n            }\n          }\n        }\n        this.graph.view.validate();\n        this.redrawHandles(states);\n        this.resetPreviewStates(states);\n      }\n    }\n  }\n  /**\n   * Redraws the preview shape for the given states array.\n   */\n  redrawHandles(states) {\n    const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n    for (let i = 0; i < states.length; i += 1) {\n      const handler = selectionCellsHandler?.getHandler(states[i][0].cell);\n      handler?.redraw(true);\n    }\n  }\n  /**\n   * Resets the given preview states array.\n   */\n  resetPreviewStates(states) {\n    for (let i = 0; i < states.length; i += 1) {\n      states[i][0].setState(states[i][1]);\n    }\n  }\n  /**\n   * Suspends the livew preview.\n   */\n  suspend() {\n    if (!this.suspended) {\n      if (this.livePreviewUsed) {\n        this.updateLivePreview(0, 0);\n      }\n      if (this.shape) {\n        this.shape.node.style.visibility = 'hidden';\n      }\n      if (this.guide) {\n        this.guide.setVisible(false);\n      }\n      this.suspended = true;\n    }\n  }\n  /**\n   * Suspends the livew preview.\n   */\n  resume() {\n    if (this.suspended) {\n      this.suspended = false;\n      if (this.livePreviewUsed) {\n        this.livePreviewActive = true;\n      }\n      if (this.shape) {\n        this.shape.node.style.visibility = 'visible';\n      }\n      if (this.guide) {\n        this.guide.setVisible(true);\n      }\n    }\n  }\n  /**\n   * Resets the livew preview.\n   */\n  resetLivePreview() {\n    this.allCells.visit((key, state) => {\n      // Restores event handling\n      if (state.shape && state.shape.originalPointerEvents !== null) {\n        state.shape.pointerEvents = state.shape.originalPointerEvents;\n        state.shape.originalPointerEvents = null;\n        // Forces repaint even if not moved to update pointer events\n        state.shape.bounds = null;\n        if (state.text && state.text.originalPointerEvents !== null) {\n          state.text.pointerEvents = state.text.originalPointerEvents;\n          state.text.originalPointerEvents = null;\n        }\n      }\n      // Shows folding icon\n      if (state.control && state.control.node && state.control.node.style.visibility === 'hidden') {\n        state.control.node.style.visibility = '';\n      }\n      // Fixes preview box for edge labels\n      if (!this.cloning) {\n        if (state.text) {\n          state.text.updateBoundingBox();\n        }\n      }\n      // Forces repaint of connected edges\n      state.view.invalidate(state.cell);\n    });\n    // Repaints all invalid states\n    this.graph.view.validate();\n  }\n  /**\n   * Sets wether the handles attached to the given cells are visible.\n   *\n   * @param cells Array of {@link Cells}.\n   * @param visible Boolean that specifies if the handles should be visible.\n   * @param force Forces an update of the handler regardless of the last used value.\n   */\n  setHandlesVisibleForCells(cells, visible, force = false) {\n    if (force || this.handlesVisible !== visible) {\n      this.handlesVisible = visible;\n      const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n      for (let i = 0; i < cells.length; i += 1) {\n        const handler = selectionCellsHandler?.getHandler(cells[i]);\n        if (handler) {\n          handler.setHandlesVisible(visible);\n          if (visible) {\n            handler.redraw();\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Sets the color of the rectangle used to highlight drop targets.\n   *\n   * @param color String that represents the new highlight color.\n   */\n  setHighlightColor(color) {\n    if (this.highlight) {\n      this.highlight.setHighlightColor(color);\n    }\n  }\n  /**\n   * Handles the event by applying the changes to the selection cells.\n   */\n  mouseUp(sender, me) {\n    if (!me.isConsumed()) {\n      if (this.livePreviewUsed) {\n        this.resetLivePreview();\n      }\n      if (this.cell && this.first && (this.shape || this.livePreviewUsed) && isNumeric(this.currentDx) && isNumeric(this.currentDy)) {\n        const {\n          graph\n        } = this;\n        const cell = me.getCell();\n        if (this.connectOnDrop && !this.target && cell && cell.isVertex() && cell.isConnectable() && graph.isEdgeValid(null, this.cell, cell)) {\n          const connectionHandler = graph.getPlugin('ConnectionHandler');\n          connectionHandler?.connect(this.cell, cell, me.getEvent());\n        } else {\n          const clone = graph.isCloneEvent(me.getEvent()) && graph.isCellsCloneable() && this.isCloneEnabled();\n          const {\n            scale\n          } = graph.getView();\n          const dx = this.roundLength(this.currentDx / scale);\n          const dy = this.roundLength(this.currentDy / scale);\n          const target = this.target;\n          if (target && graph.isSplitEnabled() && this.cells && graph.isSplitTarget(target, this.cells, me.getEvent())) {\n            graph.splitEdge(target, this.cells, null, dx, dy, me.getGraphX(), me.getGraphY());\n          } else if (this.cells) {\n            this.moveCells(this.cells, dx, dy, clone, this.target, me.getEvent());\n          }\n        }\n      } else if (this.isSelectEnabled() && this.delayedSelection && this.cell != null) {\n        this.selectDelayed(me);\n      }\n    }\n    // Consumes the event if a cell was initially clicked\n    if (this.cellWasClicked) {\n      this.consumeMouseEvent(InternalEvent.MOUSE_UP, me);\n    }\n    this.reset();\n  }\n  /**\n   * Resets the state of this handler.\n   */\n  reset() {\n    if (this.livePreviewUsed) {\n      this.resetLivePreview();\n      const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n      this.setHandlesVisibleForCells(selectionCellsHandler?.getHandledSelectionCells() ?? [], true);\n    }\n    this.destroyShapes();\n    this.removeHint();\n    this.delayedSelection = false;\n    this.livePreviewActive = false;\n    this.livePreviewUsed = false;\n    this.cellWasClicked = false;\n    this.suspended = false;\n    this.currentDx = 0;\n    this.currentDy = 0;\n    this.cellCount = 0;\n    this.cloning = false;\n    this.allCells.clear();\n    this.pBounds = null;\n    this.target = null;\n    this.first = null;\n    this.cells = null;\n    this.cell = null;\n  }\n  /**\n   * Returns true if the given cells should be removed from the parent for the specified\n   * mousereleased event.\n   */\n  shouldRemoveCellsFromParent(parent, cells, evt) {\n    if (parent.isVertex()) {\n      const pState = this.graph.getView().getState(parent);\n      if (pState) {\n        let pt = convertPoint(this.graph.container, getClientX(evt), getClientY(evt));\n        const alpha = toRadians(pState.style.rotation ?? 0);\n        if (alpha !== 0) {\n          const cos = Math.cos(-alpha);\n          const sin = Math.sin(-alpha);\n          const cx = new Point(pState.getCenterX(), pState.getCenterY());\n          pt = getRotatedPoint(pt, cos, sin, cx);\n        }\n        return !contains(pState, pt.x, pt.y);\n      }\n    }\n    return false;\n  }\n  /**\n   * Moves the given cells by the specified amount.\n   */\n  moveCells(cells, dx, dy, clone, target, evt) {\n    if (!this.cell) return;\n    if (clone) {\n      cells = this.graph.getCloneableCells(cells);\n    }\n    // Removes cells from parent\n    const parent = this.cell.getParent();\n    if (!target && parent && this.isRemoveCellsFromParent() && this.shouldRemoveCellsFromParent(parent, cells, evt)) {\n      target = this.graph.getDefaultParent();\n    }\n    // Cloning into locked cells is not allowed\n    clone = !!clone && !this.graph.isCellLocked(target || this.graph.getDefaultParent());\n    this.graph.batchUpdate(() => {\n      const parents = [];\n      // Removes parent if all child cells are removed\n      if (!clone && target && this.removeEmptyParents) {\n        // Collects all non-selected parents\n        const dict = new Dictionary();\n        for (let i = 0; i < cells.length; i += 1) {\n          dict.put(cells[i], true);\n        }\n        // LATER: Recurse up the cell hierarchy\n        for (let i = 0; i < cells.length; i += 1) {\n          const par = cells[i].getParent();\n          if (par && !dict.get(par)) {\n            dict.put(par, true);\n            parents.push(par);\n          }\n        }\n      }\n      // Passes all selected cells in order to correctly clone or move into\n      // the target cell. The method checks for each cell if its movable.\n      cells = this.graph.moveCells(cells, dx, dy, clone, target, evt);\n      // Removes parent if all child cells are removed\n      const temp = [];\n      for (let i = 0; i < parents.length; i += 1) {\n        if (this.shouldRemoveParent(parents[i])) {\n          temp.push(parents[i]);\n        }\n      }\n      this.graph.removeCells(temp, false);\n    });\n    // Selects the new cells if cells have been cloned\n    if (clone) {\n      this.graph.setSelectionCells(cells);\n    }\n    if (this.isSelectEnabled() && this.scrollOnMove) {\n      this.graph.scrollCellToVisible(cells[0]);\n    }\n  }\n  /**\n   * Returns true if the given parent should be removed after removal of child cells.\n   */\n  shouldRemoveParent(parent) {\n    const state = this.graph.view.getState(parent);\n    return state != null && (state.cell.isEdge() || state.cell.isVertex()) && this.graph.isCellDeletable(state.cell) && state.cell.getChildCount() === 0 && state.isTransparentState();\n  }\n  /**\n   * Destroy the preview and highlight shapes.\n   */\n  destroyShapes() {\n    // Destroys the preview dashed rectangle\n    if (this.shape) {\n      this.shape.destroy();\n      this.shape = null;\n    }\n    if (this.guide) {\n      this.guide.destroy();\n      this.guide = null;\n    }\n    // Destroys the drop target highlight\n    if (this.highlight) {\n      this.highlight.destroy();\n      this.highlight = null;\n    }\n  }\n  /**\n   * Destroys the handler and all its resources and DOM nodes.\n   */\n  onDestroy() {\n    this.graph.removeMouseListener(this);\n    this.graph.removeListener(this.panHandler);\n    this.graph.removeListener(this.escapeHandler);\n    this.graph.getDataModel().removeListener(this.refreshHandler);\n    this.graph.removeListener(this.refreshHandler);\n    InternalEvent.removeListener(document, 'keydown', this.keyHandler);\n    InternalEvent.removeListener(document, 'keyup', this.keyHandler);\n    this.destroyShapes();\n    this.removeHint();\n  }\n}\nSelectionHandler.pluginId = 'SelectionHandler';\nexport default SelectionHandler;","map":{"version":3,"names":["Client","InternalEvent","contains","getRotatedPoint","isNumeric","toRadians","convertPoint","RectangleShape","mxGuide","Point","CURSOR","DIALECT","DROP_TARGET_COLOR","INVALID_CONNECT_TARGET_COLOR","NONE","VALID_COLOR","Dictionary","CellHighlight","Rectangle","getClientX","getClientY","isAltDown","isMultiTouchEvent","SelectionHandler","constructor","graph","refreshThread","maxCells","enabled","highlightEnabled","cloneEnabled","moveEnabled","guidesEnabled","handlesVisible","guide","currentDx","currentDy","updateCursor","selectEnabled","removeCellsFromParent","removeEmptyParents","connectOnDrop","scrollOnMove","minimumSize","previewColor","htmlPreview","shape","scaleGrid","rotationEnabled","maxLivePreview","allowLivePreview","IS_SVG","cell","delayedSelection","first","cells","bounds","pBounds","allCells","cellWasClicked","cloning","cellCount","target","suspended","livePreviewActive","livePreviewUsed","highlight","addMouseListener","panHandler","updatePreview","updateHint","addListener","PAN","escapeHandler","sender","evt","reset","ESCAPE","refreshHandler","window","clearTimeout","setTimeout","dx","dy","getView","getBounds","getPreviewBounds","selectionCellsHandler","getPlugin","setHandlesVisibleForCells","getHandledSelectionCells","getDataModel","CHANGE","REFRESH","keyHandler","e","container","style","visibility","clone","isCloneEvent","isCellsCloneable","isCloneEnabled","checkPreview","document","isEnabled","setEnabled","value","setCloneEnabled","isMoveEnabled","setMoveEnabled","isSelectEnabled","setSelectEnabled","isRemoveCellsFromParent","setRemoveCellsFromParent","isPropagateSelectionCell","immediate","me","parent","getParent","geo","isEdge","getGeometry","isSiblingSelected","relative","isSwimlane","isToggleEvent","getEvent","isCellSelected","getInitialCellForEvent","state","getState","next","view","isVertex","isDelayedSelection","c","isHandled","cellEditorHandler","getEditingCell","selectDelayed","popupMenuHandler","isPopupTrigger","getCell","selectCellForEvent","isSource","control","consumeMouseEvent","evtName","consume","mouseDown","isConsumed","isCellMovable","getSelectionCount","points","length","getTerminal","isAllowDanglingEdges","start","getX","getY","MOUSE_DOWN","getGuideStates","getDefaultParent","filter","getCellStates","filterDescendants","getCells","initialCell","getMovableCells","getSelectionCells","getBoundingBox","width","Math","max","height","x","round","ceil","y","result","i","bbox","boundingBox","fromRectangle","add","createPreviewShape","isDashed","dialect","STRICTHTML","init","SVG","getOverlayPane","pointerEvents","IS_IOS","getSvgScreenOffset","createGuide","addStates","ignore","getChildCount","connected","opps","getOpposites","getEdges","get","put","isStateIgnored","p","isCellMoving","dict","count","childCount","getChildAt","useGuidesForEvent","isEnabledForEvent","isConstrainedEvent","snap","vector","scale","getDelta","point","getPanDx","getPanDy","removeHint","roundLength","isValidDropTarget","resetLivePreview","mouseMove","isMouseDown","delta","tol","getEventTolerance","abs","gridEnabled","isGridEnabledEvent","hideGuide","isDropEnabled","getDropTarget","setHighlightColor","isConnectable","error","getEdgeValidationError","color","hide","move","snapDelta","MOUSE_MOVE","sourceState","cursor","getCursorForMouseEvent","MOVABLE_EDGE","MOVABLE_VERTEX","setCursor","remote","updateLivePreview","updatePreviewShape","redraw","states","visit","key","realState","destroy","remove","tempState","push","originalPointerEvents","text","cellRenderer","invalidate","invalid","node","updateBoundingBox","unrotatedBoundingBox","s","geometry","j","source","visibleSourceState","visibleTargetState","pts","absolutePoints","pt0","setAbsoluteTerminalPoint","updateFixedTerminalPoint","getConnectionConstraint","ptn","updatePoints","updateFloatingTerminalPoints","updateEdgeLabelOffset","validate","redrawHandles","resetPreviewStates","handler","getHandler","setState","suspend","setVisible","resume","visible","force","setHandlesVisible","mouseUp","isEdgeValid","connectionHandler","connect","isSplitEnabled","isSplitTarget","splitEdge","getGraphX","getGraphY","moveCells","MOUSE_UP","destroyShapes","clear","shouldRemoveCellsFromParent","pState","pt","alpha","rotation","cos","sin","cx","getCenterX","getCenterY","getCloneableCells","isCellLocked","batchUpdate","parents","par","temp","shouldRemoveParent","removeCells","setSelectionCells","scrollCellToVisible","isCellDeletable","isTransparentState","onDestroy","removeMouseListener","removeListener","pluginId"],"sources":["D:/ospanel/domains/react/react-intro/node_modules/@maxgraph/core/dist/view/handler/SelectionHandler.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Client from '../../Client';\nimport InternalEvent from '../event/InternalEvent';\nimport { contains, getRotatedPoint, isNumeric, toRadians } from '../../util/mathUtils';\nimport { convertPoint } from '../../util/styleUtils';\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport mxGuide from '../other/Guide';\nimport Point from '../geometry/Point';\nimport { CURSOR, DIALECT, DROP_TARGET_COLOR, INVALID_CONNECT_TARGET_COLOR, NONE, VALID_COLOR, } from '../../util/Constants';\nimport Dictionary from '../../util/Dictionary';\nimport CellHighlight from '../cell/CellHighlight';\nimport Rectangle from '../geometry/Rectangle';\nimport { getClientX, getClientY, isAltDown, isMultiTouchEvent, } from '../../util/EventUtils';\n/**\n * Graph event handler that handles selection. Individual cells are handled\n * separately using {@link VertexHandler} or one of the edge handlers. These\n * handlers are created using {@link Graph#createHandler} in\n * {@link GraphSelectionModel#cellAdded}.\n *\n * To avoid the container to scroll a moved cell into view, set {@link scrollOnMove} to `false`.\n *\n * Constructs an event handler that creates handles for the selection cells.\n *\n * @param graph Reference to the enclosing {@link Graph}.\n */\nclass SelectionHandler {\n    constructor(graph) {\n        this.refreshThread = null;\n        /**\n         * Defines the maximum number of cells to paint subhandles\n         * for. Default is 50 for Firefox and 20 for IE. Set this\n         * to 0 if you want an unlimited number of handles to be\n         * displayed. This is only recommended if the number of\n         * cells in the graph is limited to a small number, eg.\n         * 500.\n         */\n        this.maxCells = 50;\n        /**\n         * Specifies if events are handled. Default is true.\n         */\n        this.enabled = true;\n        /**\n         * Specifies if drop targets under the mouse should be enabled. Default is\n         * true.\n         */\n        this.highlightEnabled = true;\n        /**\n         * Specifies if cloning by control-drag is enabled. Default is true.\n         */\n        this.cloneEnabled = true;\n        /**\n         * Specifies if moving is enabled. Default is true.\n         */\n        this.moveEnabled = true;\n        /**\n         * Specifies if other cells should be used for snapping the right, center or\n         * left side of the current selection. Default is false.\n         */\n        this.guidesEnabled = false;\n        /**\n         * Whether the handles of the selection are currently visible.\n         */\n        this.handlesVisible = true;\n        /**\n         * Holds the {@link Guide} instance that is used for alignment.\n         */\n        this.guide = null;\n        /**\n         * Stores the x-coordinate of the current mouse move.\n         */\n        this.currentDx = 0;\n        /**\n         * Stores the y-coordinate of the current mouse move.\n         */\n        this.currentDy = 0;\n        /**\n         * Specifies if a move cursor should be shown if the mouse is over a movable\n         * cell. Default is true.\n         */\n        this.updateCursor = true;\n        /**\n         * Specifies if selecting is enabled. Default is true.\n         */\n        this.selectEnabled = true;\n        /**\n         * Specifies if cells may be moved out of their parents. Default is true.\n         */\n        this.removeCellsFromParent = true;\n        /**\n         * If empty parents should be removed from the model after all child cells\n         * have been moved out. Default is true.\n         */\n        this.removeEmptyParents = false;\n        /**\n         * Specifies if drop events are interpreted as new connections if no other\n         * drop action is defined. Default is false.\n         */\n        this.connectOnDrop = false;\n        /**\n         * Specifies if the view should be scrolled so that a moved cell is visible.\n         * @default true\n         */\n        this.scrollOnMove = true;\n        /**\n         * Specifies the minimum number of pixels for the width and height of a\n         * selection border. Default is 6.\n         */\n        this.minimumSize = 6;\n        /**\n         * Specifies the color of the preview shape. Default is black.\n         */\n        this.previewColor = 'black';\n        /**\n         * Specifies if the graph container should be used for preview. If this is used\n         * then drop target detection relies entirely on {@link Graph#getCellAt} because\n         * the HTML preview does not \"let events through\". Default is false.\n         */\n        this.htmlPreview = false;\n        /**\n         * Reference to the {@link Shape} that represents the preview.\n         */\n        this.shape = null;\n        /**\n         * Specifies if the grid should be scaled. Default is false.\n         */\n        this.scaleGrid = false;\n        /**\n         * Specifies if the bounding box should allow for rotation. Default is true.\n         */\n        this.rotationEnabled = true;\n        /**\n         * Maximum number of cells for which live preview should be used.  Default is 0 which means no live preview.\n         */\n        this.maxLivePreview = 0;\n        /**\n         * Variable allowLivePreview\n         *\n         * If live preview is allowed on this system.  Default is true for systems with SVG support.\n         */\n        this.allowLivePreview = Client.IS_SVG;\n        this.cell = null;\n        this.delayedSelection = false;\n        this.first = null;\n        this.cells = null;\n        this.bounds = null;\n        this.pBounds = null;\n        this.allCells = new Dictionary();\n        this.cellWasClicked = false;\n        this.cloning = false;\n        this.cellCount = 0;\n        this.target = null;\n        this.suspended = false;\n        this.livePreviewActive = false;\n        this.livePreviewUsed = false;\n        this.highlight = null;\n        this.graph = graph;\n        this.graph.addMouseListener(this);\n        // Repaints the handler after autoscroll\n        this.panHandler = () => {\n            if (!this.suspended) {\n                this.updatePreview();\n                this.updateHint();\n            }\n        };\n        this.graph.addListener(InternalEvent.PAN, this.panHandler);\n        // Handles escape keystrokes\n        this.escapeHandler = (sender, evt) => {\n            this.reset();\n        };\n        this.graph.addListener(InternalEvent.ESCAPE, this.escapeHandler);\n        // Updates the preview box for remote changes\n        this.refreshHandler = (sender, evt) => {\n            // Merges multiple pending calls\n            if (this.refreshThread) {\n                window.clearTimeout(this.refreshThread);\n            }\n            // Waits for the states and handlers to be updated\n            this.refreshThread = window.setTimeout(() => {\n                this.refreshThread = null;\n                if (this.first && !this.suspended && this.cells) {\n                    // Updates preview with no translate to compute bounding box\n                    const dx = this.currentDx;\n                    const dy = this.currentDy;\n                    this.currentDx = 0;\n                    this.currentDy = 0;\n                    this.updatePreview();\n                    this.bounds = this.graph.getView().getBounds(this.cells);\n                    this.pBounds = this.getPreviewBounds(this.cells);\n                    if (this.pBounds == null && !this.livePreviewUsed) {\n                        this.reset();\n                    }\n                    else {\n                        // Restores translate and updates preview\n                        this.currentDx = dx;\n                        this.currentDy = dy;\n                        this.updatePreview();\n                        this.updateHint();\n                        if (this.livePreviewUsed) {\n                            const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n                            // Forces update to ignore last visible state\n                            this.setHandlesVisibleForCells(selectionCellsHandler?.getHandledSelectionCells() ?? [], false, true);\n                            this.updatePreview();\n                        }\n                    }\n                }\n            }, 0);\n        };\n        this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.refreshHandler);\n        this.graph.addListener(InternalEvent.REFRESH, this.refreshHandler);\n        this.keyHandler = (e) => {\n            if (this.graph.container != null &&\n                this.graph.container.style.visibility !== 'hidden' &&\n                this.first != null &&\n                !this.suspended) {\n                const clone = this.graph.isCloneEvent(e) &&\n                    this.graph.isCellsCloneable() &&\n                    this.isCloneEnabled();\n                if (clone !== this.cloning) {\n                    this.cloning = clone;\n                    this.checkPreview();\n                    this.updatePreview();\n                }\n            }\n        };\n        if (typeof document !== 'undefined') {\n            InternalEvent.addListener(document, 'keydown', this.keyHandler);\n            InternalEvent.addListener(document, 'keyup', this.keyHandler);\n        }\n    }\n    /**\n     * Returns <enabled>.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Sets <enabled>.\n     */\n    setEnabled(value) {\n        this.enabled = value;\n    }\n    /**\n     * Returns <cloneEnabled>.\n     */\n    isCloneEnabled() {\n        return this.cloneEnabled;\n    }\n    /**\n     * Sets <cloneEnabled>.\n     *\n     * @param value Boolean that specifies the new clone enabled state.\n     */\n    setCloneEnabled(value) {\n        this.cloneEnabled = value;\n    }\n    /**\n     * Returns {@link oveEnabled}.\n     */\n    isMoveEnabled() {\n        return this.moveEnabled;\n    }\n    /**\n     * Sets {@link oveEnabled}.\n     */\n    setMoveEnabled(value) {\n        this.moveEnabled = value;\n    }\n    /**\n     * Returns <selectEnabled>.\n     */\n    isSelectEnabled() {\n        return this.selectEnabled;\n    }\n    /**\n     * Sets <selectEnabled>.\n     */\n    setSelectEnabled(value) {\n        this.selectEnabled = value;\n    }\n    /**\n     * Returns <removeCellsFromParent>.\n     */\n    isRemoveCellsFromParent() {\n        return this.removeCellsFromParent;\n    }\n    /**\n     * Sets <removeCellsFromParent>.\n     */\n    setRemoveCellsFromParent(value) {\n        this.removeCellsFromParent = value;\n    }\n    /**\n     * Returns true if the given cell and parent should propagate\n     * selection state to the parent.\n     */\n    isPropagateSelectionCell(cell, immediate, me) {\n        const parent = cell.getParent();\n        if (immediate) {\n            const geo = cell.isEdge() ? null : cell.getGeometry();\n            return ((!this.graph.isSiblingSelected(cell) && geo && geo.relative) ||\n                !this.graph.isSwimlane(parent));\n        }\n        return ((!this.graph.isToggleEvent(me.getEvent()) ||\n            (!this.graph.isSiblingSelected(cell) &&\n                !this.graph.isCellSelected(cell) &&\n                !this.graph.isSwimlane(parent)) ||\n            this.graph.isCellSelected(parent)) &&\n            (this.graph.isToggleEvent(me.getEvent()) || !this.graph.isCellSelected(parent)));\n    }\n    /**\n     * Hook to return initial cell for the given event.\n     */\n    getInitialCellForEvent(me) {\n        let state = me.getState();\n        if ((!this.graph.isToggleEvent(me.getEvent()) || !isAltDown(me.getEvent())) &&\n            state &&\n            !this.graph.isCellSelected(state.cell)) {\n            let parent = state.cell.getParent();\n            let next = parent ? this.graph.view.getState(parent) : null;\n            while (next &&\n                !this.graph.isCellSelected(next.cell) &&\n                (next.cell.isVertex() || next.cell.isEdge()) &&\n                this.isPropagateSelectionCell(state.cell, true, me)) {\n                state = next;\n                parent = state.cell.getParent();\n                next = parent ? this.graph.view.getState(parent) : null;\n            }\n        }\n        return state ? state.cell : null;\n    }\n    /**\n     * Hook to return true for delayed selections.\n     */\n    isDelayedSelection(cell, me) {\n        let c = cell;\n        const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n        if (!this.graph.isToggleEvent(me.getEvent()) || !isAltDown(me.getEvent())) {\n            while (c) {\n                if (selectionCellsHandler?.isHandled(c)) {\n                    const cellEditorHandler = this.graph.getPlugin('CellEditorHandler');\n                    return cellEditorHandler?.getEditingCell() !== c;\n                }\n                c = c.getParent();\n            }\n        }\n        return this.graph.isToggleEvent(me.getEvent()) && !isAltDown(me.getEvent());\n    }\n    /**\n     * Implements the delayed selection for the given mouse event.\n     */\n    selectDelayed(me) {\n        const popupMenuHandler = this.graph.getPlugin('PopupMenuHandler');\n        if (!popupMenuHandler || !popupMenuHandler.isPopupTrigger(me)) {\n            let cell = me.getCell();\n            if (cell === null) {\n                cell = this.cell;\n            }\n            if (cell)\n                this.selectCellForEvent(cell, me);\n        }\n    }\n    /**\n     * Selects the given cell for the given {@link MouseEvent}.\n     */\n    selectCellForEvent(cell, me) {\n        const state = this.graph.view.getState(cell);\n        if (state) {\n            if (me.isSource(state.control)) {\n                this.graph.selectCellForEvent(cell, me.getEvent());\n            }\n            else {\n                if (!this.graph.isToggleEvent(me.getEvent()) || !isAltDown(me.getEvent())) {\n                    let parent = cell.getParent();\n                    while (parent &&\n                        this.graph.view.getState(parent) &&\n                        (parent.isVertex() || parent.isEdge()) &&\n                        this.isPropagateSelectionCell(cell, false, me)) {\n                        cell = parent;\n                        parent = cell.getParent();\n                    }\n                }\n                this.graph.selectCellForEvent(cell, me.getEvent());\n            }\n        }\n        return cell;\n    }\n    /**\n     * Consumes the given mouse event. NOTE: This may be used to enable click\n     * events for links in labels on iOS as follows as consuming the initial\n     * touchStart disables firing the subsequent click evnent on the link.\n     *\n     * <code>\n     * consumeMouseEvent(evtName, me)\n     * {\n     *   var source = mxEvent.getSource(me.getEvent());\n     *\n     *   if (!mxEvent.isTouchEvent(me.getEvent()) || source.nodeName != 'A')\n     *   {\n     *     me.consume();\n     *   }\n     * }\n     * </code>\n     */\n    consumeMouseEvent(evtName, me) {\n        me.consume();\n    }\n    /**\n     * Handles the event by selecing the given cell and creating a handle for\n     * it. By consuming the event all subsequent events of the gesture are\n     * redirected to this handler.\n     */\n    mouseDown(sender, me) {\n        if (!me.isConsumed() &&\n            this.isEnabled() &&\n            this.graph.isEnabled() &&\n            me.getState() &&\n            !isMultiTouchEvent(me.getEvent())) {\n            const cell = this.getInitialCellForEvent(me);\n            if (cell) {\n                this.delayedSelection = this.isDelayedSelection(cell, me);\n                this.cell = null;\n                if (this.isSelectEnabled() && !this.delayedSelection) {\n                    this.graph.selectCellForEvent(cell, me.getEvent());\n                }\n                if (this.isMoveEnabled()) {\n                    const geo = cell.getGeometry();\n                    if (geo &&\n                        this.graph.isCellMovable(cell) &&\n                        (!cell.isEdge() ||\n                            this.graph.getSelectionCount() > 1 ||\n                            (geo.points && geo.points.length > 0) ||\n                            !cell.getTerminal(true) ||\n                            !cell.getTerminal(false) ||\n                            this.graph.isAllowDanglingEdges() ||\n                            (this.graph.isCloneEvent(me.getEvent()) && this.graph.isCellsCloneable()))) {\n                        this.start(cell, me.getX(), me.getY());\n                    }\n                    else if (this.delayedSelection) {\n                        this.cell = cell;\n                    }\n                    this.cellWasClicked = true;\n                    this.consumeMouseEvent(InternalEvent.MOUSE_DOWN, me);\n                }\n            }\n        }\n    }\n    /**\n     * Creates an array of cell states which should be used as guides.\n     */\n    getGuideStates() {\n        const parent = this.graph.getDefaultParent();\n        const filter = (cell) => {\n            const geo = cell.getGeometry();\n            return (!!this.graph.view.getState(cell) && cell.isVertex() && !!geo && !geo.relative);\n        };\n        return this.graph.view.getCellStates(parent.filterDescendants(filter));\n    }\n    /**\n     * Returns the cells to be modified by this handler. This implementation\n     * returns all selection cells that are movable, or the given initial cell if\n     * the given cell is not selected and movable. This handles the case of moving\n     * unselectable or unselected cells.\n     *\n     * @param initialCell <Cell> that triggered this handler.\n     */\n    getCells(initialCell) {\n        if (!this.delayedSelection && this.graph.isCellMovable(initialCell)) {\n            return [initialCell];\n        }\n        return this.graph.getMovableCells(this.graph.getSelectionCells());\n    }\n    /**\n     * Returns the {@link Rectangle} used as the preview bounds for\n     * moving the given cells.\n     */\n    getPreviewBounds(cells) {\n        const bounds = this.getBoundingBox(cells);\n        if (bounds) {\n            // Corrects width and height\n            bounds.width = Math.max(0, bounds.width - 1);\n            bounds.height = Math.max(0, bounds.height - 1);\n            if (bounds.width < this.minimumSize) {\n                const dx = this.minimumSize - bounds.width;\n                bounds.x -= dx / 2;\n                bounds.width = this.minimumSize;\n            }\n            else {\n                bounds.x = Math.round(bounds.x);\n                bounds.width = Math.ceil(bounds.width);\n            }\n            if (bounds.height < this.minimumSize) {\n                const dy = this.minimumSize - bounds.height;\n                bounds.y -= dy / 2;\n                bounds.height = this.minimumSize;\n            }\n            else {\n                bounds.y = Math.round(bounds.y);\n                bounds.height = Math.ceil(bounds.height);\n            }\n        }\n        return bounds;\n    }\n    /**\n     * Returns the union of the {@link CellStates} for the given array of {@link Cells}.\n     * For vertices, this method uses the bounding box of the corresponding shape\n     * if one exists. The bounding box of the corresponding text label and all\n     * controls and overlays are ignored. See also: {@link GraphView#getBounds} and\n     * {@link Graph#getBoundingBox}.\n     *\n     * @param cells Array of {@link Cells} whose bounding box should be returned.\n     */\n    getBoundingBox(cells) {\n        let result = null;\n        if (cells.length > 0) {\n            for (let i = 0; i < cells.length; i += 1) {\n                if (cells[i].isVertex() || cells[i].isEdge()) {\n                    const state = this.graph.view.getState(cells[i]);\n                    if (state) {\n                        let bbox = null;\n                        if (cells[i].isVertex() && state.shape && state.shape.boundingBox) {\n                            bbox = state.shape.boundingBox;\n                        }\n                        if (bbox) {\n                            if (!result) {\n                                result = Rectangle.fromRectangle(bbox);\n                            }\n                            else {\n                                result.add(bbox);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Creates the shape used to draw the preview for the given bounds.\n     */\n    createPreviewShape(bounds) {\n        const shape = new RectangleShape(bounds, NONE, this.previewColor);\n        shape.isDashed = true;\n        if (this.htmlPreview) {\n            shape.dialect = DIALECT.STRICTHTML;\n            shape.init(this.graph.container);\n        }\n        else {\n            // Makes sure to use either VML or SVG shapes in order to implement\n            // event-transparency on the background area of the rectangle since\n            // HTML shapes do not let mouseevents through even when transparent\n            shape.dialect = DIALECT.SVG;\n            shape.init(this.graph.getView().getOverlayPane());\n            shape.pointerEvents = false;\n            // Workaround for artifacts on iOS\n            if (Client.IS_IOS) {\n                shape.getSvgScreenOffset = () => {\n                    return 0;\n                };\n            }\n        }\n        return shape;\n    }\n    createGuide() {\n        return new mxGuide(this.graph, this.getGuideStates());\n    }\n    /**\n     * Starts the handling of the mouse gesture.\n     */\n    start(cell, x, y, cells) {\n        this.cell = cell;\n        this.first = convertPoint(this.graph.container, x, y);\n        this.cells = cells ? cells : this.getCells(this.cell);\n        this.bounds = this.graph.getView().getBounds(this.cells);\n        this.pBounds = this.getPreviewBounds(this.cells);\n        this.cloning = false;\n        this.cellCount = 0;\n        for (let i = 0; i < this.cells.length; i += 1) {\n            this.cellCount += this.addStates(this.cells[i], this.allCells);\n        }\n        if (this.guidesEnabled) {\n            this.guide = this.createGuide();\n            const parent = cell.getParent();\n            const ignore = parent.getChildCount() < 2;\n            // Uses connected states as guides\n            const connected = new Dictionary();\n            const opps = this.graph.getOpposites(this.graph.getEdges(this.cell), this.cell);\n            for (let i = 0; i < opps.length; i += 1) {\n                const state = this.graph.view.getState(opps[i]);\n                if (state && !connected.get(state)) {\n                    connected.put(state, true);\n                }\n            }\n            this.guide.isStateIgnored = (state) => {\n                const p = state.cell.getParent();\n                return (!!state.cell &&\n                    ((!this.cloning && !!this.isCellMoving(state.cell)) ||\n                        (state.cell !== (this.target || parent) &&\n                            !ignore &&\n                            !connected.get(state) &&\n                            (!this.target || this.target.getChildCount() >= 2) &&\n                            p !== (this.target || parent))));\n            };\n        }\n    }\n    /**\n     * Adds the states for the given cell recursively to the given dictionary.\n     * @param cell\n     * @param dict\n     */\n    addStates(cell, dict) {\n        const state = this.graph.view.getState(cell);\n        let count = 0;\n        if (state && !dict.get(cell)) {\n            dict.put(cell, state);\n            count++;\n            const childCount = cell.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                count += this.addStates(cell.getChildAt(i), dict);\n            }\n        }\n        return count;\n    }\n    /**\n     * Returns true if the given cell is currently being moved.\n     */\n    isCellMoving(cell) {\n        return this.allCells.get(cell);\n    }\n    /**\n     * Returns true if the guides should be used for the given {@link MouseEvent}.\n     * This implementation returns {@link Guide#isEnabledForEvent}.\n     */\n    useGuidesForEvent(me) {\n        return this.guide\n            ? this.guide.isEnabledForEvent(me.getEvent()) &&\n                !this.graph.isConstrainedEvent(me.getEvent())\n            : true;\n    }\n    /**\n     * Snaps the given vector to the grid and returns the given mxPoint instance.\n     */\n    snap(vector) {\n        const scale = this.scaleGrid ? this.graph.view.scale : 1;\n        vector.x = this.graph.snap(vector.x / scale) * scale;\n        vector.y = this.graph.snap(vector.y / scale) * scale;\n        return vector;\n    }\n    /**\n     * Returns an {@link Point} that represents the vector for moving the cells\n     * for the given {@link MouseEvent}.\n     */\n    getDelta(me) {\n        const point = convertPoint(this.graph.container, me.getX(), me.getY());\n        if (!this.first)\n            return new Point();\n        return new Point(point.x - this.first.x - this.graph.getPanDx(), point.y - this.first.y - this.graph.getPanDy());\n    }\n    /**\n     * Hook for subclassers do show details while the handler is active.\n     */\n    updateHint(me) {\n        return;\n    }\n    /**\n     * Hooks for subclassers to hide details when the handler gets inactive.\n     */\n    removeHint() {\n        return;\n    }\n    /**\n     * Hook for rounding the unscaled vector. This uses Math.round.\n     */\n    roundLength(length) {\n        return Math.round(length * 100) / 100;\n    }\n    /**\n     * Returns true if the given cell is a valid drop target.\n     */\n    isValidDropTarget(target, me) {\n        return this.cell ? this.cell.getParent() !== target : false;\n    }\n    /**\n     * Updates the preview if cloning state has changed.\n     */\n    checkPreview() {\n        if (this.livePreviewActive && this.cloning) {\n            this.resetLivePreview();\n            this.livePreviewActive = false;\n        }\n        else if (this.maxLivePreview >= this.cellCount &&\n            !this.livePreviewActive &&\n            this.allowLivePreview) {\n            if (!this.cloning || !this.livePreviewActive) {\n                this.livePreviewActive = true;\n                this.livePreviewUsed = true;\n            }\n        }\n        else if (!this.livePreviewUsed && !this.shape && this.bounds) {\n            this.shape = this.createPreviewShape(this.bounds);\n        }\n    }\n    /**\n     * Handles the event by highlighting possible drop targets and updating the\n     * preview.\n     */\n    mouseMove(sender, me) {\n        const { graph } = this;\n        if (!me.isConsumed() &&\n            graph.isMouseDown &&\n            this.cell &&\n            this.first &&\n            this.bounds &&\n            !this.suspended) {\n            // Stops moving if a multi touch event is received\n            if (isMultiTouchEvent(me.getEvent())) {\n                this.reset();\n                return;\n            }\n            let delta = this.getDelta(me);\n            const tol = graph.getEventTolerance();\n            if (this.shape ||\n                this.livePreviewActive ||\n                Math.abs(delta.x) > tol ||\n                Math.abs(delta.y) > tol) {\n                // Highlight is used for highlighting drop targets\n                if (!this.highlight) {\n                    this.highlight = new CellHighlight(this.graph, DROP_TARGET_COLOR, 3);\n                }\n                const clone = graph.isCloneEvent(me.getEvent()) &&\n                    graph.isCellsCloneable() &&\n                    this.isCloneEnabled();\n                const gridEnabled = graph.isGridEnabledEvent(me.getEvent());\n                const cell = me.getCell();\n                let hideGuide = true;\n                let target = null;\n                this.cloning = clone;\n                if (graph.isDropEnabled() && this.highlightEnabled && this.cells) {\n                    // Contains a call to getCellAt to find the cell under the mouse\n                    target = graph.getDropTarget(this.cells, me.getEvent(), cell, clone);\n                }\n                let state = target ? graph.getView().getState(target) : null;\n                let highlight = false;\n                if (state && (clone || (target && this.isValidDropTarget(target, me)))) {\n                    if (this.target !== target) {\n                        this.target = target;\n                        this.setHighlightColor(DROP_TARGET_COLOR);\n                    }\n                    highlight = true;\n                }\n                else {\n                    this.target = null;\n                    if (this.connectOnDrop &&\n                        cell &&\n                        this.cells &&\n                        this.cells.length === 1 &&\n                        cell.isVertex() &&\n                        cell.isConnectable()) {\n                        state = graph.getView().getState(cell);\n                        if (state) {\n                            const error = graph.getEdgeValidationError(null, this.cell, cell);\n                            const color = error === null ? VALID_COLOR : INVALID_CONNECT_TARGET_COLOR;\n                            this.setHighlightColor(color);\n                            highlight = true;\n                        }\n                    }\n                }\n                if (state && highlight) {\n                    this.highlight.highlight(state);\n                }\n                else {\n                    this.highlight.hide();\n                }\n                if (this.guide && this.useGuidesForEvent(me)) {\n                    delta = this.guide.move(this.bounds, delta, gridEnabled, clone);\n                    hideGuide = false;\n                }\n                else {\n                    delta = this.graph.snapDelta(delta, this.bounds, !gridEnabled, false, false);\n                }\n                if (this.guide && hideGuide) {\n                    this.guide.hide();\n                }\n                // Constrained movement if shift key is pressed\n                if (graph.isConstrainedEvent(me.getEvent())) {\n                    if (Math.abs(delta.x) > Math.abs(delta.y)) {\n                        delta.y = 0;\n                    }\n                    else {\n                        delta.x = 0;\n                    }\n                }\n                this.checkPreview();\n                if (this.currentDx !== delta.x || this.currentDy !== delta.y) {\n                    this.currentDx = delta.x;\n                    this.currentDy = delta.y;\n                    this.updatePreview();\n                }\n            }\n            this.updateHint(me);\n            this.consumeMouseEvent(InternalEvent.MOUSE_MOVE, me);\n            // Cancels the bubbling of events to the container so\n            // that the droptarget is not reset due to an mouseMove\n            // fired on the container with no associated state.\n            InternalEvent.consume(me.getEvent());\n        }\n        else if ((this.isMoveEnabled() || this.isCloneEnabled()) &&\n            this.updateCursor &&\n            !me.isConsumed() &&\n            (me.getState() || me.sourceState) &&\n            !graph.isMouseDown) {\n            let cursor = graph.getCursorForMouseEvent(me);\n            const cell = me.getCell();\n            if (!cursor && cell && graph.isEnabled() && graph.isCellMovable(cell)) {\n                if (cell.isEdge()) {\n                    cursor = CURSOR.MOVABLE_EDGE;\n                }\n                else {\n                    cursor = CURSOR.MOVABLE_VERTEX;\n                }\n            }\n            // Sets the cursor on the original source state under the mouse\n            // instead of the event source state which can be the parent\n            if (cursor && me.sourceState) {\n                me.sourceState.setCursor(cursor);\n            }\n        }\n    }\n    /**\n     * Updates the bounds of the preview shape.\n     */\n    updatePreview(remote = false) {\n        if (this.livePreviewUsed && !remote) {\n            if (this.cells) {\n                const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n                this.setHandlesVisibleForCells(selectionCellsHandler?.getHandledSelectionCells() ?? [], false);\n                this.updateLivePreview(this.currentDx, this.currentDy);\n            }\n        }\n        else {\n            this.updatePreviewShape();\n        }\n    }\n    /**\n     * Updates the bounds of the preview shape.\n     */\n    updatePreviewShape() {\n        if (this.shape && this.pBounds) {\n            this.shape.bounds = new Rectangle(Math.round(this.pBounds.x + this.currentDx), Math.round(this.pBounds.y + this.currentDy), this.pBounds.width, this.pBounds.height);\n            this.shape.redraw();\n        }\n    }\n    /**\n     * Updates the bounds of the preview shape.\n     */\n    updateLivePreview(dx, dy) {\n        if (!this.suspended) {\n            const states = [];\n            if (this.allCells) {\n                this.allCells.visit((key, state) => {\n                    const realState = state ? this.graph.view.getState(state.cell) : null;\n                    // Checks if cell was removed or replaced\n                    if (realState !== state && state) {\n                        state.destroy();\n                        if (realState) {\n                            this.allCells.put(state.cell, realState);\n                        }\n                        else {\n                            this.allCells.remove(state.cell);\n                        }\n                        state = realState;\n                    }\n                    if (state) {\n                        // Saves current state\n                        const tempState = state.clone();\n                        states.push([state, tempState]);\n                        // Makes transparent for events to detect drop targets\n                        if (state.shape) {\n                            if (state.shape.originalPointerEvents === null) {\n                                state.shape.originalPointerEvents = state.shape.pointerEvents;\n                            }\n                            state.shape.pointerEvents = false;\n                            if (state.text) {\n                                if (state.text.originalPointerEvents === null) {\n                                    state.text.originalPointerEvents = state.text.pointerEvents;\n                                }\n                                state.text.pointerEvents = false;\n                            }\n                        }\n                        // Temporarily changes position\n                        if (state.cell.isVertex()) {\n                            state.x += dx;\n                            state.y += dy;\n                            // Draws the live preview\n                            if (!this.cloning) {\n                                state.view.graph.cellRenderer.redraw(state, true);\n                                // Forces redraw of connected edges after all states\n                                // have been updated but avoids update of state\n                                state.view.invalidate(state.cell);\n                                state.invalid = false;\n                                // Hides folding icon\n                                if (state.control && state.control.node) {\n                                    state.control.node.style.visibility = 'hidden';\n                                }\n                            }\n                            // Clone live preview may use text bounds\n                            else if (state.text) {\n                                state.text.updateBoundingBox();\n                                // Fixes preview box for edge labels\n                                if (state.text.boundingBox) {\n                                    state.text.boundingBox.x += dx;\n                                    state.text.boundingBox.y += dy;\n                                }\n                                if (state.text.unrotatedBoundingBox) {\n                                    state.text.unrotatedBoundingBox.x += dx;\n                                    state.text.unrotatedBoundingBox.y += dy;\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            // Resets the handler if everything was removed\n            if (states.length === 0) {\n                this.reset();\n            }\n            else {\n                // Redraws connected edges\n                const s = this.graph.view.scale;\n                for (let i = 0; i < states.length; i += 1) {\n                    const state = states[i][0];\n                    if (state.cell.isEdge()) {\n                        const geometry = state.cell.getGeometry();\n                        const points = [];\n                        if (geometry && geometry.points) {\n                            for (let j = 0; j < geometry.points.length; j++) {\n                                if (geometry.points[j]) {\n                                    points.push(new Point(geometry.points[j].x + dx / s, geometry.points[j].y + dy / s));\n                                }\n                            }\n                        }\n                        let source = state.visibleSourceState;\n                        let target = state.visibleTargetState;\n                        const pts = states[i][1].absolutePoints;\n                        if (source == null || !this.isCellMoving(source.cell)) {\n                            const pt0 = pts[0];\n                            if (pt0) {\n                                state.setAbsoluteTerminalPoint(new Point(pt0.x + dx, pt0.y + dy), true);\n                                source = null;\n                            }\n                        }\n                        else {\n                            state.view.updateFixedTerminalPoint(state, source, true, this.graph.getConnectionConstraint(state, source, true));\n                        }\n                        if (target == null || !this.isCellMoving(target.cell)) {\n                            const ptn = pts[pts.length - 1];\n                            if (ptn) {\n                                state.setAbsoluteTerminalPoint(new Point(ptn.x + dx, ptn.y + dy), false);\n                                target = null;\n                            }\n                        }\n                        else {\n                            state.view.updateFixedTerminalPoint(state, target, false, this.graph.getConnectionConstraint(state, target, false));\n                        }\n                        state.view.updatePoints(state, points, source, target);\n                        state.view.updateFloatingTerminalPoints(state, source, target);\n                        state.view.updateEdgeLabelOffset(state);\n                        state.invalid = false;\n                        // Draws the live preview but avoids update of state\n                        if (!this.cloning) {\n                            state.view.graph.cellRenderer.redraw(state, true);\n                        }\n                    }\n                }\n                this.graph.view.validate();\n                this.redrawHandles(states);\n                this.resetPreviewStates(states);\n            }\n        }\n    }\n    /**\n     * Redraws the preview shape for the given states array.\n     */\n    redrawHandles(states) {\n        const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n        for (let i = 0; i < states.length; i += 1) {\n            const handler = selectionCellsHandler?.getHandler(states[i][0].cell);\n            handler?.redraw(true);\n        }\n    }\n    /**\n     * Resets the given preview states array.\n     */\n    resetPreviewStates(states) {\n        for (let i = 0; i < states.length; i += 1) {\n            states[i][0].setState(states[i][1]);\n        }\n    }\n    /**\n     * Suspends the livew preview.\n     */\n    suspend() {\n        if (!this.suspended) {\n            if (this.livePreviewUsed) {\n                this.updateLivePreview(0, 0);\n            }\n            if (this.shape) {\n                this.shape.node.style.visibility = 'hidden';\n            }\n            if (this.guide) {\n                this.guide.setVisible(false);\n            }\n            this.suspended = true;\n        }\n    }\n    /**\n     * Suspends the livew preview.\n     */\n    resume() {\n        if (this.suspended) {\n            this.suspended = false;\n            if (this.livePreviewUsed) {\n                this.livePreviewActive = true;\n            }\n            if (this.shape) {\n                this.shape.node.style.visibility = 'visible';\n            }\n            if (this.guide) {\n                this.guide.setVisible(true);\n            }\n        }\n    }\n    /**\n     * Resets the livew preview.\n     */\n    resetLivePreview() {\n        this.allCells.visit((key, state) => {\n            // Restores event handling\n            if (state.shape && state.shape.originalPointerEvents !== null) {\n                state.shape.pointerEvents = state.shape.originalPointerEvents;\n                state.shape.originalPointerEvents = null;\n                // Forces repaint even if not moved to update pointer events\n                state.shape.bounds = null;\n                if (state.text && state.text.originalPointerEvents !== null) {\n                    state.text.pointerEvents = state.text.originalPointerEvents;\n                    state.text.originalPointerEvents = null;\n                }\n            }\n            // Shows folding icon\n            if (state.control &&\n                state.control.node &&\n                state.control.node.style.visibility === 'hidden') {\n                state.control.node.style.visibility = '';\n            }\n            // Fixes preview box for edge labels\n            if (!this.cloning) {\n                if (state.text) {\n                    state.text.updateBoundingBox();\n                }\n            }\n            // Forces repaint of connected edges\n            state.view.invalidate(state.cell);\n        });\n        // Repaints all invalid states\n        this.graph.view.validate();\n    }\n    /**\n     * Sets wether the handles attached to the given cells are visible.\n     *\n     * @param cells Array of {@link Cells}.\n     * @param visible Boolean that specifies if the handles should be visible.\n     * @param force Forces an update of the handler regardless of the last used value.\n     */\n    setHandlesVisibleForCells(cells, visible, force = false) {\n        if (force || this.handlesVisible !== visible) {\n            this.handlesVisible = visible;\n            const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n            for (let i = 0; i < cells.length; i += 1) {\n                const handler = selectionCellsHandler?.getHandler(cells[i]);\n                if (handler) {\n                    handler.setHandlesVisible(visible);\n                    if (visible) {\n                        handler.redraw();\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Sets the color of the rectangle used to highlight drop targets.\n     *\n     * @param color String that represents the new highlight color.\n     */\n    setHighlightColor(color) {\n        if (this.highlight) {\n            this.highlight.setHighlightColor(color);\n        }\n    }\n    /**\n     * Handles the event by applying the changes to the selection cells.\n     */\n    mouseUp(sender, me) {\n        if (!me.isConsumed()) {\n            if (this.livePreviewUsed) {\n                this.resetLivePreview();\n            }\n            if (this.cell &&\n                this.first &&\n                (this.shape || this.livePreviewUsed) &&\n                isNumeric(this.currentDx) &&\n                isNumeric(this.currentDy)) {\n                const { graph } = this;\n                const cell = me.getCell();\n                if (this.connectOnDrop &&\n                    !this.target &&\n                    cell &&\n                    cell.isVertex() &&\n                    cell.isConnectable() &&\n                    graph.isEdgeValid(null, this.cell, cell)) {\n                    const connectionHandler = graph.getPlugin('ConnectionHandler');\n                    connectionHandler?.connect(this.cell, cell, me.getEvent());\n                }\n                else {\n                    const clone = graph.isCloneEvent(me.getEvent()) &&\n                        graph.isCellsCloneable() &&\n                        this.isCloneEnabled();\n                    const { scale } = graph.getView();\n                    const dx = this.roundLength(this.currentDx / scale);\n                    const dy = this.roundLength(this.currentDy / scale);\n                    const target = this.target;\n                    if (target &&\n                        graph.isSplitEnabled() &&\n                        this.cells &&\n                        graph.isSplitTarget(target, this.cells, me.getEvent())) {\n                        graph.splitEdge(target, this.cells, null, dx, dy, me.getGraphX(), me.getGraphY());\n                    }\n                    else if (this.cells) {\n                        this.moveCells(this.cells, dx, dy, clone, this.target, me.getEvent());\n                    }\n                }\n            }\n            else if (this.isSelectEnabled() && this.delayedSelection && this.cell != null) {\n                this.selectDelayed(me);\n            }\n        }\n        // Consumes the event if a cell was initially clicked\n        if (this.cellWasClicked) {\n            this.consumeMouseEvent(InternalEvent.MOUSE_UP, me);\n        }\n        this.reset();\n    }\n    /**\n     * Resets the state of this handler.\n     */\n    reset() {\n        if (this.livePreviewUsed) {\n            this.resetLivePreview();\n            const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n            this.setHandlesVisibleForCells(selectionCellsHandler?.getHandledSelectionCells() ?? [], true);\n        }\n        this.destroyShapes();\n        this.removeHint();\n        this.delayedSelection = false;\n        this.livePreviewActive = false;\n        this.livePreviewUsed = false;\n        this.cellWasClicked = false;\n        this.suspended = false;\n        this.currentDx = 0;\n        this.currentDy = 0;\n        this.cellCount = 0;\n        this.cloning = false;\n        this.allCells.clear();\n        this.pBounds = null;\n        this.target = null;\n        this.first = null;\n        this.cells = null;\n        this.cell = null;\n    }\n    /**\n     * Returns true if the given cells should be removed from the parent for the specified\n     * mousereleased event.\n     */\n    shouldRemoveCellsFromParent(parent, cells, evt) {\n        if (parent.isVertex()) {\n            const pState = this.graph.getView().getState(parent);\n            if (pState) {\n                let pt = convertPoint(this.graph.container, getClientX(evt), getClientY(evt));\n                const alpha = toRadians(pState.style.rotation ?? 0);\n                if (alpha !== 0) {\n                    const cos = Math.cos(-alpha);\n                    const sin = Math.sin(-alpha);\n                    const cx = new Point(pState.getCenterX(), pState.getCenterY());\n                    pt = getRotatedPoint(pt, cos, sin, cx);\n                }\n                return !contains(pState, pt.x, pt.y);\n            }\n        }\n        return false;\n    }\n    /**\n     * Moves the given cells by the specified amount.\n     */\n    moveCells(cells, dx, dy, clone, target, evt) {\n        if (!this.cell)\n            return;\n        if (clone) {\n            cells = this.graph.getCloneableCells(cells);\n        }\n        // Removes cells from parent\n        const parent = this.cell.getParent();\n        if (!target &&\n            parent &&\n            this.isRemoveCellsFromParent() &&\n            this.shouldRemoveCellsFromParent(parent, cells, evt)) {\n            target = this.graph.getDefaultParent();\n        }\n        // Cloning into locked cells is not allowed\n        clone = !!clone && !this.graph.isCellLocked(target || this.graph.getDefaultParent());\n        this.graph.batchUpdate(() => {\n            const parents = [];\n            // Removes parent if all child cells are removed\n            if (!clone && target && this.removeEmptyParents) {\n                // Collects all non-selected parents\n                const dict = new Dictionary();\n                for (let i = 0; i < cells.length; i += 1) {\n                    dict.put(cells[i], true);\n                }\n                // LATER: Recurse up the cell hierarchy\n                for (let i = 0; i < cells.length; i += 1) {\n                    const par = cells[i].getParent();\n                    if (par && !dict.get(par)) {\n                        dict.put(par, true);\n                        parents.push(par);\n                    }\n                }\n            }\n            // Passes all selected cells in order to correctly clone or move into\n            // the target cell. The method checks for each cell if its movable.\n            cells = this.graph.moveCells(cells, dx, dy, clone, target, evt);\n            // Removes parent if all child cells are removed\n            const temp = [];\n            for (let i = 0; i < parents.length; i += 1) {\n                if (this.shouldRemoveParent(parents[i])) {\n                    temp.push(parents[i]);\n                }\n            }\n            this.graph.removeCells(temp, false);\n        });\n        // Selects the new cells if cells have been cloned\n        if (clone) {\n            this.graph.setSelectionCells(cells);\n        }\n        if (this.isSelectEnabled() && this.scrollOnMove) {\n            this.graph.scrollCellToVisible(cells[0]);\n        }\n    }\n    /**\n     * Returns true if the given parent should be removed after removal of child cells.\n     */\n    shouldRemoveParent(parent) {\n        const state = this.graph.view.getState(parent);\n        return (state != null &&\n            (state.cell.isEdge() || state.cell.isVertex()) &&\n            this.graph.isCellDeletable(state.cell) &&\n            state.cell.getChildCount() === 0 &&\n            state.isTransparentState());\n    }\n    /**\n     * Destroy the preview and highlight shapes.\n     */\n    destroyShapes() {\n        // Destroys the preview dashed rectangle\n        if (this.shape) {\n            this.shape.destroy();\n            this.shape = null;\n        }\n        if (this.guide) {\n            this.guide.destroy();\n            this.guide = null;\n        }\n        // Destroys the drop target highlight\n        if (this.highlight) {\n            this.highlight.destroy();\n            this.highlight = null;\n        }\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes.\n     */\n    onDestroy() {\n        this.graph.removeMouseListener(this);\n        this.graph.removeListener(this.panHandler);\n        this.graph.removeListener(this.escapeHandler);\n        this.graph.getDataModel().removeListener(this.refreshHandler);\n        this.graph.removeListener(this.refreshHandler);\n        InternalEvent.removeListener(document, 'keydown', this.keyHandler);\n        InternalEvent.removeListener(document, 'keyup', this.keyHandler);\n        this.destroyShapes();\n        this.removeHint();\n    }\n}\nSelectionHandler.pluginId = 'SelectionHandler';\nexport default SelectionHandler;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}