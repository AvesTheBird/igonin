{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { mixInto } from '../../util/Utils';\nimport { Graph } from '../Graph';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst LabelMixin = {\n  /**\n   * Returns a string or DOM node that represents the label for the given\n   * cell. This implementation uses {@link convertValueToString} if {@link labelsVisible}\n   * is true. Otherwise it returns an empty string.\n   *\n   * To truncate a label to match the size of the cell, the following code\n   * can be used.\n   *\n   * ```javascript\n   * graph.getLabel = function(cell)\n   * {\n   *   var label = getLabel.apply(this, arguments);\n   *\n   *   if (label != null && this.model.isVertex(cell))\n   *   {\n   *     var geo = cell.getCellGeometry();\n   *\n   *     if (geo != null)\n   *     {\n   *       var max = parseInt(geo.width / 8);\n   *\n   *       if (label.length > max)\n   *       {\n   *         label = label.substring(0, max)+'...';\n   *       }\n   *     }\n   *   }\n   *   return mxUtils.htmlEntities(label);\n   * }\n   * ```\n   *\n   * A resize listener is needed in the graph to force a repaint of the label\n   * after a resize.\n   *\n   * ```javascript\n   * graph.addListener(mxEvent.RESIZE_CELLS, function(sender, evt)\n   * {\n   *   var cells = evt.getProperty('cells');\n   *\n   *   for (var i = 0; i < cells.length; i++)\n   *   {\n   *     this.view.removeState(cells[i]);\n   *   }\n   * });\n   * ```\n   *\n   * @param cell {@link mxCell} whose label should be returned.\n   */\n  getLabel(cell) {\n    let result = '';\n    if (this.isLabelsVisible() && cell != null) {\n      const style = this.getCurrentCellStyle(cell);\n      if (!(style.noLabel ?? false)) {\n        result = this.convertValueToString(cell);\n      }\n    }\n    return result;\n  },\n  /**\n   * Returns true if the label must be rendered as HTML markup. The default\n   * implementation returns {@link htmlLabels}.\n   *\n   * @param cell {@link mxCell} whose label should be displayed as HTML markup.\n   */\n  isHtmlLabel(cell) {\n    return this.isHtmlLabels();\n  },\n  /**\n   * Specifies if labels should be visible. This is used in {@link getLabel}. Default\n   * is true.\n   */\n  labelsVisible: true,\n  isLabelsVisible() {\n    return this.labelsVisible;\n  },\n  /**\n   * Specifies the return value for {@link isHtmlLabel}.\n   * @default false\n   */\n  htmlLabels: false,\n  /**\n   * Returns {@link htmlLabels}.\n   */\n  isHtmlLabels() {\n    return this.htmlLabels;\n  },\n  /**\n   * Sets {@link htmlLabels}.\n   */\n  setHtmlLabels(value) {\n    this.htmlLabels = value;\n  },\n  /**\n   * This enables wrapping for HTML labels.\n   *\n   * Returns true if no white-space CSS style directive should be used for\n   * displaying the given cells label. This implementation returns true if\n   * {@link 'whiteSpace'} in the style of the given cell is 'wrap'.\n   *\n   * This is used as a workaround for IE ignoring the white-space directive\n   * of child elements if the directive appears in a parent element. It\n   * should be overridden to return true if a white-space directive is used\n   * in the HTML markup that represents the given cells label. In order for\n   * HTML markup to work in labels, {@link isHtmlLabel} must also return true\n   * for the given cell.\n   *\n   * @example\n   *\n   * ```javascript\n   * graph.getLabel = function(cell)\n   * {\n   *   var tmp = getLabel.apply(this, arguments); // \"supercall\"\n   *\n   *   if (this.model.isEdge(cell))\n   *   {\n   *     tmp = '<div style=\"width: 150px; white-space:normal;\">'+tmp+'</div>';\n   *   }\n   *\n   *   return tmp;\n   * }\n   *\n   * graph.isWrapping = function(state)\n   * {\n   * \t return this.model.isEdge(state.cell);\n   * }\n   * ```\n   *\n   * Makes sure no edge label is wider than 150 pixels, otherwise the content\n   * is wrapped. Note: No width must be specified for wrapped vertex labels as\n   * the vertex defines the width in its geometry.\n   *\n   * @param state {@link mxCell} whose label should be wrapped.\n   */\n  isWrapping(cell) {\n    return this.getCurrentCellStyle(cell).whiteSpace === 'wrap';\n  },\n  /**\n   * Returns true if the overflow portion of labels should be hidden. If this\n   * returns true then vertex labels will be clipped to the size of the vertices.\n   * This implementation returns true if `overflow` in the\n   * style of the given cell is 'hidden'.\n   *\n   * @param state {@link mxCell} whose label should be clipped.\n   */\n  isLabelClipped(cell) {\n    return this.getCurrentCellStyle(cell).overflow === 'hidden';\n  },\n  /**\n   * Returns true if the given edges's label is moveable. This returns\n   * {@link movable} for all given cells if {@link isLocked} does not return true\n   * for the given cell.\n   *\n   * @param cell {@link mxCell} whose label should be moved.\n   */\n  isLabelMovable(cell) {\n    return !this.isCellLocked(cell) && (cell.isEdge() && this.isEdgeLabelsMovable() || cell.isVertex() && this.isVertexLabelsMovable());\n  }\n};\nmixInto(Graph)(LabelMixin);","map":{"version":3,"names":["mixInto","Graph","LabelMixin","getLabel","cell","result","isLabelsVisible","style","getCurrentCellStyle","noLabel","convertValueToString","isHtmlLabel","isHtmlLabels","labelsVisible","htmlLabels","setHtmlLabels","value","isWrapping","whiteSpace","isLabelClipped","overflow","isLabelMovable","isCellLocked","isEdge","isEdgeLabelsMovable","isVertex","isVertexLabelsMovable"],"sources":["D:/OSPanel/domains/проекты open server/old/react/react-intro-main/node_modules/@maxgraph/core/dist/view/mixins/LabelMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { mixInto } from '../../util/Utils';\nimport { Graph } from '../Graph';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst LabelMixin = {\n    /**\n     * Returns a string or DOM node that represents the label for the given\n     * cell. This implementation uses {@link convertValueToString} if {@link labelsVisible}\n     * is true. Otherwise it returns an empty string.\n     *\n     * To truncate a label to match the size of the cell, the following code\n     * can be used.\n     *\n     * ```javascript\n     * graph.getLabel = function(cell)\n     * {\n     *   var label = getLabel.apply(this, arguments);\n     *\n     *   if (label != null && this.model.isVertex(cell))\n     *   {\n     *     var geo = cell.getCellGeometry();\n     *\n     *     if (geo != null)\n     *     {\n     *       var max = parseInt(geo.width / 8);\n     *\n     *       if (label.length > max)\n     *       {\n     *         label = label.substring(0, max)+'...';\n     *       }\n     *     }\n     *   }\n     *   return mxUtils.htmlEntities(label);\n     * }\n     * ```\n     *\n     * A resize listener is needed in the graph to force a repaint of the label\n     * after a resize.\n     *\n     * ```javascript\n     * graph.addListener(mxEvent.RESIZE_CELLS, function(sender, evt)\n     * {\n     *   var cells = evt.getProperty('cells');\n     *\n     *   for (var i = 0; i < cells.length; i++)\n     *   {\n     *     this.view.removeState(cells[i]);\n     *   }\n     * });\n     * ```\n     *\n     * @param cell {@link mxCell} whose label should be returned.\n     */\n    getLabel(cell) {\n        let result = '';\n        if (this.isLabelsVisible() && cell != null) {\n            const style = this.getCurrentCellStyle(cell);\n            if (!(style.noLabel ?? false)) {\n                result = this.convertValueToString(cell);\n            }\n        }\n        return result;\n    },\n    /**\n     * Returns true if the label must be rendered as HTML markup. The default\n     * implementation returns {@link htmlLabels}.\n     *\n     * @param cell {@link mxCell} whose label should be displayed as HTML markup.\n     */\n    isHtmlLabel(cell) {\n        return this.isHtmlLabels();\n    },\n    /**\n     * Specifies if labels should be visible. This is used in {@link getLabel}. Default\n     * is true.\n     */\n    labelsVisible: true,\n    isLabelsVisible() {\n        return this.labelsVisible;\n    },\n    /**\n     * Specifies the return value for {@link isHtmlLabel}.\n     * @default false\n     */\n    htmlLabels: false,\n    /**\n     * Returns {@link htmlLabels}.\n     */\n    isHtmlLabels() {\n        return this.htmlLabels;\n    },\n    /**\n     * Sets {@link htmlLabels}.\n     */\n    setHtmlLabels(value) {\n        this.htmlLabels = value;\n    },\n    /**\n     * This enables wrapping for HTML labels.\n     *\n     * Returns true if no white-space CSS style directive should be used for\n     * displaying the given cells label. This implementation returns true if\n     * {@link 'whiteSpace'} in the style of the given cell is 'wrap'.\n     *\n     * This is used as a workaround for IE ignoring the white-space directive\n     * of child elements if the directive appears in a parent element. It\n     * should be overridden to return true if a white-space directive is used\n     * in the HTML markup that represents the given cells label. In order for\n     * HTML markup to work in labels, {@link isHtmlLabel} must also return true\n     * for the given cell.\n     *\n     * @example\n     *\n     * ```javascript\n     * graph.getLabel = function(cell)\n     * {\n     *   var tmp = getLabel.apply(this, arguments); // \"supercall\"\n     *\n     *   if (this.model.isEdge(cell))\n     *   {\n     *     tmp = '<div style=\"width: 150px; white-space:normal;\">'+tmp+'</div>';\n     *   }\n     *\n     *   return tmp;\n     * }\n     *\n     * graph.isWrapping = function(state)\n     * {\n     * \t return this.model.isEdge(state.cell);\n     * }\n     * ```\n     *\n     * Makes sure no edge label is wider than 150 pixels, otherwise the content\n     * is wrapped. Note: No width must be specified for wrapped vertex labels as\n     * the vertex defines the width in its geometry.\n     *\n     * @param state {@link mxCell} whose label should be wrapped.\n     */\n    isWrapping(cell) {\n        return this.getCurrentCellStyle(cell).whiteSpace === 'wrap';\n    },\n    /**\n     * Returns true if the overflow portion of labels should be hidden. If this\n     * returns true then vertex labels will be clipped to the size of the vertices.\n     * This implementation returns true if `overflow` in the\n     * style of the given cell is 'hidden'.\n     *\n     * @param state {@link mxCell} whose label should be clipped.\n     */\n    isLabelClipped(cell) {\n        return this.getCurrentCellStyle(cell).overflow === 'hidden';\n    },\n    /**\n     * Returns true if the given edges's label is moveable. This returns\n     * {@link movable} for all given cells if {@link isLocked} does not return true\n     * for the given cell.\n     *\n     * @param cell {@link mxCell} whose label should be moved.\n     */\n    isLabelMovable(cell) {\n        return (!this.isCellLocked(cell) &&\n            ((cell.isEdge() && this.isEdgeLabelsMovable()) ||\n                (cell.isVertex() && this.isVertexLabelsMovable())));\n    },\n};\nmixInto(Graph)(LabelMixin);\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,OAAO,QAAQ,kBAAkB;AAC1C,SAASC,KAAK,QAAQ,UAAU;AAChC;AACA,MAAMC,UAAU,GAAG;EACf;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,QAAQA,CAACC,IAAI,EAAE;IACX,IAAIC,MAAM,GAAG,EAAE;IACf,IAAI,IAAI,CAACC,eAAe,CAAC,CAAC,IAAIF,IAAI,IAAI,IAAI,EAAE;MACxC,MAAMG,KAAK,GAAG,IAAI,CAACC,mBAAmB,CAACJ,IAAI,CAAC;MAC5C,IAAI,EAAEG,KAAK,CAACE,OAAO,IAAI,KAAK,CAAC,EAAE;QAC3BJ,MAAM,GAAG,IAAI,CAACK,oBAAoB,CAACN,IAAI,CAAC;MAC5C;IACJ;IACA,OAAOC,MAAM;EACjB,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACIM,WAAWA,CAACP,IAAI,EAAE;IACd,OAAO,IAAI,CAACQ,YAAY,CAAC,CAAC;EAC9B,CAAC;EACD;AACJ;AACA;AACA;EACIC,aAAa,EAAE,IAAI;EACnBP,eAAeA,CAAA,EAAG;IACd,OAAO,IAAI,CAACO,aAAa;EAC7B,CAAC;EACD;AACJ;AACA;AACA;EACIC,UAAU,EAAE,KAAK;EACjB;AACJ;AACA;EACIF,YAAYA,CAAA,EAAG;IACX,OAAO,IAAI,CAACE,UAAU;EAC1B,CAAC;EACD;AACJ;AACA;EACIC,aAAaA,CAACC,KAAK,EAAE;IACjB,IAAI,CAACF,UAAU,GAAGE,KAAK;EAC3B,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,UAAUA,CAACb,IAAI,EAAE;IACb,OAAO,IAAI,CAACI,mBAAmB,CAACJ,IAAI,CAAC,CAACc,UAAU,KAAK,MAAM;EAC/D,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,cAAcA,CAACf,IAAI,EAAE;IACjB,OAAO,IAAI,CAACI,mBAAmB,CAACJ,IAAI,CAAC,CAACgB,QAAQ,KAAK,QAAQ;EAC/D,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,cAAcA,CAACjB,IAAI,EAAE;IACjB,OAAQ,CAAC,IAAI,CAACkB,YAAY,CAAClB,IAAI,CAAC,KAC1BA,IAAI,CAACmB,MAAM,CAAC,CAAC,IAAI,IAAI,CAACC,mBAAmB,CAAC,CAAC,IACxCpB,IAAI,CAACqB,QAAQ,CAAC,CAAC,IAAI,IAAI,CAACC,qBAAqB,CAAC,CAAE,CAAC;EAC9D;AACJ,CAAC;AACD1B,OAAO,CAACC,KAAK,CAAC,CAACC,UAAU,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}