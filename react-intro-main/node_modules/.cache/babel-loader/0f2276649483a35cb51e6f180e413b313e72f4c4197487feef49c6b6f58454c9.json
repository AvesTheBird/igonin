{"ast":null,"code":"var _DisposableStore, _Disposable;\nimport { createSingleCallFunction } from './functional.js';\nimport { Iterable } from './iterator.js';\n// #region Disposable Tracking\n/**\n * Enables logging of potentially leaked disposables.\n *\n * A disposable is considered leaked if it is not disposed or not registered as the child of\n * another disposable. This tracking is very simple an only works for classes that either\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\n */\nconst TRACK_DISPOSABLES = false;\nlet disposableTracker = null;\nexport function setDisposableTracker(tracker) {\n  disposableTracker = tracker;\n}\nif (TRACK_DISPOSABLES) {\n  const __is_disposable_tracked__ = '__is_disposable_tracked__';\n  setDisposableTracker(new class {\n    trackDisposable(x) {\n      const stack = new Error('Potentially leaked disposable').stack;\n      setTimeout(() => {\n        if (!x[__is_disposable_tracked__]) {\n          console.log(stack);\n        }\n      }, 3000);\n    }\n    setParent(child, parent) {\n      if (child && child !== Disposable.None) {\n        try {\n          child[__is_disposable_tracked__] = true;\n        } catch {\n          // noop\n        }\n      }\n    }\n    markAsDisposed(disposable) {\n      if (disposable && disposable !== Disposable.None) {\n        try {\n          disposable[__is_disposable_tracked__] = true;\n        } catch {\n          // noop\n        }\n      }\n    }\n    markAsSingleton(disposable) {}\n  }());\n}\nexport function trackDisposable(x) {\n  var _disposableTracker;\n  (_disposableTracker = disposableTracker) === null || _disposableTracker === void 0 || _disposableTracker.trackDisposable(x);\n  return x;\n}\nexport function markAsDisposed(disposable) {\n  var _disposableTracker2;\n  (_disposableTracker2 = disposableTracker) === null || _disposableTracker2 === void 0 || _disposableTracker2.markAsDisposed(disposable);\n}\nfunction setParentOfDisposable(child, parent) {\n  var _disposableTracker3;\n  (_disposableTracker3 = disposableTracker) === null || _disposableTracker3 === void 0 || _disposableTracker3.setParent(child, parent);\n}\nfunction setParentOfDisposables(children, parent) {\n  if (!disposableTracker) {\n    return;\n  }\n  for (const child of children) {\n    disposableTracker.setParent(child, parent);\n  }\n}\n/**\n * Indicates that the given object is a singleton which does not need to be disposed.\n*/\nexport function markAsSingleton(singleton) {\n  var _disposableTracker4;\n  (_disposableTracker4 = disposableTracker) === null || _disposableTracker4 === void 0 || _disposableTracker4.markAsSingleton(singleton);\n  return singleton;\n}\n/**\n * Check if `thing` is {@link IDisposable disposable}.\n */\nexport function isDisposable(thing) {\n  return typeof thing === 'object' && thing !== null && typeof thing.dispose === 'function' && thing.dispose.length === 0;\n}\nexport function dispose(arg) {\n  if (Iterable.is(arg)) {\n    const errors = [];\n    for (const d of arg) {\n      if (d) {\n        try {\n          d.dispose();\n        } catch (e) {\n          errors.push(e);\n        }\n      }\n    }\n    if (errors.length === 1) {\n      throw errors[0];\n    } else if (errors.length > 1) {\n      throw new AggregateError(errors, 'Encountered errors while disposing of store');\n    }\n    return Array.isArray(arg) ? [] : arg;\n  } else if (arg) {\n    arg.dispose();\n    return arg;\n  }\n}\n/**\n * Combine multiple disposable values into a single {@link IDisposable}.\n */\nexport function combinedDisposable() {\n  for (var _len = arguments.length, disposables = new Array(_len), _key = 0; _key < _len; _key++) {\n    disposables[_key] = arguments[_key];\n  }\n  const parent = toDisposable(() => dispose(disposables));\n  setParentOfDisposables(disposables, parent);\n  return parent;\n}\n/**\n * Turn a function that implements dispose into an {@link IDisposable}.\n *\n * @param fn Clean up function, guaranteed to be called only **once**.\n */\nexport function toDisposable(fn) {\n  const self = trackDisposable({\n    dispose: createSingleCallFunction(() => {\n      markAsDisposed(self);\n      fn();\n    })\n  });\n  return self;\n}\n/**\n * Manages a collection of disposable values.\n *\n * This is the preferred way to manage multiple disposables. A `DisposableStore` is safer to work with than an\n * `IDisposable[]` as it considers edge cases, such as registering the same value multiple times or adding an item to a\n * store that has already been disposed of.\n */\nexport class DisposableStore {\n  constructor() {\n    this._toDispose = new Set();\n    this._isDisposed = false;\n    trackDisposable(this);\n  }\n  /**\n   * Dispose of all registered disposables and mark this object as disposed.\n   *\n   * Any future disposables added to this object will be disposed of on `add`.\n   */\n  dispose() {\n    if (this._isDisposed) {\n      return;\n    }\n    markAsDisposed(this);\n    this._isDisposed = true;\n    this.clear();\n  }\n  /**\n   * @return `true` if this object has been disposed of.\n   */\n  get isDisposed() {\n    return this._isDisposed;\n  }\n  /**\n   * Dispose of all registered disposables but do not mark this object as disposed.\n   */\n  clear() {\n    if (this._toDispose.size === 0) {\n      return;\n    }\n    try {\n      dispose(this._toDispose);\n    } finally {\n      this._toDispose.clear();\n    }\n  }\n  /**\n   * Add a new {@link IDisposable disposable} to the collection.\n   */\n  add(o) {\n    if (!o) {\n      return o;\n    }\n    if (o === this) {\n      throw new Error('Cannot register a disposable on itself!');\n    }\n    setParentOfDisposable(o, this);\n    if (this._isDisposed) {\n      if (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n        console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n      }\n    } else {\n      this._toDispose.add(o);\n    }\n    return o;\n  }\n  /**\n   * Deletes the value from the store, but does not dispose it.\n   */\n  deleteAndLeak(o) {\n    if (!o) {\n      return;\n    }\n    if (this._toDispose.has(o)) {\n      this._toDispose.delete(o);\n      setParentOfDisposable(o, null);\n    }\n  }\n}\n/**\n * Abstract base class for a {@link IDisposable disposable} object.\n *\n * Subclasses can {@linkcode _register} disposables that will be automatically cleaned up when this object is disposed of.\n */\n_DisposableStore = DisposableStore;\n_DisposableStore.DISABLE_DISPOSED_WARNING = false;\nexport class Disposable {\n  constructor() {\n    this._store = new DisposableStore();\n    trackDisposable(this);\n    setParentOfDisposable(this._store, this);\n  }\n  dispose() {\n    markAsDisposed(this);\n    this._store.dispose();\n  }\n  /**\n   * Adds `o` to the collection of disposables managed by this object.\n   */\n  _register(o) {\n    if (o === this) {\n      throw new Error('Cannot register a disposable on itself!');\n    }\n    return this._store.add(o);\n  }\n}\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\n_Disposable = Disposable;\n/**\n * A disposable that does nothing when it is disposed of.\n *\n * TODO: This should not be a static property.\n */\n_Disposable.None = Object.freeze({\n  dispose() {}\n});\nexport class MutableDisposable {\n  constructor() {\n    this._isDisposed = false;\n    trackDisposable(this);\n  }\n  get value() {\n    return this._isDisposed ? undefined : this._value;\n  }\n  set value(value) {\n    var _this$_value;\n    if (this._isDisposed || value === this._value) {\n      return;\n    }\n    (_this$_value = this._value) === null || _this$_value === void 0 || _this$_value.dispose();\n    if (value) {\n      setParentOfDisposable(value, this);\n    }\n    this._value = value;\n  }\n  /**\n   * Resets the stored value and disposed of the previously stored value.\n   */\n  clear() {\n    this.value = undefined;\n  }\n  dispose() {\n    var _this$_value2;\n    this._isDisposed = true;\n    markAsDisposed(this);\n    (_this$_value2 = this._value) === null || _this$_value2 === void 0 || _this$_value2.dispose();\n    this._value = undefined;\n  }\n}\nexport class RefCountedDisposable {\n  constructor(_disposable) {\n    this._disposable = _disposable;\n    this._counter = 1;\n  }\n  acquire() {\n    this._counter++;\n    return this;\n  }\n  release() {\n    if (--this._counter === 0) {\n      this._disposable.dispose();\n    }\n    return this;\n  }\n}\nexport class ImmortalReference {\n  constructor(object) {\n    this.object = object;\n  }\n  dispose() {}\n}\n/**\n * A map the manages the lifecycle of the values that it stores.\n */\nexport class DisposableMap {\n  constructor() {\n    this._store = new Map();\n    this._isDisposed = false;\n    trackDisposable(this);\n  }\n  /**\n   * Disposes of all stored values and mark this object as disposed.\n   *\n   * Trying to use this object after it has been disposed of is an error.\n   */\n  dispose() {\n    markAsDisposed(this);\n    this._isDisposed = true;\n    this.clearAndDisposeAll();\n  }\n  /**\n   * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.\n   */\n  clearAndDisposeAll() {\n    if (!this._store.size) {\n      return;\n    }\n    try {\n      dispose(this._store.values());\n    } finally {\n      this._store.clear();\n    }\n  }\n  get(key) {\n    return this._store.get(key);\n  }\n  set(key, value) {\n    let skipDisposeOnOverwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (this._isDisposed) {\n      console.warn(new Error('Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!').stack);\n    }\n    if (!skipDisposeOnOverwrite) {\n      var _this$_store$get;\n      (_this$_store$get = this._store.get(key)) === null || _this$_store$get === void 0 || _this$_store$get.dispose();\n    }\n    this._store.set(key, value);\n  }\n  /**\n   * Delete the value stored for `key` from this map and also dispose of it.\n   */\n  deleteAndDispose(key) {\n    var _this$_store$get2;\n    (_this$_store$get2 = this._store.get(key)) === null || _this$_store$get2 === void 0 || _this$_store$get2.dispose();\n    this._store.delete(key);\n  }\n  [Symbol.iterator]() {\n    return this._store[Symbol.iterator]();\n  }\n}","map":{"version":3,"names":["createSingleCallFunction","Iterable","TRACK_DISPOSABLES","disposableTracker","setDisposableTracker","tracker","__is_disposable_tracked__","trackDisposable","x","stack","Error","setTimeout","console","log","setParent","child","parent","Disposable","None","markAsDisposed","disposable","markAsSingleton","_disposableTracker","_disposableTracker2","setParentOfDisposable","_disposableTracker3","setParentOfDisposables","children","singleton","_disposableTracker4","isDisposable","thing","dispose","length","arg","is","errors","d","e","push","AggregateError","Array","isArray","combinedDisposable","_len","arguments","disposables","_key","toDisposable","fn","self","DisposableStore","constructor","_toDispose","Set","_isDisposed","clear","isDisposed","size","add","o","DISABLE_DISPOSED_WARNING","warn","deleteAndLeak","has","delete","_DisposableStore","_store","_register","_Disposable","Object","freeze","MutableDisposable","value","undefined","_value","_this$_value","_this$_value2","RefCountedDisposable","_disposable","_counter","acquire","release","ImmortalReference","object","DisposableMap","Map","clearAndDisposeAll","values","get","key","set","skipDisposeOnOverwrite","_this$_store$get","deleteAndDispose","_this$_store$get2","Symbol","iterator"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/base/common/lifecycle.js"],"sourcesContent":["import { createSingleCallFunction } from './functional.js';\nimport { Iterable } from './iterator.js';\n// #region Disposable Tracking\n/**\n * Enables logging of potentially leaked disposables.\n *\n * A disposable is considered leaked if it is not disposed or not registered as the child of\n * another disposable. This tracking is very simple an only works for classes that either\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\n */\nconst TRACK_DISPOSABLES = false;\nlet disposableTracker = null;\nexport function setDisposableTracker(tracker) {\n    disposableTracker = tracker;\n}\nif (TRACK_DISPOSABLES) {\n    const __is_disposable_tracked__ = '__is_disposable_tracked__';\n    setDisposableTracker(new class {\n        trackDisposable(x) {\n            const stack = new Error('Potentially leaked disposable').stack;\n            setTimeout(() => {\n                if (!x[__is_disposable_tracked__]) {\n                    console.log(stack);\n                }\n            }, 3000);\n        }\n        setParent(child, parent) {\n            if (child && child !== Disposable.None) {\n                try {\n                    child[__is_disposable_tracked__] = true;\n                }\n                catch {\n                    // noop\n                }\n            }\n        }\n        markAsDisposed(disposable) {\n            if (disposable && disposable !== Disposable.None) {\n                try {\n                    disposable[__is_disposable_tracked__] = true;\n                }\n                catch {\n                    // noop\n                }\n            }\n        }\n        markAsSingleton(disposable) { }\n    });\n}\nexport function trackDisposable(x) {\n    disposableTracker?.trackDisposable(x);\n    return x;\n}\nexport function markAsDisposed(disposable) {\n    disposableTracker?.markAsDisposed(disposable);\n}\nfunction setParentOfDisposable(child, parent) {\n    disposableTracker?.setParent(child, parent);\n}\nfunction setParentOfDisposables(children, parent) {\n    if (!disposableTracker) {\n        return;\n    }\n    for (const child of children) {\n        disposableTracker.setParent(child, parent);\n    }\n}\n/**\n * Indicates that the given object is a singleton which does not need to be disposed.\n*/\nexport function markAsSingleton(singleton) {\n    disposableTracker?.markAsSingleton(singleton);\n    return singleton;\n}\n/**\n * Check if `thing` is {@link IDisposable disposable}.\n */\nexport function isDisposable(thing) {\n    return typeof thing === 'object' && thing !== null && typeof thing.dispose === 'function' && thing.dispose.length === 0;\n}\nexport function dispose(arg) {\n    if (Iterable.is(arg)) {\n        const errors = [];\n        for (const d of arg) {\n            if (d) {\n                try {\n                    d.dispose();\n                }\n                catch (e) {\n                    errors.push(e);\n                }\n            }\n        }\n        if (errors.length === 1) {\n            throw errors[0];\n        }\n        else if (errors.length > 1) {\n            throw new AggregateError(errors, 'Encountered errors while disposing of store');\n        }\n        return Array.isArray(arg) ? [] : arg;\n    }\n    else if (arg) {\n        arg.dispose();\n        return arg;\n    }\n}\n/**\n * Combine multiple disposable values into a single {@link IDisposable}.\n */\nexport function combinedDisposable(...disposables) {\n    const parent = toDisposable(() => dispose(disposables));\n    setParentOfDisposables(disposables, parent);\n    return parent;\n}\n/**\n * Turn a function that implements dispose into an {@link IDisposable}.\n *\n * @param fn Clean up function, guaranteed to be called only **once**.\n */\nexport function toDisposable(fn) {\n    const self = trackDisposable({\n        dispose: createSingleCallFunction(() => {\n            markAsDisposed(self);\n            fn();\n        })\n    });\n    return self;\n}\n/**\n * Manages a collection of disposable values.\n *\n * This is the preferred way to manage multiple disposables. A `DisposableStore` is safer to work with than an\n * `IDisposable[]` as it considers edge cases, such as registering the same value multiple times or adding an item to a\n * store that has already been disposed of.\n */\nexport class DisposableStore {\n    static { this.DISABLE_DISPOSED_WARNING = false; }\n    constructor() {\n        this._toDispose = new Set();\n        this._isDisposed = false;\n        trackDisposable(this);\n    }\n    /**\n     * Dispose of all registered disposables and mark this object as disposed.\n     *\n     * Any future disposables added to this object will be disposed of on `add`.\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        markAsDisposed(this);\n        this._isDisposed = true;\n        this.clear();\n    }\n    /**\n     * @return `true` if this object has been disposed of.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of all registered disposables but do not mark this object as disposed.\n     */\n    clear() {\n        if (this._toDispose.size === 0) {\n            return;\n        }\n        try {\n            dispose(this._toDispose);\n        }\n        finally {\n            this._toDispose.clear();\n        }\n    }\n    /**\n     * Add a new {@link IDisposable disposable} to the collection.\n     */\n    add(o) {\n        if (!o) {\n            return o;\n        }\n        if (o === this) {\n            throw new Error('Cannot register a disposable on itself!');\n        }\n        setParentOfDisposable(o, this);\n        if (this._isDisposed) {\n            if (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n                console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n            }\n        }\n        else {\n            this._toDispose.add(o);\n        }\n        return o;\n    }\n    /**\n     * Deletes the value from the store, but does not dispose it.\n     */\n    deleteAndLeak(o) {\n        if (!o) {\n            return;\n        }\n        if (this._toDispose.has(o)) {\n            this._toDispose.delete(o);\n            setParentOfDisposable(o, null);\n        }\n    }\n}\n/**\n * Abstract base class for a {@link IDisposable disposable} object.\n *\n * Subclasses can {@linkcode _register} disposables that will be automatically cleaned up when this object is disposed of.\n */\nexport class Disposable {\n    /**\n     * A disposable that does nothing when it is disposed of.\n     *\n     * TODO: This should not be a static property.\n     */\n    static { this.None = Object.freeze({ dispose() { } }); }\n    constructor() {\n        this._store = new DisposableStore();\n        trackDisposable(this);\n        setParentOfDisposable(this._store, this);\n    }\n    dispose() {\n        markAsDisposed(this);\n        this._store.dispose();\n    }\n    /**\n     * Adds `o` to the collection of disposables managed by this object.\n     */\n    _register(o) {\n        if (o === this) {\n            throw new Error('Cannot register a disposable on itself!');\n        }\n        return this._store.add(o);\n    }\n}\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\nexport class MutableDisposable {\n    constructor() {\n        this._isDisposed = false;\n        trackDisposable(this);\n    }\n    get value() {\n        return this._isDisposed ? undefined : this._value;\n    }\n    set value(value) {\n        if (this._isDisposed || value === this._value) {\n            return;\n        }\n        this._value?.dispose();\n        if (value) {\n            setParentOfDisposable(value, this);\n        }\n        this._value = value;\n    }\n    /**\n     * Resets the stored value and disposed of the previously stored value.\n     */\n    clear() {\n        this.value = undefined;\n    }\n    dispose() {\n        this._isDisposed = true;\n        markAsDisposed(this);\n        this._value?.dispose();\n        this._value = undefined;\n    }\n}\nexport class RefCountedDisposable {\n    constructor(_disposable) {\n        this._disposable = _disposable;\n        this._counter = 1;\n    }\n    acquire() {\n        this._counter++;\n        return this;\n    }\n    release() {\n        if (--this._counter === 0) {\n            this._disposable.dispose();\n        }\n        return this;\n    }\n}\nexport class ImmortalReference {\n    constructor(object) {\n        this.object = object;\n    }\n    dispose() { }\n}\n/**\n * A map the manages the lifecycle of the values that it stores.\n */\nexport class DisposableMap {\n    constructor() {\n        this._store = new Map();\n        this._isDisposed = false;\n        trackDisposable(this);\n    }\n    /**\n     * Disposes of all stored values and mark this object as disposed.\n     *\n     * Trying to use this object after it has been disposed of is an error.\n     */\n    dispose() {\n        markAsDisposed(this);\n        this._isDisposed = true;\n        this.clearAndDisposeAll();\n    }\n    /**\n     * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.\n     */\n    clearAndDisposeAll() {\n        if (!this._store.size) {\n            return;\n        }\n        try {\n            dispose(this._store.values());\n        }\n        finally {\n            this._store.clear();\n        }\n    }\n    get(key) {\n        return this._store.get(key);\n    }\n    set(key, value, skipDisposeOnOverwrite = false) {\n        if (this._isDisposed) {\n            console.warn(new Error('Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!').stack);\n        }\n        if (!skipDisposeOnOverwrite) {\n            this._store.get(key)?.dispose();\n        }\n        this._store.set(key, value);\n    }\n    /**\n     * Delete the value stored for `key` from this map and also dispose of it.\n     */\n    deleteAndDispose(key) {\n        this._store.get(key)?.dispose();\n        this._store.delete(key);\n    }\n    [Symbol.iterator]() {\n        return this._store[Symbol.iterator]();\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}