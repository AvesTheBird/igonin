{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { SingleTextEdit } from '../core/textEdit.js';\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n */\nexport class LineRangeMapping {\n  static inverse(mapping, originalLineCount, modifiedLineCount) {\n    const result = [];\n    let lastOriginalEndLineNumber = 1;\n    let lastModifiedEndLineNumber = 1;\n    for (const m of mapping) {\n      const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, m.original.startLineNumber), new LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber));\n      if (!r.modified.isEmpty) {\n        result.push(r);\n      }\n      lastOriginalEndLineNumber = m.original.endLineNumberExclusive;\n      lastModifiedEndLineNumber = m.modified.endLineNumberExclusive;\n    }\n    const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1));\n    if (!r.modified.isEmpty) {\n      result.push(r);\n    }\n    return result;\n  }\n  static clip(mapping, originalRange, modifiedRange) {\n    const result = [];\n    for (const m of mapping) {\n      const original = m.original.intersect(originalRange);\n      const modified = m.modified.intersect(modifiedRange);\n      if (original && !original.isEmpty && modified && !modified.isEmpty) {\n        result.push(new LineRangeMapping(original, modified));\n      }\n    }\n    return result;\n  }\n  constructor(originalRange, modifiedRange) {\n    this.original = originalRange;\n    this.modified = modifiedRange;\n  }\n  toString() {\n    return \"{\".concat(this.original.toString(), \"->\").concat(this.modified.toString(), \"}\");\n  }\n  flip() {\n    return new LineRangeMapping(this.modified, this.original);\n  }\n  join(other) {\n    return new LineRangeMapping(this.original.join(other.original), this.modified.join(other.modified));\n  }\n  /**\n   * This method assumes that the LineRangeMapping describes a valid diff!\n   * I.e. if one range is empty, the other range cannot be the entire document.\n   * It avoids various problems when the line range points to non-existing line-numbers.\n  */\n  toRangeMapping() {\n    const origInclusiveRange = this.original.toInclusiveRange();\n    const modInclusiveRange = this.modified.toInclusiveRange();\n    if (origInclusiveRange && modInclusiveRange) {\n      return new RangeMapping(origInclusiveRange, modInclusiveRange);\n    } else if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {\n      if (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1)) {\n        // If one line range starts at 1, the other one must start at 1 as well.\n        throw new BugIndicatingError('not a valid diff');\n      }\n      // Because one range is empty and both ranges start at line 1, none of the ranges can cover all lines.\n      // Thus, `endLineNumberExclusive` is a valid line number.\n      return new RangeMapping(new Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));\n    } else {\n      // We can assume here that both startLineNumbers are greater than 1.\n      return new RangeMapping(new Range(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), new Range(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER));\n    }\n  }\n  /**\n   * This method assumes that the LineRangeMapping describes a valid diff!\n   * I.e. if one range is empty, the other range cannot be the entire document.\n   * It avoids various problems when the line range points to non-existing line-numbers.\n  */\n  toRangeMapping2(original, modified) {\n    if (isValidLineNumber(this.original.endLineNumberExclusive, original) && isValidLineNumber(this.modified.endLineNumberExclusive, modified)) {\n      return new RangeMapping(new Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));\n    }\n    if (!this.original.isEmpty && !this.modified.isEmpty) {\n      return new RangeMapping(Range.fromPositions(new Position(this.original.startLineNumber, 1), normalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)), Range.fromPositions(new Position(this.modified.startLineNumber, 1), normalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)));\n    }\n    if (this.original.startLineNumber > 1 && this.modified.startLineNumber > 1) {\n      return new RangeMapping(Range.fromPositions(normalizePosition(new Position(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER), original), normalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)), Range.fromPositions(normalizePosition(new Position(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER), modified), normalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)));\n    }\n    // Situation now: one range is empty and one range touches the last line and one range starts at line 1.\n    // I don't think this can happen.\n    throw new BugIndicatingError();\n  }\n}\nfunction normalizePosition(position, content) {\n  if (position.lineNumber < 1) {\n    return new Position(1, 1);\n  }\n  if (position.lineNumber > content.length) {\n    return new Position(content.length, content[content.length - 1].length + 1);\n  }\n  const line = content[position.lineNumber - 1];\n  if (position.column > line.length + 1) {\n    return new Position(position.lineNumber, line.length + 1);\n  }\n  return position;\n}\nfunction isValidLineNumber(lineNumber, lines) {\n  return lineNumber >= 1 && lineNumber <= lines.length;\n}\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n * Also contains inner range mappings.\n */\nexport class DetailedLineRangeMapping extends LineRangeMapping {\n  static fromRangeMappings(rangeMappings) {\n    const originalRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.originalRange)));\n    const modifiedRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.modifiedRange)));\n    return new DetailedLineRangeMapping(originalRange, modifiedRange, rangeMappings);\n  }\n  constructor(originalRange, modifiedRange, innerChanges) {\n    super(originalRange, modifiedRange);\n    this.innerChanges = innerChanges;\n  }\n  flip() {\n    var _this$innerChanges;\n    return new DetailedLineRangeMapping(this.modified, this.original, (_this$innerChanges = this.innerChanges) === null || _this$innerChanges === void 0 ? void 0 : _this$innerChanges.map(c => c.flip()));\n  }\n  withInnerChangesFromLineRanges() {\n    return new DetailedLineRangeMapping(this.original, this.modified, [this.toRangeMapping()]);\n  }\n}\n/**\n * Maps a range in the original text model to a range in the modified text model.\n */\nexport class RangeMapping {\n  static assertSorted(rangeMappings) {\n    for (let i = 1; i < rangeMappings.length; i++) {\n      const previous = rangeMappings[i - 1];\n      const current = rangeMappings[i];\n      if (!(previous.originalRange.getEndPosition().isBeforeOrEqual(current.originalRange.getStartPosition()) && previous.modifiedRange.getEndPosition().isBeforeOrEqual(current.modifiedRange.getStartPosition()))) {\n        throw new BugIndicatingError('Range mappings must be sorted');\n      }\n    }\n  }\n  constructor(originalRange, modifiedRange) {\n    this.originalRange = originalRange;\n    this.modifiedRange = modifiedRange;\n  }\n  toString() {\n    return \"{\".concat(this.originalRange.toString(), \"->\").concat(this.modifiedRange.toString(), \"}\");\n  }\n  flip() {\n    return new RangeMapping(this.modifiedRange, this.originalRange);\n  }\n  /**\n   * Creates a single text edit that describes the change from the original to the modified text.\n  */\n  toTextEdit(modified) {\n    const newText = modified.getValueOfRange(this.modifiedRange);\n    return new SingleTextEdit(this.originalRange, newText);\n  }\n}","map":{"version":3,"names":["BugIndicatingError","LineRange","Position","Range","SingleTextEdit","LineRangeMapping","inverse","mapping","originalLineCount","modifiedLineCount","result","lastOriginalEndLineNumber","lastModifiedEndLineNumber","m","r","original","startLineNumber","modified","isEmpty","push","endLineNumberExclusive","clip","originalRange","modifiedRange","intersect","constructor","toString","concat","flip","join","other","toRangeMapping","origInclusiveRange","toInclusiveRange","modInclusiveRange","RangeMapping","Number","MAX_SAFE_INTEGER","toRangeMapping2","isValidLineNumber","fromPositions","normalizePosition","position","content","lineNumber","length","line","column","lines","DetailedLineRangeMapping","fromRangeMappings","rangeMappings","map","fromRangeInclusive","innerChanges","_this$innerChanges","c","withInnerChangesFromLineRanges","assertSorted","i","previous","current","getEndPosition","isBeforeOrEqual","getStartPosition","toTextEdit","newText","getValueOfRange"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { SingleTextEdit } from '../core/textEdit.js';\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n */\nexport class LineRangeMapping {\n    static inverse(mapping, originalLineCount, modifiedLineCount) {\n        const result = [];\n        let lastOriginalEndLineNumber = 1;\n        let lastModifiedEndLineNumber = 1;\n        for (const m of mapping) {\n            const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, m.original.startLineNumber), new LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber));\n            if (!r.modified.isEmpty) {\n                result.push(r);\n            }\n            lastOriginalEndLineNumber = m.original.endLineNumberExclusive;\n            lastModifiedEndLineNumber = m.modified.endLineNumberExclusive;\n        }\n        const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1));\n        if (!r.modified.isEmpty) {\n            result.push(r);\n        }\n        return result;\n    }\n    static clip(mapping, originalRange, modifiedRange) {\n        const result = [];\n        for (const m of mapping) {\n            const original = m.original.intersect(originalRange);\n            const modified = m.modified.intersect(modifiedRange);\n            if (original && !original.isEmpty && modified && !modified.isEmpty) {\n                result.push(new LineRangeMapping(original, modified));\n            }\n        }\n        return result;\n    }\n    constructor(originalRange, modifiedRange) {\n        this.original = originalRange;\n        this.modified = modifiedRange;\n    }\n    toString() {\n        return `{${this.original.toString()}->${this.modified.toString()}}`;\n    }\n    flip() {\n        return new LineRangeMapping(this.modified, this.original);\n    }\n    join(other) {\n        return new LineRangeMapping(this.original.join(other.original), this.modified.join(other.modified));\n    }\n    /**\n     * This method assumes that the LineRangeMapping describes a valid diff!\n     * I.e. if one range is empty, the other range cannot be the entire document.\n     * It avoids various problems when the line range points to non-existing line-numbers.\n    */\n    toRangeMapping() {\n        const origInclusiveRange = this.original.toInclusiveRange();\n        const modInclusiveRange = this.modified.toInclusiveRange();\n        if (origInclusiveRange && modInclusiveRange) {\n            return new RangeMapping(origInclusiveRange, modInclusiveRange);\n        }\n        else if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {\n            if (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1)) {\n                // If one line range starts at 1, the other one must start at 1 as well.\n                throw new BugIndicatingError('not a valid diff');\n            }\n            // Because one range is empty and both ranges start at line 1, none of the ranges can cover all lines.\n            // Thus, `endLineNumberExclusive` is a valid line number.\n            return new RangeMapping(new Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));\n        }\n        else {\n            // We can assume here that both startLineNumbers are greater than 1.\n            return new RangeMapping(new Range(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), new Range(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER));\n        }\n    }\n    /**\n     * This method assumes that the LineRangeMapping describes a valid diff!\n     * I.e. if one range is empty, the other range cannot be the entire document.\n     * It avoids various problems when the line range points to non-existing line-numbers.\n    */\n    toRangeMapping2(original, modified) {\n        if (isValidLineNumber(this.original.endLineNumberExclusive, original)\n            && isValidLineNumber(this.modified.endLineNumberExclusive, modified)) {\n            return new RangeMapping(new Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));\n        }\n        if (!this.original.isEmpty && !this.modified.isEmpty) {\n            return new RangeMapping(Range.fromPositions(new Position(this.original.startLineNumber, 1), normalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)), Range.fromPositions(new Position(this.modified.startLineNumber, 1), normalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)));\n        }\n        if (this.original.startLineNumber > 1 && this.modified.startLineNumber > 1) {\n            return new RangeMapping(Range.fromPositions(normalizePosition(new Position(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER), original), normalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)), Range.fromPositions(normalizePosition(new Position(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER), modified), normalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)));\n        }\n        // Situation now: one range is empty and one range touches the last line and one range starts at line 1.\n        // I don't think this can happen.\n        throw new BugIndicatingError();\n    }\n}\nfunction normalizePosition(position, content) {\n    if (position.lineNumber < 1) {\n        return new Position(1, 1);\n    }\n    if (position.lineNumber > content.length) {\n        return new Position(content.length, content[content.length - 1].length + 1);\n    }\n    const line = content[position.lineNumber - 1];\n    if (position.column > line.length + 1) {\n        return new Position(position.lineNumber, line.length + 1);\n    }\n    return position;\n}\nfunction isValidLineNumber(lineNumber, lines) {\n    return lineNumber >= 1 && lineNumber <= lines.length;\n}\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n * Also contains inner range mappings.\n */\nexport class DetailedLineRangeMapping extends LineRangeMapping {\n    static fromRangeMappings(rangeMappings) {\n        const originalRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.originalRange)));\n        const modifiedRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.modifiedRange)));\n        return new DetailedLineRangeMapping(originalRange, modifiedRange, rangeMappings);\n    }\n    constructor(originalRange, modifiedRange, innerChanges) {\n        super(originalRange, modifiedRange);\n        this.innerChanges = innerChanges;\n    }\n    flip() {\n        return new DetailedLineRangeMapping(this.modified, this.original, this.innerChanges?.map(c => c.flip()));\n    }\n    withInnerChangesFromLineRanges() {\n        return new DetailedLineRangeMapping(this.original, this.modified, [this.toRangeMapping()]);\n    }\n}\n/**\n * Maps a range in the original text model to a range in the modified text model.\n */\nexport class RangeMapping {\n    static assertSorted(rangeMappings) {\n        for (let i = 1; i < rangeMappings.length; i++) {\n            const previous = rangeMappings[i - 1];\n            const current = rangeMappings[i];\n            if (!(previous.originalRange.getEndPosition().isBeforeOrEqual(current.originalRange.getStartPosition())\n                && previous.modifiedRange.getEndPosition().isBeforeOrEqual(current.modifiedRange.getStartPosition()))) {\n                throw new BugIndicatingError('Range mappings must be sorted');\n            }\n        }\n    }\n    constructor(originalRange, modifiedRange) {\n        this.originalRange = originalRange;\n        this.modifiedRange = modifiedRange;\n    }\n    toString() {\n        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n    }\n    flip() {\n        return new RangeMapping(this.modifiedRange, this.originalRange);\n    }\n    /**\n     * Creates a single text edit that describes the change from the original to the modified text.\n    */\n    toTextEdit(modified) {\n        const newText = modified.getValueOfRange(this.modifiedRange);\n        return new SingleTextEdit(this.originalRange, newText);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}