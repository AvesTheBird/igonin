{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ResourceTextEdit } from '../../../browser/services/bulkEditService.js';\nimport { SnippetParser } from '../../snippet/browser/snippetParser.js';\n/**\n * Given a {@link DropOrPasteEdit} and set of ranges, creates a {@link WorkspaceEdit} that applies the insert text from\n * the {@link DropOrPasteEdit} at each range plus any additional edits.\n */\nexport function createCombinedWorkspaceEdit(uri, ranges, edit) {\n  var _edit$additionalEdit$2, _edit$additionalEdit2;\n  // If the edit insert text is empty, skip applying at each range\n  if (typeof edit.insertText === 'string' ? edit.insertText === '' : edit.insertText.snippet === '') {\n    var _edit$additionalEdit$, _edit$additionalEdit;\n    return {\n      edits: (_edit$additionalEdit$ = (_edit$additionalEdit = edit.additionalEdit) === null || _edit$additionalEdit === void 0 ? void 0 : _edit$additionalEdit.edits) !== null && _edit$additionalEdit$ !== void 0 ? _edit$additionalEdit$ : []\n    };\n  }\n  return {\n    edits: [...ranges.map(range => new ResourceTextEdit(uri, {\n      range,\n      text: typeof edit.insertText === 'string' ? SnippetParser.escape(edit.insertText) + '$0' : edit.insertText.snippet,\n      insertAsSnippet: true\n    })), ...((_edit$additionalEdit$2 = (_edit$additionalEdit2 = edit.additionalEdit) === null || _edit$additionalEdit2 === void 0 ? void 0 : _edit$additionalEdit2.edits) !== null && _edit$additionalEdit$2 !== void 0 ? _edit$additionalEdit$2 : [])]\n  };\n}\nexport function sortEditsByYieldTo(edits) {\n  function yieldsTo(yTo, other) {\n    if ('mimeType' in yTo) {\n      return yTo.mimeType === other.handledMimeType;\n    }\n    return !!other.kind && yTo.kind.contains(other.kind);\n  }\n  // Build list of nodes each node yields to\n  const yieldsToMap = new Map();\n  for (const edit of edits) {\n    for (const yTo of (_edit$yieldTo = edit.yieldTo) !== null && _edit$yieldTo !== void 0 ? _edit$yieldTo : []) {\n      var _edit$yieldTo;\n      for (const other of edits) {\n        if (other === edit) {\n          continue;\n        }\n        if (yieldsTo(yTo, other)) {\n          let arr = yieldsToMap.get(edit);\n          if (!arr) {\n            arr = [];\n            yieldsToMap.set(edit, arr);\n          }\n          arr.push(other);\n        }\n      }\n    }\n  }\n  if (!yieldsToMap.size) {\n    return Array.from(edits);\n  }\n  // Topological sort\n  const visited = new Set();\n  const tempStack = [];\n  function visit(nodes) {\n    if (!nodes.length) {\n      return [];\n    }\n    const node = nodes[0];\n    if (tempStack.includes(node)) {\n      console.warn('Yield to cycle detected', node);\n      return nodes;\n    }\n    if (visited.has(node)) {\n      return visit(nodes.slice(1));\n    }\n    let pre = [];\n    const yTo = yieldsToMap.get(node);\n    if (yTo) {\n      tempStack.push(node);\n      pre = visit(yTo);\n      tempStack.pop();\n    }\n    visited.add(node);\n    return [...pre, node, ...visit(nodes.slice(1))];\n  }\n  return visit(Array.from(edits));\n}","map":{"version":3,"names":["ResourceTextEdit","SnippetParser","createCombinedWorkspaceEdit","uri","ranges","edit","_edit$additionalEdit$2","_edit$additionalEdit2","insertText","snippet","_edit$additionalEdit$","_edit$additionalEdit","edits","additionalEdit","map","range","text","escape","insertAsSnippet","sortEditsByYieldTo","yieldsTo","yTo","other","mimeType","handledMimeType","kind","contains","yieldsToMap","Map","_edit$yieldTo","yieldTo","arr","get","set","push","size","Array","from","visited","Set","tempStack","visit","nodes","length","node","includes","console","warn","has","slice","pre","pop","add"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/edit.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ResourceTextEdit } from '../../../browser/services/bulkEditService.js';\nimport { SnippetParser } from '../../snippet/browser/snippetParser.js';\n/**\n * Given a {@link DropOrPasteEdit} and set of ranges, creates a {@link WorkspaceEdit} that applies the insert text from\n * the {@link DropOrPasteEdit} at each range plus any additional edits.\n */\nexport function createCombinedWorkspaceEdit(uri, ranges, edit) {\n    // If the edit insert text is empty, skip applying at each range\n    if (typeof edit.insertText === 'string' ? edit.insertText === '' : edit.insertText.snippet === '') {\n        return {\n            edits: edit.additionalEdit?.edits ?? []\n        };\n    }\n    return {\n        edits: [\n            ...ranges.map(range => new ResourceTextEdit(uri, { range, text: typeof edit.insertText === 'string' ? SnippetParser.escape(edit.insertText) + '$0' : edit.insertText.snippet, insertAsSnippet: true })),\n            ...(edit.additionalEdit?.edits ?? [])\n        ]\n    };\n}\nexport function sortEditsByYieldTo(edits) {\n    function yieldsTo(yTo, other) {\n        if ('mimeType' in yTo) {\n            return yTo.mimeType === other.handledMimeType;\n        }\n        return !!other.kind && yTo.kind.contains(other.kind);\n    }\n    // Build list of nodes each node yields to\n    const yieldsToMap = new Map();\n    for (const edit of edits) {\n        for (const yTo of edit.yieldTo ?? []) {\n            for (const other of edits) {\n                if (other === edit) {\n                    continue;\n                }\n                if (yieldsTo(yTo, other)) {\n                    let arr = yieldsToMap.get(edit);\n                    if (!arr) {\n                        arr = [];\n                        yieldsToMap.set(edit, arr);\n                    }\n                    arr.push(other);\n                }\n            }\n        }\n    }\n    if (!yieldsToMap.size) {\n        return Array.from(edits);\n    }\n    // Topological sort\n    const visited = new Set();\n    const tempStack = [];\n    function visit(nodes) {\n        if (!nodes.length) {\n            return [];\n        }\n        const node = nodes[0];\n        if (tempStack.includes(node)) {\n            console.warn('Yield to cycle detected', node);\n            return nodes;\n        }\n        if (visited.has(node)) {\n            return visit(nodes.slice(1));\n        }\n        let pre = [];\n        const yTo = yieldsToMap.get(node);\n        if (yTo) {\n            tempStack.push(node);\n            pre = visit(yTo);\n            tempStack.pop();\n        }\n        visited.add(node);\n        return [...pre, node, ...visit(nodes.slice(1))];\n    }\n    return visit(Array.from(edits));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}