{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Image from '../image/ImageBox';\nimport Client from '../../Client';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport { getValue, mixInto } from '../../util/Utils';\nimport { toRadians } from '../../util/mathUtils';\nimport Rectangle from '../geometry/Rectangle';\nimport { Graph } from '../Graph';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst FoldingMixin = {\n  options: {\n    foldingEnabled: true,\n    collapsedImage: new Image(`${Client.imageBasePath}/collapsed.gif`, 9, 9),\n    expandedImage: new Image(`${Client.imageBasePath}/expanded.gif`, 9, 9),\n    collapseToPreferredSize: true\n  },\n  /**\n   * Specifies the resource key for the tooltip on the collapse/expand icon.\n   * If the resource for this key does not exist then the value is used as\n   * the tooltip.\n   * @default 'collapse-expand'\n   */\n  collapseExpandResource: Client.language != 'none' ? 'collapse-expand' : '',\n  getCollapseExpandResource() {\n    return this.collapseExpandResource;\n  },\n  isFoldingEnabled() {\n    return this.options.foldingEnabled;\n  },\n  /**\n   * @default true\n   */\n  /**\n   * Returns the cells which are movable in the given array of cells.\n   */\n  getFoldableCells(cells, collapse = false) {\n    return this.getDataModel().filterCells(cells, cell => {\n      return this.isCellFoldable(cell, collapse);\n    });\n  },\n  /**\n   * Returns true if the given cell is foldable. This implementation\n   * returns true if the cell has at least one child and its style\n   * does not specify {@link mxConstants.STYLE_FOLDABLE} to be 0.\n   *\n   * @param cell {@link mxCell} whose foldable state should be returned.\n   */\n  isCellFoldable(cell, collapse) {\n    const style = this.getCurrentCellStyle(cell);\n    return cell.getChildCount() > 0 && (style.foldable || false);\n  },\n  /**\n   * Returns the {@link Image} used to display the collapsed state of\n   * the specified cell state. This returns null for all edges.\n   */\n  getFoldingImage(state) {\n    if (state != null && this.options.foldingEnabled && !state.cell.isEdge()) {\n      const tmp = state.cell.isCollapsed();\n      if (this.isCellFoldable(state.cell, !tmp)) {\n        return tmp ? this.options.collapsedImage : this.options.expandedImage;\n      }\n    }\n    return null;\n  },\n  /*****************************************************************************\n   * Group: Folding\n   *****************************************************************************/\n  /**\n   * Sets the collapsed state of the specified cells and all descendants\n   * if recurse is true. The change is carried out using {@link cellsFolded}.\n   * This method fires {@link InternalEvent.FOLD_CELLS} while the transaction is in\n   * progress. Returns the cells whose collapsed state was changed.\n   *\n   * @param collapse Boolean indicating the collapsed state to be assigned.\n   * @param recurse Optional boolean indicating if the collapsed state of all\n   * descendants should be set. Default is `false`.\n   * @param cells Array of {@link Cell} whose collapsed state should be set. If\n   * null is specified then the foldable selection cells are used.\n   * @param checkFoldable Optional boolean indicating of isCellFoldable should be\n   * checked. Default is `false`.\n   * @param evt Optional native event that triggered the invocation.\n   */\n  // foldCells(collapse: boolean, recurse: boolean, cells: mxCellArray, checkFoldable?: boolean, evt?: Event): mxCellArray;\n  foldCells(collapse = false, recurse = false, cells = null, checkFoldable = false, evt = null) {\n    if (cells == null) {\n      cells = this.getFoldableCells(this.getSelectionCells(), collapse);\n    }\n    this.stopEditing(false);\n    this.batchUpdate(() => {\n      this.cellsFolded(cells, collapse, recurse, checkFoldable);\n      this.fireEvent(new EventObject(InternalEvent.FOLD_CELLS, 'collapse', collapse, 'recurse', recurse, 'cells', cells));\n    });\n    return cells;\n  },\n  /**\n   * Sets the collapsed state of the specified cells. This method fires\n   * {@link InternalEvent.CELLS_FOLDED} while the transaction is in progress. Returns the\n   * cells whose collapsed state was changed.\n   *\n   * @param cells Array of {@link Cell} whose collapsed state should be set.\n   * @param collapse Boolean indicating the collapsed state to be assigned.\n   * @param recurse Boolean indicating if the collapsed state of all descendants\n   * should be set.\n   * @param checkFoldable Optional boolean indicating of isCellFoldable should be\n   * checked. Default is `false`.\n   */\n  // cellsFolded(cells: mxCellArray, collapse: boolean, recurse: boolean, checkFoldable?: boolean): void;\n  cellsFolded(cells = null, collapse = false, recurse = false, checkFoldable = false) {\n    if (cells != null && cells.length > 0) {\n      this.batchUpdate(() => {\n        for (let i = 0; i < cells.length; i += 1) {\n          if ((!checkFoldable || this.isCellFoldable(cells[i], collapse)) && collapse !== cells[i].isCollapsed()) {\n            this.getDataModel().setCollapsed(cells[i], collapse);\n            this.swapBounds(cells[i], collapse);\n            if (this.isExtendParent(cells[i])) {\n              this.extendParent(cells[i]);\n            }\n            if (recurse) {\n              const children = cells[i].getChildren();\n              this.cellsFolded(children, collapse, recurse);\n            }\n            this.constrainChild(cells[i]);\n          }\n        }\n        this.fireEvent(new EventObject(InternalEvent.CELLS_FOLDED, {\n          cells,\n          collapse,\n          recurse\n        }));\n      });\n    }\n  },\n  /**\n   * Swaps the alternate and the actual bounds in the geometry of the given\n   * cell invoking {@link updateAlternateBounds} before carrying out the swap.\n   *\n   * @param cell {@link mxCell} for which the bounds should be swapped.\n   * @param willCollapse Boolean indicating if the cell is going to be collapsed.\n   */\n  // swapBounds(cell: mxCell, willCollapse: boolean): void;\n  swapBounds(cell, willCollapse = false) {\n    let geo = cell.getGeometry();\n    if (geo != null) {\n      geo = geo.clone();\n      this.updateAlternateBounds(cell, geo, willCollapse);\n      geo.swap();\n      this.getDataModel().setGeometry(cell, geo);\n    }\n  },\n  /**\n   * Updates or sets the alternate bounds in the given geometry for the given\n   * cell depending on whether the cell is going to be collapsed. If no\n   * alternate bounds are defined in the geometry and\n   * {@link collapseToPreferredSize} is true, then the preferred size is used for\n   * the alternate bounds. The top, left corner is always kept at the same\n   * location.\n   *\n   * @param cell {@link mxCell} for which the geometry is being udpated.\n   * @param g {@link mxGeometry} for which the alternate bounds should be updated.\n   * @param willCollapse Boolean indicating if the cell is going to be collapsed.\n   */\n  // updateAlternateBounds(cell: mxCell, geo: mxGeometry, willCollapse: boolean): void;\n  updateAlternateBounds(cell = null, geo = null, willCollapse = false) {\n    if (cell != null && geo != null) {\n      const style = this.getCurrentCellStyle(cell);\n      if (geo.alternateBounds == null) {\n        let bounds = geo;\n        if (this.options.collapseToPreferredSize) {\n          const tmp = this.getPreferredSizeForCell(cell);\n          if (tmp != null) {\n            bounds = tmp;\n            const startSize = getValue(style, 'startSize');\n            if (startSize > 0) {\n              bounds.height = Math.max(bounds.height, startSize);\n            }\n          }\n        }\n        geo.alternateBounds = new Rectangle(0, 0, bounds.width, bounds.height);\n      }\n      if (geo.alternateBounds != null) {\n        geo.alternateBounds.x = geo.x;\n        geo.alternateBounds.y = geo.y;\n        const alpha = toRadians(style.rotation || 0);\n        if (alpha !== 0) {\n          const dx = geo.alternateBounds.getCenterX() - geo.getCenterX();\n          const dy = geo.alternateBounds.getCenterY() - geo.getCenterY();\n          const cos = Math.cos(alpha);\n          const sin = Math.sin(alpha);\n          const dx2 = cos * dx - sin * dy;\n          const dy2 = sin * dx + cos * dy;\n          geo.alternateBounds.x += dx2 - dx;\n          geo.alternateBounds.y += dy2 - dy;\n        }\n      }\n    }\n  }\n};\nmixInto(Graph)(FoldingMixin);","map":{"version":3,"names":["Image","Client","EventObject","InternalEvent","getValue","mixInto","toRadians","Rectangle","Graph","FoldingMixin","options","foldingEnabled","collapsedImage","imageBasePath","expandedImage","collapseToPreferredSize","collapseExpandResource","language","getCollapseExpandResource","isFoldingEnabled","getFoldableCells","cells","collapse","getDataModel","filterCells","cell","isCellFoldable","style","getCurrentCellStyle","getChildCount","foldable","getFoldingImage","state","isEdge","tmp","isCollapsed","foldCells","recurse","checkFoldable","evt","getSelectionCells","stopEditing","batchUpdate","cellsFolded","fireEvent","FOLD_CELLS","length","i","setCollapsed","swapBounds","isExtendParent","extendParent","children","getChildren","constrainChild","CELLS_FOLDED","willCollapse","geo","getGeometry","clone","updateAlternateBounds","swap","setGeometry","alternateBounds","bounds","getPreferredSizeForCell","startSize","height","Math","max","width","x","y","alpha","rotation","dx","getCenterX","dy","getCenterY","cos","sin","dx2","dy2"],"sources":["D:/OSPanel/domains/old/react/react-intro/node_modules/@maxgraph/core/dist/view/mixins/FoldingMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Image from '../image/ImageBox';\nimport Client from '../../Client';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport { getValue, mixInto } from '../../util/Utils';\nimport { toRadians } from '../../util/mathUtils';\nimport Rectangle from '../geometry/Rectangle';\nimport { Graph } from '../Graph';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst FoldingMixin = {\n    options: {\n        foldingEnabled: true,\n        collapsedImage: new Image(`${Client.imageBasePath}/collapsed.gif`, 9, 9),\n        expandedImage: new Image(`${Client.imageBasePath}/expanded.gif`, 9, 9),\n        collapseToPreferredSize: true,\n    },\n    /**\n     * Specifies the resource key for the tooltip on the collapse/expand icon.\n     * If the resource for this key does not exist then the value is used as\n     * the tooltip.\n     * @default 'collapse-expand'\n     */\n    collapseExpandResource: Client.language != 'none' ? 'collapse-expand' : '',\n    getCollapseExpandResource() {\n        return this.collapseExpandResource;\n    },\n    isFoldingEnabled() {\n        return this.options.foldingEnabled;\n    },\n    /**\n     * @default true\n     */\n    /**\n     * Returns the cells which are movable in the given array of cells.\n     */\n    getFoldableCells(cells, collapse = false) {\n        return this.getDataModel().filterCells(cells, (cell) => {\n            return this.isCellFoldable(cell, collapse);\n        });\n    },\n    /**\n     * Returns true if the given cell is foldable. This implementation\n     * returns true if the cell has at least one child and its style\n     * does not specify {@link mxConstants.STYLE_FOLDABLE} to be 0.\n     *\n     * @param cell {@link mxCell} whose foldable state should be returned.\n     */\n    isCellFoldable(cell, collapse) {\n        const style = this.getCurrentCellStyle(cell);\n        return cell.getChildCount() > 0 && (style.foldable || false);\n    },\n    /**\n     * Returns the {@link Image} used to display the collapsed state of\n     * the specified cell state. This returns null for all edges.\n     */\n    getFoldingImage(state) {\n        if (state != null && this.options.foldingEnabled && !state.cell.isEdge()) {\n            const tmp = state.cell.isCollapsed();\n            if (this.isCellFoldable(state.cell, !tmp)) {\n                return tmp ? this.options.collapsedImage : this.options.expandedImage;\n            }\n        }\n        return null;\n    },\n    /*****************************************************************************\n     * Group: Folding\n     *****************************************************************************/\n    /**\n     * Sets the collapsed state of the specified cells and all descendants\n     * if recurse is true. The change is carried out using {@link cellsFolded}.\n     * This method fires {@link InternalEvent.FOLD_CELLS} while the transaction is in\n     * progress. Returns the cells whose collapsed state was changed.\n     *\n     * @param collapse Boolean indicating the collapsed state to be assigned.\n     * @param recurse Optional boolean indicating if the collapsed state of all\n     * descendants should be set. Default is `false`.\n     * @param cells Array of {@link Cell} whose collapsed state should be set. If\n     * null is specified then the foldable selection cells are used.\n     * @param checkFoldable Optional boolean indicating of isCellFoldable should be\n     * checked. Default is `false`.\n     * @param evt Optional native event that triggered the invocation.\n     */\n    // foldCells(collapse: boolean, recurse: boolean, cells: mxCellArray, checkFoldable?: boolean, evt?: Event): mxCellArray;\n    foldCells(collapse = false, recurse = false, cells = null, checkFoldable = false, evt = null) {\n        if (cells == null) {\n            cells = this.getFoldableCells(this.getSelectionCells(), collapse);\n        }\n        this.stopEditing(false);\n        this.batchUpdate(() => {\n            this.cellsFolded(cells, collapse, recurse, checkFoldable);\n            this.fireEvent(new EventObject(InternalEvent.FOLD_CELLS, 'collapse', collapse, 'recurse', recurse, 'cells', cells));\n        });\n        return cells;\n    },\n    /**\n     * Sets the collapsed state of the specified cells. This method fires\n     * {@link InternalEvent.CELLS_FOLDED} while the transaction is in progress. Returns the\n     * cells whose collapsed state was changed.\n     *\n     * @param cells Array of {@link Cell} whose collapsed state should be set.\n     * @param collapse Boolean indicating the collapsed state to be assigned.\n     * @param recurse Boolean indicating if the collapsed state of all descendants\n     * should be set.\n     * @param checkFoldable Optional boolean indicating of isCellFoldable should be\n     * checked. Default is `false`.\n     */\n    // cellsFolded(cells: mxCellArray, collapse: boolean, recurse: boolean, checkFoldable?: boolean): void;\n    cellsFolded(cells = null, collapse = false, recurse = false, checkFoldable = false) {\n        if (cells != null && cells.length > 0) {\n            this.batchUpdate(() => {\n                for (let i = 0; i < cells.length; i += 1) {\n                    if ((!checkFoldable || this.isCellFoldable(cells[i], collapse)) &&\n                        collapse !== cells[i].isCollapsed()) {\n                        this.getDataModel().setCollapsed(cells[i], collapse);\n                        this.swapBounds(cells[i], collapse);\n                        if (this.isExtendParent(cells[i])) {\n                            this.extendParent(cells[i]);\n                        }\n                        if (recurse) {\n                            const children = cells[i].getChildren();\n                            this.cellsFolded(children, collapse, recurse);\n                        }\n                        this.constrainChild(cells[i]);\n                    }\n                }\n                this.fireEvent(new EventObject(InternalEvent.CELLS_FOLDED, { cells, collapse, recurse }));\n            });\n        }\n    },\n    /**\n     * Swaps the alternate and the actual bounds in the geometry of the given\n     * cell invoking {@link updateAlternateBounds} before carrying out the swap.\n     *\n     * @param cell {@link mxCell} for which the bounds should be swapped.\n     * @param willCollapse Boolean indicating if the cell is going to be collapsed.\n     */\n    // swapBounds(cell: mxCell, willCollapse: boolean): void;\n    swapBounds(cell, willCollapse = false) {\n        let geo = cell.getGeometry();\n        if (geo != null) {\n            geo = geo.clone();\n            this.updateAlternateBounds(cell, geo, willCollapse);\n            geo.swap();\n            this.getDataModel().setGeometry(cell, geo);\n        }\n    },\n    /**\n     * Updates or sets the alternate bounds in the given geometry for the given\n     * cell depending on whether the cell is going to be collapsed. If no\n     * alternate bounds are defined in the geometry and\n     * {@link collapseToPreferredSize} is true, then the preferred size is used for\n     * the alternate bounds. The top, left corner is always kept at the same\n     * location.\n     *\n     * @param cell {@link mxCell} for which the geometry is being udpated.\n     * @param g {@link mxGeometry} for which the alternate bounds should be updated.\n     * @param willCollapse Boolean indicating if the cell is going to be collapsed.\n     */\n    // updateAlternateBounds(cell: mxCell, geo: mxGeometry, willCollapse: boolean): void;\n    updateAlternateBounds(cell = null, geo = null, willCollapse = false) {\n        if (cell != null && geo != null) {\n            const style = this.getCurrentCellStyle(cell);\n            if (geo.alternateBounds == null) {\n                let bounds = geo;\n                if (this.options.collapseToPreferredSize) {\n                    const tmp = this.getPreferredSizeForCell(cell);\n                    if (tmp != null) {\n                        bounds = tmp;\n                        const startSize = getValue(style, 'startSize');\n                        if (startSize > 0) {\n                            bounds.height = Math.max(bounds.height, startSize);\n                        }\n                    }\n                }\n                geo.alternateBounds = new Rectangle(0, 0, bounds.width, bounds.height);\n            }\n            if (geo.alternateBounds != null) {\n                geo.alternateBounds.x = geo.x;\n                geo.alternateBounds.y = geo.y;\n                const alpha = toRadians(style.rotation || 0);\n                if (alpha !== 0) {\n                    const dx = geo.alternateBounds.getCenterX() - geo.getCenterX();\n                    const dy = geo.alternateBounds.getCenterY() - geo.getCenterY();\n                    const cos = Math.cos(alpha);\n                    const sin = Math.sin(alpha);\n                    const dx2 = cos * dx - sin * dy;\n                    const dy2 = sin * dx + cos * dy;\n                    geo.alternateBounds.x += dx2 - dx;\n                    geo.alternateBounds.y += dy2 - dy;\n                }\n            }\n        }\n    },\n};\nmixInto(Graph)(FoldingMixin);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}