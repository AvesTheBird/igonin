{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2016, JGraph Ltd\nCopyright (c) 2006-2016, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Geometry from '../geometry/Geometry';\nimport Cell from '../cell/Cell';\nimport Point from '../geometry/Point';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport { CURSOR, DEFAULT_HOTSPOT, DEFAULT_INVALID_COLOR, DEFAULT_VALID_COLOR, DIALECT, HIGHLIGHT_STROKEWIDTH, INVALID_COLOR, NONE, OUTLINE_HIGHLIGHT_COLOR, OUTLINE_HIGHLIGHT_STROKEWIDTH, TOOLTIP_VERTICAL_OFFSET, VALID_COLOR } from '../../util/Constants';\nimport { getRotatedPoint, toRadians } from '../../util/mathUtils';\nimport { convertPoint, getOffset } from '../../util/styleUtils';\nimport InternalMouseEvent from '../event/InternalMouseEvent';\nimport ImageShape from '../geometry/node/ImageShape';\nimport CellMarker from '../cell/CellMarker';\nimport ConstraintHandler from './ConstraintHandler';\nimport PolylineShape from '../geometry/edge/PolylineShape';\nimport EventSource from '../event/EventSource';\nimport Rectangle from '../geometry/Rectangle';\nimport MaxLog from '../../gui/MaxLog';\nimport { getClientX, getClientY, isAltDown, isConsumed, isShiftDown } from '../../util/EventUtils';\n/**\n * Graph event handler that creates new connections. Uses {@link TerminalMarker}\n * for finding and highlighting the source and target vertices and\n * <factoryMethod> to create the edge instance. This handler is built-into\n * {@link Graph#connectionHandler} and enabled using {@link Graph#setConnectable}.\n *\n * Example:\n *\n * ```javascript\n * new mxConnectionHandler(graph, (source, target, style)=>\n * {\n *   edge = new mxCell('', new mxGeometry());\n *   edge.setEdge(true);\n *   edge.setStyle(style);\n *   edge.geometry.relative = true;\n *   return edge;\n * });\n * ```\n *\n * Here is an alternative solution that just sets a specific user object for\n * new edges by overriding <insertEdge>.\n *\n * ```javascript\n * mxConnectionHandlerInsertEdge = insertEdge;\n * insertEdge = (parent, id, value, source, target, style)=>\n * {\n *   value = 'Test';\n *\n *   return mxConnectionHandlerInsertEdge.apply(this, arguments);\n * };\n * ```\n *\n * Using images to trigger connections:\n *\n * This handler uses mxTerminalMarker to find the source and target cell for\n * the new connection and creates a new edge using <connect>. The new edge is\n * created using <createEdge> which in turn uses <factoryMethod> or creates a\n * new default edge.\n *\n * The handler uses a \"highlight-paradigm\" for indicating if a cell is being\n * used as a source or target terminal, as seen in other diagramming products.\n * In order to allow both, moving and connecting cells at the same time,\n * {@link Constants#DEFAULT_HOTSPOT} is used in the handler to determine the hotspot\n * of a cell, that is, the region of the cell which is used to trigger a new\n * connection. The constant is a value between 0 and 1 that specifies the\n * amount of the width and height around the center to be used for the hotspot\n * of a cell and its default value is 0.5. In addition,\n * {@link Constants#MIN_HOTSPOT_SIZE} defines the minimum number of pixels for the\n * width and height of the hotspot.\n *\n * This solution, while standards compliant, may be somewhat confusing because\n * there is no visual indicator for the hotspot and the highlight is seen to\n * switch on and off while the mouse is being moved in and out. Furthermore,\n * this paradigm does not allow to create different connections depending on\n * the highlighted hotspot as there is only one hotspot per cell and it\n * normally does not allow cells to be moved and connected at the same time as\n * there is no clear indication of the connectable area of the cell.\n *\n * To come across these issues, the handle has an additional <createIcons> hook\n * with a default implementation that allows to create one icon to be used to\n * trigger new connections. If this icon is specified, then new connections can\n * only be created if the image is clicked while the cell is being highlighted.\n * The <createIcons> hook may be overridden to create more than one\n * {@link ImageShape} for creating new connections, but the default implementation\n * supports one image and is used as follows:\n *\n * In order to display the \"connect image\" whenever the mouse is over the cell,\n * an DEFAULT_HOTSPOT of 1 should be used:\n *\n * ```javascript\n * mxConstants.DEFAULT_HOTSPOT = 1;\n * ```\n *\n * In order to avoid confusion with the highlighting, the highlight color\n * should not be used with a connect image:\n *\n * ```javascript\n * mxConstants.HIGHLIGHT_COLOR = null;\n * ```\n *\n * To install the image, the connectImage field of the mxConnectionHandler must\n * be assigned a new {@link Image} instance:\n *\n * ```javascript\n * connectImage = new mxImage('images/green-dot.gif', 14, 14);\n * ```\n *\n * This will use the green-dot.gif with a width and height of 14 pixels as the\n * image to trigger new connections. In createIcons the icon field of the\n * handler will be set in order to remember the icon that has been clicked for\n * creating the new connection. This field will be available under selectedIcon\n * in the connect method, which may be overridden to take the icon that\n * triggered the new connection into account. This is useful if more than one\n * icon may be used to create a connection.\n *\n * Group: Events\n *\n * Event: mxEvent.START\n *\n * Fires when a new connection is being created by the user. The <code>state</code>\n * property contains the state of the source cell.\n *\n * Event: mxEvent.CONNECT\n *\n * Fires between begin- and endUpdate in <connect>. The <code>cell</code>\n * property contains the inserted edge, the <code>event</code> and <code>target</code>\n * properties contain the respective arguments that were passed to <connect> (where\n * target corresponds to the dropTarget argument). Finally, the <code>terminal</code>\n * property corresponds to the target argument in <connect> or the clone of the source\n * terminal if <createTarget> is enabled.\n *\n * Note that the target is the cell under the mouse where the mouse button was released.\n * Depending on the logic in the handler, this doesn't necessarily have to be the target\n * of the inserted edge. To print the source, target or any optional ports IDs that the\n * edge is connected to, the following code can be used. To get more details about the\n * actual connection point, {@link Graph#getConnectionConstraint} can be used. To resolve\n * the port IDs, use <Transactions.getCell>.\n *\n * ```javascript\n * graph.getPlugin('ConnectionHandler')?.addListener(mxEvent.CONNECT, (sender, evt) =>\n * {\n *   let edge = evt.getProperty('cell');\n *   let source = graph.getDataModel().getTerminal(edge, true);\n *   let target = graph.getDataModel().getTerminal(edge, false);\n *\n *   let style = graph.getCellStyle(edge);\n *   let sourcePortId = style[mxConstants.STYLE_SOURCE_PORT];\n *   let targetPortId = style[mxConstants.STYLE_TARGET_PORT];\n *\n *   MaxLog.show();\n *   MaxLog.debug('connect', edge, source.id, target.id, sourcePortId, targetPortId);\n * });\n * ```\n *\n * Event: mxEvent.RESET\n *\n * Fires when the <reset> method is invoked.\n *\n * Constructor: mxConnectionHandler\n *\n * Constructs an event handler that connects vertices using the specified\n * factory method to create the new edges. Modify\n * {@link Constants#ACTIVE_REGION} to setup the region on a cell which triggers\n * the creation of a new connection or use connect icons as explained\n * above.\n *\n * @param graph Reference to the enclosing {@link Graph}.\n * @param factoryMethod Optional function to create the edge. The function takes\n * the source and target <Cell> as the first and second argument and an\n * optional cell style from the preview as the third argument. It returns\n * the <Cell> that represents the new edge.\n */\nclass ConnectionHandler extends EventSource {\n  constructor(graph) {\n    let factoryMethod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super();\n    this.previous = null;\n    this.iconState = null;\n    this.icons = [];\n    this.cell = null;\n    this.currentPoint = null;\n    this.sourceConstraint = null;\n    this.shape = null;\n    this.icon = null;\n    this.originalPoint = null;\n    this.currentState = null;\n    this.selectedIcon = null;\n    this.waypoints = [];\n    /**\n     * Function that is used for creating new edges. The function takes the\n     * source and target <Cell> as the first and second argument and returns\n     * a new <Cell> that represents the edge. This is used in <createEdge>.\n     */\n    this.factoryMethod = null;\n    /**\n     * Specifies if icons should be displayed inside the graph container instead\n     * of the overlay pane. This is used for HTML labels on vertices which hide\n     * the connect icon. This has precedence over {@link moveIconBack} when set\n     * to true.\n     * @default `false`\n     */\n    this.moveIconFront = false;\n    /**\n     * Specifies if icons should be moved to the back of the overlay pane. This can\n     * be set to true if the icons of the connection handler conflict with other\n     * handles, such as the vertex label move handle. Default is false.\n     */\n    this.moveIconBack = false;\n    /**\n     * {@link Image} that is used to trigger the creation of a new connection.\n     * This is used in {@link createIcons}.\n     * @default null\n     */\n    this.connectImage = null;\n    /**\n     * Specifies if the connect icon should be centered on the target state\n     * while connections are being previewed. Default is false.\n     */\n    this.targetConnectImage = false;\n    /**\n     * Specifies if events are handled. Default is false.\n     */\n    this.enabled = false;\n    /**\n     * Specifies if new edges should be selected. Default is true.\n     */\n    this.select = true;\n    /**\n     * Specifies if <createTargetVertex> should be called if no target was under the\n     * mouse for the new connection. Setting this to true means the connection\n     * will be drawn as valid if no target is under the mouse, and\n     * <createTargetVertex> will be called before the connection is created between\n     * the source cell and the newly created vertex in <createTargetVertex>, which\n     * can be overridden to create a new target. Default is false.\n     */\n    this.createTarget = false;\n    /**\n     * Holds the current validation error while connections are being created.\n     */\n    this.error = null;\n    /**\n     * Specifies if single clicks should add waypoints on the new edge. Default is\n     * false.\n     */\n    this.waypointsEnabled = false;\n    /**\n     * Specifies if the connection handler should ignore the state of the mouse\n     * button when highlighting the source. Default is false, that is, the\n     * handler only highlights the source if no button is being pressed.\n     */\n    this.ignoreMouseDown = false;\n    /**\n     * Holds the {@link Point} where the mouseDown took place while the handler is\n     * active.\n     */\n    this.first = null;\n    /**\n     * Holds the offset for connect icons during connection preview.\n     * Default is mxPoint(0, {@link Constants#TOOLTIP_VERTICAL_OFFSET}).\n     * Note that placing the icon under the mouse pointer with an\n     * offset of (0,0) will affect hit detection.\n     */\n    this.connectIconOffset = new Point(0, TOOLTIP_VERTICAL_OFFSET);\n    /**\n     * Optional <CellState> that represents the preview edge while the\n     * handler is active. This is created in <createEdgeState>.\n     */\n    this.edgeState = null;\n    /**\n     * Counts the number of mouseDown events since the start. The initial mouse\n     * down event counts as 1.\n     */\n    this.mouseDownCounter = 0;\n    /**\n     * Switch to enable moving the preview away from the mousepointer. This is required in browsers\n     * where the preview cannot be made transparent to events and if the built-in hit detection on\n     * the HTML elements in the page should be used. Default is the value of <Client.IS_VML>.\n     */\n    this.movePreviewAway = false;\n    /**\n     * Specifies if connections to the outline of a highlighted target should be\n     * enabled. This will allow to place the connection point along the outline of\n     * the highlighted target. Default is false.\n     */\n    this.outlineConnect = false;\n    /**\n     * Specifies if the actual shape of the edge state should be used for the preview.\n     * Default is false. (Ignored if no edge state is created in <createEdgeState>.)\n     */\n    this.livePreview = false;\n    /**\n     * Specifies the cursor to be used while the handler is active. Default is null.\n     */\n    this.cursor = null;\n    /**\n     * Specifies if new edges should be inserted before the source vertex in the\n     * cell hierarchy. Default is false for backwards compatibility.\n     */\n    this.insertBeforeSource = false;\n    this.graph = graph;\n    this.factoryMethod = factoryMethod;\n    this.graph.addMouseListener(this);\n    this.marker = this.createMarker();\n    this.constraintHandler = new ConstraintHandler(this.graph);\n    // Redraws the icons if the graph changes\n    this.changeHandler = sender => {\n      if (this.iconState) {\n        this.iconState = this.graph.getView().getState(this.iconState.cell);\n      }\n      if (this.iconState) {\n        this.redrawIcons(this.icons, this.iconState);\n        this.constraintHandler.reset();\n      } else if (this.previous && !this.graph.view.getState(this.previous.cell)) {\n        this.reset();\n      }\n    };\n    this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.changeHandler);\n    this.graph.getView().addListener(InternalEvent.SCALE, this.changeHandler);\n    this.graph.getView().addListener(InternalEvent.TRANSLATE, this.changeHandler);\n    this.graph.getView().addListener(InternalEvent.SCALE_AND_TRANSLATE, this.changeHandler);\n    // Removes the icon if we step into/up or start editing\n    this.drillHandler = sender => {\n      this.reset();\n    };\n    this.graph.addListener(InternalEvent.START_EDITING, this.drillHandler);\n    this.graph.getView().addListener(InternalEvent.DOWN, this.drillHandler);\n    this.graph.getView().addListener(InternalEvent.UP, this.drillHandler);\n    // Handles escape keystrokes\n    this.escapeHandler = () => {\n      this.reset();\n    };\n    this.graph.addListener(InternalEvent.ESCAPE, this.escapeHandler);\n  }\n  /**\n   * Returns true if events are handled. This implementation\n   * returns <enabled>.\n   */\n  isEnabled() {\n    return this.enabled;\n  }\n  /**\n   * Enables or disables event handling. This implementation\n   * updates <enabled>.\n   *\n   * @param enabled Boolean that specifies the new enabled state.\n   */\n  setEnabled(enabled) {\n    this.enabled = enabled;\n  }\n  /**\n   * Returns <insertBeforeSource> for non-loops and false for loops.\n   *\n   * @param edge <Cell> that represents the edge to be inserted.\n   * @param source <Cell> that represents the source terminal.\n   * @param target <Cell> that represents the target terminal.\n   * @param evt Mousedown event of the connect gesture.\n   * @param dropTarget <Cell> that represents the cell under the mouse when it was\n   * released.\n   */\n  isInsertBefore(edge, source, target, evt, dropTarget) {\n    return this.insertBeforeSource && source !== target;\n  }\n  /**\n   * Returns <createTarget>.\n   *\n   * @param evt Current active native pointer event.\n   */\n  isCreateTarget(evt) {\n    return this.createTarget;\n  }\n  /**\n   * Sets <createTarget>.\n   */\n  setCreateTarget(value) {\n    this.createTarget = value;\n  }\n  /**\n   * Creates the preview shape for new connections.\n   */\n  createShape() {\n    // Creates the edge preview\n    const shape = this.livePreview && this.edgeState ? this.graph.cellRenderer.createShape(this.edgeState) : new PolylineShape([], INVALID_COLOR);\n    if (shape && shape.node) {\n      shape.dialect = DIALECT.SVG;\n      shape.scale = this.graph.view.scale;\n      shape.pointerEvents = false;\n      shape.isDashed = true;\n      shape.init(this.graph.getView().getOverlayPane());\n      InternalEvent.redirectMouseEvents(shape.node, this.graph, null);\n    }\n    return shape;\n  }\n  /**\n   * Returns true if the given cell is connectable. This is a hook to\n   * disable floating connections. This implementation returns true.\n   */\n  isConnectableCell(cell) {\n    return true;\n  }\n  /**\n   * Creates and returns the {@link CellMarker} used in {@link arker}.\n   */\n  createMarker() {\n    return new ConnectionHandlerCellMarker(this.graph, this);\n  }\n  /**\n   * Starts a new connection for the given state and coordinates.\n   */\n  start(state, x, y, edgeState) {\n    this.previous = state;\n    this.first = new Point(x, y);\n    this.edgeState = edgeState !== null && edgeState !== void 0 ? edgeState : this.createEdgeState();\n    // Marks the source state\n    this.marker.currentColor = this.marker.validColor;\n    this.marker.markedState = state;\n    this.marker.mark();\n    this.fireEvent(new EventObject(InternalEvent.START, {\n      state: this.previous\n    }));\n  }\n  /**\n   * Returns true if the source terminal has been clicked and a new\n   * connection is currently being previewed.\n   */\n  isConnecting() {\n    return !!this.first && !!this.shape;\n  }\n  /**\n   * Returns {@link Graph#isValidSource} for the given source terminal.\n   *\n   * @param cell <Cell> that represents the source terminal.\n   * @param me {@link MouseEvent} that is associated with this call.\n   */\n  isValidSource(cell, me) {\n    return this.graph.isValidSource(cell);\n  }\n  /**\n   * Returns true. The call to {@link Graph#isValidTarget} is implicit by calling\n   * {@link Graph#getEdgeValidationError} in <validateConnection>. This is an\n   * additional hook for disabling certain targets in this specific handler.\n   *\n   * @param cell <Cell> that represents the target terminal.\n   */\n  isValidTarget(cell) {\n    return true;\n  }\n  /**\n   * Returns the error message or an empty string if the connection for the\n   * given source target pair is not valid. Otherwise it returns null. This\n   * implementation uses {@link Graph#getEdgeValidationError}.\n   *\n   * @param source <Cell> that represents the source terminal.\n   * @param target <Cell> that represents the target terminal.\n   */\n  validateConnection(source, target) {\n    if (!this.isValidTarget(target)) {\n      return '';\n    }\n    return this.graph.getEdgeValidationError(null, source, target);\n  }\n  /**\n   * Hook to return the {@link Image} used for the connection icon of the given\n   * <CellState>. This implementation returns <connectImage>.\n   *\n   * @param state <CellState> whose connect image should be returned.\n   */\n  getConnectImage(state) {\n    return this.connectImage;\n  }\n  /**\n   * Returns true if the state has a HTML label in the graph's container, otherwise\n   * it returns {@link oveIconFront}.\n   *\n   * @param state <CellState> whose connect icons should be returned.\n   */\n  isMoveIconToFrontForState(state) {\n    if (state.text && state.text.node.parentNode === this.graph.container) {\n      return true;\n    }\n    return this.moveIconFront;\n  }\n  /**\n   * Creates the array {@link ImageShapes} that represent the connect icons for\n   * the given <CellState>.\n   *\n   * @param state <CellState> whose connect icons should be returned.\n   */\n  createIcons(state) {\n    const image = this.getConnectImage(state);\n    if (image) {\n      this.iconState = state;\n      const icons = [];\n      // Cannot use HTML for the connect icons because the icon receives all\n      // mouse move events in IE, must use VML and SVG instead even if the\n      // connect-icon appears behind the selection border and the selection\n      // border consumes the events before the icon gets a chance\n      const bounds = new Rectangle(0, 0, image.width, image.height);\n      const icon = new ImageShape(bounds, image.src, undefined, undefined, 0);\n      icon.preserveImageAspect = false;\n      if (this.isMoveIconToFrontForState(state)) {\n        icon.dialect = DIALECT.STRICTHTML;\n        icon.init(this.graph.container);\n      } else {\n        icon.dialect = DIALECT.SVG;\n        icon.init(this.graph.getView().getOverlayPane());\n        // Move the icon back in the overlay pane\n        if (this.moveIconBack && icon.node.parentNode && icon.node.previousSibling) {\n          icon.node.parentNode.insertBefore(icon.node, icon.node.parentNode.firstChild);\n        }\n      }\n      icon.node.style.cursor = CURSOR.CONNECT;\n      // Events transparency\n      const getState = () => {\n        var _this$currentState;\n        return (_this$currentState = this.currentState) !== null && _this$currentState !== void 0 ? _this$currentState : state;\n      };\n      // Updates the local icon before firing the mouse down event.\n      const mouseDown = evt => {\n        if (!isConsumed(evt)) {\n          this.icon = icon;\n          this.graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt, getState()));\n        }\n      };\n      InternalEvent.redirectMouseEvents(icon.node, this.graph, getState, mouseDown);\n      icons.push(icon);\n      this.redrawIcons(icons, this.iconState);\n      return icons;\n    }\n    return [];\n  }\n  /**\n   * Redraws the given array of {@link ImageShapes}.\n   *\n   * @param icons Array of {@link ImageShapes} to be redrawn.\n   */\n  redrawIcons(icons, state) {\n    if (icons[0] && icons[0].bounds) {\n      const pos = this.getIconPosition(icons[0], state);\n      icons[0].bounds.x = pos.x;\n      icons[0].bounds.y = pos.y;\n      icons[0].redraw();\n    }\n  }\n  // TODO: Document me! ===========================================================================================================\n  getIconPosition(icon, state) {\n    const {\n      scale\n    } = this.graph.getView();\n    let cx = state.getCenterX();\n    let cy = state.getCenterY();\n    if (this.graph.isSwimlane(state.cell)) {\n      var _state$style$rotation;\n      const size = this.graph.getStartSize(state.cell);\n      cx = size.width !== 0 ? state.x + size.width * scale / 2 : cx;\n      cy = size.height !== 0 ? state.y + size.height * scale / 2 : cy;\n      const alpha = toRadians((_state$style$rotation = state.style.rotation) !== null && _state$style$rotation !== void 0 ? _state$style$rotation : 0);\n      if (alpha !== 0) {\n        const cos = Math.cos(alpha);\n        const sin = Math.sin(alpha);\n        const ct = new Point(state.getCenterX(), state.getCenterY());\n        const pt = getRotatedPoint(new Point(cx, cy), cos, sin, ct);\n        cx = pt.x;\n        cy = pt.y;\n      }\n    }\n    return new Point(cx - icon.bounds.width / 2, cy - icon.bounds.height / 2);\n  }\n  /**\n   * Destroys the connect icons and resets the respective state.\n   */\n  destroyIcons() {\n    for (let i = 0; i < this.icons.length; i += 1) {\n      this.icons[i].destroy();\n    }\n    this.icons = [];\n    this.icon = null;\n    this.selectedIcon = null;\n    this.iconState = null;\n  }\n  /**\n   * Returns true if the given mouse down event should start this handler. The\n   * This implementation returns true if the event does not force marquee\n   * selection, and the currentConstraint and currentFocus of the\n   * <constraintHandler> are not null, or <previous> and <error> are not null and\n   * <icons> is null or <icons> and <icon> are not null.\n   */\n  isStartEvent(me) {\n    return this.constraintHandler.currentFocus !== null && this.constraintHandler.currentConstraint !== null || this.previous !== null && this.error === null && (this.icons.length === 0 || this.icon !== null);\n  }\n  /**\n   * Handles the event by initiating a new connection.\n   */\n  mouseDown(sender, me) {\n    this.mouseDownCounter += 1;\n    if (this.isEnabled() && this.graph.isEnabled() && !me.isConsumed() && !this.isConnecting() && this.isStartEvent(me)) {\n      if (this.constraintHandler.currentConstraint && this.constraintHandler.currentFocus && this.constraintHandler.currentPoint) {\n        this.sourceConstraint = this.constraintHandler.currentConstraint;\n        this.previous = this.constraintHandler.currentFocus;\n        this.first = this.constraintHandler.currentPoint.clone();\n      } else {\n        // Stores the location of the initial mousedown\n        this.first = new Point(me.getGraphX(), me.getGraphY());\n      }\n      this.edgeState = this.createEdgeState(me);\n      this.mouseDownCounter = 1;\n      if (this.waypointsEnabled && !this.shape) {\n        this.waypoints = [];\n        this.shape = this.createShape();\n        if (this.edgeState) {\n          this.shape.apply(this.edgeState);\n        }\n      }\n      // Stores the starting point in the geometry of the preview\n      if (!this.previous && this.edgeState && this.edgeState.cell.geometry) {\n        const pt = this.graph.getPointForEvent(me.getEvent());\n        this.edgeState.cell.geometry.setTerminalPoint(pt, true);\n      }\n      this.fireEvent(new EventObject(InternalEvent.START, {\n        state: this.previous\n      }));\n      me.consume();\n    }\n    this.selectedIcon = this.icon;\n    this.icon = null;\n  }\n  /**\n   * Returns true if a tap on the given source state should immediately start\n   * connecting. This implementation returns true if the state is not movable\n   * in the graph.\n   */\n  isImmediateConnectSource(state) {\n    return !this.graph.isCellMovable(state.cell);\n  }\n  /**\n   * Hook to return an <CellState> which may be used during the preview.\n   * This implementation returns null.\n   *\n   * Use the following code to create a preview for an existing edge style:\n   *\n   * ```javascript\n   * graph.getPlugin('ConnectionHandler').createEdgeState(me)\n   * {\n   *   var edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=elbowEdgeStyle');\n   *\n   *   return new CellState(this.graph.view, edge, this.graph.getCellStyle(edge));\n   * };\n   * ```\n   */\n  createEdgeState(me) {\n    return null;\n  }\n  /**\n   * Returns true if <outlineConnect> is true and the source of the event is the outline shape\n   * or shift is pressed.\n   */\n  isOutlineConnectEvent(me) {\n    if (!this.currentPoint) return false;\n    const offset = getOffset(this.graph.container);\n    const evt = me.getEvent();\n    const clientX = getClientX(evt);\n    const clientY = getClientY(evt);\n    const doc = document.documentElement;\n    const left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n    const top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n    const gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;\n    const gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;\n    return this.outlineConnect && !isShiftDown(me.getEvent()) && (me.isSource(this.marker.highlight.shape) || isAltDown(me.getEvent()) && me.getState() != null || this.marker.highlight.isHighlightAt(clientX, clientY) || (gridX !== clientX || gridY !== clientY) && me.getState() == null && this.marker.highlight.isHighlightAt(gridX, gridY));\n  }\n  /**\n   * Updates the current state for a given mouse move event by using\n   * the {@link arker}.\n   */\n  updateCurrentState(me, point) {\n    this.constraintHandler.update(me, !this.first, false, !this.first || me.isSource(this.marker.highlight.shape) ? null : point);\n    if (this.constraintHandler.currentFocus != null && this.constraintHandler.currentConstraint != null) {\n      // Handles special case where grid is large and connection point is at actual point in which\n      // case the outline is not followed as long as we're < gridSize / 2 away from that point\n      if (this.marker.highlight && this.marker.highlight.state && this.marker.highlight.state.cell === this.constraintHandler.currentFocus.cell && this.marker.highlight.shape) {\n        // Direct repaint needed if cell already highlighted\n        if (this.marker.highlight.shape.stroke !== 'transparent') {\n          this.marker.highlight.shape.stroke = 'transparent';\n          this.marker.highlight.repaint();\n        }\n      } else {\n        this.marker.markCell(this.constraintHandler.currentFocus.cell, 'transparent');\n      }\n      // Updates validation state\n      if (this.previous) {\n        this.error = this.validateConnection(this.previous.cell, this.constraintHandler.currentFocus.cell);\n        if (!this.error) {\n          this.currentState = this.constraintHandler.currentFocus;\n        }\n        if (this.error || this.currentState && !this.isCellEnabled(this.currentState.cell)) {\n          this.constraintHandler.reset();\n        }\n      }\n    } else {\n      if (this.graph.isIgnoreTerminalEvent(me.getEvent())) {\n        this.marker.reset();\n        this.currentState = null;\n      } else {\n        this.marker.process(me);\n        this.currentState = this.marker.getValidState();\n      }\n      if (this.currentState != null && !this.isCellEnabled(this.currentState.cell)) {\n        this.constraintHandler.reset();\n        this.marker.reset();\n        this.currentState = null;\n      }\n      const outline = this.isOutlineConnectEvent(me);\n      if (this.currentState != null && outline) {\n        // Handles special case where mouse is on outline away from actual end point\n        // in which case the grid is ignored and mouse point is used instead\n        if (me.isSource(this.marker.highlight.shape)) {\n          point = new Point(me.getGraphX(), me.getGraphY());\n        }\n        const constraint = this.graph.getOutlineConstraint(point, this.currentState, me);\n        this.constraintHandler.setFocus(me, this.currentState, false);\n        this.constraintHandler.currentConstraint = constraint;\n        this.constraintHandler.currentPoint = point;\n      }\n      if (this.outlineConnect) {\n        if (this.marker.highlight != null && this.marker.highlight.shape != null) {\n          const s = this.graph.view.scale;\n          if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {\n            this.marker.highlight.shape.stroke = OUTLINE_HIGHLIGHT_COLOR;\n            this.marker.highlight.shape.strokeWidth = OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;\n            this.marker.highlight.repaint();\n          } else if (this.marker.hasValidState()) {\n            const cell = me.getCell();\n            // Handles special case where actual end point of edge and current mouse point\n            // are not equal (due to grid snapping) and there is no hit on shape or highlight\n            // but ignores cases where parent is used for non-connectable child cells\n            if (cell && cell.isConnectable() && this.marker.getValidState() !== me.getState()) {\n              this.marker.highlight.shape.stroke = 'transparent';\n              this.currentState = null;\n            } else {\n              this.marker.highlight.shape.stroke = DEFAULT_VALID_COLOR;\n            }\n            this.marker.highlight.shape.strokeWidth = HIGHLIGHT_STROKEWIDTH / s / s;\n            this.marker.highlight.repaint();\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Returns true if the given cell does not allow new connections to be created.\n   */\n  isCellEnabled(cell) {\n    return true;\n  }\n  /**\n   * Converts the given point from screen coordinates to model coordinates.\n   */\n  convertWaypoint(point) {\n    const scale = this.graph.getView().getScale();\n    const tr = this.graph.getView().getTranslate();\n    point.x = point.x / scale - tr.x;\n    point.y = point.y / scale - tr.y;\n  }\n  /**\n   * Called to snap the given point to the current preview. This snaps to the\n   * first point of the preview if alt is not pressed.\n   */\n  snapToPreview(me, point) {\n    if (!isAltDown(me.getEvent()) && this.previous) {\n      const tol = this.graph.getGridSize() * this.graph.view.scale / 2;\n      const tmp = this.sourceConstraint && this.first ? this.first : new Point(this.previous.getCenterX(), this.previous.getCenterY());\n      if (Math.abs(tmp.x - me.getGraphX()) < tol) {\n        point.x = tmp.x;\n      }\n      if (Math.abs(tmp.y - me.getGraphY()) < tol) {\n        point.y = tmp.y;\n      }\n    }\n  }\n  /**\n   * Handles the event by updating the preview edge or by highlighting\n   * a possible source or target terminal.\n   */\n  mouseMove(sender, me) {\n    if (!me.isConsumed() && (this.ignoreMouseDown || this.first || !this.graph.isMouseDown)) {\n      // Handles special case when handler is disabled during highlight\n      if (!this.isEnabled() && this.currentState) {\n        this.destroyIcons();\n        this.currentState = null;\n      }\n      const view = this.graph.getView();\n      const {\n        scale\n      } = view;\n      const tr = view.translate;\n      let point = new Point(me.getGraphX(), me.getGraphY());\n      this.error = null;\n      if (this.graph.isGridEnabledEvent(me.getEvent())) {\n        point = new Point((this.graph.snap(point.x / scale - tr.x) + tr.x) * scale, (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale);\n      }\n      this.snapToPreview(me, point);\n      this.currentPoint = point;\n      if ((this.first || this.isEnabled() && this.graph.isEnabled()) && (this.shape || !this.first || Math.abs(me.getGraphX() - this.first.x) > this.graph.getEventTolerance() || Math.abs(me.getGraphY() - this.first.y) > this.graph.getEventTolerance())) {\n        this.updateCurrentState(me, point);\n      }\n      if (this.first) {\n        let constraint = null;\n        let current = point;\n        // Uses the current point from the constraint handler if available\n        if (this.constraintHandler.currentConstraint && this.constraintHandler.currentFocus && this.constraintHandler.currentPoint) {\n          constraint = this.constraintHandler.currentConstraint;\n          current = this.constraintHandler.currentPoint.clone();\n        } else if (this.previous && !this.graph.isIgnoreTerminalEvent(me.getEvent()) && isShiftDown(me.getEvent())) {\n          if (Math.abs(this.previous.getCenterX() - point.x) < Math.abs(this.previous.getCenterY() - point.y)) {\n            point.x = this.previous.getCenterX();\n          } else {\n            point.y = this.previous.getCenterY();\n          }\n        }\n        let pt2 = this.first;\n        // Moves the connect icon with the mouse\n        if (this.selectedIcon && this.selectedIcon.bounds) {\n          const w = this.selectedIcon.bounds.width;\n          const h = this.selectedIcon.bounds.height;\n          if (this.currentState && this.targetConnectImage) {\n            const pos = this.getIconPosition(this.selectedIcon, this.currentState);\n            this.selectedIcon.bounds.x = pos.x;\n            this.selectedIcon.bounds.y = pos.y;\n          } else {\n            const bounds = new Rectangle(me.getGraphX() + this.connectIconOffset.x, me.getGraphY() + this.connectIconOffset.y, w, h);\n            this.selectedIcon.bounds = bounds;\n          }\n          this.selectedIcon.redraw();\n        }\n        // Uses edge state to compute the terminal points\n        if (this.edgeState) {\n          this.updateEdgeState(current, constraint);\n          current = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 1];\n          pt2 = this.edgeState.absolutePoints[0];\n        } else {\n          if (this.currentState) {\n            if (!this.constraintHandler.currentConstraint) {\n              const tmp = this.getTargetPerimeterPoint(this.currentState, me);\n              if (tmp != null) {\n                current = tmp;\n              }\n            }\n          }\n          // Computes the source perimeter point\n          if (!this.sourceConstraint && this.previous) {\n            const next = this.waypoints.length > 0 ? this.waypoints[0] : current;\n            const tmp = this.getSourcePerimeterPoint(this.previous, next, me);\n            if (tmp) {\n              pt2 = tmp;\n            }\n          }\n        }\n        // Makes sure the cell under the mousepointer can be detected\n        // by moving the preview shape away from the mouse. This\n        // makes sure the preview shape does not prevent the detection\n        // of the cell under the mousepointer even for slow gestures.\n        if (!this.currentState && this.movePreviewAway && current) {\n          let tmp = pt2;\n          if (this.edgeState && this.edgeState.absolutePoints.length >= 2) {\n            const tmp2 = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 2];\n            if (tmp2) {\n              tmp = tmp2;\n            }\n          }\n          if (tmp) {\n            const dx = current.x - tmp.x;\n            const dy = current.y - tmp.y;\n            const len = Math.sqrt(dx * dx + dy * dy);\n            if (len === 0) {\n              return;\n            }\n            // Stores old point to reuse when creating edge\n            this.originalPoint = current.clone();\n            current.x -= dx * 4 / len;\n            current.y -= dy * 4 / len;\n          }\n        } else {\n          this.originalPoint = null;\n        }\n        // Creates the preview shape (lazy)\n        if (!this.shape) {\n          const dx = Math.abs(me.getGraphX() - this.first.x);\n          const dy = Math.abs(me.getGraphY() - this.first.y);\n          if (dx > this.graph.getEventTolerance() || dy > this.graph.getEventTolerance()) {\n            this.shape = this.createShape();\n            if (this.edgeState) {\n              this.shape.apply(this.edgeState);\n            }\n            // Revalidates current connection\n            this.updateCurrentState(me, point);\n          }\n        }\n        // Updates the points in the preview edge\n        if (this.shape) {\n          if (this.edgeState) {\n            this.shape.points = this.edgeState.absolutePoints;\n          } else {\n            let pts = [pt2];\n            if (this.waypoints.length > 0) {\n              pts = pts.concat(this.waypoints);\n            }\n            pts.push(current);\n            this.shape.points = pts;\n          }\n          this.drawPreview();\n        }\n        // Makes sure endpoint of edge is visible during connect\n        if (this.cursor) {\n          this.graph.container.style.cursor = this.cursor;\n        }\n        InternalEvent.consume(me.getEvent());\n        me.consume();\n      } else if (!this.isEnabled() || !this.graph.isEnabled()) {\n        this.constraintHandler.reset();\n      } else if (this.previous !== this.currentState && !this.edgeState) {\n        this.destroyIcons();\n        // Sets the cursor on the current shape\n        if (this.currentState && !this.error && !this.constraintHandler.currentConstraint) {\n          this.icons = this.createIcons(this.currentState);\n          if (this.icons.length === 0) {\n            this.currentState.setCursor(CURSOR.CONNECT);\n            me.consume();\n          }\n        }\n        this.previous = this.currentState;\n      } else if (this.previous === this.currentState && this.currentState != null && this.icons.length === 0 && !this.graph.isMouseDown) {\n        // Makes sure that no cursors are changed\n        me.consume();\n      }\n      if (!this.graph.isMouseDown && this.currentState != null && this.icons != null) {\n        let hitsIcon = false;\n        const target = me.getSource();\n        for (let i = 0; i < this.icons.length && !hitsIcon; i += 1) {\n          hitsIcon = target === this.icons[i].node ||\n          // @ts-ignore parentNode should exist.\n          !!target && target.parentNode === this.icons[i].node;\n        }\n        if (!hitsIcon) {\n          this.updateIcons(this.currentState, this.icons, me);\n        }\n      }\n    } else {\n      this.constraintHandler.reset();\n    }\n  }\n  /**\n   * Updates <edgeState>.\n   */\n  updateEdgeState(current, constraint) {\n    if (!this.edgeState) return;\n    // TODO: Use generic method for writing constraint to style\n    if (this.sourceConstraint && this.sourceConstraint.point) {\n      this.edgeState.style.exitX = this.sourceConstraint.point.x;\n      this.edgeState.style.exitY = this.sourceConstraint.point.y;\n    }\n    if (constraint && constraint.point) {\n      this.edgeState.style.entryX = constraint.point.x;\n      this.edgeState.style.entryY = constraint.point.y;\n    } else {\n      this.edgeState.style.entryX = 0;\n      this.edgeState.style.entryY = 0;\n    }\n    this.edgeState.absolutePoints = [null, this.currentState != null ? null : current];\n    if (this.sourceConstraint) {\n      this.graph.view.updateFixedTerminalPoint(this.edgeState, this.previous, true, this.sourceConstraint);\n    }\n    if (this.currentState != null) {\n      if (constraint == null) {\n        constraint = this.graph.getConnectionConstraint(this.edgeState, this.previous, false);\n      }\n      this.edgeState.setAbsoluteTerminalPoint(null, false);\n      this.graph.view.updateFixedTerminalPoint(this.edgeState, this.currentState, false, constraint);\n    }\n    // Scales and translates the waypoints to the model\n    const realPoints = [];\n    for (let i = 0; i < this.waypoints.length; i += 1) {\n      const pt = this.waypoints[i].clone();\n      this.convertWaypoint(pt);\n      realPoints[i] = pt;\n    }\n    this.graph.view.updatePoints(this.edgeState, realPoints, this.previous, this.currentState);\n    this.graph.view.updateFloatingTerminalPoints(this.edgeState, this.previous, this.currentState);\n  }\n  /**\n   * Returns the perimeter point for the given target state.\n   *\n   * @param state <CellState> that represents the target cell state.\n   * @param _me {@link MouseEvent} that represents the mouse move.\n   */\n  getTargetPerimeterPoint(state, _me) {\n    let result = null;\n    const {\n      view\n    } = state;\n    const targetPerimeter = view.getPerimeterFunction(state);\n    if (targetPerimeter && this.previous && this.edgeState) {\n      const next = this.waypoints.length > 0 ? this.waypoints[this.waypoints.length - 1] : new Point(this.previous.getCenterX(), this.previous.getCenterY());\n      const tmp = targetPerimeter(view.getPerimeterBounds(state), this.edgeState, next, false);\n      if (tmp) {\n        result = tmp;\n      }\n    } else {\n      result = new Point(state.getCenterX(), state.getCenterY());\n    }\n    return result;\n  }\n  /**\n   * Hook to update the icon position(s) based on a mouseOver event. This is\n   * an empty implementation.\n   *\n   * @param state <CellState> that represents the target cell state.\n   * @param next {@link Point} that represents the next point along the previewed edge.\n   * @param me {@link MouseEvent} that represents the mouse move.\n   */\n  getSourcePerimeterPoint(state, next, me) {\n    let result = null;\n    const {\n      view\n    } = state;\n    const sourcePerimeter = view.getPerimeterFunction(state);\n    const c = new Point(state.getCenterX(), state.getCenterY());\n    if (sourcePerimeter) {\n      var _state$style$rotation2;\n      const theta = (_state$style$rotation2 = state.style.rotation) !== null && _state$style$rotation2 !== void 0 ? _state$style$rotation2 : 0;\n      const rad = -theta * (Math.PI / 180);\n      if (theta !== 0) {\n        next = getRotatedPoint(new Point(next.x, next.y), Math.cos(rad), Math.sin(rad), c);\n      }\n      let tmp = sourcePerimeter(view.getPerimeterBounds(state), state, next, false);\n      if (tmp) {\n        if (theta !== 0) {\n          tmp = getRotatedPoint(new Point(tmp.x, tmp.y), Math.cos(-rad), Math.sin(-rad), c);\n        }\n        result = tmp;\n      }\n    } else {\n      result = c;\n    }\n    return result;\n  }\n  /**\n   * Hook to update the icon position(s) based on a mouseOver event. This is\n   * an empty implementation.\n   *\n   * @param state <CellState> under the mouse.\n   * @param icons Array of currently displayed icons.\n   * @param me {@link MouseEvent} that contains the mouse event.\n   */\n  updateIcons(state, icons, me) {\n    // empty\n  }\n  /**\n   * Returns true if the given mouse up event should stop this handler. The\n   * connection will be created if <error> is null. Note that this is only\n   * called if <waypointsEnabled> is true. This implemtation returns true\n   * if there is a cell state in the given event.\n   */\n  isStopEvent(me) {\n    return !!me.getState();\n  }\n  /**\n   * Adds the waypoint for the given event to <waypoints>.\n   */\n  addWaypointForEvent(me) {\n    if (!this.first) return;\n    let point = convertPoint(this.graph.container, me.getX(), me.getY());\n    const dx = Math.abs(point.x - this.first.x);\n    const dy = Math.abs(point.y - this.first.y);\n    const addPoint = this.waypoints.length > 0 || this.mouseDownCounter > 1 && (dx > this.graph.getEventTolerance() || dy > this.graph.getEventTolerance());\n    if (addPoint) {\n      const {\n        scale\n      } = this.graph.view;\n      point = new Point(this.graph.snap(me.getGraphX() / scale) * scale, this.graph.snap(me.getGraphY() / scale) * scale);\n      this.waypoints.push(point);\n    }\n  }\n  /**\n   * Returns true if the connection for the given constraints is valid. This\n   * implementation returns true if the constraints are not pointing to the\n   * same fixed connection point.\n   */\n  checkConstraints(c1, c2) {\n    return !c1 || !c2 || !c1.point || !c2.point || !c1.point.equals(c2.point) || c1.dx !== c2.dx || c1.dy !== c2.dy || c1.perimeter !== c2.perimeter;\n  }\n  /**\n   * Handles the event by inserting the new connection.\n   */\n  mouseUp(sender, me) {\n    if (!me.isConsumed() && this.isConnecting()) {\n      if (this.waypointsEnabled && !this.isStopEvent(me)) {\n        this.addWaypointForEvent(me);\n        me.consume();\n        return;\n      }\n      const c1 = this.sourceConstraint;\n      const c2 = this.constraintHandler.currentConstraint;\n      const source = this.previous ? this.previous.cell : null;\n      let target = null;\n      if (this.constraintHandler.currentConstraint && this.constraintHandler.currentFocus) {\n        target = this.constraintHandler.currentFocus.cell;\n      }\n      if (!target && this.currentState) {\n        target = this.currentState.cell;\n      }\n      // Inserts the edge if no validation error exists and if constraints differ\n      if (!this.error && (!source || !target || source !== target || this.checkConstraints(c1, c2))) {\n        this.connect(source, target, me.getEvent(), me.getCell());\n      } else {\n        // Selects the source terminal for self-references\n        if (this.previous != null && this.marker.validState != null && this.previous.cell === this.marker.validState.cell) {\n          this.graph.selectCellForEvent(this.marker.validState.cell, me.getEvent());\n        }\n        // Displays the error message if it is not an empty string,\n        // for empty error messages, the event is silently dropped\n        if (this.error != null && this.error.length > 0) {\n          this.graph.validationAlert(this.error);\n        }\n      }\n      // Redraws the connect icons and resets the handler state\n      this.destroyIcons();\n      me.consume();\n    }\n    if (this.first != null) {\n      this.reset();\n    }\n  }\n  /**\n   * Resets the state of this handler.\n   */\n  reset() {\n    if (this.shape != null) {\n      this.shape.destroy();\n      this.shape = null;\n    }\n    // Resets the cursor on the container\n    if (this.cursor != null && this.graph.container != null) {\n      this.graph.container.style.cursor = '';\n    }\n    this.destroyIcons();\n    this.marker.reset();\n    this.constraintHandler.reset();\n    this.originalPoint = null;\n    this.currentPoint = null;\n    this.edgeState = null;\n    this.previous = null;\n    this.error = null;\n    this.sourceConstraint = null;\n    this.mouseDownCounter = 0;\n    this.first = null;\n    this.fireEvent(new EventObject(InternalEvent.RESET));\n  }\n  /**\n   * Redraws the preview edge using the color and width returned by\n   * <getEdgeColor> and <getEdgeWidth>.\n   */\n  drawPreview() {\n    this.updatePreview(this.error === null);\n    if (this.shape) this.shape.redraw();\n  }\n  /**\n   * Returns the color used to draw the preview edge. This returns green if\n   * there is no edge validation error and red otherwise.\n   *\n   * @param valid Boolean indicating if the color for a valid edge should be\n   * returned.\n   */\n  updatePreview(valid) {\n    if (this.shape) {\n      this.shape.strokeWidth = this.getEdgeWidth(valid);\n      this.shape.stroke = this.getEdgeColor(valid);\n    }\n  }\n  /**\n   * Returns the color used to draw the preview edge. This returns green if\n   * there is no edge validation error and red otherwise.\n   *\n   * @param valid Boolean indicating if the color for a valid edge should be\n   * returned.\n   */\n  getEdgeColor(valid) {\n    return valid ? VALID_COLOR : INVALID_COLOR;\n  }\n  /**\n   * Returns the width used to draw the preview edge. This returns 3 if\n   * there is no edge validation error and 1 otherwise.\n   *\n   * @param valid Boolean indicating if the width for a valid edge should be\n   * returned.\n   */\n  getEdgeWidth(valid) {\n    return valid ? 3 : 1;\n  }\n  /**\n   * Connects the given source and target using a new edge. This\n   * implementation uses <createEdge> to create the edge.\n   *\n   * @param source <Cell> that represents the source terminal.\n   * @param target <Cell> that represents the target terminal.\n   * @param evt Mousedown event of the connect gesture.\n   * @param dropTarget <Cell> that represents the cell under the mouse when it was\n   * released.\n   */\n  connect(source, target, evt) {\n    let dropTarget = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    if (target || this.isCreateTarget(evt) || this.graph.isAllowDanglingEdges()) {\n      // Uses the common parent of source and target or\n      // the default parent to insert the edge\n      const model = this.graph.getDataModel();\n      let terminalInserted = false;\n      let edge = null;\n      model.beginUpdate();\n      try {\n        var _source$getParent, _this$edgeState;\n        if (source && !target && !this.graph.isIgnoreTerminalEvent(evt) && this.isCreateTarget(evt)) {\n          target = this.createTargetVertex(evt, source);\n          if (target) {\n            dropTarget = this.graph.getDropTarget([target], evt, dropTarget);\n            terminalInserted = true;\n            // Disables edges as drop targets if the target cell was created\n            // FIXME: Should not shift if vertex was aligned (same in Java)\n            if (dropTarget == null || !dropTarget.isEdge()) {\n              const pstate = dropTarget ? this.graph.getView().getState(dropTarget) : null;\n              if (pstate) {\n                const tmp = target.getGeometry();\n                if (tmp) {\n                  tmp.x -= pstate.origin.x;\n                  tmp.y -= pstate.origin.y;\n                }\n              }\n            } else {\n              dropTarget = this.graph.getDefaultParent();\n            }\n            this.graph.addCell(target, dropTarget);\n          }\n        }\n        let parent = this.graph.getDefaultParent();\n        if (source && target && source.getParent() === target.getParent() && ((_source$getParent = source.getParent()) === null || _source$getParent === void 0 ? void 0 : _source$getParent.getParent()) !== model.getRoot()) {\n          parent = source.getParent();\n          if (source.geometry && source.geometry.relative && target.geometry && target.geometry.relative) {\n            parent = parent.getParent();\n          }\n        }\n        // Uses the value of the preview edge state for inserting\n        // the new edge into the graph\n        let value = null;\n        let style = {};\n        if ((_this$edgeState = this.edgeState) !== null && _this$edgeState !== void 0 && _this$edgeState.cell) {\n          var _this$edgeState$cell$;\n          value = this.edgeState.cell.value;\n          style = (_this$edgeState$cell$ = this.edgeState.cell.style) !== null && _this$edgeState$cell$ !== void 0 ? _this$edgeState$cell$ : {};\n        }\n        edge = this.insertEdge(parent, '', value, source, target, style);\n        if (edge && source) {\n          var _this$edgeState2;\n          // Updates the connection constraints\n          this.graph.setConnectionConstraint(edge, source, true, this.sourceConstraint);\n          this.graph.setConnectionConstraint(edge, target, false, this.constraintHandler.currentConstraint);\n          // Uses geometry of the preview edge state\n          if ((_this$edgeState2 = this.edgeState) !== null && _this$edgeState2 !== void 0 && (_this$edgeState2 = _this$edgeState2.cell) !== null && _this$edgeState2 !== void 0 && _this$edgeState2.geometry) {\n            model.setGeometry(edge, this.edgeState.cell.geometry);\n          }\n          parent = source.getParent();\n          // Inserts edge before source\n          if (this.isInsertBefore(edge, source, target, evt, dropTarget)) {\n            const index = null;\n            let tmp = source;\n            while (tmp && tmp.parent != null && tmp.geometry != null && tmp.geometry.relative && tmp.parent !== edge.parent) {\n              tmp = tmp.getParent();\n            }\n            if (tmp != null && tmp.parent != null && tmp.parent === edge.parent) {\n              model.add(parent, edge, tmp.parent.getIndex(tmp));\n            }\n          }\n          // Makes sure the edge has a non-null, relative geometry\n          let geo = edge.getGeometry();\n          if (geo == null) {\n            geo = new Geometry();\n            geo.relative = true;\n            model.setGeometry(edge, geo);\n          }\n          // Uses scaled waypoints in geometry\n          if (this.waypoints.length > 0) {\n            const s = this.graph.view.scale;\n            const tr = this.graph.view.translate;\n            geo.points = [];\n            for (let i = 0; i < this.waypoints.length; i += 1) {\n              const pt = this.waypoints[i];\n              geo.points.push(new Point(pt.x / s - tr.x, pt.y / s - tr.y));\n            }\n          }\n          if (!target && this.currentPoint) {\n            const t = this.graph.view.translate;\n            const s = this.graph.view.scale;\n            const pt = this.originalPoint != null ? new Point(this.originalPoint.x / s - t.x, this.originalPoint.y / s - t.y) : new Point(this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);\n            pt.x -= this.graph.getPanDx() / this.graph.view.scale;\n            pt.y -= this.graph.getPanDy() / this.graph.view.scale;\n            geo.setTerminalPoint(pt, false);\n          }\n          this.fireEvent(new EventObject(InternalEvent.CONNECT, 'cell', edge, 'terminal', target, 'event', evt, 'target', dropTarget, 'terminalInserted', terminalInserted));\n        }\n      } catch (e) {\n        MaxLog.show();\n        // MaxLog.debug(e.message);\n      } finally {\n        model.endUpdate();\n      }\n      if (this.select) {\n        this.selectCells(edge, terminalInserted ? target : null);\n      }\n    }\n  }\n  /**\n   * Selects the given edge after adding a new connection. The target argument\n   * contains the target vertex if one has been inserted.\n   */\n  selectCells(edge, target) {\n    this.graph.setSelectionCell(edge);\n  }\n  /**\n   * Creates, inserts and returns the new edge for the given parameters. This\n   * implementation does only use <createEdge> if <factoryMethod> is defined,\n   * otherwise {@link Graph#insertEdge} will be used.\n   */\n  insertEdge(parent, id, value, source, target, style) {\n    if (!this.factoryMethod) {\n      return this.graph.insertEdge(parent, id, value, source, target, style);\n    }\n    let edge = this.createEdge(value, source, target, style);\n    edge = this.graph.addEdge(edge, parent, source, target);\n    return edge;\n  }\n  /**\n   * Hook method for creating new vertices on the fly if no target was\n   * under the mouse. This is only called if <createTarget> is true and\n   * returns null.\n   *\n   * @param evt Mousedown event of the connect gesture.\n   * @param source <Cell> that represents the source terminal.\n   */\n  createTargetVertex(evt, source) {\n    // Uses the first non-relative source\n    let geo = source.getGeometry();\n    while (geo && geo.relative) {\n      source = source.getParent();\n      geo = source.getGeometry();\n    }\n    const clone = this.graph.cloneCell(source);\n    geo = clone.getGeometry();\n    if (geo && this.currentPoint) {\n      const t = this.graph.view.translate;\n      const s = this.graph.view.scale;\n      const point = new Point(this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);\n      geo.x = Math.round(point.x - geo.width / 2 - this.graph.getPanDx() / s);\n      geo.y = Math.round(point.y - geo.height / 2 - this.graph.getPanDy() / s);\n      // Aligns with source if within certain tolerance\n      const tol = this.getAlignmentTolerance();\n      if (tol > 0) {\n        const sourceState = this.graph.view.getState(source);\n        if (sourceState != null) {\n          const x = sourceState.x / s - t.x;\n          const y = sourceState.y / s - t.y;\n          if (Math.abs(x - geo.x) <= tol) {\n            geo.x = Math.round(x);\n          }\n          if (Math.abs(y - geo.y) <= tol) {\n            geo.y = Math.round(y);\n          }\n        }\n      }\n    }\n    return clone;\n  }\n  /**\n   * Returns the tolerance for aligning new targets to sources. This returns the grid size / 2.\n   */\n  getAlignmentTolerance(evt) {\n    return this.graph.isGridEnabled() ? this.graph.getGridSize() / 2 : this.graph.getSnapTolerance();\n  }\n  /**\n   * Creates and returns a new edge using <factoryMethod> if one exists. If\n   * no factory method is defined, then a new default edge is returned. The\n   * source and target arguments are informal, the actual connection is\n   * setup later by the caller of this function.\n   *\n   * @param value Value to be used for creating the edge.\n   * @param source <Cell> that represents the source terminal.\n   * @param target <Cell> that represents the target terminal.\n   * @param style Optional style from the preview edge.\n   */\n  createEdge(value, source, target) {\n    let style = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let edge = null;\n    // Creates a new edge using the factoryMethod\n    if (this.factoryMethod != null) {\n      edge = this.factoryMethod(source, target, style);\n    }\n    if (edge == null) {\n      edge = new Cell(value || '');\n      edge.setEdge(true);\n      edge.setStyle(style);\n      const geo = new Geometry();\n      geo.relative = true;\n      edge.setGeometry(geo);\n    }\n    return edge;\n  }\n  /**\n   * Destroys the handler and all its resources and DOM nodes. This should be\n   * called on all instances. It is called automatically for the built-in\n   * instance created for each {@link Graph}.\n   */\n  onDestroy() {\n    this.graph.removeMouseListener(this);\n    if (this.shape) {\n      this.shape.destroy();\n      this.shape = null;\n    }\n    if (this.marker) {\n      this.marker.destroy();\n      // @ts-expect-error this.marker is null when it is destroyed.\n      this.marker = null;\n    }\n    if (this.constraintHandler) {\n      this.constraintHandler.onDestroy();\n    }\n    if (this.changeHandler) {\n      this.graph.getDataModel().removeListener(this.changeHandler);\n      this.graph.getView().removeListener(this.changeHandler);\n    }\n    if (this.drillHandler) {\n      this.graph.removeListener(this.drillHandler);\n      this.graph.getView().removeListener(this.drillHandler);\n    }\n    if (this.escapeHandler) {\n      this.graph.removeListener(this.escapeHandler);\n    }\n  }\n}\nConnectionHandler.pluginId = 'ConnectionHandler';\nclass ConnectionHandlerCellMarker extends CellMarker {\n  constructor(graph, connectionHandler) {\n    let validColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_VALID_COLOR;\n    let invalidColor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_INVALID_COLOR;\n    let hotspot = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DEFAULT_HOTSPOT;\n    super(graph, validColor, invalidColor, hotspot);\n    this.hotspotEnabled = true;\n    this.connectionHandler = connectionHandler;\n  }\n  // Overrides to return cell at location only if valid (so that\n  // there is no highlight for invalid cells)\n  getCell(me) {\n    let cell = super.getCell(me);\n    this.connectionHandler.error = null;\n    // Checks for cell at preview point (with grid)\n    if (!cell && this.connectionHandler.currentPoint) {\n      cell = this.connectionHandler.graph.getCellAt(this.connectionHandler.currentPoint.x, this.connectionHandler.currentPoint.y);\n    }\n    // Uses connectable parent vertex if one exists\n    if (cell && !cell.isConnectable() && this.connectionHandler.cell) {\n      const parent = this.connectionHandler.cell.getParent();\n      if (parent && parent.isVertex() && parent.isConnectable()) {\n        cell = parent;\n      }\n    }\n    if (cell) {\n      if (this.connectionHandler.graph.isSwimlane(cell) && this.connectionHandler.currentPoint != null && this.connectionHandler.graph.hitsSwimlaneContent(cell, this.connectionHandler.currentPoint.x, this.connectionHandler.currentPoint.y) || !this.connectionHandler.isConnectableCell(cell)) {\n        cell = null;\n      }\n    }\n    if (cell) {\n      if (this.connectionHandler.isConnecting()) {\n        if (this.connectionHandler.previous) {\n          this.connectionHandler.error = this.connectionHandler.validateConnection(this.connectionHandler.previous.cell, cell);\n          if (this.connectionHandler.error && this.connectionHandler.error.length === 0) {\n            cell = null;\n            // Enables create target inside groups\n            if (this.connectionHandler.isCreateTarget(me.getEvent())) {\n              this.connectionHandler.error = null;\n            }\n          }\n        }\n      } else if (!this.connectionHandler.isValidSource(cell, me)) {\n        cell = null;\n      }\n    } else if (this.connectionHandler.isConnecting() && !this.connectionHandler.isCreateTarget(me.getEvent()) && !this.connectionHandler.graph.isAllowDanglingEdges()) {\n      this.connectionHandler.error = '';\n    }\n    return cell;\n  }\n  // Sets the highlight color according to validateConnection\n  isValidState(state) {\n    if (this.connectionHandler.isConnecting()) {\n      return !this.connectionHandler.error;\n    }\n    return super.isValidState(state);\n  }\n  // Overrides to use marker color only in highlight mode or for\n  // target selection\n  getMarkerColor(evt, state, isValid) {\n    return !this.connectionHandler.connectImage || this.connectionHandler.isConnecting() ? super.getMarkerColor(evt, state, isValid) : NONE;\n  }\n  // Overrides to use hotspot only for source selection otherwise\n  // intersects always returns true when over a cell\n  intersects(state, evt) {\n    if (this.connectionHandler.connectImage || this.connectionHandler.isConnecting()) {\n      return true;\n    }\n    return super.intersects(state, evt);\n  }\n}\nexport default ConnectionHandler;","map":{"version":3,"names":["Geometry","Cell","Point","EventObject","InternalEvent","CURSOR","DEFAULT_HOTSPOT","DEFAULT_INVALID_COLOR","DEFAULT_VALID_COLOR","DIALECT","HIGHLIGHT_STROKEWIDTH","INVALID_COLOR","NONE","OUTLINE_HIGHLIGHT_COLOR","OUTLINE_HIGHLIGHT_STROKEWIDTH","TOOLTIP_VERTICAL_OFFSET","VALID_COLOR","getRotatedPoint","toRadians","convertPoint","getOffset","InternalMouseEvent","ImageShape","CellMarker","ConstraintHandler","PolylineShape","EventSource","Rectangle","MaxLog","getClientX","getClientY","isAltDown","isConsumed","isShiftDown","ConnectionHandler","constructor","graph","factoryMethod","arguments","length","undefined","previous","iconState","icons","cell","currentPoint","sourceConstraint","shape","icon","originalPoint","currentState","selectedIcon","waypoints","moveIconFront","moveIconBack","connectImage","targetConnectImage","enabled","select","createTarget","error","waypointsEnabled","ignoreMouseDown","first","connectIconOffset","edgeState","mouseDownCounter","movePreviewAway","outlineConnect","livePreview","cursor","insertBeforeSource","addMouseListener","marker","createMarker","constraintHandler","changeHandler","sender","getView","getState","redrawIcons","reset","view","getDataModel","addListener","CHANGE","SCALE","TRANSLATE","SCALE_AND_TRANSLATE","drillHandler","START_EDITING","DOWN","UP","escapeHandler","ESCAPE","isEnabled","setEnabled","isInsertBefore","edge","source","target","evt","dropTarget","isCreateTarget","setCreateTarget","value","createShape","cellRenderer","node","dialect","SVG","scale","pointerEvents","isDashed","init","getOverlayPane","redirectMouseEvents","isConnectableCell","ConnectionHandlerCellMarker","start","state","x","y","createEdgeState","currentColor","validColor","markedState","mark","fireEvent","START","isConnecting","isValidSource","me","isValidTarget","validateConnection","getEdgeValidationError","getConnectImage","isMoveIconToFrontForState","text","parentNode","container","createIcons","image","bounds","width","height","src","preserveImageAspect","STRICTHTML","previousSibling","insertBefore","firstChild","style","CONNECT","_this$currentState","mouseDown","fireMouseEvent","MOUSE_DOWN","push","pos","getIconPosition","redraw","cx","getCenterX","cy","getCenterY","isSwimlane","_state$style$rotation","size","getStartSize","alpha","rotation","cos","Math","sin","ct","pt","destroyIcons","i","destroy","isStartEvent","currentFocus","currentConstraint","clone","getGraphX","getGraphY","apply","geometry","getPointForEvent","getEvent","setTerminalPoint","consume","isImmediateConnectSource","isCellMovable","isOutlineConnectEvent","offset","clientX","clientY","doc","document","documentElement","left","window","pageXOffset","scrollLeft","clientLeft","top","pageYOffset","scrollTop","clientTop","gridX","gridY","isSource","highlight","isHighlightAt","updateCurrentState","point","update","stroke","repaint","markCell","isCellEnabled","isIgnoreTerminalEvent","process","getValidState","outline","constraint","getOutlineConstraint","setFocus","s","strokeWidth","hasValidState","getCell","isConnectable","convertWaypoint","getScale","tr","getTranslate","snapToPreview","tol","getGridSize","tmp","abs","mouseMove","isMouseDown","translate","isGridEnabledEvent","snap","getEventTolerance","current","pt2","w","h","updateEdgeState","absolutePoints","getTargetPerimeterPoint","next","getSourcePerimeterPoint","tmp2","dx","dy","len","sqrt","points","pts","concat","drawPreview","setCursor","hitsIcon","getSource","updateIcons","exitX","exitY","entryX","entryY","updateFixedTerminalPoint","getConnectionConstraint","setAbsoluteTerminalPoint","realPoints","updatePoints","updateFloatingTerminalPoints","_me","result","targetPerimeter","getPerimeterFunction","getPerimeterBounds","sourcePerimeter","c","_state$style$rotation2","theta","rad","PI","isStopEvent","addWaypointForEvent","getX","getY","addPoint","checkConstraints","c1","c2","equals","perimeter","mouseUp","connect","validState","selectCellForEvent","validationAlert","RESET","updatePreview","valid","getEdgeWidth","getEdgeColor","isAllowDanglingEdges","model","terminalInserted","beginUpdate","_source$getParent","_this$edgeState","createTargetVertex","getDropTarget","isEdge","pstate","getGeometry","origin","getDefaultParent","addCell","parent","getParent","getRoot","relative","_this$edgeState$cell$","insertEdge","_this$edgeState2","setConnectionConstraint","setGeometry","index","add","getIndex","geo","t","getPanDx","getPanDy","e","show","endUpdate","selectCells","setSelectionCell","id","createEdge","addEdge","cloneCell","round","getAlignmentTolerance","sourceState","isGridEnabled","getSnapTolerance","setEdge","setStyle","onDestroy","removeMouseListener","removeListener","pluginId","connectionHandler","invalidColor","hotspot","hotspotEnabled","getCellAt","isVertex","hitsSwimlaneContent","isValidState","getMarkerColor","isValid","intersects"],"sources":["D:/ospanel/domains/old/react/react-intro/node_modules/@maxgraph/core/dist/view/handler/ConnectionHandler.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2016, JGraph Ltd\nCopyright (c) 2006-2016, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Geometry from '../geometry/Geometry';\nimport Cell from '../cell/Cell';\nimport Point from '../geometry/Point';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport { CURSOR, DEFAULT_HOTSPOT, DEFAULT_INVALID_COLOR, DEFAULT_VALID_COLOR, DIALECT, HIGHLIGHT_STROKEWIDTH, INVALID_COLOR, NONE, OUTLINE_HIGHLIGHT_COLOR, OUTLINE_HIGHLIGHT_STROKEWIDTH, TOOLTIP_VERTICAL_OFFSET, VALID_COLOR, } from '../../util/Constants';\nimport { getRotatedPoint, toRadians } from '../../util/mathUtils';\nimport { convertPoint, getOffset } from '../../util/styleUtils';\nimport InternalMouseEvent from '../event/InternalMouseEvent';\nimport ImageShape from '../geometry/node/ImageShape';\nimport CellMarker from '../cell/CellMarker';\nimport ConstraintHandler from './ConstraintHandler';\nimport PolylineShape from '../geometry/edge/PolylineShape';\nimport EventSource from '../event/EventSource';\nimport Rectangle from '../geometry/Rectangle';\nimport MaxLog from '../../gui/MaxLog';\nimport { getClientX, getClientY, isAltDown, isConsumed, isShiftDown, } from '../../util/EventUtils';\n/**\n * Graph event handler that creates new connections. Uses {@link TerminalMarker}\n * for finding and highlighting the source and target vertices and\n * <factoryMethod> to create the edge instance. This handler is built-into\n * {@link Graph#connectionHandler} and enabled using {@link Graph#setConnectable}.\n *\n * Example:\n *\n * ```javascript\n * new mxConnectionHandler(graph, (source, target, style)=>\n * {\n *   edge = new mxCell('', new mxGeometry());\n *   edge.setEdge(true);\n *   edge.setStyle(style);\n *   edge.geometry.relative = true;\n *   return edge;\n * });\n * ```\n *\n * Here is an alternative solution that just sets a specific user object for\n * new edges by overriding <insertEdge>.\n *\n * ```javascript\n * mxConnectionHandlerInsertEdge = insertEdge;\n * insertEdge = (parent, id, value, source, target, style)=>\n * {\n *   value = 'Test';\n *\n *   return mxConnectionHandlerInsertEdge.apply(this, arguments);\n * };\n * ```\n *\n * Using images to trigger connections:\n *\n * This handler uses mxTerminalMarker to find the source and target cell for\n * the new connection and creates a new edge using <connect>. The new edge is\n * created using <createEdge> which in turn uses <factoryMethod> or creates a\n * new default edge.\n *\n * The handler uses a \"highlight-paradigm\" for indicating if a cell is being\n * used as a source or target terminal, as seen in other diagramming products.\n * In order to allow both, moving and connecting cells at the same time,\n * {@link Constants#DEFAULT_HOTSPOT} is used in the handler to determine the hotspot\n * of a cell, that is, the region of the cell which is used to trigger a new\n * connection. The constant is a value between 0 and 1 that specifies the\n * amount of the width and height around the center to be used for the hotspot\n * of a cell and its default value is 0.5. In addition,\n * {@link Constants#MIN_HOTSPOT_SIZE} defines the minimum number of pixels for the\n * width and height of the hotspot.\n *\n * This solution, while standards compliant, may be somewhat confusing because\n * there is no visual indicator for the hotspot and the highlight is seen to\n * switch on and off while the mouse is being moved in and out. Furthermore,\n * this paradigm does not allow to create different connections depending on\n * the highlighted hotspot as there is only one hotspot per cell and it\n * normally does not allow cells to be moved and connected at the same time as\n * there is no clear indication of the connectable area of the cell.\n *\n * To come across these issues, the handle has an additional <createIcons> hook\n * with a default implementation that allows to create one icon to be used to\n * trigger new connections. If this icon is specified, then new connections can\n * only be created if the image is clicked while the cell is being highlighted.\n * The <createIcons> hook may be overridden to create more than one\n * {@link ImageShape} for creating new connections, but the default implementation\n * supports one image and is used as follows:\n *\n * In order to display the \"connect image\" whenever the mouse is over the cell,\n * an DEFAULT_HOTSPOT of 1 should be used:\n *\n * ```javascript\n * mxConstants.DEFAULT_HOTSPOT = 1;\n * ```\n *\n * In order to avoid confusion with the highlighting, the highlight color\n * should not be used with a connect image:\n *\n * ```javascript\n * mxConstants.HIGHLIGHT_COLOR = null;\n * ```\n *\n * To install the image, the connectImage field of the mxConnectionHandler must\n * be assigned a new {@link Image} instance:\n *\n * ```javascript\n * connectImage = new mxImage('images/green-dot.gif', 14, 14);\n * ```\n *\n * This will use the green-dot.gif with a width and height of 14 pixels as the\n * image to trigger new connections. In createIcons the icon field of the\n * handler will be set in order to remember the icon that has been clicked for\n * creating the new connection. This field will be available under selectedIcon\n * in the connect method, which may be overridden to take the icon that\n * triggered the new connection into account. This is useful if more than one\n * icon may be used to create a connection.\n *\n * Group: Events\n *\n * Event: mxEvent.START\n *\n * Fires when a new connection is being created by the user. The <code>state</code>\n * property contains the state of the source cell.\n *\n * Event: mxEvent.CONNECT\n *\n * Fires between begin- and endUpdate in <connect>. The <code>cell</code>\n * property contains the inserted edge, the <code>event</code> and <code>target</code>\n * properties contain the respective arguments that were passed to <connect> (where\n * target corresponds to the dropTarget argument). Finally, the <code>terminal</code>\n * property corresponds to the target argument in <connect> or the clone of the source\n * terminal if <createTarget> is enabled.\n *\n * Note that the target is the cell under the mouse where the mouse button was released.\n * Depending on the logic in the handler, this doesn't necessarily have to be the target\n * of the inserted edge. To print the source, target or any optional ports IDs that the\n * edge is connected to, the following code can be used. To get more details about the\n * actual connection point, {@link Graph#getConnectionConstraint} can be used. To resolve\n * the port IDs, use <Transactions.getCell>.\n *\n * ```javascript\n * graph.getPlugin('ConnectionHandler')?.addListener(mxEvent.CONNECT, (sender, evt) =>\n * {\n *   let edge = evt.getProperty('cell');\n *   let source = graph.getDataModel().getTerminal(edge, true);\n *   let target = graph.getDataModel().getTerminal(edge, false);\n *\n *   let style = graph.getCellStyle(edge);\n *   let sourcePortId = style[mxConstants.STYLE_SOURCE_PORT];\n *   let targetPortId = style[mxConstants.STYLE_TARGET_PORT];\n *\n *   MaxLog.show();\n *   MaxLog.debug('connect', edge, source.id, target.id, sourcePortId, targetPortId);\n * });\n * ```\n *\n * Event: mxEvent.RESET\n *\n * Fires when the <reset> method is invoked.\n *\n * Constructor: mxConnectionHandler\n *\n * Constructs an event handler that connects vertices using the specified\n * factory method to create the new edges. Modify\n * {@link Constants#ACTIVE_REGION} to setup the region on a cell which triggers\n * the creation of a new connection or use connect icons as explained\n * above.\n *\n * @param graph Reference to the enclosing {@link Graph}.\n * @param factoryMethod Optional function to create the edge. The function takes\n * the source and target <Cell> as the first and second argument and an\n * optional cell style from the preview as the third argument. It returns\n * the <Cell> that represents the new edge.\n */\nclass ConnectionHandler extends EventSource {\n    constructor(graph, factoryMethod = null) {\n        super();\n        this.previous = null;\n        this.iconState = null;\n        this.icons = [];\n        this.cell = null;\n        this.currentPoint = null;\n        this.sourceConstraint = null;\n        this.shape = null;\n        this.icon = null;\n        this.originalPoint = null;\n        this.currentState = null;\n        this.selectedIcon = null;\n        this.waypoints = [];\n        /**\n         * Function that is used for creating new edges. The function takes the\n         * source and target <Cell> as the first and second argument and returns\n         * a new <Cell> that represents the edge. This is used in <createEdge>.\n         */\n        this.factoryMethod = null;\n        /**\n         * Specifies if icons should be displayed inside the graph container instead\n         * of the overlay pane. This is used for HTML labels on vertices which hide\n         * the connect icon. This has precedence over {@link moveIconBack} when set\n         * to true.\n         * @default `false`\n         */\n        this.moveIconFront = false;\n        /**\n         * Specifies if icons should be moved to the back of the overlay pane. This can\n         * be set to true if the icons of the connection handler conflict with other\n         * handles, such as the vertex label move handle. Default is false.\n         */\n        this.moveIconBack = false;\n        /**\n         * {@link Image} that is used to trigger the creation of a new connection.\n         * This is used in {@link createIcons}.\n         * @default null\n         */\n        this.connectImage = null;\n        /**\n         * Specifies if the connect icon should be centered on the target state\n         * while connections are being previewed. Default is false.\n         */\n        this.targetConnectImage = false;\n        /**\n         * Specifies if events are handled. Default is false.\n         */\n        this.enabled = false;\n        /**\n         * Specifies if new edges should be selected. Default is true.\n         */\n        this.select = true;\n        /**\n         * Specifies if <createTargetVertex> should be called if no target was under the\n         * mouse for the new connection. Setting this to true means the connection\n         * will be drawn as valid if no target is under the mouse, and\n         * <createTargetVertex> will be called before the connection is created between\n         * the source cell and the newly created vertex in <createTargetVertex>, which\n         * can be overridden to create a new target. Default is false.\n         */\n        this.createTarget = false;\n        /**\n         * Holds the current validation error while connections are being created.\n         */\n        this.error = null;\n        /**\n         * Specifies if single clicks should add waypoints on the new edge. Default is\n         * false.\n         */\n        this.waypointsEnabled = false;\n        /**\n         * Specifies if the connection handler should ignore the state of the mouse\n         * button when highlighting the source. Default is false, that is, the\n         * handler only highlights the source if no button is being pressed.\n         */\n        this.ignoreMouseDown = false;\n        /**\n         * Holds the {@link Point} where the mouseDown took place while the handler is\n         * active.\n         */\n        this.first = null;\n        /**\n         * Holds the offset for connect icons during connection preview.\n         * Default is mxPoint(0, {@link Constants#TOOLTIP_VERTICAL_OFFSET}).\n         * Note that placing the icon under the mouse pointer with an\n         * offset of (0,0) will affect hit detection.\n         */\n        this.connectIconOffset = new Point(0, TOOLTIP_VERTICAL_OFFSET);\n        /**\n         * Optional <CellState> that represents the preview edge while the\n         * handler is active. This is created in <createEdgeState>.\n         */\n        this.edgeState = null;\n        /**\n         * Counts the number of mouseDown events since the start. The initial mouse\n         * down event counts as 1.\n         */\n        this.mouseDownCounter = 0;\n        /**\n         * Switch to enable moving the preview away from the mousepointer. This is required in browsers\n         * where the preview cannot be made transparent to events and if the built-in hit detection on\n         * the HTML elements in the page should be used. Default is the value of <Client.IS_VML>.\n         */\n        this.movePreviewAway = false;\n        /**\n         * Specifies if connections to the outline of a highlighted target should be\n         * enabled. This will allow to place the connection point along the outline of\n         * the highlighted target. Default is false.\n         */\n        this.outlineConnect = false;\n        /**\n         * Specifies if the actual shape of the edge state should be used for the preview.\n         * Default is false. (Ignored if no edge state is created in <createEdgeState>.)\n         */\n        this.livePreview = false;\n        /**\n         * Specifies the cursor to be used while the handler is active. Default is null.\n         */\n        this.cursor = null;\n        /**\n         * Specifies if new edges should be inserted before the source vertex in the\n         * cell hierarchy. Default is false for backwards compatibility.\n         */\n        this.insertBeforeSource = false;\n        this.graph = graph;\n        this.factoryMethod = factoryMethod;\n        this.graph.addMouseListener(this);\n        this.marker = this.createMarker();\n        this.constraintHandler = new ConstraintHandler(this.graph);\n        // Redraws the icons if the graph changes\n        this.changeHandler = (sender) => {\n            if (this.iconState) {\n                this.iconState = this.graph.getView().getState(this.iconState.cell);\n            }\n            if (this.iconState) {\n                this.redrawIcons(this.icons, this.iconState);\n                this.constraintHandler.reset();\n            }\n            else if (this.previous && !this.graph.view.getState(this.previous.cell)) {\n                this.reset();\n            }\n        };\n        this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.changeHandler);\n        this.graph.getView().addListener(InternalEvent.SCALE, this.changeHandler);\n        this.graph.getView().addListener(InternalEvent.TRANSLATE, this.changeHandler);\n        this.graph\n            .getView()\n            .addListener(InternalEvent.SCALE_AND_TRANSLATE, this.changeHandler);\n        // Removes the icon if we step into/up or start editing\n        this.drillHandler = (sender) => {\n            this.reset();\n        };\n        this.graph.addListener(InternalEvent.START_EDITING, this.drillHandler);\n        this.graph.getView().addListener(InternalEvent.DOWN, this.drillHandler);\n        this.graph.getView().addListener(InternalEvent.UP, this.drillHandler);\n        // Handles escape keystrokes\n        this.escapeHandler = () => {\n            this.reset();\n        };\n        this.graph.addListener(InternalEvent.ESCAPE, this.escapeHandler);\n    }\n    /**\n     * Returns true if events are handled. This implementation\n     * returns <enabled>.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Enables or disables event handling. This implementation\n     * updates <enabled>.\n     *\n     * @param enabled Boolean that specifies the new enabled state.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n    }\n    /**\n     * Returns <insertBeforeSource> for non-loops and false for loops.\n     *\n     * @param edge <Cell> that represents the edge to be inserted.\n     * @param source <Cell> that represents the source terminal.\n     * @param target <Cell> that represents the target terminal.\n     * @param evt Mousedown event of the connect gesture.\n     * @param dropTarget <Cell> that represents the cell under the mouse when it was\n     * released.\n     */\n    isInsertBefore(edge, source, target, evt, dropTarget) {\n        return this.insertBeforeSource && source !== target;\n    }\n    /**\n     * Returns <createTarget>.\n     *\n     * @param evt Current active native pointer event.\n     */\n    isCreateTarget(evt) {\n        return this.createTarget;\n    }\n    /**\n     * Sets <createTarget>.\n     */\n    setCreateTarget(value) {\n        this.createTarget = value;\n    }\n    /**\n     * Creates the preview shape for new connections.\n     */\n    createShape() {\n        // Creates the edge preview\n        const shape = this.livePreview && this.edgeState\n            ? this.graph.cellRenderer.createShape(this.edgeState)\n            : new PolylineShape([], INVALID_COLOR);\n        if (shape && shape.node) {\n            shape.dialect = DIALECT.SVG;\n            shape.scale = this.graph.view.scale;\n            shape.pointerEvents = false;\n            shape.isDashed = true;\n            shape.init(this.graph.getView().getOverlayPane());\n            InternalEvent.redirectMouseEvents(shape.node, this.graph, null);\n        }\n        return shape;\n    }\n    /**\n     * Returns true if the given cell is connectable. This is a hook to\n     * disable floating connections. This implementation returns true.\n     */\n    isConnectableCell(cell) {\n        return true;\n    }\n    /**\n     * Creates and returns the {@link CellMarker} used in {@link arker}.\n     */\n    createMarker() {\n        return new ConnectionHandlerCellMarker(this.graph, this);\n    }\n    /**\n     * Starts a new connection for the given state and coordinates.\n     */\n    start(state, x, y, edgeState) {\n        this.previous = state;\n        this.first = new Point(x, y);\n        this.edgeState = edgeState ?? this.createEdgeState();\n        // Marks the source state\n        this.marker.currentColor = this.marker.validColor;\n        this.marker.markedState = state;\n        this.marker.mark();\n        this.fireEvent(new EventObject(InternalEvent.START, { state: this.previous }));\n    }\n    /**\n     * Returns true if the source terminal has been clicked and a new\n     * connection is currently being previewed.\n     */\n    isConnecting() {\n        return !!this.first && !!this.shape;\n    }\n    /**\n     * Returns {@link Graph#isValidSource} for the given source terminal.\n     *\n     * @param cell <Cell> that represents the source terminal.\n     * @param me {@link MouseEvent} that is associated with this call.\n     */\n    isValidSource(cell, me) {\n        return this.graph.isValidSource(cell);\n    }\n    /**\n     * Returns true. The call to {@link Graph#isValidTarget} is implicit by calling\n     * {@link Graph#getEdgeValidationError} in <validateConnection>. This is an\n     * additional hook for disabling certain targets in this specific handler.\n     *\n     * @param cell <Cell> that represents the target terminal.\n     */\n    isValidTarget(cell) {\n        return true;\n    }\n    /**\n     * Returns the error message or an empty string if the connection for the\n     * given source target pair is not valid. Otherwise it returns null. This\n     * implementation uses {@link Graph#getEdgeValidationError}.\n     *\n     * @param source <Cell> that represents the source terminal.\n     * @param target <Cell> that represents the target terminal.\n     */\n    validateConnection(source, target) {\n        if (!this.isValidTarget(target)) {\n            return '';\n        }\n        return this.graph.getEdgeValidationError(null, source, target);\n    }\n    /**\n     * Hook to return the {@link Image} used for the connection icon of the given\n     * <CellState>. This implementation returns <connectImage>.\n     *\n     * @param state <CellState> whose connect image should be returned.\n     */\n    getConnectImage(state) {\n        return this.connectImage;\n    }\n    /**\n     * Returns true if the state has a HTML label in the graph's container, otherwise\n     * it returns {@link oveIconFront}.\n     *\n     * @param state <CellState> whose connect icons should be returned.\n     */\n    isMoveIconToFrontForState(state) {\n        if (state.text && state.text.node.parentNode === this.graph.container) {\n            return true;\n        }\n        return this.moveIconFront;\n    }\n    /**\n     * Creates the array {@link ImageShapes} that represent the connect icons for\n     * the given <CellState>.\n     *\n     * @param state <CellState> whose connect icons should be returned.\n     */\n    createIcons(state) {\n        const image = this.getConnectImage(state);\n        if (image) {\n            this.iconState = state;\n            const icons = [];\n            // Cannot use HTML for the connect icons because the icon receives all\n            // mouse move events in IE, must use VML and SVG instead even if the\n            // connect-icon appears behind the selection border and the selection\n            // border consumes the events before the icon gets a chance\n            const bounds = new Rectangle(0, 0, image.width, image.height);\n            const icon = new ImageShape(bounds, image.src, undefined, undefined, 0);\n            icon.preserveImageAspect = false;\n            if (this.isMoveIconToFrontForState(state)) {\n                icon.dialect = DIALECT.STRICTHTML;\n                icon.init(this.graph.container);\n            }\n            else {\n                icon.dialect = DIALECT.SVG;\n                icon.init(this.graph.getView().getOverlayPane());\n                // Move the icon back in the overlay pane\n                if (this.moveIconBack && icon.node.parentNode && icon.node.previousSibling) {\n                    icon.node.parentNode.insertBefore(icon.node, icon.node.parentNode.firstChild);\n                }\n            }\n            icon.node.style.cursor = CURSOR.CONNECT;\n            // Events transparency\n            const getState = () => {\n                return this.currentState ?? state;\n            };\n            // Updates the local icon before firing the mouse down event.\n            const mouseDown = (evt) => {\n                if (!isConsumed(evt)) {\n                    this.icon = icon;\n                    this.graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt, getState()));\n                }\n            };\n            InternalEvent.redirectMouseEvents(icon.node, this.graph, getState, mouseDown);\n            icons.push(icon);\n            this.redrawIcons(icons, this.iconState);\n            return icons;\n        }\n        return [];\n    }\n    /**\n     * Redraws the given array of {@link ImageShapes}.\n     *\n     * @param icons Array of {@link ImageShapes} to be redrawn.\n     */\n    redrawIcons(icons, state) {\n        if (icons[0] && icons[0].bounds) {\n            const pos = this.getIconPosition(icons[0], state);\n            icons[0].bounds.x = pos.x;\n            icons[0].bounds.y = pos.y;\n            icons[0].redraw();\n        }\n    }\n    // TODO: Document me! ===========================================================================================================\n    getIconPosition(icon, state) {\n        const { scale } = this.graph.getView();\n        let cx = state.getCenterX();\n        let cy = state.getCenterY();\n        if (this.graph.isSwimlane(state.cell)) {\n            const size = this.graph.getStartSize(state.cell);\n            cx = size.width !== 0 ? state.x + (size.width * scale) / 2 : cx;\n            cy = size.height !== 0 ? state.y + (size.height * scale) / 2 : cy;\n            const alpha = toRadians(state.style.rotation ?? 0);\n            if (alpha !== 0) {\n                const cos = Math.cos(alpha);\n                const sin = Math.sin(alpha);\n                const ct = new Point(state.getCenterX(), state.getCenterY());\n                const pt = getRotatedPoint(new Point(cx, cy), cos, sin, ct);\n                cx = pt.x;\n                cy = pt.y;\n            }\n        }\n        return new Point(cx - icon.bounds.width / 2, cy - icon.bounds.height / 2);\n    }\n    /**\n     * Destroys the connect icons and resets the respective state.\n     */\n    destroyIcons() {\n        for (let i = 0; i < this.icons.length; i += 1) {\n            this.icons[i].destroy();\n        }\n        this.icons = [];\n        this.icon = null;\n        this.selectedIcon = null;\n        this.iconState = null;\n    }\n    /**\n     * Returns true if the given mouse down event should start this handler. The\n     * This implementation returns true if the event does not force marquee\n     * selection, and the currentConstraint and currentFocus of the\n     * <constraintHandler> are not null, or <previous> and <error> are not null and\n     * <icons> is null or <icons> and <icon> are not null.\n     */\n    isStartEvent(me) {\n        return ((this.constraintHandler.currentFocus !== null &&\n            this.constraintHandler.currentConstraint !== null) ||\n            (this.previous !== null &&\n                this.error === null &&\n                (this.icons.length === 0 || this.icon !== null)));\n    }\n    /**\n     * Handles the event by initiating a new connection.\n     */\n    mouseDown(sender, me) {\n        this.mouseDownCounter += 1;\n        if (this.isEnabled() &&\n            this.graph.isEnabled() &&\n            !me.isConsumed() &&\n            !this.isConnecting() &&\n            this.isStartEvent(me)) {\n            if (this.constraintHandler.currentConstraint &&\n                this.constraintHandler.currentFocus &&\n                this.constraintHandler.currentPoint) {\n                this.sourceConstraint = this.constraintHandler.currentConstraint;\n                this.previous = this.constraintHandler.currentFocus;\n                this.first = this.constraintHandler.currentPoint.clone();\n            }\n            else {\n                // Stores the location of the initial mousedown\n                this.first = new Point(me.getGraphX(), me.getGraphY());\n            }\n            this.edgeState = this.createEdgeState(me);\n            this.mouseDownCounter = 1;\n            if (this.waypointsEnabled && !this.shape) {\n                this.waypoints = [];\n                this.shape = this.createShape();\n                if (this.edgeState) {\n                    this.shape.apply(this.edgeState);\n                }\n            }\n            // Stores the starting point in the geometry of the preview\n            if (!this.previous && this.edgeState && this.edgeState.cell.geometry) {\n                const pt = this.graph.getPointForEvent(me.getEvent());\n                this.edgeState.cell.geometry.setTerminalPoint(pt, true);\n            }\n            this.fireEvent(new EventObject(InternalEvent.START, { state: this.previous }));\n            me.consume();\n        }\n        this.selectedIcon = this.icon;\n        this.icon = null;\n    }\n    /**\n     * Returns true if a tap on the given source state should immediately start\n     * connecting. This implementation returns true if the state is not movable\n     * in the graph.\n     */\n    isImmediateConnectSource(state) {\n        return !this.graph.isCellMovable(state.cell);\n    }\n    /**\n     * Hook to return an <CellState> which may be used during the preview.\n     * This implementation returns null.\n     *\n     * Use the following code to create a preview for an existing edge style:\n     *\n     * ```javascript\n     * graph.getPlugin('ConnectionHandler').createEdgeState(me)\n     * {\n     *   var edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=elbowEdgeStyle');\n     *\n     *   return new CellState(this.graph.view, edge, this.graph.getCellStyle(edge));\n     * };\n     * ```\n     */\n    createEdgeState(me) {\n        return null;\n    }\n    /**\n     * Returns true if <outlineConnect> is true and the source of the event is the outline shape\n     * or shift is pressed.\n     */\n    isOutlineConnectEvent(me) {\n        if (!this.currentPoint)\n            return false;\n        const offset = getOffset(this.graph.container);\n        const evt = me.getEvent();\n        const clientX = getClientX(evt);\n        const clientY = getClientY(evt);\n        const doc = document.documentElement;\n        const left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n        const top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n        const gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;\n        const gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;\n        return (this.outlineConnect &&\n            !isShiftDown(me.getEvent()) &&\n            (me.isSource(this.marker.highlight.shape) ||\n                (isAltDown(me.getEvent()) && me.getState() != null) ||\n                this.marker.highlight.isHighlightAt(clientX, clientY) ||\n                ((gridX !== clientX || gridY !== clientY) &&\n                    me.getState() == null &&\n                    this.marker.highlight.isHighlightAt(gridX, gridY))));\n    }\n    /**\n     * Updates the current state for a given mouse move event by using\n     * the {@link arker}.\n     */\n    updateCurrentState(me, point) {\n        this.constraintHandler.update(me, !this.first, false, !this.first || me.isSource(this.marker.highlight.shape) ? null : point);\n        if (this.constraintHandler.currentFocus != null &&\n            this.constraintHandler.currentConstraint != null) {\n            // Handles special case where grid is large and connection point is at actual point in which\n            // case the outline is not followed as long as we're < gridSize / 2 away from that point\n            if (this.marker.highlight &&\n                this.marker.highlight.state &&\n                this.marker.highlight.state.cell === this.constraintHandler.currentFocus.cell &&\n                this.marker.highlight.shape) {\n                // Direct repaint needed if cell already highlighted\n                if (this.marker.highlight.shape.stroke !== 'transparent') {\n                    this.marker.highlight.shape.stroke = 'transparent';\n                    this.marker.highlight.repaint();\n                }\n            }\n            else {\n                this.marker.markCell(this.constraintHandler.currentFocus.cell, 'transparent');\n            }\n            // Updates validation state\n            if (this.previous) {\n                this.error = this.validateConnection(this.previous.cell, this.constraintHandler.currentFocus.cell);\n                if (!this.error) {\n                    this.currentState = this.constraintHandler.currentFocus;\n                }\n                if (this.error ||\n                    (this.currentState && !this.isCellEnabled(this.currentState.cell))) {\n                    this.constraintHandler.reset();\n                }\n            }\n        }\n        else {\n            if (this.graph.isIgnoreTerminalEvent(me.getEvent())) {\n                this.marker.reset();\n                this.currentState = null;\n            }\n            else {\n                this.marker.process(me);\n                this.currentState = this.marker.getValidState();\n            }\n            if (this.currentState != null && !this.isCellEnabled(this.currentState.cell)) {\n                this.constraintHandler.reset();\n                this.marker.reset();\n                this.currentState = null;\n            }\n            const outline = this.isOutlineConnectEvent(me);\n            if (this.currentState != null && outline) {\n                // Handles special case where mouse is on outline away from actual end point\n                // in which case the grid is ignored and mouse point is used instead\n                if (me.isSource(this.marker.highlight.shape)) {\n                    point = new Point(me.getGraphX(), me.getGraphY());\n                }\n                const constraint = this.graph.getOutlineConstraint(point, this.currentState, me);\n                this.constraintHandler.setFocus(me, this.currentState, false);\n                this.constraintHandler.currentConstraint = constraint;\n                this.constraintHandler.currentPoint = point;\n            }\n            if (this.outlineConnect) {\n                if (this.marker.highlight != null && this.marker.highlight.shape != null) {\n                    const s = this.graph.view.scale;\n                    if (this.constraintHandler.currentConstraint != null &&\n                        this.constraintHandler.currentFocus != null) {\n                        this.marker.highlight.shape.stroke = OUTLINE_HIGHLIGHT_COLOR;\n                        this.marker.highlight.shape.strokeWidth =\n                            OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;\n                        this.marker.highlight.repaint();\n                    }\n                    else if (this.marker.hasValidState()) {\n                        const cell = me.getCell();\n                        // Handles special case where actual end point of edge and current mouse point\n                        // are not equal (due to grid snapping) and there is no hit on shape or highlight\n                        // but ignores cases where parent is used for non-connectable child cells\n                        if (cell &&\n                            cell.isConnectable() &&\n                            this.marker.getValidState() !== me.getState()) {\n                            this.marker.highlight.shape.stroke = 'transparent';\n                            this.currentState = null;\n                        }\n                        else {\n                            this.marker.highlight.shape.stroke = DEFAULT_VALID_COLOR;\n                        }\n                        this.marker.highlight.shape.strokeWidth = HIGHLIGHT_STROKEWIDTH / s / s;\n                        this.marker.highlight.repaint();\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Returns true if the given cell does not allow new connections to be created.\n     */\n    isCellEnabled(cell) {\n        return true;\n    }\n    /**\n     * Converts the given point from screen coordinates to model coordinates.\n     */\n    convertWaypoint(point) {\n        const scale = this.graph.getView().getScale();\n        const tr = this.graph.getView().getTranslate();\n        point.x = point.x / scale - tr.x;\n        point.y = point.y / scale - tr.y;\n    }\n    /**\n     * Called to snap the given point to the current preview. This snaps to the\n     * first point of the preview if alt is not pressed.\n     */\n    snapToPreview(me, point) {\n        if (!isAltDown(me.getEvent()) && this.previous) {\n            const tol = (this.graph.getGridSize() * this.graph.view.scale) / 2;\n            const tmp = this.sourceConstraint && this.first\n                ? this.first\n                : new Point(this.previous.getCenterX(), this.previous.getCenterY());\n            if (Math.abs(tmp.x - me.getGraphX()) < tol) {\n                point.x = tmp.x;\n            }\n            if (Math.abs(tmp.y - me.getGraphY()) < tol) {\n                point.y = tmp.y;\n            }\n        }\n    }\n    /**\n     * Handles the event by updating the preview edge or by highlighting\n     * a possible source or target terminal.\n     */\n    mouseMove(sender, me) {\n        if (!me.isConsumed() &&\n            (this.ignoreMouseDown || this.first || !this.graph.isMouseDown)) {\n            // Handles special case when handler is disabled during highlight\n            if (!this.isEnabled() && this.currentState) {\n                this.destroyIcons();\n                this.currentState = null;\n            }\n            const view = this.graph.getView();\n            const { scale } = view;\n            const tr = view.translate;\n            let point = new Point(me.getGraphX(), me.getGraphY());\n            this.error = null;\n            if (this.graph.isGridEnabledEvent(me.getEvent())) {\n                point = new Point((this.graph.snap(point.x / scale - tr.x) + tr.x) * scale, (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale);\n            }\n            this.snapToPreview(me, point);\n            this.currentPoint = point;\n            if ((this.first || (this.isEnabled() && this.graph.isEnabled())) &&\n                (this.shape ||\n                    !this.first ||\n                    Math.abs(me.getGraphX() - this.first.x) > this.graph.getEventTolerance() ||\n                    Math.abs(me.getGraphY() - this.first.y) > this.graph.getEventTolerance())) {\n                this.updateCurrentState(me, point);\n            }\n            if (this.first) {\n                let constraint = null;\n                let current = point;\n                // Uses the current point from the constraint handler if available\n                if (this.constraintHandler.currentConstraint &&\n                    this.constraintHandler.currentFocus &&\n                    this.constraintHandler.currentPoint) {\n                    constraint = this.constraintHandler.currentConstraint;\n                    current = this.constraintHandler.currentPoint.clone();\n                }\n                else if (this.previous &&\n                    !this.graph.isIgnoreTerminalEvent(me.getEvent()) &&\n                    isShiftDown(me.getEvent())) {\n                    if (Math.abs(this.previous.getCenterX() - point.x) <\n                        Math.abs(this.previous.getCenterY() - point.y)) {\n                        point.x = this.previous.getCenterX();\n                    }\n                    else {\n                        point.y = this.previous.getCenterY();\n                    }\n                }\n                let pt2 = this.first;\n                // Moves the connect icon with the mouse\n                if (this.selectedIcon && this.selectedIcon.bounds) {\n                    const w = this.selectedIcon.bounds.width;\n                    const h = this.selectedIcon.bounds.height;\n                    if (this.currentState && this.targetConnectImage) {\n                        const pos = this.getIconPosition(this.selectedIcon, this.currentState);\n                        this.selectedIcon.bounds.x = pos.x;\n                        this.selectedIcon.bounds.y = pos.y;\n                    }\n                    else {\n                        const bounds = new Rectangle(me.getGraphX() + this.connectIconOffset.x, me.getGraphY() + this.connectIconOffset.y, w, h);\n                        this.selectedIcon.bounds = bounds;\n                    }\n                    this.selectedIcon.redraw();\n                }\n                // Uses edge state to compute the terminal points\n                if (this.edgeState) {\n                    this.updateEdgeState(current, constraint);\n                    current =\n                        this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 1];\n                    pt2 = this.edgeState.absolutePoints[0];\n                }\n                else {\n                    if (this.currentState) {\n                        if (!this.constraintHandler.currentConstraint) {\n                            const tmp = this.getTargetPerimeterPoint(this.currentState, me);\n                            if (tmp != null) {\n                                current = tmp;\n                            }\n                        }\n                    }\n                    // Computes the source perimeter point\n                    if (!this.sourceConstraint && this.previous) {\n                        const next = this.waypoints.length > 0 ? this.waypoints[0] : current;\n                        const tmp = this.getSourcePerimeterPoint(this.previous, next, me);\n                        if (tmp) {\n                            pt2 = tmp;\n                        }\n                    }\n                }\n                // Makes sure the cell under the mousepointer can be detected\n                // by moving the preview shape away from the mouse. This\n                // makes sure the preview shape does not prevent the detection\n                // of the cell under the mousepointer even for slow gestures.\n                if (!this.currentState && this.movePreviewAway && current) {\n                    let tmp = pt2;\n                    if (this.edgeState && this.edgeState.absolutePoints.length >= 2) {\n                        const tmp2 = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 2];\n                        if (tmp2) {\n                            tmp = tmp2;\n                        }\n                    }\n                    if (tmp) {\n                        const dx = current.x - tmp.x;\n                        const dy = current.y - tmp.y;\n                        const len = Math.sqrt(dx * dx + dy * dy);\n                        if (len === 0) {\n                            return;\n                        }\n                        // Stores old point to reuse when creating edge\n                        this.originalPoint = current.clone();\n                        current.x -= (dx * 4) / len;\n                        current.y -= (dy * 4) / len;\n                    }\n                }\n                else {\n                    this.originalPoint = null;\n                }\n                // Creates the preview shape (lazy)\n                if (!this.shape) {\n                    const dx = Math.abs(me.getGraphX() - this.first.x);\n                    const dy = Math.abs(me.getGraphY() - this.first.y);\n                    if (dx > this.graph.getEventTolerance() ||\n                        dy > this.graph.getEventTolerance()) {\n                        this.shape = this.createShape();\n                        if (this.edgeState) {\n                            this.shape.apply(this.edgeState);\n                        }\n                        // Revalidates current connection\n                        this.updateCurrentState(me, point);\n                    }\n                }\n                // Updates the points in the preview edge\n                if (this.shape) {\n                    if (this.edgeState) {\n                        this.shape.points = this.edgeState.absolutePoints;\n                    }\n                    else {\n                        let pts = [pt2];\n                        if (this.waypoints.length > 0) {\n                            pts = pts.concat(this.waypoints);\n                        }\n                        pts.push(current);\n                        this.shape.points = pts;\n                    }\n                    this.drawPreview();\n                }\n                // Makes sure endpoint of edge is visible during connect\n                if (this.cursor) {\n                    this.graph.container.style.cursor = this.cursor;\n                }\n                InternalEvent.consume(me.getEvent());\n                me.consume();\n            }\n            else if (!this.isEnabled() || !this.graph.isEnabled()) {\n                this.constraintHandler.reset();\n            }\n            else if (this.previous !== this.currentState && !this.edgeState) {\n                this.destroyIcons();\n                // Sets the cursor on the current shape\n                if (this.currentState &&\n                    !this.error &&\n                    !this.constraintHandler.currentConstraint) {\n                    this.icons = this.createIcons(this.currentState);\n                    if (this.icons.length === 0) {\n                        this.currentState.setCursor(CURSOR.CONNECT);\n                        me.consume();\n                    }\n                }\n                this.previous = this.currentState;\n            }\n            else if (this.previous === this.currentState &&\n                this.currentState != null &&\n                this.icons.length === 0 &&\n                !this.graph.isMouseDown) {\n                // Makes sure that no cursors are changed\n                me.consume();\n            }\n            if (!this.graph.isMouseDown && this.currentState != null && this.icons != null) {\n                let hitsIcon = false;\n                const target = me.getSource();\n                for (let i = 0; i < this.icons.length && !hitsIcon; i += 1) {\n                    hitsIcon =\n                        target === this.icons[i].node ||\n                            // @ts-ignore parentNode should exist.\n                            (!!target && target.parentNode === this.icons[i].node);\n                }\n                if (!hitsIcon) {\n                    this.updateIcons(this.currentState, this.icons, me);\n                }\n            }\n        }\n        else {\n            this.constraintHandler.reset();\n        }\n    }\n    /**\n     * Updates <edgeState>.\n     */\n    updateEdgeState(current, constraint) {\n        if (!this.edgeState)\n            return;\n        // TODO: Use generic method for writing constraint to style\n        if (this.sourceConstraint && this.sourceConstraint.point) {\n            this.edgeState.style.exitX = this.sourceConstraint.point.x;\n            this.edgeState.style.exitY = this.sourceConstraint.point.y;\n        }\n        if (constraint && constraint.point) {\n            this.edgeState.style.entryX = constraint.point.x;\n            this.edgeState.style.entryY = constraint.point.y;\n        }\n        else {\n            this.edgeState.style.entryX = 0;\n            this.edgeState.style.entryY = 0;\n        }\n        this.edgeState.absolutePoints = [null, this.currentState != null ? null : current];\n        if (this.sourceConstraint) {\n            this.graph.view.updateFixedTerminalPoint(this.edgeState, this.previous, true, this.sourceConstraint);\n        }\n        if (this.currentState != null) {\n            if (constraint == null) {\n                constraint = this.graph.getConnectionConstraint(this.edgeState, this.previous, false);\n            }\n            this.edgeState.setAbsoluteTerminalPoint(null, false);\n            this.graph.view.updateFixedTerminalPoint(this.edgeState, this.currentState, false, constraint);\n        }\n        // Scales and translates the waypoints to the model\n        const realPoints = [];\n        for (let i = 0; i < this.waypoints.length; i += 1) {\n            const pt = this.waypoints[i].clone();\n            this.convertWaypoint(pt);\n            realPoints[i] = pt;\n        }\n        this.graph.view.updatePoints(this.edgeState, realPoints, this.previous, this.currentState);\n        this.graph.view.updateFloatingTerminalPoints(this.edgeState, this.previous, this.currentState);\n    }\n    /**\n     * Returns the perimeter point for the given target state.\n     *\n     * @param state <CellState> that represents the target cell state.\n     * @param _me {@link MouseEvent} that represents the mouse move.\n     */\n    getTargetPerimeterPoint(state, _me) {\n        let result = null;\n        const { view } = state;\n        const targetPerimeter = view.getPerimeterFunction(state);\n        if (targetPerimeter && this.previous && this.edgeState) {\n            const next = this.waypoints.length > 0\n                ? this.waypoints[this.waypoints.length - 1]\n                : new Point(this.previous.getCenterX(), this.previous.getCenterY());\n            const tmp = targetPerimeter(view.getPerimeterBounds(state), this.edgeState, next, false);\n            if (tmp) {\n                result = tmp;\n            }\n        }\n        else {\n            result = new Point(state.getCenterX(), state.getCenterY());\n        }\n        return result;\n    }\n    /**\n     * Hook to update the icon position(s) based on a mouseOver event. This is\n     * an empty implementation.\n     *\n     * @param state <CellState> that represents the target cell state.\n     * @param next {@link Point} that represents the next point along the previewed edge.\n     * @param me {@link MouseEvent} that represents the mouse move.\n     */\n    getSourcePerimeterPoint(state, next, me) {\n        let result = null;\n        const { view } = state;\n        const sourcePerimeter = view.getPerimeterFunction(state);\n        const c = new Point(state.getCenterX(), state.getCenterY());\n        if (sourcePerimeter) {\n            const theta = state.style.rotation ?? 0;\n            const rad = -theta * (Math.PI / 180);\n            if (theta !== 0) {\n                next = getRotatedPoint(new Point(next.x, next.y), Math.cos(rad), Math.sin(rad), c);\n            }\n            let tmp = sourcePerimeter(view.getPerimeterBounds(state), state, next, false);\n            if (tmp) {\n                if (theta !== 0) {\n                    tmp = getRotatedPoint(new Point(tmp.x, tmp.y), Math.cos(-rad), Math.sin(-rad), c);\n                }\n                result = tmp;\n            }\n        }\n        else {\n            result = c;\n        }\n        return result;\n    }\n    /**\n     * Hook to update the icon position(s) based on a mouseOver event. This is\n     * an empty implementation.\n     *\n     * @param state <CellState> under the mouse.\n     * @param icons Array of currently displayed icons.\n     * @param me {@link MouseEvent} that contains the mouse event.\n     */\n    updateIcons(state, icons, me) {\n        // empty\n    }\n    /**\n     * Returns true if the given mouse up event should stop this handler. The\n     * connection will be created if <error> is null. Note that this is only\n     * called if <waypointsEnabled> is true. This implemtation returns true\n     * if there is a cell state in the given event.\n     */\n    isStopEvent(me) {\n        return !!me.getState();\n    }\n    /**\n     * Adds the waypoint for the given event to <waypoints>.\n     */\n    addWaypointForEvent(me) {\n        if (!this.first)\n            return;\n        let point = convertPoint(this.graph.container, me.getX(), me.getY());\n        const dx = Math.abs(point.x - this.first.x);\n        const dy = Math.abs(point.y - this.first.y);\n        const addPoint = this.waypoints.length > 0 ||\n            (this.mouseDownCounter > 1 &&\n                (dx > this.graph.getEventTolerance() || dy > this.graph.getEventTolerance()));\n        if (addPoint) {\n            const { scale } = this.graph.view;\n            point = new Point(this.graph.snap(me.getGraphX() / scale) * scale, this.graph.snap(me.getGraphY() / scale) * scale);\n            this.waypoints.push(point);\n        }\n    }\n    /**\n     * Returns true if the connection for the given constraints is valid. This\n     * implementation returns true if the constraints are not pointing to the\n     * same fixed connection point.\n     */\n    checkConstraints(c1, c2) {\n        return (!c1 ||\n            !c2 ||\n            !c1.point ||\n            !c2.point ||\n            !c1.point.equals(c2.point) ||\n            c1.dx !== c2.dx ||\n            c1.dy !== c2.dy ||\n            c1.perimeter !== c2.perimeter);\n    }\n    /**\n     * Handles the event by inserting the new connection.\n     */\n    mouseUp(sender, me) {\n        if (!me.isConsumed() && this.isConnecting()) {\n            if (this.waypointsEnabled && !this.isStopEvent(me)) {\n                this.addWaypointForEvent(me);\n                me.consume();\n                return;\n            }\n            const c1 = this.sourceConstraint;\n            const c2 = this.constraintHandler.currentConstraint;\n            const source = this.previous ? this.previous.cell : null;\n            let target = null;\n            if (this.constraintHandler.currentConstraint &&\n                this.constraintHandler.currentFocus) {\n                target = this.constraintHandler.currentFocus.cell;\n            }\n            if (!target && this.currentState) {\n                target = this.currentState.cell;\n            }\n            // Inserts the edge if no validation error exists and if constraints differ\n            if (!this.error &&\n                (!source || !target || source !== target || this.checkConstraints(c1, c2))) {\n                this.connect(source, target, me.getEvent(), me.getCell());\n            }\n            else {\n                // Selects the source terminal for self-references\n                if (this.previous != null &&\n                    this.marker.validState != null &&\n                    this.previous.cell === this.marker.validState.cell) {\n                    this.graph.selectCellForEvent(this.marker.validState.cell, me.getEvent());\n                }\n                // Displays the error message if it is not an empty string,\n                // for empty error messages, the event is silently dropped\n                if (this.error != null && this.error.length > 0) {\n                    this.graph.validationAlert(this.error);\n                }\n            }\n            // Redraws the connect icons and resets the handler state\n            this.destroyIcons();\n            me.consume();\n        }\n        if (this.first != null) {\n            this.reset();\n        }\n    }\n    /**\n     * Resets the state of this handler.\n     */\n    reset() {\n        if (this.shape != null) {\n            this.shape.destroy();\n            this.shape = null;\n        }\n        // Resets the cursor on the container\n        if (this.cursor != null && this.graph.container != null) {\n            this.graph.container.style.cursor = '';\n        }\n        this.destroyIcons();\n        this.marker.reset();\n        this.constraintHandler.reset();\n        this.originalPoint = null;\n        this.currentPoint = null;\n        this.edgeState = null;\n        this.previous = null;\n        this.error = null;\n        this.sourceConstraint = null;\n        this.mouseDownCounter = 0;\n        this.first = null;\n        this.fireEvent(new EventObject(InternalEvent.RESET));\n    }\n    /**\n     * Redraws the preview edge using the color and width returned by\n     * <getEdgeColor> and <getEdgeWidth>.\n     */\n    drawPreview() {\n        this.updatePreview(this.error === null);\n        if (this.shape)\n            this.shape.redraw();\n    }\n    /**\n     * Returns the color used to draw the preview edge. This returns green if\n     * there is no edge validation error and red otherwise.\n     *\n     * @param valid Boolean indicating if the color for a valid edge should be\n     * returned.\n     */\n    updatePreview(valid) {\n        if (this.shape) {\n            this.shape.strokeWidth = this.getEdgeWidth(valid);\n            this.shape.stroke = this.getEdgeColor(valid);\n        }\n    }\n    /**\n     * Returns the color used to draw the preview edge. This returns green if\n     * there is no edge validation error and red otherwise.\n     *\n     * @param valid Boolean indicating if the color for a valid edge should be\n     * returned.\n     */\n    getEdgeColor(valid) {\n        return valid ? VALID_COLOR : INVALID_COLOR;\n    }\n    /**\n     * Returns the width used to draw the preview edge. This returns 3 if\n     * there is no edge validation error and 1 otherwise.\n     *\n     * @param valid Boolean indicating if the width for a valid edge should be\n     * returned.\n     */\n    getEdgeWidth(valid) {\n        return valid ? 3 : 1;\n    }\n    /**\n     * Connects the given source and target using a new edge. This\n     * implementation uses <createEdge> to create the edge.\n     *\n     * @param source <Cell> that represents the source terminal.\n     * @param target <Cell> that represents the target terminal.\n     * @param evt Mousedown event of the connect gesture.\n     * @param dropTarget <Cell> that represents the cell under the mouse when it was\n     * released.\n     */\n    connect(source, target, evt, dropTarget = null) {\n        if (target || this.isCreateTarget(evt) || this.graph.isAllowDanglingEdges()) {\n            // Uses the common parent of source and target or\n            // the default parent to insert the edge\n            const model = this.graph.getDataModel();\n            let terminalInserted = false;\n            let edge = null;\n            model.beginUpdate();\n            try {\n                if (source &&\n                    !target &&\n                    !this.graph.isIgnoreTerminalEvent(evt) &&\n                    this.isCreateTarget(evt)) {\n                    target = this.createTargetVertex(evt, source);\n                    if (target) {\n                        dropTarget = this.graph.getDropTarget([target], evt, dropTarget);\n                        terminalInserted = true;\n                        // Disables edges as drop targets if the target cell was created\n                        // FIXME: Should not shift if vertex was aligned (same in Java)\n                        if (dropTarget == null || !dropTarget.isEdge()) {\n                            const pstate = dropTarget\n                                ? this.graph.getView().getState(dropTarget)\n                                : null;\n                            if (pstate) {\n                                const tmp = target.getGeometry();\n                                if (tmp) {\n                                    tmp.x -= pstate.origin.x;\n                                    tmp.y -= pstate.origin.y;\n                                }\n                            }\n                        }\n                        else {\n                            dropTarget = this.graph.getDefaultParent();\n                        }\n                        this.graph.addCell(target, dropTarget);\n                    }\n                }\n                let parent = this.graph.getDefaultParent();\n                if (source &&\n                    target &&\n                    source.getParent() === target.getParent() &&\n                    source.getParent()?.getParent() !== model.getRoot()) {\n                    parent = source.getParent();\n                    if (source.geometry &&\n                        source.geometry.relative &&\n                        target.geometry &&\n                        target.geometry.relative) {\n                        parent = parent.getParent();\n                    }\n                }\n                // Uses the value of the preview edge state for inserting\n                // the new edge into the graph\n                let value = null;\n                let style = {};\n                if (this.edgeState?.cell) {\n                    value = this.edgeState.cell.value;\n                    style = this.edgeState.cell.style ?? {};\n                }\n                edge = this.insertEdge(parent, '', value, source, target, style);\n                if (edge && source) {\n                    // Updates the connection constraints\n                    this.graph.setConnectionConstraint(edge, source, true, this.sourceConstraint);\n                    this.graph.setConnectionConstraint(edge, target, false, this.constraintHandler.currentConstraint);\n                    // Uses geometry of the preview edge state\n                    if (this.edgeState?.cell?.geometry) {\n                        model.setGeometry(edge, this.edgeState.cell.geometry);\n                    }\n                    parent = source.getParent();\n                    // Inserts edge before source\n                    if (this.isInsertBefore(edge, source, target, evt, dropTarget)) {\n                        const index = null;\n                        let tmp = source;\n                        while (tmp &&\n                            tmp.parent != null &&\n                            tmp.geometry != null &&\n                            tmp.geometry.relative &&\n                            tmp.parent !== edge.parent) {\n                            tmp = tmp.getParent();\n                        }\n                        if (tmp != null && tmp.parent != null && tmp.parent === edge.parent) {\n                            model.add(parent, edge, tmp.parent.getIndex(tmp));\n                        }\n                    }\n                    // Makes sure the edge has a non-null, relative geometry\n                    let geo = edge.getGeometry();\n                    if (geo == null) {\n                        geo = new Geometry();\n                        geo.relative = true;\n                        model.setGeometry(edge, geo);\n                    }\n                    // Uses scaled waypoints in geometry\n                    if (this.waypoints.length > 0) {\n                        const s = this.graph.view.scale;\n                        const tr = this.graph.view.translate;\n                        geo.points = [];\n                        for (let i = 0; i < this.waypoints.length; i += 1) {\n                            const pt = this.waypoints[i];\n                            geo.points.push(new Point(pt.x / s - tr.x, pt.y / s - tr.y));\n                        }\n                    }\n                    if (!target && this.currentPoint) {\n                        const t = this.graph.view.translate;\n                        const s = this.graph.view.scale;\n                        const pt = this.originalPoint != null\n                            ? new Point(this.originalPoint.x / s - t.x, this.originalPoint.y / s - t.y)\n                            : new Point(this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);\n                        pt.x -= this.graph.getPanDx() / this.graph.view.scale;\n                        pt.y -= this.graph.getPanDy() / this.graph.view.scale;\n                        geo.setTerminalPoint(pt, false);\n                    }\n                    this.fireEvent(new EventObject(InternalEvent.CONNECT, 'cell', edge, 'terminal', target, 'event', evt, 'target', dropTarget, 'terminalInserted', terminalInserted));\n                }\n            }\n            catch (e) {\n                MaxLog.show();\n                // MaxLog.debug(e.message);\n            }\n            finally {\n                model.endUpdate();\n            }\n            if (this.select) {\n                this.selectCells(edge, terminalInserted ? target : null);\n            }\n        }\n    }\n    /**\n     * Selects the given edge after adding a new connection. The target argument\n     * contains the target vertex if one has been inserted.\n     */\n    selectCells(edge, target) {\n        this.graph.setSelectionCell(edge);\n    }\n    /**\n     * Creates, inserts and returns the new edge for the given parameters. This\n     * implementation does only use <createEdge> if <factoryMethod> is defined,\n     * otherwise {@link Graph#insertEdge} will be used.\n     */\n    insertEdge(parent, id, value, source, target, style) {\n        if (!this.factoryMethod) {\n            return this.graph.insertEdge(parent, id, value, source, target, style);\n        }\n        let edge = this.createEdge(value, source, target, style);\n        edge = this.graph.addEdge(edge, parent, source, target);\n        return edge;\n    }\n    /**\n     * Hook method for creating new vertices on the fly if no target was\n     * under the mouse. This is only called if <createTarget> is true and\n     * returns null.\n     *\n     * @param evt Mousedown event of the connect gesture.\n     * @param source <Cell> that represents the source terminal.\n     */\n    createTargetVertex(evt, source) {\n        // Uses the first non-relative source\n        let geo = source.getGeometry();\n        while (geo && geo.relative) {\n            source = source.getParent();\n            geo = source.getGeometry();\n        }\n        const clone = this.graph.cloneCell(source);\n        geo = clone.getGeometry();\n        if (geo && this.currentPoint) {\n            const t = this.graph.view.translate;\n            const s = this.graph.view.scale;\n            const point = new Point(this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);\n            geo.x = Math.round(point.x - geo.width / 2 - this.graph.getPanDx() / s);\n            geo.y = Math.round(point.y - geo.height / 2 - this.graph.getPanDy() / s);\n            // Aligns with source if within certain tolerance\n            const tol = this.getAlignmentTolerance();\n            if (tol > 0) {\n                const sourceState = this.graph.view.getState(source);\n                if (sourceState != null) {\n                    const x = sourceState.x / s - t.x;\n                    const y = sourceState.y / s - t.y;\n                    if (Math.abs(x - geo.x) <= tol) {\n                        geo.x = Math.round(x);\n                    }\n                    if (Math.abs(y - geo.y) <= tol) {\n                        geo.y = Math.round(y);\n                    }\n                }\n            }\n        }\n        return clone;\n    }\n    /**\n     * Returns the tolerance for aligning new targets to sources. This returns the grid size / 2.\n     */\n    getAlignmentTolerance(evt) {\n        return this.graph.isGridEnabled()\n            ? this.graph.getGridSize() / 2\n            : this.graph.getSnapTolerance();\n    }\n    /**\n     * Creates and returns a new edge using <factoryMethod> if one exists. If\n     * no factory method is defined, then a new default edge is returned. The\n     * source and target arguments are informal, the actual connection is\n     * setup later by the caller of this function.\n     *\n     * @param value Value to be used for creating the edge.\n     * @param source <Cell> that represents the source terminal.\n     * @param target <Cell> that represents the target terminal.\n     * @param style Optional style from the preview edge.\n     */\n    createEdge(value, source, target, style = {}) {\n        let edge = null;\n        // Creates a new edge using the factoryMethod\n        if (this.factoryMethod != null) {\n            edge = this.factoryMethod(source, target, style);\n        }\n        if (edge == null) {\n            edge = new Cell(value || '');\n            edge.setEdge(true);\n            edge.setStyle(style);\n            const geo = new Geometry();\n            geo.relative = true;\n            edge.setGeometry(geo);\n        }\n        return edge;\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes. This should be\n     * called on all instances. It is called automatically for the built-in\n     * instance created for each {@link Graph}.\n     */\n    onDestroy() {\n        this.graph.removeMouseListener(this);\n        if (this.shape) {\n            this.shape.destroy();\n            this.shape = null;\n        }\n        if (this.marker) {\n            this.marker.destroy();\n            // @ts-expect-error this.marker is null when it is destroyed.\n            this.marker = null;\n        }\n        if (this.constraintHandler) {\n            this.constraintHandler.onDestroy();\n        }\n        if (this.changeHandler) {\n            this.graph.getDataModel().removeListener(this.changeHandler);\n            this.graph.getView().removeListener(this.changeHandler);\n        }\n        if (this.drillHandler) {\n            this.graph.removeListener(this.drillHandler);\n            this.graph.getView().removeListener(this.drillHandler);\n        }\n        if (this.escapeHandler) {\n            this.graph.removeListener(this.escapeHandler);\n        }\n    }\n}\nConnectionHandler.pluginId = 'ConnectionHandler';\nclass ConnectionHandlerCellMarker extends CellMarker {\n    constructor(graph, connectionHandler, validColor = DEFAULT_VALID_COLOR, invalidColor = DEFAULT_INVALID_COLOR, hotspot = DEFAULT_HOTSPOT) {\n        super(graph, validColor, invalidColor, hotspot);\n        this.hotspotEnabled = true;\n        this.connectionHandler = connectionHandler;\n    }\n    // Overrides to return cell at location only if valid (so that\n    // there is no highlight for invalid cells)\n    getCell(me) {\n        let cell = super.getCell(me);\n        this.connectionHandler.error = null;\n        // Checks for cell at preview point (with grid)\n        if (!cell && this.connectionHandler.currentPoint) {\n            cell = this.connectionHandler.graph.getCellAt(this.connectionHandler.currentPoint.x, this.connectionHandler.currentPoint.y);\n        }\n        // Uses connectable parent vertex if one exists\n        if (cell && !cell.isConnectable() && this.connectionHandler.cell) {\n            const parent = this.connectionHandler.cell.getParent();\n            if (parent && parent.isVertex() && parent.isConnectable()) {\n                cell = parent;\n            }\n        }\n        if (cell) {\n            if ((this.connectionHandler.graph.isSwimlane(cell) &&\n                this.connectionHandler.currentPoint != null &&\n                this.connectionHandler.graph.hitsSwimlaneContent(cell, this.connectionHandler.currentPoint.x, this.connectionHandler.currentPoint.y)) ||\n                !this.connectionHandler.isConnectableCell(cell)) {\n                cell = null;\n            }\n        }\n        if (cell) {\n            if (this.connectionHandler.isConnecting()) {\n                if (this.connectionHandler.previous) {\n                    this.connectionHandler.error = this.connectionHandler.validateConnection(this.connectionHandler.previous.cell, cell);\n                    if (this.connectionHandler.error && this.connectionHandler.error.length === 0) {\n                        cell = null;\n                        // Enables create target inside groups\n                        if (this.connectionHandler.isCreateTarget(me.getEvent())) {\n                            this.connectionHandler.error = null;\n                        }\n                    }\n                }\n            }\n            else if (!this.connectionHandler.isValidSource(cell, me)) {\n                cell = null;\n            }\n        }\n        else if (this.connectionHandler.isConnecting() &&\n            !this.connectionHandler.isCreateTarget(me.getEvent()) &&\n            !this.connectionHandler.graph.isAllowDanglingEdges()) {\n            this.connectionHandler.error = '';\n        }\n        return cell;\n    }\n    // Sets the highlight color according to validateConnection\n    isValidState(state) {\n        if (this.connectionHandler.isConnecting()) {\n            return !this.connectionHandler.error;\n        }\n        return super.isValidState(state);\n    }\n    // Overrides to use marker color only in highlight mode or for\n    // target selection\n    getMarkerColor(evt, state, isValid) {\n        return !this.connectionHandler.connectImage || this.connectionHandler.isConnecting()\n            ? super.getMarkerColor(evt, state, isValid)\n            : NONE;\n    }\n    // Overrides to use hotspot only for source selection otherwise\n    // intersects always returns true when over a cell\n    intersects(state, evt) {\n        if (this.connectionHandler.connectImage || this.connectionHandler.isConnecting()) {\n            return true;\n        }\n        return super.intersects(state, evt);\n    }\n}\nexport default ConnectionHandler;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,QAAQ,MAAM,sBAAsB;AAC3C,OAAOC,IAAI,MAAM,cAAc;AAC/B,OAAOC,KAAK,MAAM,mBAAmB;AACrC,OAAOC,WAAW,MAAM,sBAAsB;AAC9C,OAAOC,aAAa,MAAM,wBAAwB;AAClD,SAASC,MAAM,EAAEC,eAAe,EAAEC,qBAAqB,EAAEC,mBAAmB,EAAEC,OAAO,EAAEC,qBAAqB,EAAEC,aAAa,EAAEC,IAAI,EAAEC,uBAAuB,EAAEC,6BAA6B,EAAEC,uBAAuB,EAAEC,WAAW,QAAS,sBAAsB;AAC9P,SAASC,eAAe,EAAEC,SAAS,QAAQ,sBAAsB;AACjE,SAASC,YAAY,EAAEC,SAAS,QAAQ,uBAAuB;AAC/D,OAAOC,kBAAkB,MAAM,6BAA6B;AAC5D,OAAOC,UAAU,MAAM,6BAA6B;AACpD,OAAOC,UAAU,MAAM,oBAAoB;AAC3C,OAAOC,iBAAiB,MAAM,qBAAqB;AACnD,OAAOC,aAAa,MAAM,gCAAgC;AAC1D,OAAOC,WAAW,MAAM,sBAAsB;AAC9C,OAAOC,SAAS,MAAM,uBAAuB;AAC7C,OAAOC,MAAM,MAAM,kBAAkB;AACrC,SAASC,UAAU,EAAEC,UAAU,EAAEC,SAAS,EAAEC,UAAU,EAAEC,WAAW,QAAS,uBAAuB;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,iBAAiB,SAASR,WAAW,CAAC;EACxCS,WAAWA,CAACC,KAAK,EAAwB;IAAA,IAAtBC,aAAa,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;IACnC,KAAK,CAAC,CAAC;IACP,IAAI,CAACG,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACC,SAAS,GAAG,IAAI;IACrB,IAAI,CAACC,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,IAAI,GAAG,IAAI;IAChB,IAAI,CAACC,YAAY,GAAG,IAAI;IACxB,IAAI,CAACC,gBAAgB,GAAG,IAAI;IAC5B,IAAI,CAACC,KAAK,GAAG,IAAI;IACjB,IAAI,CAACC,IAAI,GAAG,IAAI;IAChB,IAAI,CAACC,aAAa,GAAG,IAAI;IACzB,IAAI,CAACC,YAAY,GAAG,IAAI;IACxB,IAAI,CAACC,YAAY,GAAG,IAAI;IACxB,IAAI,CAACC,SAAS,GAAG,EAAE;IACnB;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACf,aAAa,GAAG,IAAI;IACzB;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACgB,aAAa,GAAG,KAAK;IAC1B;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACC,YAAY,GAAG,KAAK;IACzB;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACC,YAAY,GAAG,IAAI;IACxB;AACR;AACA;AACA;IACQ,IAAI,CAACC,kBAAkB,GAAG,KAAK;IAC/B;AACR;AACA;I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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}