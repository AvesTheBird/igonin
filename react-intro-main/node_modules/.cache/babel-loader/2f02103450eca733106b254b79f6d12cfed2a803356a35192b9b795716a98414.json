{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ElementsDragAndDropData } from '../list/listView.js';\nimport { ComposedTreeDelegate } from './abstractTree.js';\nimport { getVisibleState, isFilterResult } from './indexTreeModel.js';\nimport { CompressibleObjectTree, ObjectTree } from './objectTree.js';\nimport { ObjectTreeElementCollapseState, TreeError, WeakMapper } from './tree.js';\nimport { createCancelablePromise, Promises, timeout } from '../../../common/async.js';\nimport { Codicon } from '../../../common/codicons.js';\nimport { ThemeIcon } from '../../../common/themables.js';\nimport { isCancellationError, onUnexpectedError } from '../../../common/errors.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\nimport { DisposableStore, dispose } from '../../../common/lifecycle.js';\nimport { isIterable } from '../../../common/types.js';\nfunction createAsyncDataTreeNode(props) {\n  return {\n    ...props,\n    children: [],\n    refreshPromise: undefined,\n    stale: true,\n    slow: false,\n    forceExpanded: false\n  };\n}\nfunction isAncestor(ancestor, descendant) {\n  if (!descendant.parent) {\n    return false;\n  } else if (descendant.parent === ancestor) {\n    return true;\n  } else {\n    return isAncestor(ancestor, descendant.parent);\n  }\n}\nfunction intersects(node, other) {\n  return node === other || isAncestor(node, other) || isAncestor(other, node);\n}\nclass AsyncDataTreeNodeWrapper {\n  get element() {\n    return this.node.element.element;\n  }\n  get children() {\n    return this.node.children.map(node => new AsyncDataTreeNodeWrapper(node));\n  }\n  get depth() {\n    return this.node.depth;\n  }\n  get visibleChildrenCount() {\n    return this.node.visibleChildrenCount;\n  }\n  get visibleChildIndex() {\n    return this.node.visibleChildIndex;\n  }\n  get collapsible() {\n    return this.node.collapsible;\n  }\n  get collapsed() {\n    return this.node.collapsed;\n  }\n  get visible() {\n    return this.node.visible;\n  }\n  get filterData() {\n    return this.node.filterData;\n  }\n  constructor(node) {\n    this.node = node;\n  }\n}\nclass AsyncDataTreeRenderer {\n  constructor(renderer, nodeMapper, onDidChangeTwistieState) {\n    this.renderer = renderer;\n    this.nodeMapper = nodeMapper;\n    this.onDidChangeTwistieState = onDidChangeTwistieState;\n    this.renderedNodes = new Map();\n    this.templateId = renderer.templateId;\n  }\n  renderTemplate(container) {\n    const templateData = this.renderer.renderTemplate(container);\n    return {\n      templateData\n    };\n  }\n  renderElement(node, index, templateData, height) {\n    this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n  }\n  renderTwistie(element, twistieElement) {\n    if (element.slow) {\n      twistieElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n      return true;\n    } else {\n      twistieElement.classList.remove(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n      return false;\n    }\n  }\n  disposeElement(node, index, templateData, height) {\n    var _this$renderer$dispos, _this$renderer;\n    (_this$renderer$dispos = (_this$renderer = this.renderer).disposeElement) === null || _this$renderer$dispos === void 0 || _this$renderer$dispos.call(_this$renderer, this.nodeMapper.map(node), index, templateData.templateData, height);\n  }\n  disposeTemplate(templateData) {\n    this.renderer.disposeTemplate(templateData.templateData);\n  }\n  dispose() {\n    this.renderedNodes.clear();\n  }\n}\nfunction asTreeEvent(e) {\n  return {\n    browserEvent: e.browserEvent,\n    elements: e.elements.map(e => e.element)\n  };\n}\nfunction asTreeMouseEvent(e) {\n  return {\n    browserEvent: e.browserEvent,\n    element: e.element && e.element.element,\n    target: e.target\n  };\n}\nclass AsyncDataTreeElementsDragAndDropData extends ElementsDragAndDropData {\n  constructor(data) {\n    super(data.elements.map(node => node.element));\n    this.data = data;\n  }\n}\nfunction asAsyncDataTreeDragAndDropData(data) {\n  if (data instanceof ElementsDragAndDropData) {\n    return new AsyncDataTreeElementsDragAndDropData(data);\n  }\n  return data;\n}\nclass AsyncDataTreeNodeListDragAndDrop {\n  constructor(dnd) {\n    this.dnd = dnd;\n  }\n  getDragURI(node) {\n    return this.dnd.getDragURI(node.element);\n  }\n  getDragLabel(nodes, originalEvent) {\n    if (this.dnd.getDragLabel) {\n      return this.dnd.getDragLabel(nodes.map(node => node.element), originalEvent);\n    }\n    return undefined;\n  }\n  onDragStart(data, originalEvent) {\n    var _this$dnd$onDragStart, _this$dnd;\n    (_this$dnd$onDragStart = (_this$dnd = this.dnd).onDragStart) === null || _this$dnd$onDragStart === void 0 || _this$dnd$onDragStart.call(_this$dnd, asAsyncDataTreeDragAndDropData(data), originalEvent);\n  }\n  onDragOver(data, targetNode, targetIndex, targetSector, originalEvent) {\n    let raw = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    return this.dnd.onDragOver(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, targetSector, originalEvent);\n  }\n  drop(data, targetNode, targetIndex, targetSector, originalEvent) {\n    this.dnd.drop(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, targetSector, originalEvent);\n  }\n  onDragEnd(originalEvent) {\n    var _this$dnd$onDragEnd, _this$dnd2;\n    (_this$dnd$onDragEnd = (_this$dnd2 = this.dnd).onDragEnd) === null || _this$dnd$onDragEnd === void 0 || _this$dnd$onDragEnd.call(_this$dnd2, originalEvent);\n  }\n  dispose() {\n    this.dnd.dispose();\n  }\n}\nfunction asObjectTreeOptions(options) {\n  return options && {\n    ...options,\n    collapseByDefault: true,\n    identityProvider: options.identityProvider && {\n      getId(el) {\n        return options.identityProvider.getId(el.element);\n      }\n    },\n    dnd: options.dnd && new AsyncDataTreeNodeListDragAndDrop(options.dnd),\n    multipleSelectionController: options.multipleSelectionController && {\n      isSelectionSingleChangeEvent(e) {\n        return options.multipleSelectionController.isSelectionSingleChangeEvent({\n          ...e,\n          element: e.element\n        });\n      },\n      isSelectionRangeChangeEvent(e) {\n        return options.multipleSelectionController.isSelectionRangeChangeEvent({\n          ...e,\n          element: e.element\n        });\n      }\n    },\n    accessibilityProvider: options.accessibilityProvider && {\n      ...options.accessibilityProvider,\n      getPosInSet: undefined,\n      getSetSize: undefined,\n      getRole: options.accessibilityProvider.getRole ? el => {\n        return options.accessibilityProvider.getRole(el.element);\n      } : () => 'treeitem',\n      isChecked: options.accessibilityProvider.isChecked ? e => {\n        var _options$accessibilit;\n        return !!((_options$accessibilit = options.accessibilityProvider) !== null && _options$accessibilit !== void 0 && _options$accessibilit.isChecked(e.element));\n      } : undefined,\n      getAriaLabel(e) {\n        return options.accessibilityProvider.getAriaLabel(e.element);\n      },\n      getWidgetAriaLabel() {\n        return options.accessibilityProvider.getWidgetAriaLabel();\n      },\n      getWidgetRole: options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => 'tree',\n      getAriaLevel: options.accessibilityProvider.getAriaLevel && (node => {\n        return options.accessibilityProvider.getAriaLevel(node.element);\n      }),\n      getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {\n        return options.accessibilityProvider.getActiveDescendantId(node.element);\n      })\n    },\n    filter: options.filter && {\n      filter(e, parentVisibility) {\n        return options.filter.filter(e.element, parentVisibility);\n      }\n    },\n    keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && {\n      ...options.keyboardNavigationLabelProvider,\n      getKeyboardNavigationLabel(e) {\n        return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);\n      }\n    },\n    sorter: undefined,\n    expandOnlyOnTwistieClick: typeof options.expandOnlyOnTwistieClick === 'undefined' ? undefined : typeof options.expandOnlyOnTwistieClick !== 'function' ? options.expandOnlyOnTwistieClick : e => options.expandOnlyOnTwistieClick(e.element),\n    defaultFindVisibility: e => {\n      if (e.hasChildren && e.stale) {\n        return 1 /* TreeVisibility.Visible */;\n      } else if (typeof options.defaultFindVisibility === 'number') {\n        return options.defaultFindVisibility;\n      } else if (typeof options.defaultFindVisibility === 'undefined') {\n        return 2 /* TreeVisibility.Recurse */;\n      } else {\n        return options.defaultFindVisibility(e.element);\n      }\n    }\n  };\n}\nfunction dfs(node, fn) {\n  fn(node);\n  node.children.forEach(child => dfs(child, fn));\n}\nexport class AsyncDataTree {\n  get onDidScroll() {\n    return this.tree.onDidScroll;\n  }\n  get onDidChangeFocus() {\n    return Event.map(this.tree.onDidChangeFocus, asTreeEvent);\n  }\n  get onDidChangeSelection() {\n    return Event.map(this.tree.onDidChangeSelection, asTreeEvent);\n  }\n  get onMouseDblClick() {\n    return Event.map(this.tree.onMouseDblClick, asTreeMouseEvent);\n  }\n  get onPointer() {\n    return Event.map(this.tree.onPointer, asTreeMouseEvent);\n  }\n  get onDidFocus() {\n    return this.tree.onDidFocus;\n  }\n  /**\n   * To be used internally only!\n   * @deprecated\n   */\n  get onDidChangeModel() {\n    return this.tree.onDidChangeModel;\n  }\n  get onDidChangeCollapseState() {\n    return this.tree.onDidChangeCollapseState;\n  }\n  get onDidChangeFindOpenState() {\n    return this.tree.onDidChangeFindOpenState;\n  }\n  get onDidChangeStickyScrollFocused() {\n    return this.tree.onDidChangeStickyScrollFocused;\n  }\n  get onDidDispose() {\n    return this.tree.onDidDispose;\n  }\n  constructor(user, container, delegate, renderers, dataSource) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    this.user = user;\n    this.dataSource = dataSource;\n    this.nodes = new Map();\n    this.subTreeRefreshPromises = new Map();\n    this.refreshPromises = new Map();\n    this._onDidRender = new Emitter();\n    this._onDidChangeNodeSlowState = new Emitter();\n    this.nodeMapper = new WeakMapper(node => new AsyncDataTreeNodeWrapper(node));\n    this.disposables = new DisposableStore();\n    this.identityProvider = options.identityProvider;\n    this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n    this.sorter = options.sorter;\n    this.getDefaultCollapseState = e => options.collapseByDefault ? options.collapseByDefault(e) ? ObjectTreeElementCollapseState.PreserveOrCollapsed : ObjectTreeElementCollapseState.PreserveOrExpanded : undefined;\n    this.tree = this.createTree(user, container, delegate, renderers, options);\n    this.onDidChangeFindMode = this.tree.onDidChangeFindMode;\n    this.onDidChangeFindMatchType = this.tree.onDidChangeFindMatchType;\n    this.root = createAsyncDataTreeNode({\n      element: undefined,\n      parent: null,\n      hasChildren: true,\n      defaultCollapseState: undefined\n    });\n    if (this.identityProvider) {\n      this.root = {\n        ...this.root,\n        id: null\n      };\n    }\n    this.nodes.set(null, this.root);\n    this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);\n  }\n  createTree(user, container, delegate, renderers, options) {\n    const objectTreeDelegate = new ComposedTreeDelegate(delegate);\n    const objectTreeRenderers = renderers.map(r => new AsyncDataTreeRenderer(r, this.nodeMapper, this._onDidChangeNodeSlowState.event));\n    const objectTreeOptions = asObjectTreeOptions(options) || {};\n    return new ObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n  }\n  updateOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.tree.updateOptions(options);\n  }\n  // Widget\n  getHTMLElement() {\n    return this.tree.getHTMLElement();\n  }\n  get scrollTop() {\n    return this.tree.scrollTop;\n  }\n  set scrollTop(scrollTop) {\n    this.tree.scrollTop = scrollTop;\n  }\n  get scrollHeight() {\n    return this.tree.scrollHeight;\n  }\n  get renderHeight() {\n    return this.tree.renderHeight;\n  }\n  domFocus() {\n    this.tree.domFocus();\n  }\n  layout(height, width) {\n    this.tree.layout(height, width);\n  }\n  style(styles) {\n    this.tree.style(styles);\n  }\n  // Model\n  getInput() {\n    return this.root.element;\n  }\n  async setInput(input, viewState) {\n    this.refreshPromises.forEach(promise => promise.cancel());\n    this.refreshPromises.clear();\n    this.root.element = input;\n    const viewStateContext = viewState && {\n      viewState,\n      focus: [],\n      selection: []\n    };\n    await this._updateChildren(input, true, false, viewStateContext);\n    if (viewStateContext) {\n      this.tree.setFocus(viewStateContext.focus);\n      this.tree.setSelection(viewStateContext.selection);\n    }\n    if (viewState && typeof viewState.scrollTop === 'number') {\n      this.scrollTop = viewState.scrollTop;\n    }\n  }\n  async _updateChildren() {\n    let element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.root.element;\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let rerender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let viewStateContext = arguments.length > 3 ? arguments[3] : undefined;\n    let options = arguments.length > 4 ? arguments[4] : undefined;\n    if (typeof this.root.element === 'undefined') {\n      throw new TreeError(this.user, 'Tree input not set');\n    }\n    if (this.root.refreshPromise) {\n      await this.root.refreshPromise;\n      await Event.toPromise(this._onDidRender.event);\n    }\n    const node = this.getDataNode(element);\n    await this.refreshAndRenderNode(node, recursive, viewStateContext, options);\n    if (rerender) {\n      try {\n        this.tree.rerender(node);\n      } catch {\n        // missing nodes are fine, this could've resulted from\n        // parallel refresh calls, removing `node` altogether\n      }\n    }\n  }\n  // View\n  rerender(element) {\n    if (element === undefined || element === this.root.element) {\n      this.tree.rerender();\n      return;\n    }\n    const node = this.getDataNode(element);\n    this.tree.rerender(node);\n  }\n  // Tree\n  getNode() {\n    let element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.root.element;\n    const dataNode = this.getDataNode(element);\n    const node = this.tree.getNode(dataNode === this.root ? null : dataNode);\n    return this.nodeMapper.map(node);\n  }\n  collapse(element) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const node = this.getDataNode(element);\n    return this.tree.collapse(node === this.root ? null : node, recursive);\n  }\n  async expand(element) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (typeof this.root.element === 'undefined') {\n      throw new TreeError(this.user, 'Tree input not set');\n    }\n    if (this.root.refreshPromise) {\n      await this.root.refreshPromise;\n      await Event.toPromise(this._onDidRender.event);\n    }\n    const node = this.getDataNode(element);\n    if (this.tree.hasElement(node) && !this.tree.isCollapsible(node)) {\n      return false;\n    }\n    if (node.refreshPromise) {\n      await this.root.refreshPromise;\n      await Event.toPromise(this._onDidRender.event);\n    }\n    if (node !== this.root && !node.refreshPromise && !this.tree.isCollapsed(node)) {\n      return false;\n    }\n    const result = this.tree.expand(node === this.root ? null : node, recursive);\n    if (node.refreshPromise) {\n      await this.root.refreshPromise;\n      await Event.toPromise(this._onDidRender.event);\n    }\n    return result;\n  }\n  setSelection(elements, browserEvent) {\n    const nodes = elements.map(e => this.getDataNode(e));\n    this.tree.setSelection(nodes, browserEvent);\n  }\n  getSelection() {\n    const nodes = this.tree.getSelection();\n    return nodes.map(n => n.element);\n  }\n  setFocus(elements, browserEvent) {\n    const nodes = elements.map(e => this.getDataNode(e));\n    this.tree.setFocus(nodes, browserEvent);\n  }\n  getFocus() {\n    const nodes = this.tree.getFocus();\n    return nodes.map(n => n.element);\n  }\n  reveal(element, relativeTop) {\n    this.tree.reveal(this.getDataNode(element), relativeTop);\n  }\n  // Tree navigation\n  getParentElement(element) {\n    const node = this.tree.getParentElement(this.getDataNode(element));\n    return node && node.element;\n  }\n  getFirstElementChild() {\n    let element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.root.element;\n    const dataNode = this.getDataNode(element);\n    const node = this.tree.getFirstElementChild(dataNode === this.root ? null : dataNode);\n    return node && node.element;\n  }\n  // Implementation\n  getDataNode(element) {\n    const node = this.nodes.get(element === this.root.element ? null : element);\n    if (!node) {\n      throw new TreeError(this.user, \"Data tree node not found: \".concat(element));\n    }\n    return node;\n  }\n  async refreshAndRenderNode(node, recursive, viewStateContext, options) {\n    await this.refreshNode(node, recursive, viewStateContext);\n    if (this.disposables.isDisposed) {\n      return; // tree disposed during refresh (#199264)\n    }\n    this.render(node, viewStateContext, options);\n  }\n  async refreshNode(node, recursive, viewStateContext) {\n    let result;\n    this.subTreeRefreshPromises.forEach((refreshPromise, refreshNode) => {\n      if (!result && intersects(refreshNode, node)) {\n        result = refreshPromise.then(() => this.refreshNode(node, recursive, viewStateContext));\n      }\n    });\n    if (result) {\n      return result;\n    }\n    if (node !== this.root) {\n      const treeNode = this.tree.getNode(node);\n      if (treeNode.collapsed) {\n        node.hasChildren = !!this.dataSource.hasChildren(node.element);\n        node.stale = true;\n        this.setChildren(node, [], recursive, viewStateContext);\n        return;\n      }\n    }\n    return this.doRefreshSubTree(node, recursive, viewStateContext);\n  }\n  async doRefreshSubTree(node, recursive, viewStateContext) {\n    let done;\n    node.refreshPromise = new Promise(c => done = c);\n    this.subTreeRefreshPromises.set(node, node.refreshPromise);\n    node.refreshPromise.finally(() => {\n      node.refreshPromise = undefined;\n      this.subTreeRefreshPromises.delete(node);\n    });\n    try {\n      const childrenToRefresh = await this.doRefreshNode(node, recursive, viewStateContext);\n      node.stale = false;\n      await Promises.settled(childrenToRefresh.map(child => this.doRefreshSubTree(child, recursive, viewStateContext)));\n    } finally {\n      done();\n    }\n  }\n  async doRefreshNode(node, recursive, viewStateContext) {\n    node.hasChildren = !!this.dataSource.hasChildren(node.element);\n    let childrenPromise;\n    if (!node.hasChildren) {\n      childrenPromise = Promise.resolve(Iterable.empty());\n    } else {\n      const children = this.doGetChildren(node);\n      if (isIterable(children)) {\n        childrenPromise = Promise.resolve(children);\n      } else {\n        const slowTimeout = timeout(800);\n        slowTimeout.then(() => {\n          node.slow = true;\n          this._onDidChangeNodeSlowState.fire(node);\n        }, _ => null);\n        childrenPromise = children.finally(() => slowTimeout.cancel());\n      }\n    }\n    try {\n      const children = await childrenPromise;\n      return this.setChildren(node, children, recursive, viewStateContext);\n    } catch (err) {\n      if (node !== this.root && this.tree.hasElement(node)) {\n        this.tree.collapse(node);\n      }\n      if (isCancellationError(err)) {\n        return [];\n      }\n      throw err;\n    } finally {\n      if (node.slow) {\n        node.slow = false;\n        this._onDidChangeNodeSlowState.fire(node);\n      }\n    }\n  }\n  doGetChildren(node) {\n    let result = this.refreshPromises.get(node);\n    if (result) {\n      return result;\n    }\n    const children = this.dataSource.getChildren(node.element);\n    if (isIterable(children)) {\n      return this.processChildren(children);\n    } else {\n      result = createCancelablePromise(async () => this.processChildren(await children));\n      this.refreshPromises.set(node, result);\n      return result.finally(() => {\n        this.refreshPromises.delete(node);\n      });\n    }\n  }\n  _onDidChangeCollapseState(_ref) {\n    let {\n      node,\n      deep\n    } = _ref;\n    if (node.element === null) {\n      return;\n    }\n    if (!node.collapsed && node.element.stale) {\n      if (deep) {\n        this.collapse(node.element.element);\n      } else {\n        this.refreshAndRenderNode(node.element, false).catch(onUnexpectedError);\n      }\n    }\n  }\n  setChildren(node, childrenElementsIterable, recursive, viewStateContext) {\n    const childrenElements = [...childrenElementsIterable];\n    // perf: if the node was and still is a leaf, avoid all this hassle\n    if (node.children.length === 0 && childrenElements.length === 0) {\n      return [];\n    }\n    const nodesToForget = new Map();\n    const childrenTreeNodesById = new Map();\n    for (const child of node.children) {\n      nodesToForget.set(child.element, child);\n      if (this.identityProvider) {\n        childrenTreeNodesById.set(child.id, {\n          node: child,\n          collapsed: this.tree.hasElement(child) && this.tree.isCollapsed(child)\n        });\n      }\n    }\n    const childrenToRefresh = [];\n    const children = childrenElements.map(element => {\n      const hasChildren = !!this.dataSource.hasChildren(element);\n      if (!this.identityProvider) {\n        const asyncDataTreeNode = createAsyncDataTreeNode({\n          element,\n          parent: node,\n          hasChildren,\n          defaultCollapseState: this.getDefaultCollapseState(element)\n        });\n        if (hasChildren && asyncDataTreeNode.defaultCollapseState === ObjectTreeElementCollapseState.PreserveOrExpanded) {\n          childrenToRefresh.push(asyncDataTreeNode);\n        }\n        return asyncDataTreeNode;\n      }\n      const id = this.identityProvider.getId(element).toString();\n      const result = childrenTreeNodesById.get(id);\n      if (result) {\n        const asyncDataTreeNode = result.node;\n        nodesToForget.delete(asyncDataTreeNode.element);\n        this.nodes.delete(asyncDataTreeNode.element);\n        this.nodes.set(element, asyncDataTreeNode);\n        asyncDataTreeNode.element = element;\n        asyncDataTreeNode.hasChildren = hasChildren;\n        if (recursive) {\n          if (result.collapsed) {\n            asyncDataTreeNode.children.forEach(node => dfs(node, node => this.nodes.delete(node.element)));\n            asyncDataTreeNode.children.splice(0, asyncDataTreeNode.children.length);\n            asyncDataTreeNode.stale = true;\n          } else {\n            childrenToRefresh.push(asyncDataTreeNode);\n          }\n        } else if (hasChildren && !result.collapsed) {\n          childrenToRefresh.push(asyncDataTreeNode);\n        }\n        return asyncDataTreeNode;\n      }\n      const childAsyncDataTreeNode = createAsyncDataTreeNode({\n        element,\n        parent: node,\n        id,\n        hasChildren,\n        defaultCollapseState: this.getDefaultCollapseState(element)\n      });\n      if (viewStateContext && viewStateContext.viewState.focus && viewStateContext.viewState.focus.indexOf(id) > -1) {\n        viewStateContext.focus.push(childAsyncDataTreeNode);\n      }\n      if (viewStateContext && viewStateContext.viewState.selection && viewStateContext.viewState.selection.indexOf(id) > -1) {\n        viewStateContext.selection.push(childAsyncDataTreeNode);\n      }\n      if (viewStateContext && viewStateContext.viewState.expanded && viewStateContext.viewState.expanded.indexOf(id) > -1) {\n        childrenToRefresh.push(childAsyncDataTreeNode);\n      } else if (hasChildren && childAsyncDataTreeNode.defaultCollapseState === ObjectTreeElementCollapseState.PreserveOrExpanded) {\n        childrenToRefresh.push(childAsyncDataTreeNode);\n      }\n      return childAsyncDataTreeNode;\n    });\n    for (const node of nodesToForget.values()) {\n      dfs(node, node => this.nodes.delete(node.element));\n    }\n    for (const child of children) {\n      this.nodes.set(child.element, child);\n    }\n    node.children.splice(0, node.children.length, ...children);\n    // TODO@joao this doesn't take filter into account\n    if (node !== this.root && this.autoExpandSingleChildren && children.length === 1 && childrenToRefresh.length === 0) {\n      children[0].forceExpanded = true;\n      childrenToRefresh.push(children[0]);\n    }\n    return childrenToRefresh;\n  }\n  render(node, viewStateContext, options) {\n    const children = node.children.map(node => this.asTreeElement(node, viewStateContext));\n    const objectTreeOptions = options && {\n      ...options,\n      diffIdentityProvider: options.diffIdentityProvider && {\n        getId(node) {\n          return options.diffIdentityProvider.getId(node.element);\n        }\n      }\n    };\n    this.tree.setChildren(node === this.root ? null : node, children, objectTreeOptions);\n    if (node !== this.root) {\n      this.tree.setCollapsible(node, node.hasChildren);\n    }\n    this._onDidRender.fire();\n  }\n  asTreeElement(node, viewStateContext) {\n    if (node.stale) {\n      return {\n        element: node,\n        collapsible: node.hasChildren,\n        collapsed: true\n      };\n    }\n    let collapsed;\n    if (viewStateContext && viewStateContext.viewState.expanded && node.id && viewStateContext.viewState.expanded.indexOf(node.id) > -1) {\n      collapsed = false;\n    } else if (node.forceExpanded) {\n      collapsed = false;\n      node.forceExpanded = false;\n    } else {\n      collapsed = node.defaultCollapseState;\n    }\n    return {\n      element: node,\n      children: node.hasChildren ? Iterable.map(node.children, child => this.asTreeElement(child, viewStateContext)) : [],\n      collapsible: node.hasChildren,\n      collapsed\n    };\n  }\n  processChildren(children) {\n    if (this.sorter) {\n      children = [...children].sort(this.sorter.compare.bind(this.sorter));\n    }\n    return children;\n  }\n  dispose() {\n    this.disposables.dispose();\n    this.tree.dispose();\n  }\n}\nclass CompressibleAsyncDataTreeNodeWrapper {\n  get element() {\n    return {\n      elements: this.node.element.elements.map(e => e.element),\n      incompressible: this.node.element.incompressible\n    };\n  }\n  get children() {\n    return this.node.children.map(node => new CompressibleAsyncDataTreeNodeWrapper(node));\n  }\n  get depth() {\n    return this.node.depth;\n  }\n  get visibleChildrenCount() {\n    return this.node.visibleChildrenCount;\n  }\n  get visibleChildIndex() {\n    return this.node.visibleChildIndex;\n  }\n  get collapsible() {\n    return this.node.collapsible;\n  }\n  get collapsed() {\n    return this.node.collapsed;\n  }\n  get visible() {\n    return this.node.visible;\n  }\n  get filterData() {\n    return this.node.filterData;\n  }\n  constructor(node) {\n    this.node = node;\n  }\n}\nclass CompressibleAsyncDataTreeRenderer {\n  constructor(renderer, nodeMapper, compressibleNodeMapperProvider, onDidChangeTwistieState) {\n    this.renderer = renderer;\n    this.nodeMapper = nodeMapper;\n    this.compressibleNodeMapperProvider = compressibleNodeMapperProvider;\n    this.onDidChangeTwistieState = onDidChangeTwistieState;\n    this.renderedNodes = new Map();\n    this.disposables = [];\n    this.templateId = renderer.templateId;\n  }\n  renderTemplate(container) {\n    const templateData = this.renderer.renderTemplate(container);\n    return {\n      templateData\n    };\n  }\n  renderElement(node, index, templateData, height) {\n    this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n  }\n  renderCompressedElements(node, index, templateData, height) {\n    this.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);\n  }\n  renderTwistie(element, twistieElement) {\n    if (element.slow) {\n      twistieElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n      return true;\n    } else {\n      twistieElement.classList.remove(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n      return false;\n    }\n  }\n  disposeElement(node, index, templateData, height) {\n    var _this$renderer$dispos2, _this$renderer2;\n    (_this$renderer$dispos2 = (_this$renderer2 = this.renderer).disposeElement) === null || _this$renderer$dispos2 === void 0 || _this$renderer$dispos2.call(_this$renderer2, this.nodeMapper.map(node), index, templateData.templateData, height);\n  }\n  disposeCompressedElements(node, index, templateData, height) {\n    var _this$renderer$dispos3, _this$renderer3;\n    (_this$renderer$dispos3 = (_this$renderer3 = this.renderer).disposeCompressedElements) === null || _this$renderer$dispos3 === void 0 || _this$renderer$dispos3.call(_this$renderer3, this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);\n  }\n  disposeTemplate(templateData) {\n    this.renderer.disposeTemplate(templateData.templateData);\n  }\n  dispose() {\n    this.renderedNodes.clear();\n    this.disposables = dispose(this.disposables);\n  }\n}\nfunction asCompressibleObjectTreeOptions(options) {\n  const objectTreeOptions = options && asObjectTreeOptions(options);\n  return objectTreeOptions && {\n    ...objectTreeOptions,\n    keyboardNavigationLabelProvider: objectTreeOptions.keyboardNavigationLabelProvider && {\n      ...objectTreeOptions.keyboardNavigationLabelProvider,\n      getCompressedNodeKeyboardNavigationLabel(els) {\n        return options.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(els.map(e => e.element));\n      }\n    }\n  };\n}\nexport class CompressibleAsyncDataTree extends AsyncDataTree {\n  constructor(user, container, virtualDelegate, compressionDelegate, renderers, dataSource) {\n    let options = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n    super(user, container, virtualDelegate, renderers, dataSource, options);\n    this.compressionDelegate = compressionDelegate;\n    this.compressibleNodeMapper = new WeakMapper(node => new CompressibleAsyncDataTreeNodeWrapper(node));\n    this.filter = options.filter;\n  }\n  createTree(user, container, delegate, renderers, options) {\n    const objectTreeDelegate = new ComposedTreeDelegate(delegate);\n    const objectTreeRenderers = renderers.map(r => new CompressibleAsyncDataTreeRenderer(r, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event));\n    const objectTreeOptions = asCompressibleObjectTreeOptions(options) || {};\n    return new CompressibleObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n  }\n  asTreeElement(node, viewStateContext) {\n    return {\n      incompressible: this.compressionDelegate.isIncompressible(node.element),\n      ...super.asTreeElement(node, viewStateContext)\n    };\n  }\n  updateOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.tree.updateOptions(options);\n  }\n  render(node, viewStateContext, options) {\n    if (!this.identityProvider) {\n      return super.render(node, viewStateContext);\n    }\n    // Preserve traits across compressions. Hacky but does the trick.\n    // This is hard to fix properly since it requires rewriting the traits\n    // across trees and lists. Let's just keep it this way for now.\n    const getId = element => this.identityProvider.getId(element).toString();\n    const getUncompressedIds = nodes => {\n      const result = new Set();\n      for (const node of nodes) {\n        const compressedNode = this.tree.getCompressedTreeNode(node === this.root ? null : node);\n        if (!compressedNode.element) {\n          continue;\n        }\n        for (const node of compressedNode.element.elements) {\n          result.add(getId(node.element));\n        }\n      }\n      return result;\n    };\n    const oldSelection = getUncompressedIds(this.tree.getSelection());\n    const oldFocus = getUncompressedIds(this.tree.getFocus());\n    super.render(node, viewStateContext, options);\n    const selection = this.getSelection();\n    let didChangeSelection = false;\n    const focus = this.getFocus();\n    let didChangeFocus = false;\n    const visit = node => {\n      const compressedNode = node.element;\n      if (compressedNode) {\n        for (let i = 0; i < compressedNode.elements.length; i++) {\n          const id = getId(compressedNode.elements[i].element);\n          const element = compressedNode.elements[compressedNode.elements.length - 1].element;\n          // github.com/microsoft/vscode/issues/85938\n          if (oldSelection.has(id) && selection.indexOf(element) === -1) {\n            selection.push(element);\n            didChangeSelection = true;\n          }\n          if (oldFocus.has(id) && focus.indexOf(element) === -1) {\n            focus.push(element);\n            didChangeFocus = true;\n          }\n        }\n      }\n      node.children.forEach(visit);\n    };\n    visit(this.tree.getCompressedTreeNode(node === this.root ? null : node));\n    if (didChangeSelection) {\n      this.setSelection(selection);\n    }\n    if (didChangeFocus) {\n      this.setFocus(focus);\n    }\n  }\n  // For compressed async data trees, `TreeVisibility.Recurse` doesn't currently work\n  // and we have to filter everything beforehand\n  // Related to #85193 and #85835\n  processChildren(children) {\n    if (this.filter) {\n      children = Iterable.filter(children, e => {\n        const result = this.filter.filter(e, 1 /* TreeVisibility.Visible */);\n        const visibility = getVisibility(result);\n        if (visibility === 2 /* TreeVisibility.Recurse */) {\n          throw new Error('Recursive tree visibility not supported in async data compressed trees');\n        }\n        return visibility === 1 /* TreeVisibility.Visible */;\n      });\n    }\n    return super.processChildren(children);\n  }\n}\nfunction getVisibility(filterResult) {\n  if (typeof filterResult === 'boolean') {\n    return filterResult ? 1 /* TreeVisibility.Visible */ : 0 /* TreeVisibility.Hidden */;\n  } else if (isFilterResult(filterResult)) {\n    return getVisibleState(filterResult.visibility);\n  } else {\n    return getVisibleState(filterResult);\n  }\n}","map":{"version":3,"names":["ElementsDragAndDropData","ComposedTreeDelegate","getVisibleState","isFilterResult","CompressibleObjectTree","ObjectTree","ObjectTreeElementCollapseState","TreeError","WeakMapper","createCancelablePromise","Promises","timeout","Codicon","ThemeIcon","isCancellationError","onUnexpectedError","Emitter","Event","Iterable","DisposableStore","dispose","isIterable","createAsyncDataTreeNode","props","children","refreshPromise","undefined","stale","slow","forceExpanded","isAncestor","ancestor","descendant","parent","intersects","node","other","AsyncDataTreeNodeWrapper","element","map","depth","visibleChildrenCount","visibleChildIndex","collapsible","collapsed","visible","filterData","constructor","AsyncDataTreeRenderer","renderer","nodeMapper","onDidChangeTwistieState","renderedNodes","Map","templateId","renderTemplate","container","templateData","renderElement","index","height","renderTwistie","twistieElement","classList","add","asClassNameArray","treeItemLoading","remove","disposeElement","_this$renderer$dispos","_this$renderer","call","disposeTemplate","clear","asTreeEvent","e","browserEvent","elements","asTreeMouseEvent","target","AsyncDataTreeElementsDragAndDropData","data","asAsyncDataTreeDragAndDropData","AsyncDataTreeNodeListDragAndDrop","dnd","getDragURI","getDragLabel","nodes","originalEvent","onDragStart","_this$dnd$onDragStart","_this$dnd","onDragOver","targetNode","targetIndex","targetSector","raw","arguments","length","drop","onDragEnd","_this$dnd$onDragEnd","_this$dnd2","asObjectTreeOptions","options","collapseByDefault","identityProvider","getId","el","multipleSelectionController","isSelectionSingleChangeEvent","isSelectionRangeChangeEvent","accessibilityProvider","getPosInSet","getSetSize","getRole","isChecked","_options$accessibilit","getAriaLabel","getWidgetAriaLabel","getWidgetRole","getAriaLevel","getActiveDescendantId","filter","parentVisibility","keyboardNavigationLabelProvider","getKeyboardNavigationLabel","sorter","expandOnlyOnTwistieClick","defaultFindVisibility","hasChildren","dfs","fn","forEach","child","AsyncDataTree","onDidScroll","tree","onDidChangeFocus","onDidChangeSelection","onMouseDblClick","onPointer","onDidFocus","onDidChangeModel","onDidChangeCollapseState","onDidChangeFindOpenState","onDidChangeStickyScrollFocused","onDidDispose","user","delegate","renderers","dataSource","subTreeRefreshPromises","refreshPromises","_onDidRender","_onDidChangeNodeSlowState","disposables","autoExpandSingleChildren","getDefaultCollapseState","PreserveOrCollapsed","PreserveOrExpanded","createTree","onDidChangeFindMode","onDidChangeFindMatchType","root","defaultCollapseState","id","set","_onDidChangeCollapseState","objectTreeDelegate","objectTreeRenderers","r","event","objectTreeOptions","updateOptions","getHTMLElement","scrollTop","scrollHeight","renderHeight","domFocus","layout","width","style","styles","getInput","setInput","input","viewState","promise","cancel","viewStateContext","focus","selection","_updateChildren","setFocus","setSelection","recursive","rerender","toPromise","getDataNode","refreshAndRenderNode","getNode","dataNode","collapse","expand","hasElement","isCollapsible","isCollapsed","result","getSelection","n","getFocus","reveal","relativeTop","getParentElement","getFirstElementChild","get","concat","refreshNode","isDisposed","render","then","treeNode","setChildren","doRefreshSubTree","done","Promise","c","finally","delete","childrenToRefresh","doRefreshNode","settled","childrenPromise","resolve","empty","doGetChildren","slowTimeout","fire","_","err","getChildren","processChildren","_ref","deep","catch","childrenElementsIterable","childrenElements","nodesToForget","childrenTreeNodesById","asyncDataTreeNode","push","toString","splice","childAsyncDataTreeNode","indexOf","expanded","values","asTreeElement","diffIdentityProvider","setCollapsible","sort","compare","bind","CompressibleAsyncDataTreeNodeWrapper","incompressible","CompressibleAsyncDataTreeRenderer","compressibleNodeMapperProvider","renderCompressedElements","_this$renderer$dispos2","_this$renderer2","disposeCompressedElements","_this$renderer$dispos3","_this$renderer3","asCompressibleObjectTreeOptions","getCompressedNodeKeyboardNavigationLabel","els","CompressibleAsyncDataTree","virtualDelegate","compressionDelegate","compressibleNodeMapper","isIncompressible","getUncompressedIds","Set","compressedNode","getCompressedTreeNode","oldSelection","oldFocus","didChangeSelection","didChangeFocus","visit","i","has","visibility","getVisibility","Error","filterResult"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/base/browser/ui/tree/asyncDataTree.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ElementsDragAndDropData } from '../list/listView.js';\nimport { ComposedTreeDelegate } from './abstractTree.js';\nimport { getVisibleState, isFilterResult } from './indexTreeModel.js';\nimport { CompressibleObjectTree, ObjectTree } from './objectTree.js';\nimport { ObjectTreeElementCollapseState, TreeError, WeakMapper } from './tree.js';\nimport { createCancelablePromise, Promises, timeout } from '../../../common/async.js';\nimport { Codicon } from '../../../common/codicons.js';\nimport { ThemeIcon } from '../../../common/themables.js';\nimport { isCancellationError, onUnexpectedError } from '../../../common/errors.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\nimport { DisposableStore, dispose } from '../../../common/lifecycle.js';\nimport { isIterable } from '../../../common/types.js';\nfunction createAsyncDataTreeNode(props) {\n    return {\n        ...props,\n        children: [],\n        refreshPromise: undefined,\n        stale: true,\n        slow: false,\n        forceExpanded: false\n    };\n}\nfunction isAncestor(ancestor, descendant) {\n    if (!descendant.parent) {\n        return false;\n    }\n    else if (descendant.parent === ancestor) {\n        return true;\n    }\n    else {\n        return isAncestor(ancestor, descendant.parent);\n    }\n}\nfunction intersects(node, other) {\n    return node === other || isAncestor(node, other) || isAncestor(other, node);\n}\nclass AsyncDataTreeNodeWrapper {\n    get element() { return this.node.element.element; }\n    get children() { return this.node.children.map(node => new AsyncDataTreeNodeWrapper(node)); }\n    get depth() { return this.node.depth; }\n    get visibleChildrenCount() { return this.node.visibleChildrenCount; }\n    get visibleChildIndex() { return this.node.visibleChildIndex; }\n    get collapsible() { return this.node.collapsible; }\n    get collapsed() { return this.node.collapsed; }\n    get visible() { return this.node.visible; }\n    get filterData() { return this.node.filterData; }\n    constructor(node) {\n        this.node = node;\n    }\n}\nclass AsyncDataTreeRenderer {\n    constructor(renderer, nodeMapper, onDidChangeTwistieState) {\n        this.renderer = renderer;\n        this.nodeMapper = nodeMapper;\n        this.onDidChangeTwistieState = onDidChangeTwistieState;\n        this.renderedNodes = new Map();\n        this.templateId = renderer.templateId;\n    }\n    renderTemplate(container) {\n        const templateData = this.renderer.renderTemplate(container);\n        return { templateData };\n    }\n    renderElement(node, index, templateData, height) {\n        this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n    }\n    renderTwistie(element, twistieElement) {\n        if (element.slow) {\n            twistieElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n            return true;\n        }\n        else {\n            twistieElement.classList.remove(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n            return false;\n        }\n    }\n    disposeElement(node, index, templateData, height) {\n        this.renderer.disposeElement?.(this.nodeMapper.map(node), index, templateData.templateData, height);\n    }\n    disposeTemplate(templateData) {\n        this.renderer.disposeTemplate(templateData.templateData);\n    }\n    dispose() {\n        this.renderedNodes.clear();\n    }\n}\nfunction asTreeEvent(e) {\n    return {\n        browserEvent: e.browserEvent,\n        elements: e.elements.map(e => e.element)\n    };\n}\nfunction asTreeMouseEvent(e) {\n    return {\n        browserEvent: e.browserEvent,\n        element: e.element && e.element.element,\n        target: e.target\n    };\n}\nclass AsyncDataTreeElementsDragAndDropData extends ElementsDragAndDropData {\n    constructor(data) {\n        super(data.elements.map(node => node.element));\n        this.data = data;\n    }\n}\nfunction asAsyncDataTreeDragAndDropData(data) {\n    if (data instanceof ElementsDragAndDropData) {\n        return new AsyncDataTreeElementsDragAndDropData(data);\n    }\n    return data;\n}\nclass AsyncDataTreeNodeListDragAndDrop {\n    constructor(dnd) {\n        this.dnd = dnd;\n    }\n    getDragURI(node) {\n        return this.dnd.getDragURI(node.element);\n    }\n    getDragLabel(nodes, originalEvent) {\n        if (this.dnd.getDragLabel) {\n            return this.dnd.getDragLabel(nodes.map(node => node.element), originalEvent);\n        }\n        return undefined;\n    }\n    onDragStart(data, originalEvent) {\n        this.dnd.onDragStart?.(asAsyncDataTreeDragAndDropData(data), originalEvent);\n    }\n    onDragOver(data, targetNode, targetIndex, targetSector, originalEvent, raw = true) {\n        return this.dnd.onDragOver(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, targetSector, originalEvent);\n    }\n    drop(data, targetNode, targetIndex, targetSector, originalEvent) {\n        this.dnd.drop(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, targetSector, originalEvent);\n    }\n    onDragEnd(originalEvent) {\n        this.dnd.onDragEnd?.(originalEvent);\n    }\n    dispose() {\n        this.dnd.dispose();\n    }\n}\nfunction asObjectTreeOptions(options) {\n    return options && {\n        ...options,\n        collapseByDefault: true,\n        identityProvider: options.identityProvider && {\n            getId(el) {\n                return options.identityProvider.getId(el.element);\n            }\n        },\n        dnd: options.dnd && new AsyncDataTreeNodeListDragAndDrop(options.dnd),\n        multipleSelectionController: options.multipleSelectionController && {\n            isSelectionSingleChangeEvent(e) {\n                return options.multipleSelectionController.isSelectionSingleChangeEvent({ ...e, element: e.element });\n            },\n            isSelectionRangeChangeEvent(e) {\n                return options.multipleSelectionController.isSelectionRangeChangeEvent({ ...e, element: e.element });\n            }\n        },\n        accessibilityProvider: options.accessibilityProvider && {\n            ...options.accessibilityProvider,\n            getPosInSet: undefined,\n            getSetSize: undefined,\n            getRole: options.accessibilityProvider.getRole ? (el) => {\n                return options.accessibilityProvider.getRole(el.element);\n            } : () => 'treeitem',\n            isChecked: options.accessibilityProvider.isChecked ? (e) => {\n                return !!(options.accessibilityProvider?.isChecked(e.element));\n            } : undefined,\n            getAriaLabel(e) {\n                return options.accessibilityProvider.getAriaLabel(e.element);\n            },\n            getWidgetAriaLabel() {\n                return options.accessibilityProvider.getWidgetAriaLabel();\n            },\n            getWidgetRole: options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => 'tree',\n            getAriaLevel: options.accessibilityProvider.getAriaLevel && (node => {\n                return options.accessibilityProvider.getAriaLevel(node.element);\n            }),\n            getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {\n                return options.accessibilityProvider.getActiveDescendantId(node.element);\n            })\n        },\n        filter: options.filter && {\n            filter(e, parentVisibility) {\n                return options.filter.filter(e.element, parentVisibility);\n            }\n        },\n        keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && {\n            ...options.keyboardNavigationLabelProvider,\n            getKeyboardNavigationLabel(e) {\n                return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);\n            }\n        },\n        sorter: undefined,\n        expandOnlyOnTwistieClick: typeof options.expandOnlyOnTwistieClick === 'undefined' ? undefined : (typeof options.expandOnlyOnTwistieClick !== 'function' ? options.expandOnlyOnTwistieClick : (e => options.expandOnlyOnTwistieClick(e.element))),\n        defaultFindVisibility: e => {\n            if (e.hasChildren && e.stale) {\n                return 1 /* TreeVisibility.Visible */;\n            }\n            else if (typeof options.defaultFindVisibility === 'number') {\n                return options.defaultFindVisibility;\n            }\n            else if (typeof options.defaultFindVisibility === 'undefined') {\n                return 2 /* TreeVisibility.Recurse */;\n            }\n            else {\n                return options.defaultFindVisibility(e.element);\n            }\n        }\n    };\n}\nfunction dfs(node, fn) {\n    fn(node);\n    node.children.forEach(child => dfs(child, fn));\n}\nexport class AsyncDataTree {\n    get onDidScroll() { return this.tree.onDidScroll; }\n    get onDidChangeFocus() { return Event.map(this.tree.onDidChangeFocus, asTreeEvent); }\n    get onDidChangeSelection() { return Event.map(this.tree.onDidChangeSelection, asTreeEvent); }\n    get onMouseDblClick() { return Event.map(this.tree.onMouseDblClick, asTreeMouseEvent); }\n    get onPointer() { return Event.map(this.tree.onPointer, asTreeMouseEvent); }\n    get onDidFocus() { return this.tree.onDidFocus; }\n    /**\n     * To be used internally only!\n     * @deprecated\n     */\n    get onDidChangeModel() { return this.tree.onDidChangeModel; }\n    get onDidChangeCollapseState() { return this.tree.onDidChangeCollapseState; }\n    get onDidChangeFindOpenState() { return this.tree.onDidChangeFindOpenState; }\n    get onDidChangeStickyScrollFocused() { return this.tree.onDidChangeStickyScrollFocused; }\n    get onDidDispose() { return this.tree.onDidDispose; }\n    constructor(user, container, delegate, renderers, dataSource, options = {}) {\n        this.user = user;\n        this.dataSource = dataSource;\n        this.nodes = new Map();\n        this.subTreeRefreshPromises = new Map();\n        this.refreshPromises = new Map();\n        this._onDidRender = new Emitter();\n        this._onDidChangeNodeSlowState = new Emitter();\n        this.nodeMapper = new WeakMapper(node => new AsyncDataTreeNodeWrapper(node));\n        this.disposables = new DisposableStore();\n        this.identityProvider = options.identityProvider;\n        this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n        this.sorter = options.sorter;\n        this.getDefaultCollapseState = e => options.collapseByDefault ? (options.collapseByDefault(e) ? ObjectTreeElementCollapseState.PreserveOrCollapsed : ObjectTreeElementCollapseState.PreserveOrExpanded) : undefined;\n        this.tree = this.createTree(user, container, delegate, renderers, options);\n        this.onDidChangeFindMode = this.tree.onDidChangeFindMode;\n        this.onDidChangeFindMatchType = this.tree.onDidChangeFindMatchType;\n        this.root = createAsyncDataTreeNode({\n            element: undefined,\n            parent: null,\n            hasChildren: true,\n            defaultCollapseState: undefined\n        });\n        if (this.identityProvider) {\n            this.root = {\n                ...this.root,\n                id: null\n            };\n        }\n        this.nodes.set(null, this.root);\n        this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);\n    }\n    createTree(user, container, delegate, renderers, options) {\n        const objectTreeDelegate = new ComposedTreeDelegate(delegate);\n        const objectTreeRenderers = renderers.map(r => new AsyncDataTreeRenderer(r, this.nodeMapper, this._onDidChangeNodeSlowState.event));\n        const objectTreeOptions = asObjectTreeOptions(options) || {};\n        return new ObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n    }\n    updateOptions(options = {}) {\n        this.tree.updateOptions(options);\n    }\n    // Widget\n    getHTMLElement() {\n        return this.tree.getHTMLElement();\n    }\n    get scrollTop() {\n        return this.tree.scrollTop;\n    }\n    set scrollTop(scrollTop) {\n        this.tree.scrollTop = scrollTop;\n    }\n    get scrollHeight() {\n        return this.tree.scrollHeight;\n    }\n    get renderHeight() {\n        return this.tree.renderHeight;\n    }\n    domFocus() {\n        this.tree.domFocus();\n    }\n    layout(height, width) {\n        this.tree.layout(height, width);\n    }\n    style(styles) {\n        this.tree.style(styles);\n    }\n    // Model\n    getInput() {\n        return this.root.element;\n    }\n    async setInput(input, viewState) {\n        this.refreshPromises.forEach(promise => promise.cancel());\n        this.refreshPromises.clear();\n        this.root.element = input;\n        const viewStateContext = viewState && { viewState, focus: [], selection: [] };\n        await this._updateChildren(input, true, false, viewStateContext);\n        if (viewStateContext) {\n            this.tree.setFocus(viewStateContext.focus);\n            this.tree.setSelection(viewStateContext.selection);\n        }\n        if (viewState && typeof viewState.scrollTop === 'number') {\n            this.scrollTop = viewState.scrollTop;\n        }\n    }\n    async _updateChildren(element = this.root.element, recursive = true, rerender = false, viewStateContext, options) {\n        if (typeof this.root.element === 'undefined') {\n            throw new TreeError(this.user, 'Tree input not set');\n        }\n        if (this.root.refreshPromise) {\n            await this.root.refreshPromise;\n            await Event.toPromise(this._onDidRender.event);\n        }\n        const node = this.getDataNode(element);\n        await this.refreshAndRenderNode(node, recursive, viewStateContext, options);\n        if (rerender) {\n            try {\n                this.tree.rerender(node);\n            }\n            catch {\n                // missing nodes are fine, this could've resulted from\n                // parallel refresh calls, removing `node` altogether\n            }\n        }\n    }\n    // View\n    rerender(element) {\n        if (element === undefined || element === this.root.element) {\n            this.tree.rerender();\n            return;\n        }\n        const node = this.getDataNode(element);\n        this.tree.rerender(node);\n    }\n    // Tree\n    getNode(element = this.root.element) {\n        const dataNode = this.getDataNode(element);\n        const node = this.tree.getNode(dataNode === this.root ? null : dataNode);\n        return this.nodeMapper.map(node);\n    }\n    collapse(element, recursive = false) {\n        const node = this.getDataNode(element);\n        return this.tree.collapse(node === this.root ? null : node, recursive);\n    }\n    async expand(element, recursive = false) {\n        if (typeof this.root.element === 'undefined') {\n            throw new TreeError(this.user, 'Tree input not set');\n        }\n        if (this.root.refreshPromise) {\n            await this.root.refreshPromise;\n            await Event.toPromise(this._onDidRender.event);\n        }\n        const node = this.getDataNode(element);\n        if (this.tree.hasElement(node) && !this.tree.isCollapsible(node)) {\n            return false;\n        }\n        if (node.refreshPromise) {\n            await this.root.refreshPromise;\n            await Event.toPromise(this._onDidRender.event);\n        }\n        if (node !== this.root && !node.refreshPromise && !this.tree.isCollapsed(node)) {\n            return false;\n        }\n        const result = this.tree.expand(node === this.root ? null : node, recursive);\n        if (node.refreshPromise) {\n            await this.root.refreshPromise;\n            await Event.toPromise(this._onDidRender.event);\n        }\n        return result;\n    }\n    setSelection(elements, browserEvent) {\n        const nodes = elements.map(e => this.getDataNode(e));\n        this.tree.setSelection(nodes, browserEvent);\n    }\n    getSelection() {\n        const nodes = this.tree.getSelection();\n        return nodes.map(n => n.element);\n    }\n    setFocus(elements, browserEvent) {\n        const nodes = elements.map(e => this.getDataNode(e));\n        this.tree.setFocus(nodes, browserEvent);\n    }\n    getFocus() {\n        const nodes = this.tree.getFocus();\n        return nodes.map(n => n.element);\n    }\n    reveal(element, relativeTop) {\n        this.tree.reveal(this.getDataNode(element), relativeTop);\n    }\n    // Tree navigation\n    getParentElement(element) {\n        const node = this.tree.getParentElement(this.getDataNode(element));\n        return (node && node.element);\n    }\n    getFirstElementChild(element = this.root.element) {\n        const dataNode = this.getDataNode(element);\n        const node = this.tree.getFirstElementChild(dataNode === this.root ? null : dataNode);\n        return (node && node.element);\n    }\n    // Implementation\n    getDataNode(element) {\n        const node = this.nodes.get((element === this.root.element ? null : element));\n        if (!node) {\n            throw new TreeError(this.user, `Data tree node not found: ${element}`);\n        }\n        return node;\n    }\n    async refreshAndRenderNode(node, recursive, viewStateContext, options) {\n        await this.refreshNode(node, recursive, viewStateContext);\n        if (this.disposables.isDisposed) {\n            return; // tree disposed during refresh (#199264)\n        }\n        this.render(node, viewStateContext, options);\n    }\n    async refreshNode(node, recursive, viewStateContext) {\n        let result;\n        this.subTreeRefreshPromises.forEach((refreshPromise, refreshNode) => {\n            if (!result && intersects(refreshNode, node)) {\n                result = refreshPromise.then(() => this.refreshNode(node, recursive, viewStateContext));\n            }\n        });\n        if (result) {\n            return result;\n        }\n        if (node !== this.root) {\n            const treeNode = this.tree.getNode(node);\n            if (treeNode.collapsed) {\n                node.hasChildren = !!this.dataSource.hasChildren(node.element);\n                node.stale = true;\n                this.setChildren(node, [], recursive, viewStateContext);\n                return;\n            }\n        }\n        return this.doRefreshSubTree(node, recursive, viewStateContext);\n    }\n    async doRefreshSubTree(node, recursive, viewStateContext) {\n        let done;\n        node.refreshPromise = new Promise(c => done = c);\n        this.subTreeRefreshPromises.set(node, node.refreshPromise);\n        node.refreshPromise.finally(() => {\n            node.refreshPromise = undefined;\n            this.subTreeRefreshPromises.delete(node);\n        });\n        try {\n            const childrenToRefresh = await this.doRefreshNode(node, recursive, viewStateContext);\n            node.stale = false;\n            await Promises.settled(childrenToRefresh.map(child => this.doRefreshSubTree(child, recursive, viewStateContext)));\n        }\n        finally {\n            done();\n        }\n    }\n    async doRefreshNode(node, recursive, viewStateContext) {\n        node.hasChildren = !!this.dataSource.hasChildren(node.element);\n        let childrenPromise;\n        if (!node.hasChildren) {\n            childrenPromise = Promise.resolve(Iterable.empty());\n        }\n        else {\n            const children = this.doGetChildren(node);\n            if (isIterable(children)) {\n                childrenPromise = Promise.resolve(children);\n            }\n            else {\n                const slowTimeout = timeout(800);\n                slowTimeout.then(() => {\n                    node.slow = true;\n                    this._onDidChangeNodeSlowState.fire(node);\n                }, _ => null);\n                childrenPromise = children.finally(() => slowTimeout.cancel());\n            }\n        }\n        try {\n            const children = await childrenPromise;\n            return this.setChildren(node, children, recursive, viewStateContext);\n        }\n        catch (err) {\n            if (node !== this.root && this.tree.hasElement(node)) {\n                this.tree.collapse(node);\n            }\n            if (isCancellationError(err)) {\n                return [];\n            }\n            throw err;\n        }\n        finally {\n            if (node.slow) {\n                node.slow = false;\n                this._onDidChangeNodeSlowState.fire(node);\n            }\n        }\n    }\n    doGetChildren(node) {\n        let result = this.refreshPromises.get(node);\n        if (result) {\n            return result;\n        }\n        const children = this.dataSource.getChildren(node.element);\n        if (isIterable(children)) {\n            return this.processChildren(children);\n        }\n        else {\n            result = createCancelablePromise(async () => this.processChildren(await children));\n            this.refreshPromises.set(node, result);\n            return result.finally(() => { this.refreshPromises.delete(node); });\n        }\n    }\n    _onDidChangeCollapseState({ node, deep }) {\n        if (node.element === null) {\n            return;\n        }\n        if (!node.collapsed && node.element.stale) {\n            if (deep) {\n                this.collapse(node.element.element);\n            }\n            else {\n                this.refreshAndRenderNode(node.element, false)\n                    .catch(onUnexpectedError);\n            }\n        }\n    }\n    setChildren(node, childrenElementsIterable, recursive, viewStateContext) {\n        const childrenElements = [...childrenElementsIterable];\n        // perf: if the node was and still is a leaf, avoid all this hassle\n        if (node.children.length === 0 && childrenElements.length === 0) {\n            return [];\n        }\n        const nodesToForget = new Map();\n        const childrenTreeNodesById = new Map();\n        for (const child of node.children) {\n            nodesToForget.set(child.element, child);\n            if (this.identityProvider) {\n                childrenTreeNodesById.set(child.id, { node: child, collapsed: this.tree.hasElement(child) && this.tree.isCollapsed(child) });\n            }\n        }\n        const childrenToRefresh = [];\n        const children = childrenElements.map(element => {\n            const hasChildren = !!this.dataSource.hasChildren(element);\n            if (!this.identityProvider) {\n                const asyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, hasChildren, defaultCollapseState: this.getDefaultCollapseState(element) });\n                if (hasChildren && asyncDataTreeNode.defaultCollapseState === ObjectTreeElementCollapseState.PreserveOrExpanded) {\n                    childrenToRefresh.push(asyncDataTreeNode);\n                }\n                return asyncDataTreeNode;\n            }\n            const id = this.identityProvider.getId(element).toString();\n            const result = childrenTreeNodesById.get(id);\n            if (result) {\n                const asyncDataTreeNode = result.node;\n                nodesToForget.delete(asyncDataTreeNode.element);\n                this.nodes.delete(asyncDataTreeNode.element);\n                this.nodes.set(element, asyncDataTreeNode);\n                asyncDataTreeNode.element = element;\n                asyncDataTreeNode.hasChildren = hasChildren;\n                if (recursive) {\n                    if (result.collapsed) {\n                        asyncDataTreeNode.children.forEach(node => dfs(node, node => this.nodes.delete(node.element)));\n                        asyncDataTreeNode.children.splice(0, asyncDataTreeNode.children.length);\n                        asyncDataTreeNode.stale = true;\n                    }\n                    else {\n                        childrenToRefresh.push(asyncDataTreeNode);\n                    }\n                }\n                else if (hasChildren && !result.collapsed) {\n                    childrenToRefresh.push(asyncDataTreeNode);\n                }\n                return asyncDataTreeNode;\n            }\n            const childAsyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, id, hasChildren, defaultCollapseState: this.getDefaultCollapseState(element) });\n            if (viewStateContext && viewStateContext.viewState.focus && viewStateContext.viewState.focus.indexOf(id) > -1) {\n                viewStateContext.focus.push(childAsyncDataTreeNode);\n            }\n            if (viewStateContext && viewStateContext.viewState.selection && viewStateContext.viewState.selection.indexOf(id) > -1) {\n                viewStateContext.selection.push(childAsyncDataTreeNode);\n            }\n            if (viewStateContext && viewStateContext.viewState.expanded && viewStateContext.viewState.expanded.indexOf(id) > -1) {\n                childrenToRefresh.push(childAsyncDataTreeNode);\n            }\n            else if (hasChildren && childAsyncDataTreeNode.defaultCollapseState === ObjectTreeElementCollapseState.PreserveOrExpanded) {\n                childrenToRefresh.push(childAsyncDataTreeNode);\n            }\n            return childAsyncDataTreeNode;\n        });\n        for (const node of nodesToForget.values()) {\n            dfs(node, node => this.nodes.delete(node.element));\n        }\n        for (const child of children) {\n            this.nodes.set(child.element, child);\n        }\n        node.children.splice(0, node.children.length, ...children);\n        // TODO@joao this doesn't take filter into account\n        if (node !== this.root && this.autoExpandSingleChildren && children.length === 1 && childrenToRefresh.length === 0) {\n            children[0].forceExpanded = true;\n            childrenToRefresh.push(children[0]);\n        }\n        return childrenToRefresh;\n    }\n    render(node, viewStateContext, options) {\n        const children = node.children.map(node => this.asTreeElement(node, viewStateContext));\n        const objectTreeOptions = options && {\n            ...options,\n            diffIdentityProvider: options.diffIdentityProvider && {\n                getId(node) {\n                    return options.diffIdentityProvider.getId(node.element);\n                }\n            }\n        };\n        this.tree.setChildren(node === this.root ? null : node, children, objectTreeOptions);\n        if (node !== this.root) {\n            this.tree.setCollapsible(node, node.hasChildren);\n        }\n        this._onDidRender.fire();\n    }\n    asTreeElement(node, viewStateContext) {\n        if (node.stale) {\n            return {\n                element: node,\n                collapsible: node.hasChildren,\n                collapsed: true\n            };\n        }\n        let collapsed;\n        if (viewStateContext && viewStateContext.viewState.expanded && node.id && viewStateContext.viewState.expanded.indexOf(node.id) > -1) {\n            collapsed = false;\n        }\n        else if (node.forceExpanded) {\n            collapsed = false;\n            node.forceExpanded = false;\n        }\n        else {\n            collapsed = node.defaultCollapseState;\n        }\n        return {\n            element: node,\n            children: node.hasChildren ? Iterable.map(node.children, child => this.asTreeElement(child, viewStateContext)) : [],\n            collapsible: node.hasChildren,\n            collapsed\n        };\n    }\n    processChildren(children) {\n        if (this.sorter) {\n            children = [...children].sort(this.sorter.compare.bind(this.sorter));\n        }\n        return children;\n    }\n    dispose() {\n        this.disposables.dispose();\n        this.tree.dispose();\n    }\n}\nclass CompressibleAsyncDataTreeNodeWrapper {\n    get element() {\n        return {\n            elements: this.node.element.elements.map(e => e.element),\n            incompressible: this.node.element.incompressible\n        };\n    }\n    get children() { return this.node.children.map(node => new CompressibleAsyncDataTreeNodeWrapper(node)); }\n    get depth() { return this.node.depth; }\n    get visibleChildrenCount() { return this.node.visibleChildrenCount; }\n    get visibleChildIndex() { return this.node.visibleChildIndex; }\n    get collapsible() { return this.node.collapsible; }\n    get collapsed() { return this.node.collapsed; }\n    get visible() { return this.node.visible; }\n    get filterData() { return this.node.filterData; }\n    constructor(node) {\n        this.node = node;\n    }\n}\nclass CompressibleAsyncDataTreeRenderer {\n    constructor(renderer, nodeMapper, compressibleNodeMapperProvider, onDidChangeTwistieState) {\n        this.renderer = renderer;\n        this.nodeMapper = nodeMapper;\n        this.compressibleNodeMapperProvider = compressibleNodeMapperProvider;\n        this.onDidChangeTwistieState = onDidChangeTwistieState;\n        this.renderedNodes = new Map();\n        this.disposables = [];\n        this.templateId = renderer.templateId;\n    }\n    renderTemplate(container) {\n        const templateData = this.renderer.renderTemplate(container);\n        return { templateData };\n    }\n    renderElement(node, index, templateData, height) {\n        this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n    }\n    renderCompressedElements(node, index, templateData, height) {\n        this.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);\n    }\n    renderTwistie(element, twistieElement) {\n        if (element.slow) {\n            twistieElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n            return true;\n        }\n        else {\n            twistieElement.classList.remove(...ThemeIcon.asClassNameArray(Codicon.treeItemLoading));\n            return false;\n        }\n    }\n    disposeElement(node, index, templateData, height) {\n        this.renderer.disposeElement?.(this.nodeMapper.map(node), index, templateData.templateData, height);\n    }\n    disposeCompressedElements(node, index, templateData, height) {\n        this.renderer.disposeCompressedElements?.(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);\n    }\n    disposeTemplate(templateData) {\n        this.renderer.disposeTemplate(templateData.templateData);\n    }\n    dispose() {\n        this.renderedNodes.clear();\n        this.disposables = dispose(this.disposables);\n    }\n}\nfunction asCompressibleObjectTreeOptions(options) {\n    const objectTreeOptions = options && asObjectTreeOptions(options);\n    return objectTreeOptions && {\n        ...objectTreeOptions,\n        keyboardNavigationLabelProvider: objectTreeOptions.keyboardNavigationLabelProvider && {\n            ...objectTreeOptions.keyboardNavigationLabelProvider,\n            getCompressedNodeKeyboardNavigationLabel(els) {\n                return options.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(els.map(e => e.element));\n            }\n        }\n    };\n}\nexport class CompressibleAsyncDataTree extends AsyncDataTree {\n    constructor(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, options = {}) {\n        super(user, container, virtualDelegate, renderers, dataSource, options);\n        this.compressionDelegate = compressionDelegate;\n        this.compressibleNodeMapper = new WeakMapper(node => new CompressibleAsyncDataTreeNodeWrapper(node));\n        this.filter = options.filter;\n    }\n    createTree(user, container, delegate, renderers, options) {\n        const objectTreeDelegate = new ComposedTreeDelegate(delegate);\n        const objectTreeRenderers = renderers.map(r => new CompressibleAsyncDataTreeRenderer(r, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event));\n        const objectTreeOptions = asCompressibleObjectTreeOptions(options) || {};\n        return new CompressibleObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n    }\n    asTreeElement(node, viewStateContext) {\n        return {\n            incompressible: this.compressionDelegate.isIncompressible(node.element),\n            ...super.asTreeElement(node, viewStateContext)\n        };\n    }\n    updateOptions(options = {}) {\n        this.tree.updateOptions(options);\n    }\n    render(node, viewStateContext, options) {\n        if (!this.identityProvider) {\n            return super.render(node, viewStateContext);\n        }\n        // Preserve traits across compressions. Hacky but does the trick.\n        // This is hard to fix properly since it requires rewriting the traits\n        // across trees and lists. Let's just keep it this way for now.\n        const getId = (element) => this.identityProvider.getId(element).toString();\n        const getUncompressedIds = (nodes) => {\n            const result = new Set();\n            for (const node of nodes) {\n                const compressedNode = this.tree.getCompressedTreeNode(node === this.root ? null : node);\n                if (!compressedNode.element) {\n                    continue;\n                }\n                for (const node of compressedNode.element.elements) {\n                    result.add(getId(node.element));\n                }\n            }\n            return result;\n        };\n        const oldSelection = getUncompressedIds(this.tree.getSelection());\n        const oldFocus = getUncompressedIds(this.tree.getFocus());\n        super.render(node, viewStateContext, options);\n        const selection = this.getSelection();\n        let didChangeSelection = false;\n        const focus = this.getFocus();\n        let didChangeFocus = false;\n        const visit = (node) => {\n            const compressedNode = node.element;\n            if (compressedNode) {\n                for (let i = 0; i < compressedNode.elements.length; i++) {\n                    const id = getId(compressedNode.elements[i].element);\n                    const element = compressedNode.elements[compressedNode.elements.length - 1].element;\n                    // github.com/microsoft/vscode/issues/85938\n                    if (oldSelection.has(id) && selection.indexOf(element) === -1) {\n                        selection.push(element);\n                        didChangeSelection = true;\n                    }\n                    if (oldFocus.has(id) && focus.indexOf(element) === -1) {\n                        focus.push(element);\n                        didChangeFocus = true;\n                    }\n                }\n            }\n            node.children.forEach(visit);\n        };\n        visit(this.tree.getCompressedTreeNode(node === this.root ? null : node));\n        if (didChangeSelection) {\n            this.setSelection(selection);\n        }\n        if (didChangeFocus) {\n            this.setFocus(focus);\n        }\n    }\n    // For compressed async data trees, `TreeVisibility.Recurse` doesn't currently work\n    // and we have to filter everything beforehand\n    // Related to #85193 and #85835\n    processChildren(children) {\n        if (this.filter) {\n            children = Iterable.filter(children, e => {\n                const result = this.filter.filter(e, 1 /* TreeVisibility.Visible */);\n                const visibility = getVisibility(result);\n                if (visibility === 2 /* TreeVisibility.Recurse */) {\n                    throw new Error('Recursive tree visibility not supported in async data compressed trees');\n                }\n                return visibility === 1 /* TreeVisibility.Visible */;\n            });\n        }\n        return super.processChildren(children);\n    }\n}\nfunction getVisibility(filterResult) {\n    if (typeof filterResult === 'boolean') {\n        return filterResult ? 1 /* TreeVisibility.Visible */ : 0 /* TreeVisibility.Hidden */;\n    }\n    else if (isFilterResult(filterResult)) {\n        return getVisibleState(filterResult.visibility);\n    }\n    else {\n        return getVisibleState(filterResult);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}