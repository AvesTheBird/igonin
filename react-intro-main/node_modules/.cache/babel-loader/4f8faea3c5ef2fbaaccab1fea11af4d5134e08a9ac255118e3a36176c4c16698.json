{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nimport './textAreaHandler.css';\nimport * as nls from '../../../nls.js';\nimport * as browser from '../../../base/browser/browser.js';\nimport { createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { applyFontInfo } from '../config/domFontInfo.js';\nimport { CopyOptions, TextAreaInput, TextAreaWrapper } from './textAreaInput.js';\nimport { PagedScreenReaderStrategy, TextAreaState, _debugComposition } from './textAreaState.js';\nimport { PartFingerprints, ViewPart } from '../view/viewPart.js';\nimport { LineNumbersOverlay } from '../viewParts/lineNumbers/lineNumbers.js';\nimport { Margin } from '../viewParts/margin/margin.js';\nimport { EditorOptions } from '../../common/config/editorOptions.js';\nimport { getMapForWordSeparators } from '../../common/core/wordCharacterClassifier.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { MOUSE_CURSOR_TEXT_CSS_CLASS_NAME } from '../../../base/browser/ui/mouseCursor/mouseCursor.js';\nimport { TokenizationRegistry } from '../../common/languages.js';\nimport { Color } from '../../../base/common/color.js';\nimport { IME } from '../../../base/common/ime.js';\nimport { IKeybindingService } from '../../../platform/keybinding/common/keybinding.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nclass VisibleTextAreaData {\n  constructor(_context, modelLineNumber, distanceToModelLineStart, widthOfHiddenLineTextBefore, distanceToModelLineEnd) {\n    this._context = _context;\n    this.modelLineNumber = modelLineNumber;\n    this.distanceToModelLineStart = distanceToModelLineStart;\n    this.widthOfHiddenLineTextBefore = widthOfHiddenLineTextBefore;\n    this.distanceToModelLineEnd = distanceToModelLineEnd;\n    this._visibleTextAreaBrand = undefined;\n    this.startPosition = null;\n    this.endPosition = null;\n    this.visibleTextareaStart = null;\n    this.visibleTextareaEnd = null;\n    /**\n     * When doing composition, the currently composed text might be split up into\n     * multiple tokens, then merged again into a single token, etc. Here we attempt\n     * to keep the presentation of the <textarea> stable by using the previous used\n     * style if multiple tokens come into play. This avoids flickering.\n     */\n    this._previousPresentation = null;\n  }\n  prepareRender(visibleRangeProvider) {\n    const startModelPosition = new Position(this.modelLineNumber, this.distanceToModelLineStart + 1);\n    const endModelPosition = new Position(this.modelLineNumber, this._context.viewModel.model.getLineMaxColumn(this.modelLineNumber) - this.distanceToModelLineEnd);\n    this.startPosition = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(startModelPosition);\n    this.endPosition = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(endModelPosition);\n    if (this.startPosition.lineNumber === this.endPosition.lineNumber) {\n      this.visibleTextareaStart = visibleRangeProvider.visibleRangeForPosition(this.startPosition);\n      this.visibleTextareaEnd = visibleRangeProvider.visibleRangeForPosition(this.endPosition);\n    } else {\n      // TODO: what if the view positions are not on the same line?\n      this.visibleTextareaStart = null;\n      this.visibleTextareaEnd = null;\n    }\n  }\n  definePresentation(tokenPresentation) {\n    if (!this._previousPresentation) {\n      // To avoid flickering, once set, always reuse a presentation throughout the entire IME session\n      if (tokenPresentation) {\n        this._previousPresentation = tokenPresentation;\n      } else {\n        this._previousPresentation = {\n          foreground: 1 /* ColorId.DefaultForeground */,\n          italic: false,\n          bold: false,\n          underline: false,\n          strikethrough: false\n        };\n      }\n    }\n    return this._previousPresentation;\n  }\n}\nconst canUseZeroSizeTextarea = browser.isFirefox;\nlet TextAreaHandler = class TextAreaHandler extends ViewPart {\n  constructor(context, viewController, visibleRangeProvider, _keybindingService, _instantiationService) {\n    super(context);\n    this._keybindingService = _keybindingService;\n    this._instantiationService = _instantiationService;\n    this._primaryCursorPosition = new Position(1, 1);\n    this._primaryCursorVisibleRange = null;\n    this._viewController = viewController;\n    this._visibleRangeProvider = visibleRangeProvider;\n    this._scrollLeft = 0;\n    this._scrollTop = 0;\n    const options = this._context.configuration.options;\n    const layoutInfo = options.get(146 /* EditorOption.layoutInfo */);\n    this._setAccessibilityOptions(options);\n    this._contentLeft = layoutInfo.contentLeft;\n    this._contentWidth = layoutInfo.contentWidth;\n    this._contentHeight = layoutInfo.height;\n    this._fontInfo = options.get(50 /* EditorOption.fontInfo */);\n    this._lineHeight = options.get(67 /* EditorOption.lineHeight */);\n    this._emptySelectionClipboard = options.get(37 /* EditorOption.emptySelectionClipboard */);\n    this._copyWithSyntaxHighlighting = options.get(25 /* EditorOption.copyWithSyntaxHighlighting */);\n    this._visibleTextArea = null;\n    this._selections = [new Selection(1, 1, 1, 1)];\n    this._modelSelections = [new Selection(1, 1, 1, 1)];\n    this._lastRenderPosition = null;\n    // Text Area (The focus will always be in the textarea when the cursor is blinking)\n    this.textArea = createFastDomNode(document.createElement('textarea'));\n    PartFingerprints.write(this.textArea, 7 /* PartFingerprint.TextArea */);\n    this.textArea.setClassName(\"inputarea \".concat(MOUSE_CURSOR_TEXT_CSS_CLASS_NAME));\n    this.textArea.setAttribute('wrap', this._textAreaWrapping && !this._visibleTextArea ? 'on' : 'off');\n    const {\n      tabSize\n    } = this._context.viewModel.model.getOptions();\n    this.textArea.domNode.style.tabSize = \"\".concat(tabSize * this._fontInfo.spaceWidth, \"px\");\n    this.textArea.setAttribute('autocorrect', 'off');\n    this.textArea.setAttribute('autocapitalize', 'off');\n    this.textArea.setAttribute('autocomplete', 'off');\n    this.textArea.setAttribute('spellcheck', 'false');\n    this.textArea.setAttribute('aria-label', this._getAriaLabel(options));\n    this.textArea.setAttribute('aria-required', options.get(5 /* EditorOption.ariaRequired */) ? 'true' : 'false');\n    this.textArea.setAttribute('tabindex', String(options.get(125 /* EditorOption.tabIndex */)));\n    this.textArea.setAttribute('role', 'textbox');\n    this.textArea.setAttribute('aria-roledescription', nls.localize('editor', \"editor\"));\n    this.textArea.setAttribute('aria-multiline', 'true');\n    this.textArea.setAttribute('aria-autocomplete', options.get(92 /* EditorOption.readOnly */) ? 'none' : 'both');\n    this._ensureReadOnlyAttribute();\n    this.textAreaCover = createFastDomNode(document.createElement('div'));\n    this.textAreaCover.setPosition('absolute');\n    const simpleModel = {\n      getLineCount: () => {\n        return this._context.viewModel.getLineCount();\n      },\n      getLineMaxColumn: lineNumber => {\n        return this._context.viewModel.getLineMaxColumn(lineNumber);\n      },\n      getValueInRange: (range, eol) => {\n        return this._context.viewModel.getValueInRange(range, eol);\n      },\n      getValueLengthInRange: (range, eol) => {\n        return this._context.viewModel.getValueLengthInRange(range, eol);\n      },\n      modifyPosition: (position, offset) => {\n        return this._context.viewModel.modifyPosition(position, offset);\n      }\n    };\n    const textAreaInputHost = {\n      getDataToCopy: () => {\n        const rawTextToCopy = this._context.viewModel.getPlainTextToCopy(this._modelSelections, this._emptySelectionClipboard, platform.isWindows);\n        const newLineCharacter = this._context.viewModel.model.getEOL();\n        const isFromEmptySelection = this._emptySelectionClipboard && this._modelSelections.length === 1 && this._modelSelections[0].isEmpty();\n        const multicursorText = Array.isArray(rawTextToCopy) ? rawTextToCopy : null;\n        const text = Array.isArray(rawTextToCopy) ? rawTextToCopy.join(newLineCharacter) : rawTextToCopy;\n        let html = undefined;\n        let mode = null;\n        if (CopyOptions.forceCopyWithSyntaxHighlighting || this._copyWithSyntaxHighlighting && text.length < 65536) {\n          const richText = this._context.viewModel.getRichTextToCopy(this._modelSelections, this._emptySelectionClipboard);\n          if (richText) {\n            html = richText.html;\n            mode = richText.mode;\n          }\n        }\n        return {\n          isFromEmptySelection,\n          multicursorText,\n          text,\n          html,\n          mode\n        };\n      },\n      getScreenReaderContent: () => {\n        if (this._accessibilitySupport === 1 /* AccessibilitySupport.Disabled */) {\n          // We know for a fact that a screen reader is not attached\n          // On OSX, we write the character before the cursor to allow for \"long-press\" composition\n          // Also on OSX, we write the word before the cursor to allow for the Accessibility Keyboard to give good hints\n          const selection = this._selections[0];\n          if (platform.isMacintosh && selection.isEmpty()) {\n            const position = selection.getStartPosition();\n            let textBefore = this._getWordBeforePosition(position);\n            if (textBefore.length === 0) {\n              textBefore = this._getCharacterBeforePosition(position);\n            }\n            if (textBefore.length > 0) {\n              return new TextAreaState(textBefore, textBefore.length, textBefore.length, Range.fromPositions(position), 0);\n            }\n          }\n          // on macOS, write current selection into textarea will allow system text services pick selected text,\n          // but we still want to limit the amount of text given Chromium handles very poorly text even of a few\n          // thousand chars\n          // (https://github.com/microsoft/vscode/issues/27799)\n          const LIMIT_CHARS = 500;\n          if (platform.isMacintosh && !selection.isEmpty() && simpleModel.getValueLengthInRange(selection, 0 /* EndOfLinePreference.TextDefined */) < LIMIT_CHARS) {\n            const text = simpleModel.getValueInRange(selection, 0 /* EndOfLinePreference.TextDefined */);\n            return new TextAreaState(text, 0, text.length, selection, 0);\n          }\n          // on Safari, document.execCommand('cut') and document.execCommand('copy') will just not work\n          // if the textarea has no content selected. So if there is an editor selection, ensure something\n          // is selected in the textarea.\n          if (browser.isSafari && !selection.isEmpty()) {\n            const placeholderText = 'vscode-placeholder';\n            return new TextAreaState(placeholderText, 0, placeholderText.length, null, undefined);\n          }\n          return TextAreaState.EMPTY;\n        }\n        if (browser.isAndroid) {\n          // when tapping in the editor on a word, Android enters composition mode.\n          // in the `compositionstart` event we cannot clear the textarea, because\n          // it then forgets to ever send a `compositionend`.\n          // we therefore only write the current word in the textarea\n          const selection = this._selections[0];\n          if (selection.isEmpty()) {\n            const position = selection.getStartPosition();\n            const [wordAtPosition, positionOffsetInWord] = this._getAndroidWordAtPosition(position);\n            if (wordAtPosition.length > 0) {\n              return new TextAreaState(wordAtPosition, positionOffsetInWord, positionOffsetInWord, Range.fromPositions(position), 0);\n            }\n          }\n          return TextAreaState.EMPTY;\n        }\n        return PagedScreenReaderStrategy.fromEditorSelection(simpleModel, this._selections[0], this._accessibilityPageSize, this._accessibilitySupport === 0 /* AccessibilitySupport.Unknown */);\n      },\n      deduceModelPosition: (viewAnchorPosition, deltaOffset, lineFeedCnt) => {\n        return this._context.viewModel.deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt);\n      }\n    };\n    const textAreaWrapper = this._register(new TextAreaWrapper(this.textArea.domNode));\n    this._textAreaInput = this._register(this._instantiationService.createInstance(TextAreaInput, textAreaInputHost, textAreaWrapper, platform.OS, {\n      isAndroid: browser.isAndroid,\n      isChrome: browser.isChrome,\n      isFirefox: browser.isFirefox,\n      isSafari: browser.isSafari\n    }));\n    this._register(this._textAreaInput.onKeyDown(e => {\n      this._viewController.emitKeyDown(e);\n    }));\n    this._register(this._textAreaInput.onKeyUp(e => {\n      this._viewController.emitKeyUp(e);\n    }));\n    this._register(this._textAreaInput.onPaste(e => {\n      let pasteOnNewLine = false;\n      let multicursorText = null;\n      let mode = null;\n      if (e.metadata) {\n        pasteOnNewLine = this._emptySelectionClipboard && !!e.metadata.isFromEmptySelection;\n        multicursorText = typeof e.metadata.multicursorText !== 'undefined' ? e.metadata.multicursorText : null;\n        mode = e.metadata.mode;\n      }\n      this._viewController.paste(e.text, pasteOnNewLine, multicursorText, mode);\n    }));\n    this._register(this._textAreaInput.onCut(() => {\n      this._viewController.cut();\n    }));\n    this._register(this._textAreaInput.onType(e => {\n      if (e.replacePrevCharCnt || e.replaceNextCharCnt || e.positionDelta) {\n        // must be handled through the new command\n        if (_debugComposition) {\n          console.log(\" => compositionType: <<\".concat(e.text, \">>, \").concat(e.replacePrevCharCnt, \", \").concat(e.replaceNextCharCnt, \", \").concat(e.positionDelta));\n        }\n        this._viewController.compositionType(e.text, e.replacePrevCharCnt, e.replaceNextCharCnt, e.positionDelta);\n      } else {\n        if (_debugComposition) {\n          console.log(\" => type: <<\".concat(e.text, \">>\"));\n        }\n        this._viewController.type(e.text);\n      }\n    }));\n    this._register(this._textAreaInput.onSelectionChangeRequest(modelSelection => {\n      this._viewController.setSelection(modelSelection);\n    }));\n    this._register(this._textAreaInput.onCompositionStart(e => {\n      // The textarea might contain some content when composition starts.\n      //\n      // When we make the textarea visible, it always has a height of 1 line,\n      // so we don't need to worry too much about content on lines above or below\n      // the selection.\n      //\n      // However, the text on the current line needs to be made visible because\n      // some IME methods allow to move to other glyphs on the current line\n      // (by pressing arrow keys).\n      //\n      // (1) The textarea might contain only some parts of the current line,\n      // like the word before the selection. Also, the content inside the textarea\n      // can grow or shrink as composition occurs. We therefore anchor the textarea\n      // in terms of distance to a certain line start and line end.\n      //\n      // (2) Also, we should not make \\t characters visible, because their rendering\n      // inside the <textarea> will not align nicely with our rendering. We therefore\n      // will hide (if necessary) some of the leading text on the current line.\n      const ta = this.textArea.domNode;\n      const modelSelection = this._modelSelections[0];\n      const {\n        distanceToModelLineStart,\n        widthOfHiddenTextBefore\n      } = (() => {\n        // Find the text that is on the current line before the selection\n        const textBeforeSelection = ta.value.substring(0, Math.min(ta.selectionStart, ta.selectionEnd));\n        const lineFeedOffset1 = textBeforeSelection.lastIndexOf('\\n');\n        const lineTextBeforeSelection = textBeforeSelection.substring(lineFeedOffset1 + 1);\n        // We now search to see if we should hide some part of it (if it contains \\t)\n        const tabOffset1 = lineTextBeforeSelection.lastIndexOf('\\t');\n        const desiredVisibleBeforeCharCount = lineTextBeforeSelection.length - tabOffset1 - 1;\n        const startModelPosition = modelSelection.getStartPosition();\n        const visibleBeforeCharCount = Math.min(startModelPosition.column - 1, desiredVisibleBeforeCharCount);\n        const distanceToModelLineStart = startModelPosition.column - 1 - visibleBeforeCharCount;\n        const hiddenLineTextBefore = lineTextBeforeSelection.substring(0, lineTextBeforeSelection.length - visibleBeforeCharCount);\n        const {\n          tabSize\n        } = this._context.viewModel.model.getOptions();\n        const widthOfHiddenTextBefore = measureText(this.textArea.domNode.ownerDocument, hiddenLineTextBefore, this._fontInfo, tabSize);\n        return {\n          distanceToModelLineStart,\n          widthOfHiddenTextBefore\n        };\n      })();\n      const {\n        distanceToModelLineEnd\n      } = (() => {\n        // Find the text that is on the current line after the selection\n        const textAfterSelection = ta.value.substring(Math.max(ta.selectionStart, ta.selectionEnd));\n        const lineFeedOffset2 = textAfterSelection.indexOf('\\n');\n        const lineTextAfterSelection = lineFeedOffset2 === -1 ? textAfterSelection : textAfterSelection.substring(0, lineFeedOffset2);\n        const tabOffset2 = lineTextAfterSelection.indexOf('\\t');\n        const desiredVisibleAfterCharCount = tabOffset2 === -1 ? lineTextAfterSelection.length : lineTextAfterSelection.length - tabOffset2 - 1;\n        const endModelPosition = modelSelection.getEndPosition();\n        const visibleAfterCharCount = Math.min(this._context.viewModel.model.getLineMaxColumn(endModelPosition.lineNumber) - endModelPosition.column, desiredVisibleAfterCharCount);\n        const distanceToModelLineEnd = this._context.viewModel.model.getLineMaxColumn(endModelPosition.lineNumber) - endModelPosition.column - visibleAfterCharCount;\n        return {\n          distanceToModelLineEnd\n        };\n      })();\n      // Scroll to reveal the location in the editor where composition occurs\n      this._context.viewModel.revealRange('keyboard', true, Range.fromPositions(this._selections[0].getStartPosition()), 0 /* viewEvents.VerticalRevealType.Simple */, 1 /* ScrollType.Immediate */);\n      this._visibleTextArea = new VisibleTextAreaData(this._context, modelSelection.startLineNumber, distanceToModelLineStart, widthOfHiddenTextBefore, distanceToModelLineEnd);\n      // We turn off wrapping if the <textarea> becomes visible for composition\n      this.textArea.setAttribute('wrap', this._textAreaWrapping && !this._visibleTextArea ? 'on' : 'off');\n      this._visibleTextArea.prepareRender(this._visibleRangeProvider);\n      this._render();\n      // Show the textarea\n      this.textArea.setClassName(\"inputarea \".concat(MOUSE_CURSOR_TEXT_CSS_CLASS_NAME, \" ime-input\"));\n      this._viewController.compositionStart();\n      this._context.viewModel.onCompositionStart();\n    }));\n    this._register(this._textAreaInput.onCompositionUpdate(e => {\n      if (!this._visibleTextArea) {\n        return;\n      }\n      this._visibleTextArea.prepareRender(this._visibleRangeProvider);\n      this._render();\n    }));\n    this._register(this._textAreaInput.onCompositionEnd(() => {\n      this._visibleTextArea = null;\n      // We turn on wrapping as necessary if the <textarea> hides after composition\n      this.textArea.setAttribute('wrap', this._textAreaWrapping && !this._visibleTextArea ? 'on' : 'off');\n      this._render();\n      this.textArea.setClassName(\"inputarea \".concat(MOUSE_CURSOR_TEXT_CSS_CLASS_NAME));\n      this._viewController.compositionEnd();\n      this._context.viewModel.onCompositionEnd();\n    }));\n    this._register(this._textAreaInput.onFocus(() => {\n      this._context.viewModel.setHasFocus(true);\n    }));\n    this._register(this._textAreaInput.onBlur(() => {\n      this._context.viewModel.setHasFocus(false);\n    }));\n    this._register(IME.onDidChange(() => {\n      this._ensureReadOnlyAttribute();\n    }));\n  }\n  writeScreenReaderContent(reason) {\n    this._textAreaInput.writeNativeTextAreaContent(reason);\n  }\n  dispose() {\n    super.dispose();\n  }\n  _getAndroidWordAtPosition(position) {\n    const ANDROID_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\",.<>/?';\n    const lineContent = this._context.viewModel.getLineContent(position.lineNumber);\n    const wordSeparators = getMapForWordSeparators(ANDROID_WORD_SEPARATORS, []);\n    let goingLeft = true;\n    let startColumn = position.column;\n    let goingRight = true;\n    let endColumn = position.column;\n    let distance = 0;\n    while (distance < 50 && (goingLeft || goingRight)) {\n      if (goingLeft && startColumn <= 1) {\n        goingLeft = false;\n      }\n      if (goingLeft) {\n        const charCode = lineContent.charCodeAt(startColumn - 2);\n        const charClass = wordSeparators.get(charCode);\n        if (charClass !== 0 /* WordCharacterClass.Regular */) {\n          goingLeft = false;\n        } else {\n          startColumn--;\n        }\n      }\n      if (goingRight && endColumn > lineContent.length) {\n        goingRight = false;\n      }\n      if (goingRight) {\n        const charCode = lineContent.charCodeAt(endColumn - 1);\n        const charClass = wordSeparators.get(charCode);\n        if (charClass !== 0 /* WordCharacterClass.Regular */) {\n          goingRight = false;\n        } else {\n          endColumn++;\n        }\n      }\n      distance++;\n    }\n    return [lineContent.substring(startColumn - 1, endColumn - 1), position.column - startColumn];\n  }\n  _getWordBeforePosition(position) {\n    const lineContent = this._context.viewModel.getLineContent(position.lineNumber);\n    const wordSeparators = getMapForWordSeparators(this._context.configuration.options.get(132 /* EditorOption.wordSeparators */), []);\n    let column = position.column;\n    let distance = 0;\n    while (column > 1) {\n      const charCode = lineContent.charCodeAt(column - 2);\n      const charClass = wordSeparators.get(charCode);\n      if (charClass !== 0 /* WordCharacterClass.Regular */ || distance > 50) {\n        return lineContent.substring(column - 1, position.column - 1);\n      }\n      distance++;\n      column--;\n    }\n    return lineContent.substring(0, position.column - 1);\n  }\n  _getCharacterBeforePosition(position) {\n    if (position.column > 1) {\n      const lineContent = this._context.viewModel.getLineContent(position.lineNumber);\n      const charBefore = lineContent.charAt(position.column - 2);\n      if (!strings.isHighSurrogate(charBefore.charCodeAt(0))) {\n        return charBefore;\n      }\n    }\n    return '';\n  }\n  _getAriaLabel(options) {\n    const accessibilitySupport = options.get(2 /* EditorOption.accessibilitySupport */);\n    if (accessibilitySupport === 1 /* AccessibilitySupport.Disabled */) {\n      var _this$_keybindingServ, _this$_keybindingServ2, _this$_keybindingServ3;\n      const toggleKeybindingLabel = (_this$_keybindingServ = this._keybindingService.lookupKeybinding('editor.action.toggleScreenReaderAccessibilityMode')) === null || _this$_keybindingServ === void 0 ? void 0 : _this$_keybindingServ.getAriaLabel();\n      const runCommandKeybindingLabel = (_this$_keybindingServ2 = this._keybindingService.lookupKeybinding('workbench.action.showCommands')) === null || _this$_keybindingServ2 === void 0 ? void 0 : _this$_keybindingServ2.getAriaLabel();\n      const keybindingEditorKeybindingLabel = (_this$_keybindingServ3 = this._keybindingService.lookupKeybinding('workbench.action.openGlobalKeybindings')) === null || _this$_keybindingServ3 === void 0 ? void 0 : _this$_keybindingServ3.getAriaLabel();\n      const editorNotAccessibleMessage = nls.localize('accessibilityModeOff', \"The editor is not accessible at this time.\");\n      if (toggleKeybindingLabel) {\n        return nls.localize('accessibilityOffAriaLabel', \"{0} To enable screen reader optimized mode, use {1}\", editorNotAccessibleMessage, toggleKeybindingLabel);\n      } else if (runCommandKeybindingLabel) {\n        return nls.localize('accessibilityOffAriaLabelNoKb', \"{0} To enable screen reader optimized mode, open the quick pick with {1} and run the command Toggle Screen Reader Accessibility Mode, which is currently not triggerable via keyboard.\", editorNotAccessibleMessage, runCommandKeybindingLabel);\n      } else if (keybindingEditorKeybindingLabel) {\n        return nls.localize('accessibilityOffAriaLabelNoKbs', \"{0} Please assign a keybinding for the command Toggle Screen Reader Accessibility Mode by accessing the keybindings editor with {1} and run it.\", editorNotAccessibleMessage, keybindingEditorKeybindingLabel);\n      } else {\n        // SOS\n        return editorNotAccessibleMessage;\n      }\n    }\n    return options.get(4 /* EditorOption.ariaLabel */);\n  }\n  _setAccessibilityOptions(options) {\n    this._accessibilitySupport = options.get(2 /* EditorOption.accessibilitySupport */);\n    const accessibilityPageSize = options.get(3 /* EditorOption.accessibilityPageSize */);\n    if (this._accessibilitySupport === 2 /* AccessibilitySupport.Enabled */ && accessibilityPageSize === EditorOptions.accessibilityPageSize.defaultValue) {\n      // If a screen reader is attached and the default value is not set we should automatically increase the page size to 500 for a better experience\n      this._accessibilityPageSize = 500;\n    } else {\n      this._accessibilityPageSize = accessibilityPageSize;\n    }\n    // When wrapping is enabled and a screen reader might be attached,\n    // we will size the textarea to match the width used for wrapping points computation (see `domLineBreaksComputer.ts`).\n    // This is because screen readers will read the text in the textarea and we'd like that the\n    // wrapping points in the textarea match the wrapping points in the editor.\n    const layoutInfo = options.get(146 /* EditorOption.layoutInfo */);\n    const wrappingColumn = layoutInfo.wrappingColumn;\n    if (wrappingColumn !== -1 && this._accessibilitySupport !== 1 /* AccessibilitySupport.Disabled */) {\n      const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n      this._textAreaWrapping = true;\n      this._textAreaWidth = Math.round(wrappingColumn * fontInfo.typicalHalfwidthCharacterWidth);\n    } else {\n      this._textAreaWrapping = false;\n      this._textAreaWidth = canUseZeroSizeTextarea ? 0 : 1;\n    }\n  }\n  // --- begin event handlers\n  onConfigurationChanged(e) {\n    const options = this._context.configuration.options;\n    const layoutInfo = options.get(146 /* EditorOption.layoutInfo */);\n    this._setAccessibilityOptions(options);\n    this._contentLeft = layoutInfo.contentLeft;\n    this._contentWidth = layoutInfo.contentWidth;\n    this._contentHeight = layoutInfo.height;\n    this._fontInfo = options.get(50 /* EditorOption.fontInfo */);\n    this._lineHeight = options.get(67 /* EditorOption.lineHeight */);\n    this._emptySelectionClipboard = options.get(37 /* EditorOption.emptySelectionClipboard */);\n    this._copyWithSyntaxHighlighting = options.get(25 /* EditorOption.copyWithSyntaxHighlighting */);\n    this.textArea.setAttribute('wrap', this._textAreaWrapping && !this._visibleTextArea ? 'on' : 'off');\n    const {\n      tabSize\n    } = this._context.viewModel.model.getOptions();\n    this.textArea.domNode.style.tabSize = \"\".concat(tabSize * this._fontInfo.spaceWidth, \"px\");\n    this.textArea.setAttribute('aria-label', this._getAriaLabel(options));\n    this.textArea.setAttribute('aria-required', options.get(5 /* EditorOption.ariaRequired */) ? 'true' : 'false');\n    this.textArea.setAttribute('tabindex', String(options.get(125 /* EditorOption.tabIndex */)));\n    if (e.hasChanged(34 /* EditorOption.domReadOnly */) || e.hasChanged(92 /* EditorOption.readOnly */)) {\n      this._ensureReadOnlyAttribute();\n    }\n    if (e.hasChanged(2 /* EditorOption.accessibilitySupport */)) {\n      this._textAreaInput.writeNativeTextAreaContent('strategy changed');\n    }\n    return true;\n  }\n  onCursorStateChanged(e) {\n    this._selections = e.selections.slice(0);\n    this._modelSelections = e.modelSelections.slice(0);\n    // We must update the <textarea> synchronously, otherwise long press IME on macos breaks.\n    // See https://github.com/microsoft/vscode/issues/165821\n    this._textAreaInput.writeNativeTextAreaContent('selection changed');\n    return true;\n  }\n  onDecorationsChanged(e) {\n    // true for inline decorations that can end up relayouting text\n    return true;\n  }\n  onFlushed(e) {\n    return true;\n  }\n  onLinesChanged(e) {\n    return true;\n  }\n  onLinesDeleted(e) {\n    return true;\n  }\n  onLinesInserted(e) {\n    return true;\n  }\n  onScrollChanged(e) {\n    this._scrollLeft = e.scrollLeft;\n    this._scrollTop = e.scrollTop;\n    return true;\n  }\n  onZonesChanged(e) {\n    return true;\n  }\n  // --- end event handlers\n  // --- begin view API\n  isFocused() {\n    return this._textAreaInput.isFocused();\n  }\n  focusTextArea() {\n    this._textAreaInput.focusTextArea();\n  }\n  getLastRenderData() {\n    return this._lastRenderPosition;\n  }\n  setAriaOptions(options) {\n    if (options.activeDescendant) {\n      this.textArea.setAttribute('aria-haspopup', 'true');\n      this.textArea.setAttribute('aria-autocomplete', 'list');\n      this.textArea.setAttribute('aria-activedescendant', options.activeDescendant);\n    } else {\n      this.textArea.setAttribute('aria-haspopup', 'false');\n      this.textArea.setAttribute('aria-autocomplete', 'both');\n      this.textArea.removeAttribute('aria-activedescendant');\n    }\n    if (options.role) {\n      this.textArea.setAttribute('role', options.role);\n    }\n  }\n  // --- end view API\n  _ensureReadOnlyAttribute() {\n    const options = this._context.configuration.options;\n    // When someone requests to disable IME, we set the \"readonly\" attribute on the <textarea>.\n    // This will prevent composition.\n    const useReadOnly = !IME.enabled || options.get(34 /* EditorOption.domReadOnly */) && options.get(92 /* EditorOption.readOnly */);\n    if (useReadOnly) {\n      this.textArea.setAttribute('readonly', 'true');\n    } else {\n      this.textArea.removeAttribute('readonly');\n    }\n  }\n  prepareRender(ctx) {\n    var _this$_visibleTextAre;\n    this._primaryCursorPosition = new Position(this._selections[0].positionLineNumber, this._selections[0].positionColumn);\n    this._primaryCursorVisibleRange = ctx.visibleRangeForPosition(this._primaryCursorPosition);\n    (_this$_visibleTextAre = this._visibleTextArea) === null || _this$_visibleTextAre === void 0 || _this$_visibleTextAre.prepareRender(ctx);\n  }\n  render(ctx) {\n    this._textAreaInput.writeNativeTextAreaContent('render');\n    this._render();\n  }\n  _render() {\n    if (this._visibleTextArea) {\n      // The text area is visible for composition reasons\n      const visibleStart = this._visibleTextArea.visibleTextareaStart;\n      const visibleEnd = this._visibleTextArea.visibleTextareaEnd;\n      const startPosition = this._visibleTextArea.startPosition;\n      const endPosition = this._visibleTextArea.endPosition;\n      if (startPosition && endPosition && visibleStart && visibleEnd && visibleEnd.left >= this._scrollLeft && visibleStart.left <= this._scrollLeft + this._contentWidth) {\n        const top = this._context.viewLayout.getVerticalOffsetForLineNumber(this._primaryCursorPosition.lineNumber) - this._scrollTop;\n        const lineCount = this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));\n        let scrollLeft = this._visibleTextArea.widthOfHiddenLineTextBefore;\n        let left = this._contentLeft + visibleStart.left - this._scrollLeft;\n        // See https://github.com/microsoft/vscode/issues/141725#issuecomment-1050670841\n        // Here we are adding +1 to avoid flickering that might be caused by having a width that is too small.\n        // This could be caused by rounding errors that might only show up with certain font families.\n        // In other words, a pixel might be lost when doing something like\n        //      `Math.round(end) - Math.round(start)`\n        // vs\n        //      `Math.round(end - start)`\n        let width = visibleEnd.left - visibleStart.left + 1;\n        if (left < this._contentLeft) {\n          // the textarea would be rendered on top of the margin,\n          // so reduce its width. We use the same technique as\n          // for hiding text before\n          const delta = this._contentLeft - left;\n          left += delta;\n          scrollLeft += delta;\n          width -= delta;\n        }\n        if (width > this._contentWidth) {\n          // the textarea would be wider than the content width,\n          // so reduce its width.\n          width = this._contentWidth;\n        }\n        // Try to render the textarea with the color/font style to match the text under it\n        const viewLineData = this._context.viewModel.getViewLineData(startPosition.lineNumber);\n        const startTokenIndex = viewLineData.tokens.findTokenIndexAtOffset(startPosition.column - 1);\n        const endTokenIndex = viewLineData.tokens.findTokenIndexAtOffset(endPosition.column - 1);\n        const textareaSpansSingleToken = startTokenIndex === endTokenIndex;\n        const presentation = this._visibleTextArea.definePresentation(textareaSpansSingleToken ? viewLineData.tokens.getPresentation(startTokenIndex) : null);\n        this.textArea.domNode.scrollTop = lineCount * this._lineHeight;\n        this.textArea.domNode.scrollLeft = scrollLeft;\n        this._doRender({\n          lastRenderPosition: null,\n          top: top,\n          left: left,\n          width: width,\n          height: this._lineHeight,\n          useCover: false,\n          color: (TokenizationRegistry.getColorMap() || [])[presentation.foreground],\n          italic: presentation.italic,\n          bold: presentation.bold,\n          underline: presentation.underline,\n          strikethrough: presentation.strikethrough\n        });\n      }\n      return;\n    }\n    if (!this._primaryCursorVisibleRange) {\n      // The primary cursor is outside the viewport => place textarea to the top left\n      this._renderAtTopLeft();\n      return;\n    }\n    const left = this._contentLeft + this._primaryCursorVisibleRange.left - this._scrollLeft;\n    if (left < this._contentLeft || left > this._contentLeft + this._contentWidth) {\n      // cursor is outside the viewport\n      this._renderAtTopLeft();\n      return;\n    }\n    const top = this._context.viewLayout.getVerticalOffsetForLineNumber(this._selections[0].positionLineNumber) - this._scrollTop;\n    if (top < 0 || top > this._contentHeight) {\n      // cursor is outside the viewport\n      this._renderAtTopLeft();\n      return;\n    }\n    // The primary cursor is in the viewport (at least vertically) => place textarea on the cursor\n    if (platform.isMacintosh || this._accessibilitySupport === 2 /* AccessibilitySupport.Enabled */) {\n      var _this$_textAreaInput$;\n      // For the popup emoji input, we will make the text area as high as the line height\n      // We will also make the fontSize and lineHeight the correct dimensions to help with the placement of these pickers\n      this._doRender({\n        lastRenderPosition: this._primaryCursorPosition,\n        top,\n        left: this._textAreaWrapping ? this._contentLeft : left,\n        width: this._textAreaWidth,\n        height: this._lineHeight,\n        useCover: false\n      });\n      // In case the textarea contains a word, we're going to try to align the textarea's cursor\n      // with our cursor by scrolling the textarea as much as possible\n      this.textArea.domNode.scrollLeft = this._primaryCursorVisibleRange.left;\n      const lineCount = (_this$_textAreaInput$ = this._textAreaInput.textAreaState.newlineCountBeforeSelection) !== null && _this$_textAreaInput$ !== void 0 ? _this$_textAreaInput$ : this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));\n      this.textArea.domNode.scrollTop = lineCount * this._lineHeight;\n      return;\n    }\n    this._doRender({\n      lastRenderPosition: this._primaryCursorPosition,\n      top: top,\n      left: this._textAreaWrapping ? this._contentLeft : left,\n      width: this._textAreaWidth,\n      height: canUseZeroSizeTextarea ? 0 : 1,\n      useCover: false\n    });\n  }\n  _newlinecount(text) {\n    let result = 0;\n    let startIndex = -1;\n    do {\n      startIndex = text.indexOf('\\n', startIndex + 1);\n      if (startIndex === -1) {\n        break;\n      }\n      result++;\n    } while (true);\n    return result;\n  }\n  _renderAtTopLeft() {\n    // (in WebKit the textarea is 1px by 1px because it cannot handle input to a 0x0 textarea)\n    // specifically, when doing Korean IME, setting the textarea to 0x0 breaks IME badly.\n    this._doRender({\n      lastRenderPosition: null,\n      top: 0,\n      left: 0,\n      width: this._textAreaWidth,\n      height: canUseZeroSizeTextarea ? 0 : 1,\n      useCover: true\n    });\n  }\n  _doRender(renderData) {\n    this._lastRenderPosition = renderData.lastRenderPosition;\n    const ta = this.textArea;\n    const tac = this.textAreaCover;\n    applyFontInfo(ta, this._fontInfo);\n    ta.setTop(renderData.top);\n    ta.setLeft(renderData.left);\n    ta.setWidth(renderData.width);\n    ta.setHeight(renderData.height);\n    ta.setColor(renderData.color ? Color.Format.CSS.formatHex(renderData.color) : '');\n    ta.setFontStyle(renderData.italic ? 'italic' : '');\n    if (renderData.bold) {\n      // fontWeight is also set by `applyFontInfo`, so only overwrite it if necessary\n      ta.setFontWeight('bold');\n    }\n    ta.setTextDecoration(\"\".concat(renderData.underline ? ' underline' : '').concat(renderData.strikethrough ? ' line-through' : ''));\n    tac.setTop(renderData.useCover ? renderData.top : 0);\n    tac.setLeft(renderData.useCover ? renderData.left : 0);\n    tac.setWidth(renderData.useCover ? renderData.width : 0);\n    tac.setHeight(renderData.useCover ? renderData.height : 0);\n    const options = this._context.configuration.options;\n    if (options.get(57 /* EditorOption.glyphMargin */)) {\n      tac.setClassName('monaco-editor-background textAreaCover ' + Margin.OUTER_CLASS_NAME);\n    } else {\n      if (options.get(68 /* EditorOption.lineNumbers */).renderType !== 0 /* RenderLineNumbersType.Off */) {\n        tac.setClassName('monaco-editor-background textAreaCover ' + LineNumbersOverlay.CLASS_NAME);\n      } else {\n        tac.setClassName('monaco-editor-background textAreaCover');\n      }\n    }\n  }\n};\nTextAreaHandler = __decorate([__param(3, IKeybindingService), __param(4, IInstantiationService)], TextAreaHandler);\nexport { TextAreaHandler };\nfunction measureText(targetDocument, text, fontInfo, tabSize) {\n  if (text.length === 0) {\n    return 0;\n  }\n  const container = targetDocument.createElement('div');\n  container.style.position = 'absolute';\n  container.style.top = '-50000px';\n  container.style.width = '50000px';\n  const regularDomNode = targetDocument.createElement('span');\n  applyFontInfo(regularDomNode, fontInfo);\n  regularDomNode.style.whiteSpace = 'pre'; // just like the textarea\n  regularDomNode.style.tabSize = \"\".concat(tabSize * fontInfo.spaceWidth, \"px\"); // just like the textarea\n  regularDomNode.append(text);\n  container.appendChild(regularDomNode);\n  targetDocument.body.appendChild(container);\n  const res = regularDomNode.offsetWidth;\n  container.remove();\n  return res;\n}","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","nls","browser","createFastDomNode","platform","strings","applyFontInfo","CopyOptions","TextAreaInput","TextAreaWrapper","PagedScreenReaderStrategy","TextAreaState","_debugComposition","PartFingerprints","ViewPart","LineNumbersOverlay","Margin","EditorOptions","getMapForWordSeparators","Position","Range","Selection","MOUSE_CURSOR_TEXT_CSS_CLASS_NAME","TokenizationRegistry","Color","IME","IKeybindingService","IInstantiationService","VisibleTextAreaData","constructor","_context","modelLineNumber","distanceToModelLineStart","widthOfHiddenLineTextBefore","distanceToModelLineEnd","_visibleTextAreaBrand","undefined","startPosition","endPosition","visibleTextareaStart","visibleTextareaEnd","_previousPresentation","prepareRender","visibleRangeProvider","startModelPosition","endModelPosition","viewModel","model","getLineMaxColumn","coordinatesConverter","convertModelPositionToViewPosition","lineNumber","visibleRangeForPosition","definePresentation","tokenPresentation","foreground","italic","bold","underline","strikethrough","canUseZeroSizeTextarea","isFirefox","TextAreaHandler","context","viewController","_keybindingService","_instantiationService","_primaryCursorPosition","_primaryCursorVisibleRange","_viewController","_visibleRangeProvider","_scrollLeft","_scrollTop","options","configuration","layoutInfo","get","_setAccessibilityOptions","_contentLeft","contentLeft","_contentWidth","contentWidth","_contentHeight","height","_fontInfo","_lineHeight","_emptySelectionClipboard","_copyWithSyntaxHighlighting","_visibleTextArea","_selections","_modelSelections","_lastRenderPosition","textArea","document","createElement","write","setClassName","concat","setAttribute","_textAreaWrapping","tabSize","getOptions","domNode","style","spaceWidth","_getAriaLabel","String","localize","_ensureReadOnlyAttribute","textAreaCover","setPosition","simpleModel","getLineCount","getValueInRange","range","eol","getValueLengthInRange","modifyPosition","position","offset","textAreaInputHost","getDataToCopy","rawTextToCopy","getPlainTextToCopy","isWindows","newLineCharacter","getEOL","isFromEmptySelection","isEmpty","multicursorText","Array","isArray","text","join","html","mode","forceCopyWithSyntaxHighlighting","richText","getRichTextToCopy","getScreenReaderContent","_accessibilitySupport","selection","isMacintosh","getStartPosition","textBefore","_getWordBeforePosition","_getCharacterBeforePosition","fromPositions","LIMIT_CHARS","isSafari","placeholderText","EMPTY","isAndroid","wordAtPosition","positionOffsetInWord","_getAndroidWordAtPosition","fromEditorSelection","_accessibilityPageSize","deduceModelPosition","viewAnchorPosition","deltaOffset","lineFeedCnt","deduceModelPositionRelativeToViewPosition","textAreaWrapper","_register","_textAreaInput","createInstance","OS","isChrome","onKeyDown","e","emitKeyDown","onKeyUp","emitKeyUp","onPaste","pasteOnNewLine","metadata","paste","onCut","cut","onType","replacePrevCharCnt","replaceNextCharCnt","positionDelta","console","log","compositionType","type","onSelectionChangeRequest","modelSelection","setSelection","onCompositionStart","ta","widthOfHiddenTextBefore","textBeforeSelection","value","substring","Math","min","selectionStart","selectionEnd","lineFeedOffset1","lastIndexOf","lineTextBeforeSelection","tabOffset1","desiredVisibleBeforeCharCount","visibleBeforeCharCount","column","hiddenLineTextBefore","measureText","ownerDocument","textAfterSelection","max","lineFeedOffset2","indexOf","lineTextAfterSelection","tabOffset2","desiredVisibleAfterCharCount","getEndPosition","visibleAfterCharCount","revealRange","startLineNumber","_render","compositionStart","onCompositionUpdate","onCompositionEnd","compositionEnd","onFocus","setHasFocus","onBlur","onDidChange","writeScreenReaderContent","reason","writeNativeTextAreaContent","dispose","ANDROID_WORD_SEPARATORS","lineContent","getLineContent","wordSeparators","goingLeft","startColumn","goingRight","endColumn","distance","charCode","charCodeAt","charClass","charBefore","charAt","isHighSurrogate","accessibilitySupport","_this$_keybindingServ","_this$_keybindingServ2","_this$_keybindingServ3","toggleKeybindingLabel","lookupKeybinding","getAriaLabel","runCommandKeybindingLabel","keybindingEditorKeybindingLabel","editorNotAccessibleMessage","accessibilityPageSize","defaultValue","wrappingColumn","fontInfo","_textAreaWidth","round","typicalHalfwidthCharacterWidth","onConfigurationChanged","hasChanged","onCursorStateChanged","selections","slice","modelSelections","onDecorationsChanged","onFlushed","onLinesChanged","onLinesDeleted","onLinesInserted","onScrollChanged","scrollLeft","scrollTop","onZonesChanged","isFocused","focusTextArea","getLastRenderData","setAriaOptions","activeDescendant","removeAttribute","role","useReadOnly","enabled","ctx","_this$_visibleTextAre","positionLineNumber","positionColumn","render","visibleStart","visibleEnd","left","top","viewLayout","getVerticalOffsetForLineNumber","lineCount","_newlinecount","substr","width","delta","viewLineData","getViewLineData","startTokenIndex","tokens","findTokenIndexAtOffset","endTokenIndex","textareaSpansSingleToken","presentation","getPresentation","_doRender","lastRenderPosition","useCover","color","getColorMap","_renderAtTopLeft","_this$_textAreaInput$","textAreaState","newlineCountBeforeSelection","result","startIndex","renderData","tac","setTop","setLeft","setWidth","setHeight","setColor","Format","CSS","formatHex","setFontStyle","setFontWeight","setTextDecoration","OUTER_CLASS_NAME","renderType","CLASS_NAME","targetDocument","container","regularDomNode","whiteSpace","append","appendChild","body","res","offsetWidth","remove"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaHandler.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport './textAreaHandler.css';\nimport * as nls from '../../../nls.js';\nimport * as browser from '../../../base/browser/browser.js';\nimport { createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { applyFontInfo } from '../config/domFontInfo.js';\nimport { CopyOptions, TextAreaInput, TextAreaWrapper } from './textAreaInput.js';\nimport { PagedScreenReaderStrategy, TextAreaState, _debugComposition } from './textAreaState.js';\nimport { PartFingerprints, ViewPart } from '../view/viewPart.js';\nimport { LineNumbersOverlay } from '../viewParts/lineNumbers/lineNumbers.js';\nimport { Margin } from '../viewParts/margin/margin.js';\nimport { EditorOptions } from '../../common/config/editorOptions.js';\nimport { getMapForWordSeparators } from '../../common/core/wordCharacterClassifier.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { MOUSE_CURSOR_TEXT_CSS_CLASS_NAME } from '../../../base/browser/ui/mouseCursor/mouseCursor.js';\nimport { TokenizationRegistry } from '../../common/languages.js';\nimport { Color } from '../../../base/common/color.js';\nimport { IME } from '../../../base/common/ime.js';\nimport { IKeybindingService } from '../../../platform/keybinding/common/keybinding.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nclass VisibleTextAreaData {\n    constructor(_context, modelLineNumber, distanceToModelLineStart, widthOfHiddenLineTextBefore, distanceToModelLineEnd) {\n        this._context = _context;\n        this.modelLineNumber = modelLineNumber;\n        this.distanceToModelLineStart = distanceToModelLineStart;\n        this.widthOfHiddenLineTextBefore = widthOfHiddenLineTextBefore;\n        this.distanceToModelLineEnd = distanceToModelLineEnd;\n        this._visibleTextAreaBrand = undefined;\n        this.startPosition = null;\n        this.endPosition = null;\n        this.visibleTextareaStart = null;\n        this.visibleTextareaEnd = null;\n        /**\n         * When doing composition, the currently composed text might be split up into\n         * multiple tokens, then merged again into a single token, etc. Here we attempt\n         * to keep the presentation of the <textarea> stable by using the previous used\n         * style if multiple tokens come into play. This avoids flickering.\n         */\n        this._previousPresentation = null;\n    }\n    prepareRender(visibleRangeProvider) {\n        const startModelPosition = new Position(this.modelLineNumber, this.distanceToModelLineStart + 1);\n        const endModelPosition = new Position(this.modelLineNumber, this._context.viewModel.model.getLineMaxColumn(this.modelLineNumber) - this.distanceToModelLineEnd);\n        this.startPosition = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(startModelPosition);\n        this.endPosition = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(endModelPosition);\n        if (this.startPosition.lineNumber === this.endPosition.lineNumber) {\n            this.visibleTextareaStart = visibleRangeProvider.visibleRangeForPosition(this.startPosition);\n            this.visibleTextareaEnd = visibleRangeProvider.visibleRangeForPosition(this.endPosition);\n        }\n        else {\n            // TODO: what if the view positions are not on the same line?\n            this.visibleTextareaStart = null;\n            this.visibleTextareaEnd = null;\n        }\n    }\n    definePresentation(tokenPresentation) {\n        if (!this._previousPresentation) {\n            // To avoid flickering, once set, always reuse a presentation throughout the entire IME session\n            if (tokenPresentation) {\n                this._previousPresentation = tokenPresentation;\n            }\n            else {\n                this._previousPresentation = {\n                    foreground: 1 /* ColorId.DefaultForeground */,\n                    italic: false,\n                    bold: false,\n                    underline: false,\n                    strikethrough: false,\n                };\n            }\n        }\n        return this._previousPresentation;\n    }\n}\nconst canUseZeroSizeTextarea = (browser.isFirefox);\nlet TextAreaHandler = class TextAreaHandler extends ViewPart {\n    constructor(context, viewController, visibleRangeProvider, _keybindingService, _instantiationService) {\n        super(context);\n        this._keybindingService = _keybindingService;\n        this._instantiationService = _instantiationService;\n        this._primaryCursorPosition = new Position(1, 1);\n        this._primaryCursorVisibleRange = null;\n        this._viewController = viewController;\n        this._visibleRangeProvider = visibleRangeProvider;\n        this._scrollLeft = 0;\n        this._scrollTop = 0;\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(146 /* EditorOption.layoutInfo */);\n        this._setAccessibilityOptions(options);\n        this._contentLeft = layoutInfo.contentLeft;\n        this._contentWidth = layoutInfo.contentWidth;\n        this._contentHeight = layoutInfo.height;\n        this._fontInfo = options.get(50 /* EditorOption.fontInfo */);\n        this._lineHeight = options.get(67 /* EditorOption.lineHeight */);\n        this._emptySelectionClipboard = options.get(37 /* EditorOption.emptySelectionClipboard */);\n        this._copyWithSyntaxHighlighting = options.get(25 /* EditorOption.copyWithSyntaxHighlighting */);\n        this._visibleTextArea = null;\n        this._selections = [new Selection(1, 1, 1, 1)];\n        this._modelSelections = [new Selection(1, 1, 1, 1)];\n        this._lastRenderPosition = null;\n        // Text Area (The focus will always be in the textarea when the cursor is blinking)\n        this.textArea = createFastDomNode(document.createElement('textarea'));\n        PartFingerprints.write(this.textArea, 7 /* PartFingerprint.TextArea */);\n        this.textArea.setClassName(`inputarea ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);\n        this.textArea.setAttribute('wrap', this._textAreaWrapping && !this._visibleTextArea ? 'on' : 'off');\n        const { tabSize } = this._context.viewModel.model.getOptions();\n        this.textArea.domNode.style.tabSize = `${tabSize * this._fontInfo.spaceWidth}px`;\n        this.textArea.setAttribute('autocorrect', 'off');\n        this.textArea.setAttribute('autocapitalize', 'off');\n        this.textArea.setAttribute('autocomplete', 'off');\n        this.textArea.setAttribute('spellcheck', 'false');\n        this.textArea.setAttribute('aria-label', this._getAriaLabel(options));\n        this.textArea.setAttribute('aria-required', options.get(5 /* EditorOption.ariaRequired */) ? 'true' : 'false');\n        this.textArea.setAttribute('tabindex', String(options.get(125 /* EditorOption.tabIndex */)));\n        this.textArea.setAttribute('role', 'textbox');\n        this.textArea.setAttribute('aria-roledescription', nls.localize('editor', \"editor\"));\n        this.textArea.setAttribute('aria-multiline', 'true');\n        this.textArea.setAttribute('aria-autocomplete', options.get(92 /* EditorOption.readOnly */) ? 'none' : 'both');\n        this._ensureReadOnlyAttribute();\n        this.textAreaCover = createFastDomNode(document.createElement('div'));\n        this.textAreaCover.setPosition('absolute');\n        const simpleModel = {\n            getLineCount: () => {\n                return this._context.viewModel.getLineCount();\n            },\n            getLineMaxColumn: (lineNumber) => {\n                return this._context.viewModel.getLineMaxColumn(lineNumber);\n            },\n            getValueInRange: (range, eol) => {\n                return this._context.viewModel.getValueInRange(range, eol);\n            },\n            getValueLengthInRange: (range, eol) => {\n                return this._context.viewModel.getValueLengthInRange(range, eol);\n            },\n            modifyPosition: (position, offset) => {\n                return this._context.viewModel.modifyPosition(position, offset);\n            }\n        };\n        const textAreaInputHost = {\n            getDataToCopy: () => {\n                const rawTextToCopy = this._context.viewModel.getPlainTextToCopy(this._modelSelections, this._emptySelectionClipboard, platform.isWindows);\n                const newLineCharacter = this._context.viewModel.model.getEOL();\n                const isFromEmptySelection = (this._emptySelectionClipboard && this._modelSelections.length === 1 && this._modelSelections[0].isEmpty());\n                const multicursorText = (Array.isArray(rawTextToCopy) ? rawTextToCopy : null);\n                const text = (Array.isArray(rawTextToCopy) ? rawTextToCopy.join(newLineCharacter) : rawTextToCopy);\n                let html = undefined;\n                let mode = null;\n                if (CopyOptions.forceCopyWithSyntaxHighlighting || (this._copyWithSyntaxHighlighting && text.length < 65536)) {\n                    const richText = this._context.viewModel.getRichTextToCopy(this._modelSelections, this._emptySelectionClipboard);\n                    if (richText) {\n                        html = richText.html;\n                        mode = richText.mode;\n                    }\n                }\n                return {\n                    isFromEmptySelection,\n                    multicursorText,\n                    text,\n                    html,\n                    mode\n                };\n            },\n            getScreenReaderContent: () => {\n                if (this._accessibilitySupport === 1 /* AccessibilitySupport.Disabled */) {\n                    // We know for a fact that a screen reader is not attached\n                    // On OSX, we write the character before the cursor to allow for \"long-press\" composition\n                    // Also on OSX, we write the word before the cursor to allow for the Accessibility Keyboard to give good hints\n                    const selection = this._selections[0];\n                    if (platform.isMacintosh && selection.isEmpty()) {\n                        const position = selection.getStartPosition();\n                        let textBefore = this._getWordBeforePosition(position);\n                        if (textBefore.length === 0) {\n                            textBefore = this._getCharacterBeforePosition(position);\n                        }\n                        if (textBefore.length > 0) {\n                            return new TextAreaState(textBefore, textBefore.length, textBefore.length, Range.fromPositions(position), 0);\n                        }\n                    }\n                    // on macOS, write current selection into textarea will allow system text services pick selected text,\n                    // but we still want to limit the amount of text given Chromium handles very poorly text even of a few\n                    // thousand chars\n                    // (https://github.com/microsoft/vscode/issues/27799)\n                    const LIMIT_CHARS = 500;\n                    if (platform.isMacintosh && !selection.isEmpty() && simpleModel.getValueLengthInRange(selection, 0 /* EndOfLinePreference.TextDefined */) < LIMIT_CHARS) {\n                        const text = simpleModel.getValueInRange(selection, 0 /* EndOfLinePreference.TextDefined */);\n                        return new TextAreaState(text, 0, text.length, selection, 0);\n                    }\n                    // on Safari, document.execCommand('cut') and document.execCommand('copy') will just not work\n                    // if the textarea has no content selected. So if there is an editor selection, ensure something\n                    // is selected in the textarea.\n                    if (browser.isSafari && !selection.isEmpty()) {\n                        const placeholderText = 'vscode-placeholder';\n                        return new TextAreaState(placeholderText, 0, placeholderText.length, null, undefined);\n                    }\n                    return TextAreaState.EMPTY;\n                }\n                if (browser.isAndroid) {\n                    // when tapping in the editor on a word, Android enters composition mode.\n                    // in the `compositionstart` event we cannot clear the textarea, because\n                    // it then forgets to ever send a `compositionend`.\n                    // we therefore only write the current word in the textarea\n                    const selection = this._selections[0];\n                    if (selection.isEmpty()) {\n                        const position = selection.getStartPosition();\n                        const [wordAtPosition, positionOffsetInWord] = this._getAndroidWordAtPosition(position);\n                        if (wordAtPosition.length > 0) {\n                            return new TextAreaState(wordAtPosition, positionOffsetInWord, positionOffsetInWord, Range.fromPositions(position), 0);\n                        }\n                    }\n                    return TextAreaState.EMPTY;\n                }\n                return PagedScreenReaderStrategy.fromEditorSelection(simpleModel, this._selections[0], this._accessibilityPageSize, this._accessibilitySupport === 0 /* AccessibilitySupport.Unknown */);\n            },\n            deduceModelPosition: (viewAnchorPosition, deltaOffset, lineFeedCnt) => {\n                return this._context.viewModel.deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt);\n            }\n        };\n        const textAreaWrapper = this._register(new TextAreaWrapper(this.textArea.domNode));\n        this._textAreaInput = this._register(this._instantiationService.createInstance(TextAreaInput, textAreaInputHost, textAreaWrapper, platform.OS, {\n            isAndroid: browser.isAndroid,\n            isChrome: browser.isChrome,\n            isFirefox: browser.isFirefox,\n            isSafari: browser.isSafari,\n        }));\n        this._register(this._textAreaInput.onKeyDown((e) => {\n            this._viewController.emitKeyDown(e);\n        }));\n        this._register(this._textAreaInput.onKeyUp((e) => {\n            this._viewController.emitKeyUp(e);\n        }));\n        this._register(this._textAreaInput.onPaste((e) => {\n            let pasteOnNewLine = false;\n            let multicursorText = null;\n            let mode = null;\n            if (e.metadata) {\n                pasteOnNewLine = (this._emptySelectionClipboard && !!e.metadata.isFromEmptySelection);\n                multicursorText = (typeof e.metadata.multicursorText !== 'undefined' ? e.metadata.multicursorText : null);\n                mode = e.metadata.mode;\n            }\n            this._viewController.paste(e.text, pasteOnNewLine, multicursorText, mode);\n        }));\n        this._register(this._textAreaInput.onCut(() => {\n            this._viewController.cut();\n        }));\n        this._register(this._textAreaInput.onType((e) => {\n            if (e.replacePrevCharCnt || e.replaceNextCharCnt || e.positionDelta) {\n                // must be handled through the new command\n                if (_debugComposition) {\n                    console.log(` => compositionType: <<${e.text}>>, ${e.replacePrevCharCnt}, ${e.replaceNextCharCnt}, ${e.positionDelta}`);\n                }\n                this._viewController.compositionType(e.text, e.replacePrevCharCnt, e.replaceNextCharCnt, e.positionDelta);\n            }\n            else {\n                if (_debugComposition) {\n                    console.log(` => type: <<${e.text}>>`);\n                }\n                this._viewController.type(e.text);\n            }\n        }));\n        this._register(this._textAreaInput.onSelectionChangeRequest((modelSelection) => {\n            this._viewController.setSelection(modelSelection);\n        }));\n        this._register(this._textAreaInput.onCompositionStart((e) => {\n            // The textarea might contain some content when composition starts.\n            //\n            // When we make the textarea visible, it always has a height of 1 line,\n            // so we don't need to worry too much about content on lines above or below\n            // the selection.\n            //\n            // However, the text on the current line needs to be made visible because\n            // some IME methods allow to move to other glyphs on the current line\n            // (by pressing arrow keys).\n            //\n            // (1) The textarea might contain only some parts of the current line,\n            // like the word before the selection. Also, the content inside the textarea\n            // can grow or shrink as composition occurs. We therefore anchor the textarea\n            // in terms of distance to a certain line start and line end.\n            //\n            // (2) Also, we should not make \\t characters visible, because their rendering\n            // inside the <textarea> will not align nicely with our rendering. We therefore\n            // will hide (if necessary) some of the leading text on the current line.\n            const ta = this.textArea.domNode;\n            const modelSelection = this._modelSelections[0];\n            const { distanceToModelLineStart, widthOfHiddenTextBefore } = (() => {\n                // Find the text that is on the current line before the selection\n                const textBeforeSelection = ta.value.substring(0, Math.min(ta.selectionStart, ta.selectionEnd));\n                const lineFeedOffset1 = textBeforeSelection.lastIndexOf('\\n');\n                const lineTextBeforeSelection = textBeforeSelection.substring(lineFeedOffset1 + 1);\n                // We now search to see if we should hide some part of it (if it contains \\t)\n                const tabOffset1 = lineTextBeforeSelection.lastIndexOf('\\t');\n                const desiredVisibleBeforeCharCount = lineTextBeforeSelection.length - tabOffset1 - 1;\n                const startModelPosition = modelSelection.getStartPosition();\n                const visibleBeforeCharCount = Math.min(startModelPosition.column - 1, desiredVisibleBeforeCharCount);\n                const distanceToModelLineStart = startModelPosition.column - 1 - visibleBeforeCharCount;\n                const hiddenLineTextBefore = lineTextBeforeSelection.substring(0, lineTextBeforeSelection.length - visibleBeforeCharCount);\n                const { tabSize } = this._context.viewModel.model.getOptions();\n                const widthOfHiddenTextBefore = measureText(this.textArea.domNode.ownerDocument, hiddenLineTextBefore, this._fontInfo, tabSize);\n                return { distanceToModelLineStart, widthOfHiddenTextBefore };\n            })();\n            const { distanceToModelLineEnd } = (() => {\n                // Find the text that is on the current line after the selection\n                const textAfterSelection = ta.value.substring(Math.max(ta.selectionStart, ta.selectionEnd));\n                const lineFeedOffset2 = textAfterSelection.indexOf('\\n');\n                const lineTextAfterSelection = lineFeedOffset2 === -1 ? textAfterSelection : textAfterSelection.substring(0, lineFeedOffset2);\n                const tabOffset2 = lineTextAfterSelection.indexOf('\\t');\n                const desiredVisibleAfterCharCount = (tabOffset2 === -1 ? lineTextAfterSelection.length : lineTextAfterSelection.length - tabOffset2 - 1);\n                const endModelPosition = modelSelection.getEndPosition();\n                const visibleAfterCharCount = Math.min(this._context.viewModel.model.getLineMaxColumn(endModelPosition.lineNumber) - endModelPosition.column, desiredVisibleAfterCharCount);\n                const distanceToModelLineEnd = this._context.viewModel.model.getLineMaxColumn(endModelPosition.lineNumber) - endModelPosition.column - visibleAfterCharCount;\n                return { distanceToModelLineEnd };\n            })();\n            // Scroll to reveal the location in the editor where composition occurs\n            this._context.viewModel.revealRange('keyboard', true, Range.fromPositions(this._selections[0].getStartPosition()), 0 /* viewEvents.VerticalRevealType.Simple */, 1 /* ScrollType.Immediate */);\n            this._visibleTextArea = new VisibleTextAreaData(this._context, modelSelection.startLineNumber, distanceToModelLineStart, widthOfHiddenTextBefore, distanceToModelLineEnd);\n            // We turn off wrapping if the <textarea> becomes visible for composition\n            this.textArea.setAttribute('wrap', this._textAreaWrapping && !this._visibleTextArea ? 'on' : 'off');\n            this._visibleTextArea.prepareRender(this._visibleRangeProvider);\n            this._render();\n            // Show the textarea\n            this.textArea.setClassName(`inputarea ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME} ime-input`);\n            this._viewController.compositionStart();\n            this._context.viewModel.onCompositionStart();\n        }));\n        this._register(this._textAreaInput.onCompositionUpdate((e) => {\n            if (!this._visibleTextArea) {\n                return;\n            }\n            this._visibleTextArea.prepareRender(this._visibleRangeProvider);\n            this._render();\n        }));\n        this._register(this._textAreaInput.onCompositionEnd(() => {\n            this._visibleTextArea = null;\n            // We turn on wrapping as necessary if the <textarea> hides after composition\n            this.textArea.setAttribute('wrap', this._textAreaWrapping && !this._visibleTextArea ? 'on' : 'off');\n            this._render();\n            this.textArea.setClassName(`inputarea ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);\n            this._viewController.compositionEnd();\n            this._context.viewModel.onCompositionEnd();\n        }));\n        this._register(this._textAreaInput.onFocus(() => {\n            this._context.viewModel.setHasFocus(true);\n        }));\n        this._register(this._textAreaInput.onBlur(() => {\n            this._context.viewModel.setHasFocus(false);\n        }));\n        this._register(IME.onDidChange(() => {\n            this._ensureReadOnlyAttribute();\n        }));\n    }\n    writeScreenReaderContent(reason) {\n        this._textAreaInput.writeNativeTextAreaContent(reason);\n    }\n    dispose() {\n        super.dispose();\n    }\n    _getAndroidWordAtPosition(position) {\n        const ANDROID_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\",.<>/?';\n        const lineContent = this._context.viewModel.getLineContent(position.lineNumber);\n        const wordSeparators = getMapForWordSeparators(ANDROID_WORD_SEPARATORS, []);\n        let goingLeft = true;\n        let startColumn = position.column;\n        let goingRight = true;\n        let endColumn = position.column;\n        let distance = 0;\n        while (distance < 50 && (goingLeft || goingRight)) {\n            if (goingLeft && startColumn <= 1) {\n                goingLeft = false;\n            }\n            if (goingLeft) {\n                const charCode = lineContent.charCodeAt(startColumn - 2);\n                const charClass = wordSeparators.get(charCode);\n                if (charClass !== 0 /* WordCharacterClass.Regular */) {\n                    goingLeft = false;\n                }\n                else {\n                    startColumn--;\n                }\n            }\n            if (goingRight && endColumn > lineContent.length) {\n                goingRight = false;\n            }\n            if (goingRight) {\n                const charCode = lineContent.charCodeAt(endColumn - 1);\n                const charClass = wordSeparators.get(charCode);\n                if (charClass !== 0 /* WordCharacterClass.Regular */) {\n                    goingRight = false;\n                }\n                else {\n                    endColumn++;\n                }\n            }\n            distance++;\n        }\n        return [lineContent.substring(startColumn - 1, endColumn - 1), position.column - startColumn];\n    }\n    _getWordBeforePosition(position) {\n        const lineContent = this._context.viewModel.getLineContent(position.lineNumber);\n        const wordSeparators = getMapForWordSeparators(this._context.configuration.options.get(132 /* EditorOption.wordSeparators */), []);\n        let column = position.column;\n        let distance = 0;\n        while (column > 1) {\n            const charCode = lineContent.charCodeAt(column - 2);\n            const charClass = wordSeparators.get(charCode);\n            if (charClass !== 0 /* WordCharacterClass.Regular */ || distance > 50) {\n                return lineContent.substring(column - 1, position.column - 1);\n            }\n            distance++;\n            column--;\n        }\n        return lineContent.substring(0, position.column - 1);\n    }\n    _getCharacterBeforePosition(position) {\n        if (position.column > 1) {\n            const lineContent = this._context.viewModel.getLineContent(position.lineNumber);\n            const charBefore = lineContent.charAt(position.column - 2);\n            if (!strings.isHighSurrogate(charBefore.charCodeAt(0))) {\n                return charBefore;\n            }\n        }\n        return '';\n    }\n    _getAriaLabel(options) {\n        const accessibilitySupport = options.get(2 /* EditorOption.accessibilitySupport */);\n        if (accessibilitySupport === 1 /* AccessibilitySupport.Disabled */) {\n            const toggleKeybindingLabel = this._keybindingService.lookupKeybinding('editor.action.toggleScreenReaderAccessibilityMode')?.getAriaLabel();\n            const runCommandKeybindingLabel = this._keybindingService.lookupKeybinding('workbench.action.showCommands')?.getAriaLabel();\n            const keybindingEditorKeybindingLabel = this._keybindingService.lookupKeybinding('workbench.action.openGlobalKeybindings')?.getAriaLabel();\n            const editorNotAccessibleMessage = nls.localize('accessibilityModeOff', \"The editor is not accessible at this time.\");\n            if (toggleKeybindingLabel) {\n                return nls.localize('accessibilityOffAriaLabel', \"{0} To enable screen reader optimized mode, use {1}\", editorNotAccessibleMessage, toggleKeybindingLabel);\n            }\n            else if (runCommandKeybindingLabel) {\n                return nls.localize('accessibilityOffAriaLabelNoKb', \"{0} To enable screen reader optimized mode, open the quick pick with {1} and run the command Toggle Screen Reader Accessibility Mode, which is currently not triggerable via keyboard.\", editorNotAccessibleMessage, runCommandKeybindingLabel);\n            }\n            else if (keybindingEditorKeybindingLabel) {\n                return nls.localize('accessibilityOffAriaLabelNoKbs', \"{0} Please assign a keybinding for the command Toggle Screen Reader Accessibility Mode by accessing the keybindings editor with {1} and run it.\", editorNotAccessibleMessage, keybindingEditorKeybindingLabel);\n            }\n            else {\n                // SOS\n                return editorNotAccessibleMessage;\n            }\n        }\n        return options.get(4 /* EditorOption.ariaLabel */);\n    }\n    _setAccessibilityOptions(options) {\n        this._accessibilitySupport = options.get(2 /* EditorOption.accessibilitySupport */);\n        const accessibilityPageSize = options.get(3 /* EditorOption.accessibilityPageSize */);\n        if (this._accessibilitySupport === 2 /* AccessibilitySupport.Enabled */ && accessibilityPageSize === EditorOptions.accessibilityPageSize.defaultValue) {\n            // If a screen reader is attached and the default value is not set we should automatically increase the page size to 500 for a better experience\n            this._accessibilityPageSize = 500;\n        }\n        else {\n            this._accessibilityPageSize = accessibilityPageSize;\n        }\n        // When wrapping is enabled and a screen reader might be attached,\n        // we will size the textarea to match the width used for wrapping points computation (see `domLineBreaksComputer.ts`).\n        // This is because screen readers will read the text in the textarea and we'd like that the\n        // wrapping points in the textarea match the wrapping points in the editor.\n        const layoutInfo = options.get(146 /* EditorOption.layoutInfo */);\n        const wrappingColumn = layoutInfo.wrappingColumn;\n        if (wrappingColumn !== -1 && this._accessibilitySupport !== 1 /* AccessibilitySupport.Disabled */) {\n            const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n            this._textAreaWrapping = true;\n            this._textAreaWidth = Math.round(wrappingColumn * fontInfo.typicalHalfwidthCharacterWidth);\n        }\n        else {\n            this._textAreaWrapping = false;\n            this._textAreaWidth = (canUseZeroSizeTextarea ? 0 : 1);\n        }\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(146 /* EditorOption.layoutInfo */);\n        this._setAccessibilityOptions(options);\n        this._contentLeft = layoutInfo.contentLeft;\n        this._contentWidth = layoutInfo.contentWidth;\n        this._contentHeight = layoutInfo.height;\n        this._fontInfo = options.get(50 /* EditorOption.fontInfo */);\n        this._lineHeight = options.get(67 /* EditorOption.lineHeight */);\n        this._emptySelectionClipboard = options.get(37 /* EditorOption.emptySelectionClipboard */);\n        this._copyWithSyntaxHighlighting = options.get(25 /* EditorOption.copyWithSyntaxHighlighting */);\n        this.textArea.setAttribute('wrap', this._textAreaWrapping && !this._visibleTextArea ? 'on' : 'off');\n        const { tabSize } = this._context.viewModel.model.getOptions();\n        this.textArea.domNode.style.tabSize = `${tabSize * this._fontInfo.spaceWidth}px`;\n        this.textArea.setAttribute('aria-label', this._getAriaLabel(options));\n        this.textArea.setAttribute('aria-required', options.get(5 /* EditorOption.ariaRequired */) ? 'true' : 'false');\n        this.textArea.setAttribute('tabindex', String(options.get(125 /* EditorOption.tabIndex */)));\n        if (e.hasChanged(34 /* EditorOption.domReadOnly */) || e.hasChanged(92 /* EditorOption.readOnly */)) {\n            this._ensureReadOnlyAttribute();\n        }\n        if (e.hasChanged(2 /* EditorOption.accessibilitySupport */)) {\n            this._textAreaInput.writeNativeTextAreaContent('strategy changed');\n        }\n        return true;\n    }\n    onCursorStateChanged(e) {\n        this._selections = e.selections.slice(0);\n        this._modelSelections = e.modelSelections.slice(0);\n        // We must update the <textarea> synchronously, otherwise long press IME on macos breaks.\n        // See https://github.com/microsoft/vscode/issues/165821\n        this._textAreaInput.writeNativeTextAreaContent('selection changed');\n        return true;\n    }\n    onDecorationsChanged(e) {\n        // true for inline decorations that can end up relayouting text\n        return true;\n    }\n    onFlushed(e) {\n        return true;\n    }\n    onLinesChanged(e) {\n        return true;\n    }\n    onLinesDeleted(e) {\n        return true;\n    }\n    onLinesInserted(e) {\n        return true;\n    }\n    onScrollChanged(e) {\n        this._scrollLeft = e.scrollLeft;\n        this._scrollTop = e.scrollTop;\n        return true;\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    // --- end event handlers\n    // --- begin view API\n    isFocused() {\n        return this._textAreaInput.isFocused();\n    }\n    focusTextArea() {\n        this._textAreaInput.focusTextArea();\n    }\n    getLastRenderData() {\n        return this._lastRenderPosition;\n    }\n    setAriaOptions(options) {\n        if (options.activeDescendant) {\n            this.textArea.setAttribute('aria-haspopup', 'true');\n            this.textArea.setAttribute('aria-autocomplete', 'list');\n            this.textArea.setAttribute('aria-activedescendant', options.activeDescendant);\n        }\n        else {\n            this.textArea.setAttribute('aria-haspopup', 'false');\n            this.textArea.setAttribute('aria-autocomplete', 'both');\n            this.textArea.removeAttribute('aria-activedescendant');\n        }\n        if (options.role) {\n            this.textArea.setAttribute('role', options.role);\n        }\n    }\n    // --- end view API\n    _ensureReadOnlyAttribute() {\n        const options = this._context.configuration.options;\n        // When someone requests to disable IME, we set the \"readonly\" attribute on the <textarea>.\n        // This will prevent composition.\n        const useReadOnly = !IME.enabled || (options.get(34 /* EditorOption.domReadOnly */) && options.get(92 /* EditorOption.readOnly */));\n        if (useReadOnly) {\n            this.textArea.setAttribute('readonly', 'true');\n        }\n        else {\n            this.textArea.removeAttribute('readonly');\n        }\n    }\n    prepareRender(ctx) {\n        this._primaryCursorPosition = new Position(this._selections[0].positionLineNumber, this._selections[0].positionColumn);\n        this._primaryCursorVisibleRange = ctx.visibleRangeForPosition(this._primaryCursorPosition);\n        this._visibleTextArea?.prepareRender(ctx);\n    }\n    render(ctx) {\n        this._textAreaInput.writeNativeTextAreaContent('render');\n        this._render();\n    }\n    _render() {\n        if (this._visibleTextArea) {\n            // The text area is visible for composition reasons\n            const visibleStart = this._visibleTextArea.visibleTextareaStart;\n            const visibleEnd = this._visibleTextArea.visibleTextareaEnd;\n            const startPosition = this._visibleTextArea.startPosition;\n            const endPosition = this._visibleTextArea.endPosition;\n            if (startPosition && endPosition && visibleStart && visibleEnd && visibleEnd.left >= this._scrollLeft && visibleStart.left <= this._scrollLeft + this._contentWidth) {\n                const top = (this._context.viewLayout.getVerticalOffsetForLineNumber(this._primaryCursorPosition.lineNumber) - this._scrollTop);\n                const lineCount = this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));\n                let scrollLeft = this._visibleTextArea.widthOfHiddenLineTextBefore;\n                let left = (this._contentLeft + visibleStart.left - this._scrollLeft);\n                // See https://github.com/microsoft/vscode/issues/141725#issuecomment-1050670841\n                // Here we are adding +1 to avoid flickering that might be caused by having a width that is too small.\n                // This could be caused by rounding errors that might only show up with certain font families.\n                // In other words, a pixel might be lost when doing something like\n                //      `Math.round(end) - Math.round(start)`\n                // vs\n                //      `Math.round(end - start)`\n                let width = visibleEnd.left - visibleStart.left + 1;\n                if (left < this._contentLeft) {\n                    // the textarea would be rendered on top of the margin,\n                    // so reduce its width. We use the same technique as\n                    // for hiding text before\n                    const delta = (this._contentLeft - left);\n                    left += delta;\n                    scrollLeft += delta;\n                    width -= delta;\n                }\n                if (width > this._contentWidth) {\n                    // the textarea would be wider than the content width,\n                    // so reduce its width.\n                    width = this._contentWidth;\n                }\n                // Try to render the textarea with the color/font style to match the text under it\n                const viewLineData = this._context.viewModel.getViewLineData(startPosition.lineNumber);\n                const startTokenIndex = viewLineData.tokens.findTokenIndexAtOffset(startPosition.column - 1);\n                const endTokenIndex = viewLineData.tokens.findTokenIndexAtOffset(endPosition.column - 1);\n                const textareaSpansSingleToken = (startTokenIndex === endTokenIndex);\n                const presentation = this._visibleTextArea.definePresentation((textareaSpansSingleToken ? viewLineData.tokens.getPresentation(startTokenIndex) : null));\n                this.textArea.domNode.scrollTop = lineCount * this._lineHeight;\n                this.textArea.domNode.scrollLeft = scrollLeft;\n                this._doRender({\n                    lastRenderPosition: null,\n                    top: top,\n                    left: left,\n                    width: width,\n                    height: this._lineHeight,\n                    useCover: false,\n                    color: (TokenizationRegistry.getColorMap() || [])[presentation.foreground],\n                    italic: presentation.italic,\n                    bold: presentation.bold,\n                    underline: presentation.underline,\n                    strikethrough: presentation.strikethrough\n                });\n            }\n            return;\n        }\n        if (!this._primaryCursorVisibleRange) {\n            // The primary cursor is outside the viewport => place textarea to the top left\n            this._renderAtTopLeft();\n            return;\n        }\n        const left = this._contentLeft + this._primaryCursorVisibleRange.left - this._scrollLeft;\n        if (left < this._contentLeft || left > this._contentLeft + this._contentWidth) {\n            // cursor is outside the viewport\n            this._renderAtTopLeft();\n            return;\n        }\n        const top = this._context.viewLayout.getVerticalOffsetForLineNumber(this._selections[0].positionLineNumber) - this._scrollTop;\n        if (top < 0 || top > this._contentHeight) {\n            // cursor is outside the viewport\n            this._renderAtTopLeft();\n            return;\n        }\n        // The primary cursor is in the viewport (at least vertically) => place textarea on the cursor\n        if (platform.isMacintosh || this._accessibilitySupport === 2 /* AccessibilitySupport.Enabled */) {\n            // For the popup emoji input, we will make the text area as high as the line height\n            // We will also make the fontSize and lineHeight the correct dimensions to help with the placement of these pickers\n            this._doRender({\n                lastRenderPosition: this._primaryCursorPosition,\n                top,\n                left: this._textAreaWrapping ? this._contentLeft : left,\n                width: this._textAreaWidth,\n                height: this._lineHeight,\n                useCover: false\n            });\n            // In case the textarea contains a word, we're going to try to align the textarea's cursor\n            // with our cursor by scrolling the textarea as much as possible\n            this.textArea.domNode.scrollLeft = this._primaryCursorVisibleRange.left;\n            const lineCount = this._textAreaInput.textAreaState.newlineCountBeforeSelection ?? this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));\n            this.textArea.domNode.scrollTop = lineCount * this._lineHeight;\n            return;\n        }\n        this._doRender({\n            lastRenderPosition: this._primaryCursorPosition,\n            top: top,\n            left: this._textAreaWrapping ? this._contentLeft : left,\n            width: this._textAreaWidth,\n            height: (canUseZeroSizeTextarea ? 0 : 1),\n            useCover: false\n        });\n    }\n    _newlinecount(text) {\n        let result = 0;\n        let startIndex = -1;\n        do {\n            startIndex = text.indexOf('\\n', startIndex + 1);\n            if (startIndex === -1) {\n                break;\n            }\n            result++;\n        } while (true);\n        return result;\n    }\n    _renderAtTopLeft() {\n        // (in WebKit the textarea is 1px by 1px because it cannot handle input to a 0x0 textarea)\n        // specifically, when doing Korean IME, setting the textarea to 0x0 breaks IME badly.\n        this._doRender({\n            lastRenderPosition: null,\n            top: 0,\n            left: 0,\n            width: this._textAreaWidth,\n            height: (canUseZeroSizeTextarea ? 0 : 1),\n            useCover: true\n        });\n    }\n    _doRender(renderData) {\n        this._lastRenderPosition = renderData.lastRenderPosition;\n        const ta = this.textArea;\n        const tac = this.textAreaCover;\n        applyFontInfo(ta, this._fontInfo);\n        ta.setTop(renderData.top);\n        ta.setLeft(renderData.left);\n        ta.setWidth(renderData.width);\n        ta.setHeight(renderData.height);\n        ta.setColor(renderData.color ? Color.Format.CSS.formatHex(renderData.color) : '');\n        ta.setFontStyle(renderData.italic ? 'italic' : '');\n        if (renderData.bold) {\n            // fontWeight is also set by `applyFontInfo`, so only overwrite it if necessary\n            ta.setFontWeight('bold');\n        }\n        ta.setTextDecoration(`${renderData.underline ? ' underline' : ''}${renderData.strikethrough ? ' line-through' : ''}`);\n        tac.setTop(renderData.useCover ? renderData.top : 0);\n        tac.setLeft(renderData.useCover ? renderData.left : 0);\n        tac.setWidth(renderData.useCover ? renderData.width : 0);\n        tac.setHeight(renderData.useCover ? renderData.height : 0);\n        const options = this._context.configuration.options;\n        if (options.get(57 /* EditorOption.glyphMargin */)) {\n            tac.setClassName('monaco-editor-background textAreaCover ' + Margin.OUTER_CLASS_NAME);\n        }\n        else {\n            if (options.get(68 /* EditorOption.lineNumbers */).renderType !== 0 /* RenderLineNumbersType.Off */) {\n                tac.setClassName('monaco-editor-background textAreaCover ' + LineNumbersOverlay.CLASS_NAME);\n            }\n            else {\n                tac.setClassName('monaco-editor-background textAreaCover');\n            }\n        }\n    }\n};\nTextAreaHandler = __decorate([\n    __param(3, IKeybindingService),\n    __param(4, IInstantiationService)\n], TextAreaHandler);\nexport { TextAreaHandler };\nfunction measureText(targetDocument, text, fontInfo, tabSize) {\n    if (text.length === 0) {\n        return 0;\n    }\n    const container = targetDocument.createElement('div');\n    container.style.position = 'absolute';\n    container.style.top = '-50000px';\n    container.style.width = '50000px';\n    const regularDomNode = targetDocument.createElement('span');\n    applyFontInfo(regularDomNode, fontInfo);\n    regularDomNode.style.whiteSpace = 'pre'; // just like the textarea\n    regularDomNode.style.tabSize = `${tabSize * fontInfo.spaceWidth}px`; // just like the textarea\n    regularDomNode.append(text);\n    container.appendChild(regularDomNode);\n    targetDocument.body.appendChild(container);\n    const res = regularDomNode.offsetWidth;\n    container.remove();\n    return res;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}