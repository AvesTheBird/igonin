{"ast":null,"code":"/**\n * A namespace.\n * @namespace VCDParser\n */\n\nconst async = require('async');\nconst {\n  extend\n} = require('./utils');\n\n/**\n * Parse VCD text content and generate a valid JSON representation.\n * The function returns a promise unless a callback is provided.\n * @name VCDParser~parse\n * @function\n * @param {string} content - The text content of the VCD file\n * @param {VCDParser~Options} [opts = {}] - Optional configuration to customize the parsing process\n * @param {VCDParser~ParseCallback} [cb = null] - Optional callback if you don't prefer to use promises\n * @return {Promise<VCDParser~ParsedData>} Promise object that resolves with the parsed data\n * @example\n * const VCDParser = require('vcd-parser');\n * VCDParser.parse(`\n\t$date\n\tTue Feb 12 14:01:15 2019\n\t$end\n\t$version\n\tIcarus Verilog\n\t$end\n\t$timescale\n\t1ns\n\t$end\n\t$scope module test_tb $end\n\t$var reg 1 ! clk $end\n\t$var wire 1 \" rst $end\n\t$upscope $end\n\t$enddefinitions $end\n\t#0\n\t$dumpvars\n\t0\"\n\t0!\n\t$end\n\t#15\n\t1\"\n\t#20\n\t1!\n\t#40\n\t0!\n\t#60\n\t1!\n\t#80\n\t0!\n\t#100\n\t1!\n\t#115\n`).then(parsedData => {\n *\tconsole.log(parsedData);\n// {\n// \t\"date\": \"Tue Feb 12 14:01:15 2019\",\n// \t\"version\": \"Icarus Verilog\",\n// \t\"timescale\": \"1ns\",\n// \t\"endtime\": \"115\",\n// \t\"scale\": \"1ns\",\n// \t\"signal\": [\n// \t\t{\n// \t\t\t\"type\": \"reg\",\n// \t\t\t\"size\": 1,\n// \t\t\t\"refName\": \"!\",\n// \t\t\t\"signalName\": \"clk\",\n// \t\t\t\"module\": \"test_tb\",\n// \t\t\t\"name\": \"test_tb.clk\",\n// \t\t\t\"wave\": [\n// \t\t\t\t[\n// \t\t\t\t\t\"0\",\n// \t\t\t\t\t\"0\"\n// \t\t\t\t],\n// \t\t\t\t[\n// \t\t\t\t\t\"20\",\n// \t\t\t\t\t\"1\"\n// \t\t\t\t],\n// \t\t\t\t[\n// \t\t\t\t\t\"40\",\n// \t\t\t\t\t\"0\"\n// \t\t\t\t],\n// \t\t\t\t[\n// \t\t\t\t\t\"60\",\n// \t\t\t\t\t\"1\"\n// \t\t\t\t],\n// \t\t\t\t[\n// \t\t\t\t\t\"80\",\n// \t\t\t\t\t\"0\"\n// \t\t\t\t],\n// \t\t\t\t[\n// \t\t\t\t\t\"100\",\n// \t\t\t\t\t\"1\"\n// \t\t\t\t]\n// \t\t\t]\n// \t\t},\n// \t\t{\n// \t\t\t\"type\": \"wire\",\n// \t\t\t\"size\": 1,\n// \t\t\t\"refName\": \"\\\"\",\n// \t\t\t\"signalName\": \"rst\",\n// \t\t\t\"module\": \"test_tb\",\n// \t\t\t\"name\": \"test_tb.rst\",\n// \t\t\t\"wave\": [\n// \t\t\t\t[\n// \t\t\t\t\t\"0\",\n// \t\t\t\t\t\"0\"\n// \t\t\t\t],\n// \t\t\t\t[\n// \t\t\t\t\t\"15\",\n// \t\t\t\t\t\"1\"\n// \t\t\t\t]\n// \t\t\t]\n// \t\t}\n// \t]\n// }\n * }).catch(err => {\n *\tconsole.error(err);\n * }).\n */\nconst parse = (content, opts = {}, cb) => {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  const wrappedCallback = () => {\n    if (typeof cb !== 'function') {\n      return null;\n    }\n    return function () {\n      return cb(null, ...arguments);\n    };\n  };\n  return new Promise((resolve, reject) => {\n    setTimeout(function () {\n      process.nextTick(function () {\n        const blocks = content.split(/\\s*\\$end\\s/gm).map(line => line.replace(/[\\n\\t]/gm, ' '));\n        const States = {\n          Init: 0,\n          Meta: 1,\n          Def: 2,\n          Dump: 3\n        };\n        let modules = [];\n        const meta = {};\n        const signals = [];\n        const signalMap = {};\n        let lastIndex;\n        for (let i = 0; i < blocks.length; i++) {\n          const block = blocks[i].trim();\n          if (block === '') {\n            continue;\n          }\n          const scopeMatches = /\\$(\\w+?)\\b/gm.exec(block);\n          if (scopeMatches) {\n            const scopeName = scopeMatches[1];\n            if (scopeName === 'scope') {\n              state = States.Def;\n              const scopeDefMatches = /\\$(\\w+)\\s+([\\s\\S]+)\\s+([\\s\\S]+)/gm.exec(block);\n              if (!scopeDefMatches) {\n                return reject({\n                  error: 'Invalid VCD data'\n                });\n              }\n              const modName = scopeDefMatches[3];\n              modules.push(modName);\n            } else if (scopeName === 'enddefinitions') {\n              state = States.Dump;\n              lastIndex = i + 1;\n              break;\n            } else if (scopeName === 'upscope') {\n              modules.pop();\n            } else if (scopeName === 'var') {\n              const varDefMatches = /\\$(\\w+)\\s+([\\s\\S]+?)\\s+(\\d+)\\s+([\\s\\S]+?)\\s+([\\s\\S]+)\\s*/gm.exec(block);\n              const signalName = varDefMatches[5].replace(/\\s+/, '');\n              const refName = varDefMatches[4];\n              if (!signalMap[refName]) {\n                const signal = {\n                  type: varDefMatches[2],\n                  size: parseInt(varDefMatches[3]),\n                  refName,\n                  signalName,\n                  module: modules[modules.length - 1] || '',\n                  name: modules.concat(signalName).join('.'),\n                  wave: []\n                };\n                signals.push(signal);\n                signalMap[refName] = signal;\n              }\n            } else {\n              const contentMatches = /\\$(\\w+)\\b\\s*([\\s\\S]+)?\\s*/gm.exec(block);\n              if (contentMatches) {\n                meta[contentMatches[1]] = contentMatches[2];\n              }\n            }\n          } else {\n            return reject({\n              error: 'Invalid VCD data'\n            });\n          }\n        }\n        if (!lastIndex) {\n          return reject({\n            error: 'Invalid VCD data'\n          });\n        }\n        let currentTime = 0;\n        const rem = content.split(/\\s*\\$enddefinitions\\s*/gm)[1];\n        if (!rem) {\n          return reject({\n            error: 'Invalid VCD data'\n          });\n        }\n        const lines = rem.split(/\\s*\\n\\s*/gm);\n        async.eachSeries(lines, function (line, callback) {\n          (function (line) {\n            setTimeout(function () {\n              const block = line.trim();\n              if (block === '') {\n                return callback();\n              }\n              const timingMatches = /^#(\\d+)$/gm.exec(block);\n              if (timingMatches) {\n                const time = parseInt(timingMatches[1]);\n                currentTime = time;\n              } else if (block === '$dumpvars') {\n                return callback();\n              } else if (block === '$end') {\n                return callback();\n              } else {\n                if (block.startsWith('x')) {\n                  const refName = block.substr(1).trim();\n                  if (!signalMap[refName]) {\n                    return callback({\n                      error: 'Invalid VCD data'\n                    });\n                  }\n                  const wave = signalMap[refName].wave;\n                  if (!opts.compress || !wave.length || wave[wave.length - 1][1] !== 'x') {\n                    signalMap[refName].wave.push([currentTime.toString(), 'x']);\n                  }\n                } else if (block.startsWith('b')) {\n                  const matches = /b([01xz]+)\\s+([\\s\\S]+)/gm.exec(block);\n                  if (!matches) {\n                    return callback({\n                      error: 'Invalid VCD data'\n                    });\n                  }\n                  const refName = matches[2];\n                  if (!signalMap[refName]) {\n                    return callback({\n                      error: 'Invalid VCD data'\n                    });\n                  }\n                  let value = matches[1];\n                  if (!opts.expandAmbigousBus) {\n                    if (/z/gm.test(value)) {\n                      value = 'z';\n                    } else if (/x/gm.test(value)) {\n                      value = 'x';\n                    }\n                  }\n                  const wave = signalMap[refName].wave;\n                  if (!opts.compress || !wave.length || wave[wave.length - 1][1] !== value) {\n                    signalMap[refName].wave.push([currentTime.toString(), value]);\n                  }\n                } else if (block.startsWith('z')) {\n                  const refName = block.substr(1).trim();\n                  if (!signalMap[refName]) {\n                    return callback({\n                      error: 'Invalid VCD data'\n                    });\n                  }\n                  const wave = signalMap[refName].wave;\n                  if (!opts.compress || !wave.length || wave[wave.length - 1][1] !== 'z') {\n                    signalMap[refName].wave.push([currentTime.toString(), 'z']);\n                  }\n                } else if (/^[01]([\\s\\S]+)/gm.test(block)) {\n                  const matches = /^([01])([\\s\\S]+)/gm.exec(block);\n                  const refName = matches[2];\n                  if (!signalMap[refName]) {\n                    return callback({\n                      error: 'Invalid VCD data'\n                    });\n                  }\n                  const converted = parseInt(matches[1], 10).toString(2);\n                  const wave = signalMap[refName].wave;\n                  if (!opts.compress || !wave.length || wave[wave.length - 1][1] !== converted) {\n                    signalMap[refName].wave.push([currentTime.toString(), converted]);\n                  }\n                } else if (block.startsWith('r')) {\n                  const matches = /r((\\d+\\.?\\d*)|(nan)|(x+)|(z+))\\s+([\\s\\S]+)/gm.exec(block);\n                  if (!matches) {\n                    return callback({\n                      error: 'Invalid VCD data'\n                    });\n                  }\n                  let value;\n                  if (matches[1] === 'nan' || matches[1].charAt(0) === 'x') {\n                    value = 'x';\n                  } else if (matches[1].charAt(0) === 'z') {\n                    value = 'z';\n                  } else {\n                    value = parseFloat(matches[1]);\n                  }\n                  const refName = matches[6];\n                  if (!signalMap[refName]) {\n                    return callback({\n                      error: 'Invalid VCD data'\n                    });\n                  }\n                  const wave = signalMap[refName].wave;\n                  if (!opts.compress || !wave.length || wave[wave.length - 1][1] !== converted) {\n                    signalMap[refName].wave.push([currentTime.toString(), isNaN(value) ? 'x' : value.toString()]);\n                  }\n                } else {\n                  return callback({\n                    error: 'Invalid VCD data'\n                  });\n                }\n              }\n              return callback();\n            }, 0);\n          })(line);\n        }, function (err) {\n          if (err) {\n            return reject(err);\n          }\n          meta.endtime = currentTime.toString();\n          meta.scale = meta.timescale;\n          return resolve(extend({}, meta, {\n            signal: signals\n          }));\n        });\n      });\n    }, 0);\n  }).then(wrappedCallback()).catch(cb);\n};\n\n/**\n * The optional configuration for the VCD parser\n * @typedef {Object} VCDParser~Options\n * @property {boolean} compress - Compress the output wave by ignoring the unchanged values\n * @property {boolean} expandAmbigousBus - If the bus has some ambigous value (z | x), it gets expanded to represent the whole bus signal\n */\n\n/**\n * The value of a signal at a specific point of time, represnted as a tuple [time, value]\n * @typedef {Array<number>} VCDParser~SignalValue\n * @property {number} 0 - The time of the event\n * @property {number} 1 - The value of the signal at that event\n */\n\n/**\n * The object representing one signal data\n * @typedef {Object} VCDParser~Signal\n * @property {string} name - The full name of the signal\n * @property {string} type - The type of the signal, e.g. wire, reg,..etc\n * @property {number} size - The size/width of the signal in bits\n * @property {string} refName - The reference for this signal used inside the VCD file\n * @property {string} module - The name of the top module for which this signal belongs\n * @property {Array<VCDParser~SignalValue>} wave - The values of the signal at different points of time\n */\n\n/**\n * The parsed VCD object generated by the parser\n * @typedef {Object} VCDParser~ParsedData\n * @property {string} [<\"meta\">] - The values of different initial meta-data, e.g. date, timescale..etc\n * @property {string} endtime - The endtime of the simulation\n * @property {string} scale - The time-scale unit of the simulation\n * @property {Array<VCDParser~Signal>} signal - The signal values of the simulation\n */\n\n/**\n * The callback for the parsing function.\n * @callback VCDParser~ParseCallback\n * @param {error} err - The error generated while parsing\n * @param {ParsedData} parsedJSON - The JSON document generated by the parser\n */\n\nmodule.exports = {\n  parse\n};","map":{"version":3,"names":["async","require","extend","parse","content","opts","cb","wrappedCallback","arguments","Promise","resolve","reject","setTimeout","process","nextTick","blocks","split","map","line","replace","States","Init","Meta","Def","Dump","modules","meta","signals","signalMap","lastIndex","i","length","block","trim","scopeMatches","exec","scopeName","state","scopeDefMatches","error","modName","push","pop","varDefMatches","signalName","refName","signal","type","size","parseInt","module","name","concat","join","wave","contentMatches","currentTime","rem","lines","eachSeries","callback","timingMatches","time","startsWith","substr","compress","toString","matches","value","expandAmbigousBus","test","converted","charAt","parseFloat","isNaN","err","endtime","scale","timescale","then","catch","exports"],"sources":["D:/OSPanel/domains/react/react-intro-main/node_modules/vcd-parser/lib/vcd-parser.js"],"sourcesContent":["/**\n * A namespace.\n * @namespace VCDParser\n */\n\nconst async = require('async');\nconst { extend } = require('./utils');\n\n/**\n * Parse VCD text content and generate a valid JSON representation.\n * The function returns a promise unless a callback is provided.\n * @name VCDParser~parse\n * @function\n * @param {string} content - The text content of the VCD file\n * @param {VCDParser~Options} [opts = {}] - Optional configuration to customize the parsing process\n * @param {VCDParser~ParseCallback} [cb = null] - Optional callback if you don't prefer to use promises\n * @return {Promise<VCDParser~ParsedData>} Promise object that resolves with the parsed data\n * @example\n * const VCDParser = require('vcd-parser');\n * VCDParser.parse(`\n\t$date\n\tTue Feb 12 14:01:15 2019\n\t$end\n\t$version\n\tIcarus Verilog\n\t$end\n\t$timescale\n\t1ns\n\t$end\n\t$scope module test_tb $end\n\t$var reg 1 ! clk $end\n\t$var wire 1 \" rst $end\n\t$upscope $end\n\t$enddefinitions $end\n\t#0\n\t$dumpvars\n\t0\"\n\t0!\n\t$end\n\t#15\n\t1\"\n\t#20\n\t1!\n\t#40\n\t0!\n\t#60\n\t1!\n\t#80\n\t0!\n\t#100\n\t1!\n\t#115\n`).then(parsedData => {\n *\tconsole.log(parsedData);\n// {\n// \t\"date\": \"Tue Feb 12 14:01:15 2019\",\n// \t\"version\": \"Icarus Verilog\",\n// \t\"timescale\": \"1ns\",\n// \t\"endtime\": \"115\",\n// \t\"scale\": \"1ns\",\n// \t\"signal\": [\n// \t\t{\n// \t\t\t\"type\": \"reg\",\n// \t\t\t\"size\": 1,\n// \t\t\t\"refName\": \"!\",\n// \t\t\t\"signalName\": \"clk\",\n// \t\t\t\"module\": \"test_tb\",\n// \t\t\t\"name\": \"test_tb.clk\",\n// \t\t\t\"wave\": [\n// \t\t\t\t[\n// \t\t\t\t\t\"0\",\n// \t\t\t\t\t\"0\"\n// \t\t\t\t],\n// \t\t\t\t[\n// \t\t\t\t\t\"20\",\n// \t\t\t\t\t\"1\"\n// \t\t\t\t],\n// \t\t\t\t[\n// \t\t\t\t\t\"40\",\n// \t\t\t\t\t\"0\"\n// \t\t\t\t],\n// \t\t\t\t[\n// \t\t\t\t\t\"60\",\n// \t\t\t\t\t\"1\"\n// \t\t\t\t],\n// \t\t\t\t[\n// \t\t\t\t\t\"80\",\n// \t\t\t\t\t\"0\"\n// \t\t\t\t],\n// \t\t\t\t[\n// \t\t\t\t\t\"100\",\n// \t\t\t\t\t\"1\"\n// \t\t\t\t]\n// \t\t\t]\n// \t\t},\n// \t\t{\n// \t\t\t\"type\": \"wire\",\n// \t\t\t\"size\": 1,\n// \t\t\t\"refName\": \"\\\"\",\n// \t\t\t\"signalName\": \"rst\",\n// \t\t\t\"module\": \"test_tb\",\n// \t\t\t\"name\": \"test_tb.rst\",\n// \t\t\t\"wave\": [\n// \t\t\t\t[\n// \t\t\t\t\t\"0\",\n// \t\t\t\t\t\"0\"\n// \t\t\t\t],\n// \t\t\t\t[\n// \t\t\t\t\t\"15\",\n// \t\t\t\t\t\"1\"\n// \t\t\t\t]\n// \t\t\t]\n// \t\t}\n// \t]\n// }\n * }).catch(err => {\n *\tconsole.error(err);\n * }).\n */\nconst parse = (content, opts = {}, cb) => {\n\tif (typeof opts === 'function') {\n\t\tcb = opts;\n\t\topts = {};\n\t}\n\tconst wrappedCallback = () => {\n\t\tif (typeof cb !== 'function') {\n\t\t\treturn null;\n\t\t}\n\t\treturn function() {\n\t\t\treturn cb(null, ...arguments);\n\t\t};\n\t};\n\treturn new Promise((resolve, reject) => {\n\t\tsetTimeout(function() {\n\t\t\tprocess.nextTick(function() {\n\t\t\t\tconst blocks = content\n\t\t\t\t\t.split(/\\s*\\$end\\s/gm)\n\t\t\t\t\t.map(line => line.replace(/[\\n\\t]/gm, ' '));\n\t\t\t\tconst States = {\n\t\t\t\t\tInit: 0,\n\t\t\t\t\tMeta: 1,\n\t\t\t\t\tDef: 2,\n\t\t\t\t\tDump: 3\n\t\t\t\t};\n\t\t\t\tlet modules = [];\n\t\t\t\tconst meta = {};\n\t\t\t\tconst signals = [];\n\t\t\t\tconst signalMap = {};\n\t\t\t\tlet lastIndex;\n\t\t\t\tfor (let i = 0; i < blocks.length; i++) {\n\t\t\t\t\tconst block = blocks[i].trim();\n\t\t\t\t\tif (block === '') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst scopeMatches = /\\$(\\w+?)\\b/gm.exec(block);\n\t\t\t\t\tif (scopeMatches) {\n\t\t\t\t\t\tconst scopeName = scopeMatches[1];\n\t\t\t\t\t\tif (scopeName === 'scope') {\n\t\t\t\t\t\t\tstate = States.Def;\n\t\t\t\t\t\t\tconst scopeDefMatches = /\\$(\\w+)\\s+([\\s\\S]+)\\s+([\\s\\S]+)/gm.exec(\n\t\t\t\t\t\t\t\tblock\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (!scopeDefMatches) {\n\t\t\t\t\t\t\t\treturn reject({\n\t\t\t\t\t\t\t\t\terror: 'Invalid VCD data'\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst modName = scopeDefMatches[3];\n\t\t\t\t\t\t\tmodules.push(modName);\n\t\t\t\t\t\t} else if (scopeName === 'enddefinitions') {\n\t\t\t\t\t\t\tstate = States.Dump;\n\t\t\t\t\t\t\tlastIndex = i + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (scopeName === 'upscope') {\n\t\t\t\t\t\t\tmodules.pop();\n\t\t\t\t\t\t} else if (scopeName === 'var') {\n\t\t\t\t\t\t\tconst varDefMatches = /\\$(\\w+)\\s+([\\s\\S]+?)\\s+(\\d+)\\s+([\\s\\S]+?)\\s+([\\s\\S]+)\\s*/gm.exec(\n\t\t\t\t\t\t\t\tblock\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst signalName = varDefMatches[5].replace(\n\t\t\t\t\t\t\t\t/\\s+/,\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst refName = varDefMatches[4];\n\t\t\t\t\t\t\tif (!signalMap[refName]) {\n\t\t\t\t\t\t\t\tconst signal = {\n\t\t\t\t\t\t\t\t\ttype: varDefMatches[2],\n\t\t\t\t\t\t\t\t\tsize: parseInt(varDefMatches[3]),\n\t\t\t\t\t\t\t\t\trefName,\n\t\t\t\t\t\t\t\t\tsignalName,\n\t\t\t\t\t\t\t\t\tmodule: modules[modules.length - 1] || '',\n\t\t\t\t\t\t\t\t\tname: modules.concat(signalName).join('.'),\n\t\t\t\t\t\t\t\t\twave: []\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tsignals.push(signal);\n\t\t\t\t\t\t\t\tsignalMap[refName] = signal;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst contentMatches = /\\$(\\w+)\\b\\s*([\\s\\S]+)?\\s*/gm.exec(\n\t\t\t\t\t\t\t\tblock\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (contentMatches) {\n\t\t\t\t\t\t\t\tmeta[contentMatches[1]] = contentMatches[2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn reject({\n\t\t\t\t\t\t\terror: 'Invalid VCD data'\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!lastIndex) {\n\t\t\t\t\treturn reject({\n\t\t\t\t\t\terror: 'Invalid VCD data'\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tlet currentTime = 0;\n\t\t\t\tconst rem = content.split(/\\s*\\$enddefinitions\\s*/gm)[1];\n\t\t\t\tif (!rem) {\n\t\t\t\t\treturn reject({\n\t\t\t\t\t\terror: 'Invalid VCD data'\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst lines = rem.split(/\\s*\\n\\s*/gm);\n\t\t\t\tasync.eachSeries(\n\t\t\t\t\tlines,\n\t\t\t\t\tfunction(line, callback) {\n\t\t\t\t\t\t(function(line) {\n\t\t\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t\t\tconst block = line.trim();\n\t\t\t\t\t\t\t\tif (block === '') {\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst timingMatches = /^#(\\d+)$/gm.exec(block);\n\t\t\t\t\t\t\t\tif (timingMatches) {\n\t\t\t\t\t\t\t\t\tconst time = parseInt(timingMatches[1]);\n\t\t\t\t\t\t\t\t\tcurrentTime = time;\n\t\t\t\t\t\t\t\t} else if (block === '$dumpvars') {\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t} else if (block === '$end') {\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (block.startsWith('x')) {\n\t\t\t\t\t\t\t\t\t\tconst refName = block.substr(1).trim();\n\t\t\t\t\t\t\t\t\t\tif (!signalMap[refName]) {\n\t\t\t\t\t\t\t\t\t\t\treturn callback({\n\t\t\t\t\t\t\t\t\t\t\t\terror: 'Invalid VCD data'\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst wave = signalMap[refName].wave;\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t!opts.compress ||\n\t\t\t\t\t\t\t\t\t\t\t!wave.length ||\n\t\t\t\t\t\t\t\t\t\t\twave[wave.length - 1][1] !== 'x'\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tsignalMap[refName].wave.push([\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentTime.toString(),\n\t\t\t\t\t\t\t\t\t\t\t\t'x'\n\t\t\t\t\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (block.startsWith('b')) {\n\t\t\t\t\t\t\t\t\t\tconst matches = /b([01xz]+)\\s+([\\s\\S]+)/gm.exec(\n\t\t\t\t\t\t\t\t\t\t\tblock\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tif (!matches) {\n\t\t\t\t\t\t\t\t\t\t\treturn callback({\n\t\t\t\t\t\t\t\t\t\t\t\terror: 'Invalid VCD data'\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst refName = matches[2];\n\t\t\t\t\t\t\t\t\t\tif (!signalMap[refName]) {\n\t\t\t\t\t\t\t\t\t\t\treturn callback({\n\t\t\t\t\t\t\t\t\t\t\t\terror: 'Invalid VCD data'\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tlet value = matches[1];\n\t\t\t\t\t\t\t\t\t\tif (!opts.expandAmbigousBus) {\n\t\t\t\t\t\t\t\t\t\t\tif (/z/gm.test(value)) {\n\t\t\t\t\t\t\t\t\t\t\t\tvalue = 'z';\n\t\t\t\t\t\t\t\t\t\t\t} else if (/x/gm.test(value)) {\n\t\t\t\t\t\t\t\t\t\t\t\tvalue = 'x';\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst wave = signalMap[refName].wave;\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t!opts.compress ||\n\t\t\t\t\t\t\t\t\t\t\t!wave.length ||\n\t\t\t\t\t\t\t\t\t\t\twave[wave.length - 1][1] !== value\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tsignalMap[refName].wave.push([\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentTime.toString(),\n\t\t\t\t\t\t\t\t\t\t\t\tvalue\n\t\t\t\t\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (block.startsWith('z')) {\n\t\t\t\t\t\t\t\t\t\tconst refName = block.substr(1).trim();\n\t\t\t\t\t\t\t\t\t\tif (!signalMap[refName]) {\n\t\t\t\t\t\t\t\t\t\t\treturn callback({\n\t\t\t\t\t\t\t\t\t\t\t\terror: 'Invalid VCD data'\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst wave = signalMap[refName].wave;\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t!opts.compress ||\n\t\t\t\t\t\t\t\t\t\t\t!wave.length ||\n\t\t\t\t\t\t\t\t\t\t\twave[wave.length - 1][1] !== 'z'\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tsignalMap[refName].wave.push([\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentTime.toString(),\n\t\t\t\t\t\t\t\t\t\t\t\t'z'\n\t\t\t\t\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (/^[01]([\\s\\S]+)/gm.test(block)) {\n\t\t\t\t\t\t\t\t\t\tconst matches = /^([01])([\\s\\S]+)/gm.exec(\n\t\t\t\t\t\t\t\t\t\t\tblock\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tconst refName = matches[2];\n\t\t\t\t\t\t\t\t\t\tif (!signalMap[refName]) {\n\t\t\t\t\t\t\t\t\t\t\treturn callback({\n\t\t\t\t\t\t\t\t\t\t\t\terror: 'Invalid VCD data'\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst converted = parseInt(\n\t\t\t\t\t\t\t\t\t\t\tmatches[1],\n\t\t\t\t\t\t\t\t\t\t\t10\n\t\t\t\t\t\t\t\t\t\t).toString(2);\n\t\t\t\t\t\t\t\t\t\tconst wave = signalMap[refName].wave;\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t!opts.compress ||\n\t\t\t\t\t\t\t\t\t\t\t!wave.length ||\n\t\t\t\t\t\t\t\t\t\t\twave[wave.length - 1][1] !==\n\t\t\t\t\t\t\t\t\t\t\t\tconverted\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tsignalMap[refName].wave.push([\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentTime.toString(),\n\t\t\t\t\t\t\t\t\t\t\t\tconverted\n\t\t\t\t\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (block.startsWith('r')) {\n\t\t\t\t\t\t\t\t\t\tconst matches = /r((\\d+\\.?\\d*)|(nan)|(x+)|(z+))\\s+([\\s\\S]+)/gm.exec(\n\t\t\t\t\t\t\t\t\t\t\tblock\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tif (!matches) {\n\t\t\t\t\t\t\t\t\t\t\treturn callback({\n\t\t\t\t\t\t\t\t\t\t\t\terror: 'Invalid VCD data'\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tlet value;\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\tmatches[1] === 'nan' ||\n\t\t\t\t\t\t\t\t\t\t\tmatches[1].charAt(0) === 'x'\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tvalue = 'x';\n\t\t\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\t\t\tmatches[1].charAt(0) === 'z'\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tvalue = 'z';\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tvalue = parseFloat(matches[1]);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst refName = matches[6];\n\t\t\t\t\t\t\t\t\t\tif (!signalMap[refName]) {\n\t\t\t\t\t\t\t\t\t\t\treturn callback({\n\t\t\t\t\t\t\t\t\t\t\t\terror: 'Invalid VCD data'\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst wave = signalMap[refName].wave;\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t!opts.compress ||\n\t\t\t\t\t\t\t\t\t\t\t!wave.length ||\n\t\t\t\t\t\t\t\t\t\t\twave[wave.length - 1][1] !==\n\t\t\t\t\t\t\t\t\t\t\t\tconverted\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tsignalMap[refName].wave.push([\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentTime.toString(),\n\t\t\t\t\t\t\t\t\t\t\t\tisNaN(value)\n\t\t\t\t\t\t\t\t\t\t\t\t\t? 'x'\n\t\t\t\t\t\t\t\t\t\t\t\t\t: value.toString()\n\t\t\t\t\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\treturn callback({\n\t\t\t\t\t\t\t\t\t\t\terror: 'Invalid VCD data'\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t}, 0);\n\t\t\t\t\t\t})(line);\n\t\t\t\t\t},\n\t\t\t\t\tfunction(err) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmeta.endtime = currentTime.toString();\n\t\t\t\t\t\tmeta.scale = meta.timescale;\n\t\t\t\t\t\treturn resolve(\n\t\t\t\t\t\t\textend({}, meta, {\n\t\t\t\t\t\t\t\tsignal: signals\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t\t}, 0);\n\t})\n\t\t.then(wrappedCallback())\n\t\t.catch(cb);\n};\n\n/**\n * The optional configuration for the VCD parser\n * @typedef {Object} VCDParser~Options\n * @property {boolean} compress - Compress the output wave by ignoring the unchanged values\n * @property {boolean} expandAmbigousBus - If the bus has some ambigous value (z | x), it gets expanded to represent the whole bus signal\n */\n\n/**\n * The value of a signal at a specific point of time, represnted as a tuple [time, value]\n * @typedef {Array<number>} VCDParser~SignalValue\n * @property {number} 0 - The time of the event\n * @property {number} 1 - The value of the signal at that event\n */\n\n/**\n * The object representing one signal data\n * @typedef {Object} VCDParser~Signal\n * @property {string} name - The full name of the signal\n * @property {string} type - The type of the signal, e.g. wire, reg,..etc\n * @property {number} size - The size/width of the signal in bits\n * @property {string} refName - The reference for this signal used inside the VCD file\n * @property {string} module - The name of the top module for which this signal belongs\n * @property {Array<VCDParser~SignalValue>} wave - The values of the signal at different points of time\n */\n\n/**\n * The parsed VCD object generated by the parser\n * @typedef {Object} VCDParser~ParsedData\n * @property {string} [<\"meta\">] - The values of different initial meta-data, e.g. date, timescale..etc\n * @property {string} endtime - The endtime of the simulation\n * @property {string} scale - The time-scale unit of the simulation\n * @property {Array<VCDParser~Signal>} signal - The signal values of the simulation\n */\n\n/**\n * The callback for the parsing function.\n * @callback VCDParser~ParseCallback\n * @param {error} err - The error generated while parsing\n * @param {ParsedData} parsedJSON - The JSON document generated by the parser\n */\n\nmodule.exports = { parse };\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAO,CAAC;AAC9B,MAAM;EAAEC;AAAO,CAAC,GAAGD,OAAO,CAAC,SAAS,CAAC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,KAAK,GAAGA,CAACC,OAAO,EAAEC,IAAI,GAAG,CAAC,CAAC,EAAEC,EAAE,KAAK;EACzC,IAAI,OAAOD,IAAI,KAAK,UAAU,EAAE;IAC/BC,EAAE,GAAGD,IAAI;IACTA,IAAI,GAAG,CAAC,CAAC;EACV;EACA,MAAME,eAAe,GAAGA,CAAA,KAAM;IAC7B,IAAI,OAAOD,EAAE,KAAK,UAAU,EAAE;MAC7B,OAAO,IAAI;IACZ;IACA,OAAO,YAAW;MACjB,OAAOA,EAAE,CAAC,IAAI,EAAE,GAAGE,SAAS,CAAC;IAC9B,CAAC;EACF,CAAC;EACD,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACvCC,UAAU,CAAC,YAAW;MACrBC,OAAO,CAACC,QAAQ,CAAC,YAAW;QAC3B,MAAMC,MAAM,GAAGX,OAAO,CACpBY,KAAK,CAAC,cAAc,CAAC,CACrBC,GAAG,CAACC,IAAI,I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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}