{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport InternalMouseEvent from '../event/InternalMouseEvent';\nimport { NONE, OUTLINE_COLOR, OUTLINE_HANDLE_FILLCOLOR, OUTLINE_HANDLE_STROKECOLOR, OUTLINE_STROKEWIDTH } from '../../util/Constants';\nimport Point from '../geometry/Point';\nimport Rectangle from '../geometry/Rectangle';\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport { Graph, defaultPlugins } from '../Graph';\nimport ImageShape from '../geometry/node/ImageShape';\nimport InternalEvent from '../event/InternalEvent';\nimport { getSource, isMouseEvent } from '../../util/EventUtils';\nimport { hasScrollbars } from '../../util/styleUtils';\n/**\n * @class Outline\n *\n * Implements an outline (aka overview) for a graph. Set {@link updateOnPan} to true\n * to enable updates while the source graph is panning.\n *\n * ### Example\n *\n * ```javascript\n * var outline = new mxOutline(graph, div);\n * ```\n *\n * If an outline is used in an {@link MaxWindow} in IE8 standards mode, the following\n * code makes sure that the shadow filter is not inherited and that any\n * transparent elements in the graph do not show the page background, but the\n * background of the graph container.\n *\n * ```javascript\n * if (document.documentMode == 8)\n * {\n *   container.style.filter = 'progid:DXImageTransform.Microsoft.alpha(opacity=100)';\n * }\n * ```\n *\n * To move the graph to the top, left corner the following code can be used.\n *\n * ```javascript\n * var scale = graph.view.scale;\n * var bounds = graph.getGraphBounds();\n * graph.view.setTranslate(-bounds.x / scale, -bounds.y / scale);\n * ```\n *\n * To toggle the suspended mode, the following can be used.\n *\n * ```javascript\n * outline.suspended = !outln.suspended;\n * if (!outline.suspended)\n * {\n *   outline.update(true);\n * }\n * ```\n */\nclass Outline {\n  constructor(source) {\n    let container = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    // TODO: Document me!!\n    this.sizer = null;\n    this.selectionBorder = null;\n    this.updateHandler = null;\n    this.refreshHandler = null;\n    this.panHandler = null;\n    this.active = null;\n    this.bounds = null;\n    this.zoom = false;\n    this.startX = null;\n    this.startY = null;\n    this.dx0 = null;\n    this.dy0 = null;\n    this.index = null;\n    /**\n     * Reference to the {@link graph} that renders the outline.\n     */\n    this.outline = null;\n    /**\n     * Renderhint to be used for the outline graph.\n     * @default faster\n     */\n    this.graphRenderHint = 'exact';\n    /**\n     * Specifies if events are handled.\n     * @default true\n     */\n    this.enabled = true;\n    /**\n     * Specifies a viewport rectangle should be shown.\n     * @default true\n     */\n    this.showViewport = true;\n    /**\n     * Border to be added at the bottom and right.\n     * @default 10\n     */\n    this.border = 10;\n    /**\n     * Specifies the size of the sizer handler.\n     * @default 8\n     */\n    this.sizerSize = 8;\n    /**\n     * Specifies if labels should be visible in the outline.\n     * @default false\n     */\n    this.labelsVisible = false;\n    /**\n     * Specifies if {@link update} should be called for {@link InternalEvent.PAN} in the source\n     * graph.\n     * @default false\n     */\n    this.updateOnPan = false;\n    /**\n     * Optional {@link Image} to be used for the sizer.\n     * @default null\n     */\n    this.sizerImage = null;\n    /**\n     * Minimum scale to be used.\n     * @default 0.0001\n     */\n    this.minScale = 0.0001;\n    /**\n     * Optional boolean flag to suspend updates. This flag will\n     * also suspend repaints of the outline. To toggle this switch, use the\n     * following code.\n     *\n     * @default false\n     *\n     * @example\n     * ```javascript\n     * nav.suspended = !nav.suspended;\n     *\n     * if (!nav.suspended)\n     * {\n     *   nav.update(true);\n     * }\n     * ```\n     */\n    this.suspended = false;\n    this.source = source;\n    if (container != null) {\n      this.init(container);\n    }\n  }\n  /**\n   * Initializes the outline inside the given container.\n   */\n  init(container) {\n    this.outline = this.createGraph(container);\n    // Do not repaint when suspended\n    const outlineGraphModelChanged = this.outline.graphModelChanged;\n    this.outline.graphModelChanged = changes => {\n      if (!this.suspended && this.outline != null) {\n        outlineGraphModelChanged.apply(this.outline, [changes]);\n      }\n    };\n    // Enable faster painting in SVG\n    //const node = <SVGElement>this.outline.getView().getCanvas().parentNode;\n    //node.setAttribute('shape-rendering', 'optimizeSpeed');\n    //node.setAttribute('image-rendering', 'optimizeSpeed');\n    // Hides cursors and labels\n    this.outline.labelsVisible = this.labelsVisible;\n    this.outline.setEnabled(false);\n    this.updateHandler = (sender, evt) => {\n      if (!this.suspended && !this.active) {\n        this.update();\n      }\n    };\n    // Updates the scale of the outline after a change of the main graph\n    this.source.getDataModel().addListener(InternalEvent.CHANGE, this.updateHandler);\n    this.outline.addMouseListener(this);\n    // Adds listeners to keep the outline in sync with the source graph\n    const view = this.source.getView();\n    view.addListener(InternalEvent.SCALE, this.updateHandler);\n    view.addListener(InternalEvent.TRANSLATE, this.updateHandler);\n    view.addListener(InternalEvent.SCALE_AND_TRANSLATE, this.updateHandler);\n    view.addListener(InternalEvent.DOWN, this.updateHandler);\n    view.addListener(InternalEvent.UP, this.updateHandler);\n    // Updates blue rectangle on scroll\n    // @ts-ignore because sender and evt don't seem used\n    InternalEvent.addListener(this.source.container, 'scroll', this.updateHandler);\n    this.panHandler = (sender, evt) => {\n      if (this.updateOnPan) {\n        this.updateHandler(sender, evt);\n      }\n    };\n    this.source.addListener(InternalEvent.PAN, this.panHandler);\n    // Refreshes the graph in the outline after a refresh of the main graph\n    this.refreshHandler = sender => {\n      const outline = this.outline;\n      outline.setStylesheet(this.source.getStylesheet());\n      outline.refresh();\n    };\n    this.source.addListener(InternalEvent.REFRESH, this.refreshHandler);\n    // Creates the blue rectangle for the viewport\n    this.bounds = new Rectangle(0, 0, 0, 0);\n    this.selectionBorder = new RectangleShape(this.bounds, NONE, OUTLINE_COLOR, OUTLINE_STROKEWIDTH);\n    this.selectionBorder.dialect = this.outline.dialect;\n    this.selectionBorder.init(this.outline.getView().getOverlayPane());\n    const selectionBorderNode = this.selectionBorder.node;\n    // Handles event by catching the initial pointer start and then listening to the\n    // complete gesture on the event target. This is needed because all the events\n    // are routed via the initial element even if that element is removed from the\n    // DOM, which happens when we repaint the selection border and zoom handles.\n    const handler = evt => {\n      const t = getSource(evt);\n      const redirect = evt => {\n        const outline = this.outline;\n        outline.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt));\n      };\n      const redirect2 = evt => {\n        const outline = this.outline;\n        InternalEvent.removeGestureListeners(t, null, redirect, redirect2);\n        outline.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt));\n      };\n      const outline = this.outline;\n      InternalEvent.addGestureListeners(t, null, redirect, redirect2);\n      outline.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt));\n    };\n    InternalEvent.addGestureListeners(this.selectionBorder.node, handler);\n    // Creates a small blue rectangle for sizing (sizer handle)\n    const sizer = this.sizer = this.createSizer();\n    const sizerNode = sizer.node;\n    sizer.init(this.outline.getView().getOverlayPane());\n    if (this.enabled) {\n      sizerNode.style.cursor = 'nwse-resize';\n    }\n    InternalEvent.addGestureListeners(this.sizer.node, handler);\n    selectionBorderNode.style.display = this.showViewport ? '' : 'none';\n    sizerNode.style.display = selectionBorderNode.style.display;\n    selectionBorderNode.style.cursor = 'move';\n    this.update(false);\n  }\n  /**\n   * Creates the {@link graph} used in the outline.\n   */\n  createGraph(container) {\n    const graph = new Graph(container, this.source.getDataModel(), defaultPlugins, this.source.getStylesheet());\n    graph.foldingEnabled = false;\n    graph.autoScroll = false;\n    return graph;\n  }\n  /**\n   * Returns true if events are handled. This implementation\n   * returns {@link enabled}.\n   */\n  isEnabled() {\n    return this.enabled;\n  }\n  /**\n   * Enables or disables event handling. This implementation\n   * updates {@link enabled}.\n   *\n   * @param value Boolean that specifies the new enabled state.\n   */\n  setEnabled(value) {\n    this.enabled = value;\n  }\n  /**\n   * Enables or disables the zoom handling by showing or hiding the respective\n   * handle.\n   *\n   * @param value Boolean that specifies the new enabled state.\n   */\n  setZoomEnabled(value) {\n    // @ts-ignore\n    this.sizer.node.style.visibility = value ? 'visible' : 'hidden';\n  }\n  /**\n   * Invokes {@link update} and revalidate the outline. This method is deprecated.\n   */\n  refresh() {\n    this.update(true);\n  }\n  /**\n   * Creates the shape used as the sizer.\n   */\n  // createSizer(): mxShape;\n  createSizer() {\n    const outline = this.outline;\n    if (this.sizerImage != null) {\n      const sizer = new ImageShape(new Rectangle(0, 0, this.sizerImage.width, this.sizerImage.height), this.sizerImage.src);\n      sizer.dialect = outline.dialect;\n      return sizer;\n    }\n    const sizer = new RectangleShape(new Rectangle(0, 0, this.sizerSize, this.sizerSize), OUTLINE_HANDLE_FILLCOLOR, OUTLINE_HANDLE_STROKECOLOR);\n    sizer.dialect = outline.dialect;\n    return sizer;\n  }\n  /**\n   * Returns the size of the source container.\n   */\n  getSourceContainerSize() {\n    return new Rectangle(0, 0, this.source.container.scrollWidth, this.source.container.scrollHeight);\n  }\n  /**\n   * Returns the offset for drawing the outline graph.\n   */\n  getOutlineOffset(scale) {\n    // TODO: Should number -> mxPoint?\n    return null;\n  }\n  /**\n   * Returns the offset for drawing the outline graph.\n   */\n  getSourceGraphBounds() {\n    return this.source.getGraphBounds();\n  }\n  /**\n   * Updates the outline.\n   */\n  update() {\n    let revalidate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.source != null && this.source.container != null && this.outline != null && this.outline.container != null) {\n      const sourceScale = this.source.view.scale;\n      const scaledGraphBounds = this.getSourceGraphBounds();\n      const unscaledGraphBounds = new Rectangle(scaledGraphBounds.x / sourceScale + this.source.panDx, scaledGraphBounds.y / sourceScale + this.source.panDy, scaledGraphBounds.width / sourceScale, scaledGraphBounds.height / sourceScale);\n      const unscaledFinderBounds = new Rectangle(0, 0, this.source.container.clientWidth / sourceScale, this.source.container.clientHeight / sourceScale);\n      const union = unscaledGraphBounds.clone();\n      union.add(unscaledFinderBounds);\n      // Zooms to the scrollable area if that is bigger than the graph\n      const size = this.getSourceContainerSize();\n      const completeWidth = Math.max(size.width / sourceScale, union.width);\n      const completeHeight = Math.max(size.height / sourceScale, union.height);\n      const availableWidth = Math.max(0, this.outline.container.clientWidth - this.border);\n      const availableHeight = Math.max(0, this.outline.container.clientHeight - this.border);\n      const outlineScale = Math.min(availableWidth / completeWidth, availableHeight / completeHeight);\n      let scale = Number.isNaN(outlineScale) ? this.minScale : Math.max(this.minScale, outlineScale);\n      if (scale > 0) {\n        if (this.outline.getView().scale !== scale) {\n          this.outline.getView().scale = scale;\n          revalidate = true;\n        }\n        const navView = this.outline.getView();\n        if (navView.currentRoot !== this.source.getView().currentRoot) {\n          navView.setCurrentRoot(this.source.getView().currentRoot);\n        }\n        const t = this.source.view.translate;\n        let tx = t.x + this.source.panDx;\n        let ty = t.y + this.source.panDy;\n        const off = this.getOutlineOffset(scale);\n        if (off != null) {\n          tx += off.x;\n          ty += off.y;\n        }\n        if (unscaledGraphBounds.x < 0) {\n          tx -= unscaledGraphBounds.x;\n        }\n        if (unscaledGraphBounds.y < 0) {\n          ty -= unscaledGraphBounds.y;\n        }\n        if (navView.translate.x !== tx || navView.translate.y !== ty) {\n          navView.translate.x = tx;\n          navView.translate.y = ty;\n          revalidate = true;\n        }\n        // Prepares local variables for computations\n        const t2 = navView.translate;\n        scale = this.source.getView().scale;\n        const scale2 = scale / navView.scale;\n        const scale3 = 1.0 / navView.scale;\n        const {\n          container\n        } = this.source;\n        // Updates the bounds of the viewrect in the navigation\n        this.bounds = new Rectangle((t2.x - t.x - this.source.panDx) / scale3, (t2.y - t.y - this.source.panDy) / scale3, container.clientWidth / scale2, container.clientHeight / scale2);\n        // Adds the scrollbar offset to the finder\n        this.bounds.x += this.source.container.scrollLeft * navView.scale / scale;\n        this.bounds.y += this.source.container.scrollTop * navView.scale / scale;\n        const selectionBorder = this.selectionBorder;\n        let b = selectionBorder.bounds;\n        if (b.x !== this.bounds.x || b.y !== this.bounds.y || b.width !== this.bounds.width || b.height !== this.bounds.height) {\n          selectionBorder.bounds = this.bounds;\n          selectionBorder.redraw();\n        }\n        // Updates the bounds of the zoom handle at the bottom right\n        const sizer = this.sizer;\n        b = sizer.bounds;\n        const b2 = new Rectangle(this.bounds.x + this.bounds.width - b.width / 2, this.bounds.y + this.bounds.height - b.height / 2, b.width, b.height);\n        if (b.x !== b2.x || b.y !== b2.y || b.width !== b2.width || b.height !== b2.height) {\n          sizer.bounds = b2;\n          // Avoids update of visibility in redraw for VML\n          if (sizer.node.style.visibility !== 'hidden') {\n            sizer.redraw();\n          }\n        }\n        if (revalidate) {\n          this.outline.view.revalidate();\n        }\n      }\n    }\n  }\n  /**\n   * Handles the event by starting a translation or zoom.\n   */\n  mouseDown(sender, me) {\n    if (this.enabled && this.showViewport) {\n      const tol = !isMouseEvent(me.getEvent()) ? this.source.tolerance : 0;\n      const hit = tol > 0 ? new Rectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;\n      this.zoom = me.isSource(this.sizer) ||\n      // @ts-ignore\n      hit != null && intersects(this.sizer.bounds, hit);\n      this.startX = me.getX();\n      this.startY = me.getY();\n      this.active = true;\n      const sourceContainer = this.source.container;\n      if (this.source.useScrollbarsForPanning && hasScrollbars(this.source.container)) {\n        this.dx0 = sourceContainer.scrollLeft;\n        this.dy0 = sourceContainer.scrollTop;\n      } else {\n        this.dx0 = 0;\n        this.dy0 = 0;\n      }\n    }\n    me.consume();\n  }\n  /**\n   * Handles the event by previewing the viewrect in {@link graph} and updating the\n   * rectangle that represents the viewrect in the outline.\n   */\n  mouseMove(sender, me) {\n    if (this.active) {\n      const myBounds = this.bounds;\n      const sizer = this.sizer;\n      const sizerNode = sizer.node;\n      const selectionBorder = this.selectionBorder;\n      const selectionBorderNode = selectionBorder.node;\n      const source = this.source;\n      const outline = this.outline;\n      selectionBorderNode.style.display = this.showViewport ? '' : 'none';\n      sizerNode.style.display = selectionBorderNode.style.display;\n      const delta = this.getTranslateForEvent(me);\n      let dx = delta.x;\n      let dy = delta.y;\n      let bounds = null;\n      if (!this.zoom) {\n        // Previews the panning on the source graph\n        const {\n          scale\n        } = outline.getView();\n        bounds = new Rectangle(myBounds.x + dx, myBounds.y + dy, myBounds.width, myBounds.height);\n        selectionBorder.bounds = bounds;\n        selectionBorder.redraw();\n        dx /= scale;\n        dx *= source.getView().scale;\n        dy /= scale;\n        dy *= source.getView().scale;\n        source.panGraph(-dx - this.dx0, -dy - this.dy0);\n      } else {\n        // Does *not* preview zooming on the source graph\n        const {\n          container\n        } = this.source;\n        // @ts-ignore\n        const viewRatio = container.clientWidth / container.clientHeight;\n        dy = dx / viewRatio;\n        bounds = new Rectangle(myBounds.x, myBounds.y, Math.max(1, myBounds.width + dx), Math.max(1, myBounds.height + dy));\n        selectionBorder.bounds = bounds;\n        selectionBorder.redraw();\n      }\n      // Updates the zoom handle\n      const b = sizer.bounds;\n      sizer.bounds = new Rectangle(bounds.x + bounds.width - b.width / 2, bounds.y + bounds.height - b.height / 2, b.width, b.height);\n      // Avoids update of visibility in redraw for VML\n      if (sizerNode.style.visibility !== 'hidden') {\n        sizer.redraw();\n      }\n      me.consume();\n    }\n  }\n  /**\n   * Gets the translate for the given mouse event. Here is an example to limit\n   * the outline to stay within positive coordinates:\n   *\n   * @example\n   * ```javascript\n   * outline.getTranslateForEvent(me)\n   * {\n   *   var pt = new mxPoint(me.getX() - this.startX, me.getY() - this.startY);\n   *\n   *   if (!this.zoom)\n   *   {\n   *     var tr = this.source.view.translate;\n   *     pt.x = Math.max(tr.x * this.outline.view.scale, pt.x);\n   *     pt.y = Math.max(tr.y * this.outline.view.scale, pt.y);\n   *   }\n   *\n   *   return pt;\n   * };\n   * ```\n   */\n  getTranslateForEvent(me) {\n    return new Point(me.getX() - this.startX, me.getY() - this.startY);\n  }\n  /**\n   * Handles the event by applying the translation or zoom to {@link graph}.\n   */\n  mouseUp(sender, me) {\n    if (this.active) {\n      const delta = this.getTranslateForEvent(me);\n      let dx = delta.x;\n      let dy = delta.y;\n      const source = this.source;\n      const outline = this.outline;\n      const selectionBorder = this.selectionBorder;\n      if (Math.abs(dx) > 0 || Math.abs(dy) > 0) {\n        if (!this.zoom) {\n          // Applies the new translation if the source\n          // has no scrollbars\n          if (!source.useScrollbarsForPanning || !hasScrollbars(source.container)) {\n            source.panGraph(0, 0);\n            dx /= outline.getView().scale;\n            dy /= outline.getView().scale;\n            const t = source.getView().translate;\n            source.getView().setTranslate(t.x - dx, t.y - dy);\n          }\n        } else {\n          // Applies the new zoom\n          const w = selectionBorder.bounds.width;\n          const {\n            scale\n          } = source.getView();\n          source.zoomTo(Math.max(this.minScale, scale - dx * scale / w), false);\n        }\n        this.update();\n        me.consume();\n      }\n      // Resets the state of the handler\n      this.index = null;\n      this.active = false;\n    }\n  }\n  /**\n   * Destroy this outline and removes all listeners from {@link source}.\n   */\n  destroy() {\n    if (this.source != null) {\n      // @ts-ignore\n      this.source.removeListener(this.panHandler);\n      // @ts-ignore\n      this.source.removeListener(this.refreshHandler);\n      // @ts-ignore\n      this.source.getDataModel().removeListener(this.updateHandler);\n      // @ts-ignore\n      this.source.getView().removeListener(this.updateHandler);\n      // @ts-ignore\n      InternalEvent.removeListener(this.source.container, 'scroll', this.updateHandler);\n      // @ts-ignore\n      this.source = null;\n    }\n    if (this.outline != null) {\n      this.outline.removeMouseListener(this);\n      this.outline.destroy();\n      this.outline = null;\n    }\n    if (this.selectionBorder != null) {\n      this.selectionBorder.destroy();\n      this.selectionBorder = null;\n    }\n    if (this.sizer != null) {\n      this.sizer.destroy();\n      this.sizer = null;\n    }\n  }\n}\nexport default Outline;","map":{"version":3,"names":["InternalMouseEvent","NONE","OUTLINE_COLOR","OUTLINE_HANDLE_FILLCOLOR","OUTLINE_HANDLE_STROKECOLOR","OUTLINE_STROKEWIDTH","Point","Rectangle","RectangleShape","Graph","defaultPlugins","ImageShape","InternalEvent","getSource","isMouseEvent","hasScrollbars","Outline","constructor","source","container","arguments","length","undefined","sizer","selectionBorder","updateHandler","refreshHandler","panHandler","active","bounds","zoom","startX","startY","dx0","dy0","index","outline","graphRenderHint","enabled","showViewport","border","sizerSize","labelsVisible","updateOnPan","sizerImage","minScale","suspended","init","createGraph","outlineGraphModelChanged","graphModelChanged","changes","apply","setEnabled","sender","evt","update","getDataModel","addListener","CHANGE","addMouseListener","view","getView","SCALE","TRANSLATE","SCALE_AND_TRANSLATE","DOWN","UP","PAN","setStylesheet","getStylesheet","refresh","REFRESH","dialect","getOverlayPane","selectionBorderNode","node","handler","t","redirect","fireMouseEvent","MOUSE_MOVE","redirect2","removeGestureListeners","MOUSE_UP","addGestureListeners","MOUSE_DOWN","createSizer","sizerNode","style","cursor","display","graph","foldingEnabled","autoScroll","isEnabled","value","setZoomEnabled","visibility","width","height","src","getSourceContainerSize","scrollWidth","scrollHeight","getOutlineOffset","scale","getSourceGraphBounds","getGraphBounds","revalidate","sourceScale","scaledGraphBounds","unscaledGraphBounds","x","panDx","y","panDy","unscaledFinderBounds","clientWidth","clientHeight","union","clone","add","size","completeWidth","Math","max","completeHeight","availableWidth","availableHeight","outlineScale","min","Number","isNaN","navView","currentRoot","setCurrentRoot","translate","tx","ty","off","t2","scale2","scale3","scrollLeft","scrollTop","b","redraw","b2","mouseDown","me","tol","getEvent","tolerance","hit","getGraphX","getGraphY","isSource","intersects","getX","getY","sourceContainer","useScrollbarsForPanning","consume","mouseMove","myBounds","delta","getTranslateForEvent","dx","dy","panGraph","viewRatio","mouseUp","abs","setTranslate","w","zoomTo","destroy","removeListener","removeMouseListener"],"sources":["D:/ospanel/domains/old/react/react-intro/node_modules/@maxgraph/core/dist/view/other/Outline.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport InternalMouseEvent from '../event/InternalMouseEvent';\nimport { NONE, OUTLINE_COLOR, OUTLINE_HANDLE_FILLCOLOR, OUTLINE_HANDLE_STROKECOLOR, OUTLINE_STROKEWIDTH, } from '../../util/Constants';\nimport Point from '../geometry/Point';\nimport Rectangle from '../geometry/Rectangle';\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport { Graph, defaultPlugins } from '../Graph';\nimport ImageShape from '../geometry/node/ImageShape';\nimport InternalEvent from '../event/InternalEvent';\nimport { getSource, isMouseEvent } from '../../util/EventUtils';\nimport { hasScrollbars } from '../../util/styleUtils';\n/**\n * @class Outline\n *\n * Implements an outline (aka overview) for a graph. Set {@link updateOnPan} to true\n * to enable updates while the source graph is panning.\n *\n * ### Example\n *\n * ```javascript\n * var outline = new mxOutline(graph, div);\n * ```\n *\n * If an outline is used in an {@link MaxWindow} in IE8 standards mode, the following\n * code makes sure that the shadow filter is not inherited and that any\n * transparent elements in the graph do not show the page background, but the\n * background of the graph container.\n *\n * ```javascript\n * if (document.documentMode == 8)\n * {\n *   container.style.filter = 'progid:DXImageTransform.Microsoft.alpha(opacity=100)';\n * }\n * ```\n *\n * To move the graph to the top, left corner the following code can be used.\n *\n * ```javascript\n * var scale = graph.view.scale;\n * var bounds = graph.getGraphBounds();\n * graph.view.setTranslate(-bounds.x / scale, -bounds.y / scale);\n * ```\n *\n * To toggle the suspended mode, the following can be used.\n *\n * ```javascript\n * outline.suspended = !outln.suspended;\n * if (!outline.suspended)\n * {\n *   outline.update(true);\n * }\n * ```\n */\nclass Outline {\n    constructor(source, container = null) {\n        // TODO: Document me!!\n        this.sizer = null;\n        this.selectionBorder = null;\n        this.updateHandler = null;\n        this.refreshHandler = null;\n        this.panHandler = null;\n        this.active = null;\n        this.bounds = null;\n        this.zoom = false;\n        this.startX = null;\n        this.startY = null;\n        this.dx0 = null;\n        this.dy0 = null;\n        this.index = null;\n        /**\n         * Reference to the {@link graph} that renders the outline.\n         */\n        this.outline = null;\n        /**\n         * Renderhint to be used for the outline graph.\n         * @default faster\n         */\n        this.graphRenderHint = 'exact';\n        /**\n         * Specifies if events are handled.\n         * @default true\n         */\n        this.enabled = true;\n        /**\n         * Specifies a viewport rectangle should be shown.\n         * @default true\n         */\n        this.showViewport = true;\n        /**\n         * Border to be added at the bottom and right.\n         * @default 10\n         */\n        this.border = 10;\n        /**\n         * Specifies the size of the sizer handler.\n         * @default 8\n         */\n        this.sizerSize = 8;\n        /**\n         * Specifies if labels should be visible in the outline.\n         * @default false\n         */\n        this.labelsVisible = false;\n        /**\n         * Specifies if {@link update} should be called for {@link InternalEvent.PAN} in the source\n         * graph.\n         * @default false\n         */\n        this.updateOnPan = false;\n        /**\n         * Optional {@link Image} to be used for the sizer.\n         * @default null\n         */\n        this.sizerImage = null;\n        /**\n         * Minimum scale to be used.\n         * @default 0.0001\n         */\n        this.minScale = 0.0001;\n        /**\n         * Optional boolean flag to suspend updates. This flag will\n         * also suspend repaints of the outline. To toggle this switch, use the\n         * following code.\n         *\n         * @default false\n         *\n         * @example\n         * ```javascript\n         * nav.suspended = !nav.suspended;\n         *\n         * if (!nav.suspended)\n         * {\n         *   nav.update(true);\n         * }\n         * ```\n         */\n        this.suspended = false;\n        this.source = source;\n        if (container != null) {\n            this.init(container);\n        }\n    }\n    /**\n     * Initializes the outline inside the given container.\n     */\n    init(container) {\n        this.outline = this.createGraph(container);\n        // Do not repaint when suspended\n        const outlineGraphModelChanged = this.outline.graphModelChanged;\n        this.outline.graphModelChanged = (changes) => {\n            if (!this.suspended && this.outline != null) {\n                outlineGraphModelChanged.apply(this.outline, [changes]);\n            }\n        };\n        // Enable faster painting in SVG\n        //const node = <SVGElement>this.outline.getView().getCanvas().parentNode;\n        //node.setAttribute('shape-rendering', 'optimizeSpeed');\n        //node.setAttribute('image-rendering', 'optimizeSpeed');\n        // Hides cursors and labels\n        this.outline.labelsVisible = this.labelsVisible;\n        this.outline.setEnabled(false);\n        this.updateHandler = (sender, evt) => {\n            if (!this.suspended && !this.active) {\n                this.update();\n            }\n        };\n        // Updates the scale of the outline after a change of the main graph\n        this.source.getDataModel().addListener(InternalEvent.CHANGE, this.updateHandler);\n        this.outline.addMouseListener(this);\n        // Adds listeners to keep the outline in sync with the source graph\n        const view = this.source.getView();\n        view.addListener(InternalEvent.SCALE, this.updateHandler);\n        view.addListener(InternalEvent.TRANSLATE, this.updateHandler);\n        view.addListener(InternalEvent.SCALE_AND_TRANSLATE, this.updateHandler);\n        view.addListener(InternalEvent.DOWN, this.updateHandler);\n        view.addListener(InternalEvent.UP, this.updateHandler);\n        // Updates blue rectangle on scroll\n        // @ts-ignore because sender and evt don't seem used\n        InternalEvent.addListener(this.source.container, 'scroll', this.updateHandler);\n        this.panHandler = (sender, evt) => {\n            if (this.updateOnPan) {\n                this.updateHandler(sender, evt);\n            }\n        };\n        this.source.addListener(InternalEvent.PAN, this.panHandler);\n        // Refreshes the graph in the outline after a refresh of the main graph\n        this.refreshHandler = (sender) => {\n            const outline = this.outline;\n            outline.setStylesheet(this.source.getStylesheet());\n            outline.refresh();\n        };\n        this.source.addListener(InternalEvent.REFRESH, this.refreshHandler);\n        // Creates the blue rectangle for the viewport\n        this.bounds = new Rectangle(0, 0, 0, 0);\n        this.selectionBorder = new RectangleShape(this.bounds, NONE, OUTLINE_COLOR, OUTLINE_STROKEWIDTH);\n        this.selectionBorder.dialect = this.outline.dialect;\n        this.selectionBorder.init(this.outline.getView().getOverlayPane());\n        const selectionBorderNode = this.selectionBorder.node;\n        // Handles event by catching the initial pointer start and then listening to the\n        // complete gesture on the event target. This is needed because all the events\n        // are routed via the initial element even if that element is removed from the\n        // DOM, which happens when we repaint the selection border and zoom handles.\n        const handler = (evt) => {\n            const t = getSource(evt);\n            const redirect = (evt) => {\n                const outline = this.outline;\n                outline.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt));\n            };\n            const redirect2 = (evt) => {\n                const outline = this.outline;\n                InternalEvent.removeGestureListeners(t, null, redirect, redirect2);\n                outline.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt));\n            };\n            const outline = this.outline;\n            InternalEvent.addGestureListeners(t, null, redirect, redirect2);\n            outline.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt));\n        };\n        InternalEvent.addGestureListeners(this.selectionBorder.node, handler);\n        // Creates a small blue rectangle for sizing (sizer handle)\n        const sizer = (this.sizer = this.createSizer());\n        const sizerNode = sizer.node;\n        sizer.init(this.outline.getView().getOverlayPane());\n        if (this.enabled) {\n            sizerNode.style.cursor = 'nwse-resize';\n        }\n        InternalEvent.addGestureListeners(this.sizer.node, handler);\n        selectionBorderNode.style.display = this.showViewport ? '' : 'none';\n        sizerNode.style.display = selectionBorderNode.style.display;\n        selectionBorderNode.style.cursor = 'move';\n        this.update(false);\n    }\n    /**\n     * Creates the {@link graph} used in the outline.\n     */\n    createGraph(container) {\n        const graph = new Graph(container, this.source.getDataModel(), defaultPlugins, this.source.getStylesheet());\n        graph.foldingEnabled = false;\n        graph.autoScroll = false;\n        return graph;\n    }\n    /**\n     * Returns true if events are handled. This implementation\n     * returns {@link enabled}.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Enables or disables event handling. This implementation\n     * updates {@link enabled}.\n     *\n     * @param value Boolean that specifies the new enabled state.\n     */\n    setEnabled(value) {\n        this.enabled = value;\n    }\n    /**\n     * Enables or disables the zoom handling by showing or hiding the respective\n     * handle.\n     *\n     * @param value Boolean that specifies the new enabled state.\n     */\n    setZoomEnabled(value) {\n        // @ts-ignore\n        this.sizer.node.style.visibility = value ? 'visible' : 'hidden';\n    }\n    /**\n     * Invokes {@link update} and revalidate the outline. This method is deprecated.\n     */\n    refresh() {\n        this.update(true);\n    }\n    /**\n     * Creates the shape used as the sizer.\n     */\n    // createSizer(): mxShape;\n    createSizer() {\n        const outline = this.outline;\n        if (this.sizerImage != null) {\n            const sizer = new ImageShape(new Rectangle(0, 0, this.sizerImage.width, this.sizerImage.height), this.sizerImage.src);\n            sizer.dialect = outline.dialect;\n            return sizer;\n        }\n        const sizer = new RectangleShape(new Rectangle(0, 0, this.sizerSize, this.sizerSize), OUTLINE_HANDLE_FILLCOLOR, OUTLINE_HANDLE_STROKECOLOR);\n        sizer.dialect = outline.dialect;\n        return sizer;\n    }\n    /**\n     * Returns the size of the source container.\n     */\n    getSourceContainerSize() {\n        return new Rectangle(0, 0, this.source.container.scrollWidth, this.source.container.scrollHeight);\n    }\n    /**\n     * Returns the offset for drawing the outline graph.\n     */\n    getOutlineOffset(scale) {\n        // TODO: Should number -> mxPoint?\n        return null;\n    }\n    /**\n     * Returns the offset for drawing the outline graph.\n     */\n    getSourceGraphBounds() {\n        return this.source.getGraphBounds();\n    }\n    /**\n     * Updates the outline.\n     */\n    update(revalidate = false) {\n        if (this.source != null &&\n            this.source.container != null &&\n            this.outline != null &&\n            this.outline.container != null) {\n            const sourceScale = this.source.view.scale;\n            const scaledGraphBounds = this.getSourceGraphBounds();\n            const unscaledGraphBounds = new Rectangle(scaledGraphBounds.x / sourceScale + this.source.panDx, scaledGraphBounds.y / sourceScale + this.source.panDy, scaledGraphBounds.width / sourceScale, scaledGraphBounds.height / sourceScale);\n            const unscaledFinderBounds = new Rectangle(0, 0, this.source.container.clientWidth / sourceScale, this.source.container.clientHeight / sourceScale);\n            const union = unscaledGraphBounds.clone();\n            union.add(unscaledFinderBounds);\n            // Zooms to the scrollable area if that is bigger than the graph\n            const size = this.getSourceContainerSize();\n            const completeWidth = Math.max(size.width / sourceScale, union.width);\n            const completeHeight = Math.max(size.height / sourceScale, union.height);\n            const availableWidth = Math.max(0, this.outline.container.clientWidth - this.border);\n            const availableHeight = Math.max(0, this.outline.container.clientHeight - this.border);\n            const outlineScale = Math.min(availableWidth / completeWidth, availableHeight / completeHeight);\n            let scale = Number.isNaN(outlineScale)\n                ? this.minScale\n                : Math.max(this.minScale, outlineScale);\n            if (scale > 0) {\n                if (this.outline.getView().scale !== scale) {\n                    this.outline.getView().scale = scale;\n                    revalidate = true;\n                }\n                const navView = this.outline.getView();\n                if (navView.currentRoot !== this.source.getView().currentRoot) {\n                    navView.setCurrentRoot(this.source.getView().currentRoot);\n                }\n                const t = this.source.view.translate;\n                let tx = t.x + this.source.panDx;\n                let ty = t.y + this.source.panDy;\n                const off = this.getOutlineOffset(scale);\n                if (off != null) {\n                    tx += off.x;\n                    ty += off.y;\n                }\n                if (unscaledGraphBounds.x < 0) {\n                    tx -= unscaledGraphBounds.x;\n                }\n                if (unscaledGraphBounds.y < 0) {\n                    ty -= unscaledGraphBounds.y;\n                }\n                if (navView.translate.x !== tx || navView.translate.y !== ty) {\n                    navView.translate.x = tx;\n                    navView.translate.y = ty;\n                    revalidate = true;\n                }\n                // Prepares local variables for computations\n                const t2 = navView.translate;\n                scale = this.source.getView().scale;\n                const scale2 = scale / navView.scale;\n                const scale3 = 1.0 / navView.scale;\n                const { container } = this.source;\n                // Updates the bounds of the viewrect in the navigation\n                this.bounds = new Rectangle((t2.x - t.x - this.source.panDx) / scale3, (t2.y - t.y - this.source.panDy) / scale3, container.clientWidth / scale2, container.clientHeight / scale2);\n                // Adds the scrollbar offset to the finder\n                this.bounds.x += (this.source.container.scrollLeft * navView.scale) / scale;\n                this.bounds.y += (this.source.container.scrollTop * navView.scale) / scale;\n                const selectionBorder = this.selectionBorder;\n                let b = selectionBorder.bounds;\n                if (b.x !== this.bounds.x ||\n                    b.y !== this.bounds.y ||\n                    b.width !== this.bounds.width ||\n                    b.height !== this.bounds.height) {\n                    selectionBorder.bounds = this.bounds;\n                    selectionBorder.redraw();\n                }\n                // Updates the bounds of the zoom handle at the bottom right\n                const sizer = this.sizer;\n                b = sizer.bounds;\n                const b2 = new Rectangle(this.bounds.x + this.bounds.width - b.width / 2, this.bounds.y + this.bounds.height - b.height / 2, b.width, b.height);\n                if (b.x !== b2.x ||\n                    b.y !== b2.y ||\n                    b.width !== b2.width ||\n                    b.height !== b2.height) {\n                    sizer.bounds = b2;\n                    // Avoids update of visibility in redraw for VML\n                    if (sizer.node.style.visibility !== 'hidden') {\n                        sizer.redraw();\n                    }\n                }\n                if (revalidate) {\n                    this.outline.view.revalidate();\n                }\n            }\n        }\n    }\n    /**\n     * Handles the event by starting a translation or zoom.\n     */\n    mouseDown(sender, me) {\n        if (this.enabled && this.showViewport) {\n            const tol = !isMouseEvent(me.getEvent()) ? this.source.tolerance : 0;\n            const hit = tol > 0\n                ? new Rectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol)\n                : null;\n            this.zoom =\n                me.isSource(this.sizer) ||\n                    // @ts-ignore\n                    (hit != null && intersects(this.sizer.bounds, hit));\n            this.startX = me.getX();\n            this.startY = me.getY();\n            this.active = true;\n            const sourceContainer = this.source.container;\n            if (this.source.useScrollbarsForPanning && hasScrollbars(this.source.container)) {\n                this.dx0 = sourceContainer.scrollLeft;\n                this.dy0 = sourceContainer.scrollTop;\n            }\n            else {\n                this.dx0 = 0;\n                this.dy0 = 0;\n            }\n        }\n        me.consume();\n    }\n    /**\n     * Handles the event by previewing the viewrect in {@link graph} and updating the\n     * rectangle that represents the viewrect in the outline.\n     */\n    mouseMove(sender, me) {\n        if (this.active) {\n            const myBounds = this.bounds;\n            const sizer = this.sizer;\n            const sizerNode = sizer.node;\n            const selectionBorder = this.selectionBorder;\n            const selectionBorderNode = selectionBorder.node;\n            const source = this.source;\n            const outline = this.outline;\n            selectionBorderNode.style.display = this.showViewport ? '' : 'none';\n            sizerNode.style.display = selectionBorderNode.style.display;\n            const delta = this.getTranslateForEvent(me);\n            let dx = delta.x;\n            let dy = delta.y;\n            let bounds = null;\n            if (!this.zoom) {\n                // Previews the panning on the source graph\n                const { scale } = outline.getView();\n                bounds = new Rectangle(myBounds.x + dx, myBounds.y + dy, myBounds.width, myBounds.height);\n                selectionBorder.bounds = bounds;\n                selectionBorder.redraw();\n                dx /= scale;\n                dx *= source.getView().scale;\n                dy /= scale;\n                dy *= source.getView().scale;\n                source.panGraph(-dx - this.dx0, -dy - this.dy0);\n            }\n            else {\n                // Does *not* preview zooming on the source graph\n                const { container } = this.source;\n                // @ts-ignore\n                const viewRatio = container.clientWidth / container.clientHeight;\n                dy = dx / viewRatio;\n                bounds = new Rectangle(myBounds.x, myBounds.y, Math.max(1, myBounds.width + dx), Math.max(1, myBounds.height + dy));\n                selectionBorder.bounds = bounds;\n                selectionBorder.redraw();\n            }\n            // Updates the zoom handle\n            const b = sizer.bounds;\n            sizer.bounds = new Rectangle(bounds.x + bounds.width - b.width / 2, bounds.y + bounds.height - b.height / 2, b.width, b.height);\n            // Avoids update of visibility in redraw for VML\n            if (sizerNode.style.visibility !== 'hidden') {\n                sizer.redraw();\n            }\n            me.consume();\n        }\n    }\n    /**\n     * Gets the translate for the given mouse event. Here is an example to limit\n     * the outline to stay within positive coordinates:\n     *\n     * @example\n     * ```javascript\n     * outline.getTranslateForEvent(me)\n     * {\n     *   var pt = new mxPoint(me.getX() - this.startX, me.getY() - this.startY);\n     *\n     *   if (!this.zoom)\n     *   {\n     *     var tr = this.source.view.translate;\n     *     pt.x = Math.max(tr.x * this.outline.view.scale, pt.x);\n     *     pt.y = Math.max(tr.y * this.outline.view.scale, pt.y);\n     *   }\n     *\n     *   return pt;\n     * };\n     * ```\n     */\n    getTranslateForEvent(me) {\n        return new Point(me.getX() - this.startX, me.getY() - this.startY);\n    }\n    /**\n     * Handles the event by applying the translation or zoom to {@link graph}.\n     */\n    mouseUp(sender, me) {\n        if (this.active) {\n            const delta = this.getTranslateForEvent(me);\n            let dx = delta.x;\n            let dy = delta.y;\n            const source = this.source;\n            const outline = this.outline;\n            const selectionBorder = this.selectionBorder;\n            if (Math.abs(dx) > 0 || Math.abs(dy) > 0) {\n                if (!this.zoom) {\n                    // Applies the new translation if the source\n                    // has no scrollbars\n                    if (!source.useScrollbarsForPanning || !hasScrollbars(source.container)) {\n                        source.panGraph(0, 0);\n                        dx /= outline.getView().scale;\n                        dy /= outline.getView().scale;\n                        const t = source.getView().translate;\n                        source.getView().setTranslate(t.x - dx, t.y - dy);\n                    }\n                }\n                else {\n                    // Applies the new zoom\n                    const w = selectionBorder.bounds.width;\n                    const { scale } = source.getView();\n                    source.zoomTo(Math.max(this.minScale, scale - (dx * scale) / w), false);\n                }\n                this.update();\n                me.consume();\n            }\n            // Resets the state of the handler\n            this.index = null;\n            this.active = false;\n        }\n    }\n    /**\n     * Destroy this outline and removes all listeners from {@link source}.\n     */\n    destroy() {\n        if (this.source != null) {\n            // @ts-ignore\n            this.source.removeListener(this.panHandler);\n            // @ts-ignore\n            this.source.removeListener(this.refreshHandler);\n            // @ts-ignore\n            this.source.getDataModel().removeListener(this.updateHandler);\n            // @ts-ignore\n            this.source.getView().removeListener(this.updateHandler);\n            // @ts-ignore\n            InternalEvent.removeListener(this.source.container, 'scroll', this.updateHandler);\n            // @ts-ignore\n            this.source = null;\n        }\n        if (this.outline != null) {\n            this.outline.removeMouseListener(this);\n            this.outline.destroy();\n            this.outline = null;\n        }\n        if (this.selectionBorder != null) {\n            this.selectionBorder.destroy();\n            this.selectionBorder = null;\n        }\n        if (this.sizer != null) {\n            this.sizer.destroy();\n            this.sizer = null;\n        }\n    }\n}\nexport default Outline;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}