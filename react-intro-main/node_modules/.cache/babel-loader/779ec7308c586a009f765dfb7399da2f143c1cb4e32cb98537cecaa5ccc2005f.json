{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Cell from '../cell/Cell';\nimport Dictionary from '../../util/Dictionary';\nimport RootChange from '../undoable_changes/RootChange';\nimport ChildChange from '../undoable_changes/ChildChange';\nimport { Graph } from '../Graph';\nimport { mixInto } from '../../util/Utils';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst SelectionMixin = {\n  selectionModel: null,\n  /**\n   * Returns the {@link mxGraphSelectionModel} that contains the selection.\n   */\n  getSelectionModel() {\n    return this.selectionModel;\n  },\n  /**\n   * Sets the {@link mxSelectionModel} that contains the selection.\n   */\n  setSelectionModel(selectionModel) {\n    this.selectionModel = selectionModel;\n  },\n  /*****************************************************************************\n   * Selection\n   *****************************************************************************/\n  /**\n   * Returns true if the given cell is selected.\n   *\n   * @param cell {@link mxCell} for which the selection state should be returned.\n   */\n  isCellSelected(cell) {\n    return this.selectionModel.isSelected(cell);\n  },\n  /**\n   * Returns true if the selection is empty.\n   */\n  isSelectionEmpty() {\n    return this.selectionModel.isEmpty();\n  },\n  /**\n   * Clears the selection using {@link mxGraphSelectionModel.clear}.\n   */\n  clearSelection() {\n    this.selectionModel.clear();\n  },\n  /**\n   * Returns the number of selected cells.\n   */\n  getSelectionCount() {\n    return this.selectionModel.cells.length;\n  },\n  /**\n   * Returns the first cell from the array of selected {@link Cell}.\n   */\n  getSelectionCell() {\n    return this.selectionModel.cells[0];\n  },\n  /**\n   * Returns the array of selected {@link Cell}.\n   */\n  getSelectionCells() {\n    return this.selectionModel.cells.slice();\n  },\n  /**\n   * Sets the selection cell.\n   *\n   * @param cell {@link mxCell} to be selected.\n   */\n  setSelectionCell(cell) {\n    this.selectionModel.setCell(cell);\n  },\n  /**\n   * Sets the selection cell.\n   *\n   * @param cells Array of {@link Cell} to be selected.\n   */\n  setSelectionCells(cells) {\n    this.selectionModel.setCells(cells);\n  },\n  /**\n   * Adds the given cell to the selection.\n   *\n   * @param cell {@link mxCell} to be add to the selection.\n   */\n  addSelectionCell(cell) {\n    this.selectionModel.addCell(cell);\n  },\n  /**\n   * Adds the given cells to the selection.\n   *\n   * @param cells Array of {@link Cell} to be added to the selection.\n   */\n  addSelectionCells(cells) {\n    this.selectionModel.addCells(cells);\n  },\n  /**\n   * Removes the given cell from the selection.\n   *\n   * @param cell {@link mxCell} to be removed from the selection.\n   */\n  removeSelectionCell(cell) {\n    this.selectionModel.removeCell(cell);\n  },\n  /**\n   * Removes the given cells from the selection.\n   *\n   * @param cells Array of {@link Cell} to be removed from the selection.\n   */\n  removeSelectionCells(cells) {\n    this.selectionModel.removeCells(cells);\n  },\n  /**\n   * Selects and returns the cells inside the given rectangle for the\n   * specified event.\n   *\n   * @param rect {@link mxRectangle} that represents the region to be selected.\n   * @param evt Mouseevent that triggered the selection.\n   */\n  // selectRegion(rect: mxRectangle, evt: Event): mxCellArray;\n  selectRegion(rect, evt) {\n    const cells = this.getCells(rect.x, rect.y, rect.width, rect.height);\n    this.selectCellsForEvent(cells, evt);\n    return cells;\n  },\n  /**\n   * Selects the next cell.\n   */\n  selectNextCell() {\n    this.selectCell(true);\n  },\n  /**\n   * Selects the previous cell.\n   */\n  selectPreviousCell() {\n    this.selectCell();\n  },\n  /**\n   * Selects the parent cell.\n   */\n  selectParentCell() {\n    this.selectCell(false, true);\n  },\n  /**\n   * Selects the first child cell.\n   */\n  selectChildCell() {\n    this.selectCell(false, false, true);\n  },\n  /**\n   * Selects the next, parent, first child or previous cell, if all arguments\n   * are false.\n   *\n   * @param isNext Boolean indicating if the next cell should be selected.\n   * @param isParent Boolean indicating if the parent cell should be selected.\n   * @param isChild Boolean indicating if the first child cell should be selected.\n   */\n  selectCell() {\n    let isNext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let isParent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let isChild = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const cell = this.selectionModel.cells.length > 0 ? this.selectionModel.cells[0] : null;\n    if (this.selectionModel.cells.length > 1) {\n      this.selectionModel.clear();\n    }\n    const parent = cell ? cell.getParent() : this.getDefaultParent();\n    const childCount = parent.getChildCount();\n    if (!cell && childCount > 0) {\n      const child = parent.getChildAt(0);\n      this.setSelectionCell(child);\n    } else if (parent && (!cell || isParent) && this.getView().getState(parent) && parent.getGeometry()) {\n      if (this.getCurrentRoot() !== parent) {\n        this.setSelectionCell(parent);\n      }\n    } else if (cell && isChild) {\n      const tmp = cell.getChildCount();\n      if (tmp > 0) {\n        const child = cell.getChildAt(0);\n        this.setSelectionCell(child);\n      }\n    } else if (childCount > 0) {\n      let i = parent.getIndex(cell);\n      if (isNext) {\n        i++;\n        const child = parent.getChildAt(i % childCount);\n        this.setSelectionCell(child);\n      } else {\n        i--;\n        const index = i < 0 ? childCount - 1 : i;\n        const child = parent.getChildAt(index);\n        this.setSelectionCell(child);\n      }\n    }\n  },\n  /**\n   * Selects all children of the given parent cell or the children of the\n   * default parent if no parent is specified. To select leaf vertices and/or\n   * edges use {@link selectCells}.\n   *\n   * @param parent Optional {@link Cell} whose children should be selected.\n   * Default is {@link defaultParent}.\n   * @param descendants Optional boolean specifying whether all descendants should be\n   * selected. Default is `false`.\n   */\n  selectAll(parent) {\n    var _parent;\n    let descendants = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    parent = (_parent = parent) !== null && _parent !== void 0 ? _parent : this.getDefaultParent();\n    const cells = descendants ? parent.filterDescendants(cell => {\n      return cell !== parent && !!this.getView().getState(cell);\n    }) : parent.getChildren();\n    this.setSelectionCells(cells);\n  },\n  /**\n   * Select all vertices inside the given parent or the default parent.\n   */\n  selectVertices(parent) {\n    let selectGroups = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.selectCells(true, false, parent, selectGroups);\n  },\n  /**\n   * Select all vertices inside the given parent or the default parent.\n   */\n  selectEdges(parent) {\n    this.selectCells(false, true, parent);\n  },\n  /**\n   * Selects all vertices and/or edges depending on the given boolean\n   * arguments recursively, starting at the given parent or the default\n   * parent if no parent is specified. Use {@link selectAll} to select all cells.\n   * For vertices, only cells with no children are selected.\n   *\n   * @param vertices Boolean indicating if vertices should be selected.\n   * @param edges Boolean indicating if edges should be selected.\n   * @param parent Optional {@link Cell} that acts as the root of the recursion.\n   * Default is {@link defaultParent}.\n   * @param selectGroups Optional boolean that specifies if groups should be\n   * selected. Default is `false`.\n   */\n  selectCells() {\n    var _parent2;\n    let vertices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let edges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let parent = arguments.length > 2 ? arguments[2] : undefined;\n    let selectGroups = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    parent = (_parent2 = parent) !== null && _parent2 !== void 0 ? _parent2 : this.getDefaultParent();\n    const filter = cell => {\n      const p = cell.getParent();\n      return !!this.getView().getState(cell) && ((selectGroups || cell.getChildCount() === 0) && cell.isVertex() && vertices && p && !p.isEdge() || cell.isEdge() && edges);\n    };\n    const cells = parent.filterDescendants(filter);\n    this.setSelectionCells(cells);\n  },\n  /**\n   * Selects the given cell by either adding it to the selection or\n   * replacing the selection depending on whether the given mouse event is a\n   * toggle event.\n   *\n   * @param cell {@link mxCell} to be selected.\n   * @param evt Optional mouseevent that triggered the selection.\n   */\n  selectCellForEvent(cell, evt) {\n    const isSelected = this.isCellSelected(cell);\n    if (this.isToggleEvent(evt)) {\n      if (isSelected) {\n        this.removeSelectionCell(cell);\n      } else {\n        this.addSelectionCell(cell);\n      }\n    } else if (!isSelected || this.getSelectionCount() !== 1) {\n      this.setSelectionCell(cell);\n    }\n  },\n  /**\n   * Selects the given cells by either adding them to the selection or\n   * replacing the selection depending on whether the given mouse event is a\n   * toggle event.\n   *\n   * @param cells Array of {@link Cell} to be selected.\n   * @param evt Optional mouseevent that triggered the selection.\n   */\n  selectCellsForEvent(cells, evt) {\n    if (this.isToggleEvent(evt)) {\n      this.addSelectionCells(cells);\n    } else {\n      this.setSelectionCells(cells);\n    }\n  },\n  /**\n   * Returns true if any sibling of the given cell is selected.\n   */\n  isSiblingSelected(cell) {\n    const parent = cell.getParent();\n    const childCount = parent.getChildCount();\n    for (let i = 0; i < childCount; i += 1) {\n      const child = parent.getChildAt(i);\n      if (cell !== child && this.isCellSelected(child)) {\n        return true;\n      }\n    }\n    return false;\n  },\n  /*****************************************************************************\n   * Selection state\n   *****************************************************************************/\n  /**\n   * Returns the cells to be selected for the given array of changes.\n   *\n   * @param ignoreFn Optional function that takes a change and returns true if the\n   * change should be ignored.\n   */\n  getSelectionCellsForChanges(changes) {\n    let ignoreFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const dict = new Dictionary();\n    const cells = [];\n    const addCell = cell => {\n      if (!dict.get(cell) && this.getDataModel().contains(cell)) {\n        if (cell.isEdge() || cell.isVertex()) {\n          dict.put(cell, true);\n          cells.push(cell);\n        } else {\n          const childCount = cell.getChildCount();\n          for (let i = 0; i < childCount; i += 1) {\n            addCell(cell.getChildAt(i));\n          }\n        }\n      }\n    };\n    for (let i = 0; i < changes.length; i += 1) {\n      const change = changes[i];\n      if (change.constructor !== RootChange && (!ignoreFn || !ignoreFn(change))) {\n        let cell = null;\n        if (change instanceof ChildChange) {\n          cell = change.child;\n        } else if (change.cell && change.cell instanceof Cell) {\n          cell = change.cell;\n        }\n        if (cell) {\n          addCell(cell);\n        }\n      }\n    }\n    return cells;\n  },\n  /**\n   * Removes selection cells that are not in the model from the selection.\n   */\n  updateSelection() {\n    const cells = this.getSelectionCells();\n    const removed = [];\n    for (const cell of cells) {\n      if (!this.getDataModel().contains(cell) || !cell.isVisible()) {\n        removed.push(cell);\n      } else {\n        let par = cell.getParent();\n        while (par && par !== this.getView().currentRoot) {\n          if (par.isCollapsed() || !par.isVisible()) {\n            removed.push(cell);\n            break;\n          }\n          par = par.getParent();\n        }\n      }\n    }\n    this.removeSelectionCells(removed);\n  }\n};\nmixInto(Graph)(SelectionMixin);","map":{"version":3,"names":["Cell","Dictionary","RootChange","ChildChange","Graph","mixInto","SelectionMixin","selectionModel","getSelectionModel","setSelectionModel","isCellSelected","cell","isSelected","isSelectionEmpty","isEmpty","clearSelection","clear","getSelectionCount","cells","length","getSelectionCell","getSelectionCells","slice","setSelectionCell","setCell","setSelectionCells","setCells","addSelectionCell","addCell","addSelectionCells","addCells","removeSelectionCell","removeCell","removeSelectionCells","removeCells","selectRegion","rect","evt","getCells","x","y","width","height","selectCellsForEvent","selectNextCell","selectCell","selectPreviousCell","selectParentCell","selectChildCell","isNext","arguments","undefined","isParent","isChild","parent","getParent","getDefaultParent","childCount","getChildCount","child","getChildAt","getView","getState","getGeometry","getCurrentRoot","tmp","i","getIndex","index","selectAll","_parent","descendants","filterDescendants","getChildren","selectVertices","selectGroups","selectCells","selectEdges","_parent2","vertices","edges","filter","p","isVertex","isEdge","selectCellForEvent","isToggleEvent","isSiblingSelected","getSelectionCellsForChanges","changes","ignoreFn","dict","get","getDataModel","contains","put","push","change","constructor","updateSelection","removed","isVisible","par","currentRoot","isCollapsed"],"sources":["D:/ospanel/domains/old/react/react-intro/node_modules/@maxgraph/core/dist/view/mixins/SelectionMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Cell from '../cell/Cell';\nimport Dictionary from '../../util/Dictionary';\nimport RootChange from '../undoable_changes/RootChange';\nimport ChildChange from '../undoable_changes/ChildChange';\nimport { Graph } from '../Graph';\nimport { mixInto } from '../../util/Utils';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst SelectionMixin = {\n    selectionModel: null,\n    /**\n     * Returns the {@link mxGraphSelectionModel} that contains the selection.\n     */\n    getSelectionModel() {\n        return this.selectionModel;\n    },\n    /**\n     * Sets the {@link mxSelectionModel} that contains the selection.\n     */\n    setSelectionModel(selectionModel) {\n        this.selectionModel = selectionModel;\n    },\n    /*****************************************************************************\n     * Selection\n     *****************************************************************************/\n    /**\n     * Returns true if the given cell is selected.\n     *\n     * @param cell {@link mxCell} for which the selection state should be returned.\n     */\n    isCellSelected(cell) {\n        return this.selectionModel.isSelected(cell);\n    },\n    /**\n     * Returns true if the selection is empty.\n     */\n    isSelectionEmpty() {\n        return this.selectionModel.isEmpty();\n    },\n    /**\n     * Clears the selection using {@link mxGraphSelectionModel.clear}.\n     */\n    clearSelection() {\n        this.selectionModel.clear();\n    },\n    /**\n     * Returns the number of selected cells.\n     */\n    getSelectionCount() {\n        return this.selectionModel.cells.length;\n    },\n    /**\n     * Returns the first cell from the array of selected {@link Cell}.\n     */\n    getSelectionCell() {\n        return this.selectionModel.cells[0];\n    },\n    /**\n     * Returns the array of selected {@link Cell}.\n     */\n    getSelectionCells() {\n        return this.selectionModel.cells.slice();\n    },\n    /**\n     * Sets the selection cell.\n     *\n     * @param cell {@link mxCell} to be selected.\n     */\n    setSelectionCell(cell) {\n        this.selectionModel.setCell(cell);\n    },\n    /**\n     * Sets the selection cell.\n     *\n     * @param cells Array of {@link Cell} to be selected.\n     */\n    setSelectionCells(cells) {\n        this.selectionModel.setCells(cells);\n    },\n    /**\n     * Adds the given cell to the selection.\n     *\n     * @param cell {@link mxCell} to be add to the selection.\n     */\n    addSelectionCell(cell) {\n        this.selectionModel.addCell(cell);\n    },\n    /**\n     * Adds the given cells to the selection.\n     *\n     * @param cells Array of {@link Cell} to be added to the selection.\n     */\n    addSelectionCells(cells) {\n        this.selectionModel.addCells(cells);\n    },\n    /**\n     * Removes the given cell from the selection.\n     *\n     * @param cell {@link mxCell} to be removed from the selection.\n     */\n    removeSelectionCell(cell) {\n        this.selectionModel.removeCell(cell);\n    },\n    /**\n     * Removes the given cells from the selection.\n     *\n     * @param cells Array of {@link Cell} to be removed from the selection.\n     */\n    removeSelectionCells(cells) {\n        this.selectionModel.removeCells(cells);\n    },\n    /**\n     * Selects and returns the cells inside the given rectangle for the\n     * specified event.\n     *\n     * @param rect {@link mxRectangle} that represents the region to be selected.\n     * @param evt Mouseevent that triggered the selection.\n     */\n    // selectRegion(rect: mxRectangle, evt: Event): mxCellArray;\n    selectRegion(rect, evt) {\n        const cells = this.getCells(rect.x, rect.y, rect.width, rect.height);\n        this.selectCellsForEvent(cells, evt);\n        return cells;\n    },\n    /**\n     * Selects the next cell.\n     */\n    selectNextCell() {\n        this.selectCell(true);\n    },\n    /**\n     * Selects the previous cell.\n     */\n    selectPreviousCell() {\n        this.selectCell();\n    },\n    /**\n     * Selects the parent cell.\n     */\n    selectParentCell() {\n        this.selectCell(false, true);\n    },\n    /**\n     * Selects the first child cell.\n     */\n    selectChildCell() {\n        this.selectCell(false, false, true);\n    },\n    /**\n     * Selects the next, parent, first child or previous cell, if all arguments\n     * are false.\n     *\n     * @param isNext Boolean indicating if the next cell should be selected.\n     * @param isParent Boolean indicating if the parent cell should be selected.\n     * @param isChild Boolean indicating if the first child cell should be selected.\n     */\n    selectCell(isNext = false, isParent = false, isChild = false) {\n        const cell = this.selectionModel.cells.length > 0 ? this.selectionModel.cells[0] : null;\n        if (this.selectionModel.cells.length > 1) {\n            this.selectionModel.clear();\n        }\n        const parent = cell ? cell.getParent() : this.getDefaultParent();\n        const childCount = parent.getChildCount();\n        if (!cell && childCount > 0) {\n            const child = parent.getChildAt(0);\n            this.setSelectionCell(child);\n        }\n        else if (parent &&\n            (!cell || isParent) &&\n            this.getView().getState(parent) &&\n            parent.getGeometry()) {\n            if (this.getCurrentRoot() !== parent) {\n                this.setSelectionCell(parent);\n            }\n        }\n        else if (cell && isChild) {\n            const tmp = cell.getChildCount();\n            if (tmp > 0) {\n                const child = cell.getChildAt(0);\n                this.setSelectionCell(child);\n            }\n        }\n        else if (childCount > 0) {\n            let i = parent.getIndex(cell);\n            if (isNext) {\n                i++;\n                const child = parent.getChildAt(i % childCount);\n                this.setSelectionCell(child);\n            }\n            else {\n                i--;\n                const index = i < 0 ? childCount - 1 : i;\n                const child = parent.getChildAt(index);\n                this.setSelectionCell(child);\n            }\n        }\n    },\n    /**\n     * Selects all children of the given parent cell or the children of the\n     * default parent if no parent is specified. To select leaf vertices and/or\n     * edges use {@link selectCells}.\n     *\n     * @param parent Optional {@link Cell} whose children should be selected.\n     * Default is {@link defaultParent}.\n     * @param descendants Optional boolean specifying whether all descendants should be\n     * selected. Default is `false`.\n     */\n    selectAll(parent, descendants = false) {\n        parent = parent ?? this.getDefaultParent();\n        const cells = descendants\n            ? parent.filterDescendants((cell) => {\n                return cell !== parent && !!this.getView().getState(cell);\n            })\n            : parent.getChildren();\n        this.setSelectionCells(cells);\n    },\n    /**\n     * Select all vertices inside the given parent or the default parent.\n     */\n    selectVertices(parent, selectGroups = false) {\n        this.selectCells(true, false, parent, selectGroups);\n    },\n    /**\n     * Select all vertices inside the given parent or the default parent.\n     */\n    selectEdges(parent) {\n        this.selectCells(false, true, parent);\n    },\n    /**\n     * Selects all vertices and/or edges depending on the given boolean\n     * arguments recursively, starting at the given parent or the default\n     * parent if no parent is specified. Use {@link selectAll} to select all cells.\n     * For vertices, only cells with no children are selected.\n     *\n     * @param vertices Boolean indicating if vertices should be selected.\n     * @param edges Boolean indicating if edges should be selected.\n     * @param parent Optional {@link Cell} that acts as the root of the recursion.\n     * Default is {@link defaultParent}.\n     * @param selectGroups Optional boolean that specifies if groups should be\n     * selected. Default is `false`.\n     */\n    selectCells(vertices = false, edges = false, parent, selectGroups = false) {\n        parent = parent ?? this.getDefaultParent();\n        const filter = (cell) => {\n            const p = cell.getParent();\n            return (!!this.getView().getState(cell) &&\n                (((selectGroups || cell.getChildCount() === 0) &&\n                    cell.isVertex() &&\n                    vertices &&\n                    p &&\n                    !p.isEdge()) ||\n                    (cell.isEdge() && edges)));\n        };\n        const cells = parent.filterDescendants(filter);\n        this.setSelectionCells(cells);\n    },\n    /**\n     * Selects the given cell by either adding it to the selection or\n     * replacing the selection depending on whether the given mouse event is a\n     * toggle event.\n     *\n     * @param cell {@link mxCell} to be selected.\n     * @param evt Optional mouseevent that triggered the selection.\n     */\n    selectCellForEvent(cell, evt) {\n        const isSelected = this.isCellSelected(cell);\n        if (this.isToggleEvent(evt)) {\n            if (isSelected) {\n                this.removeSelectionCell(cell);\n            }\n            else {\n                this.addSelectionCell(cell);\n            }\n        }\n        else if (!isSelected || this.getSelectionCount() !== 1) {\n            this.setSelectionCell(cell);\n        }\n    },\n    /**\n     * Selects the given cells by either adding them to the selection or\n     * replacing the selection depending on whether the given mouse event is a\n     * toggle event.\n     *\n     * @param cells Array of {@link Cell} to be selected.\n     * @param evt Optional mouseevent that triggered the selection.\n     */\n    selectCellsForEvent(cells, evt) {\n        if (this.isToggleEvent(evt)) {\n            this.addSelectionCells(cells);\n        }\n        else {\n            this.setSelectionCells(cells);\n        }\n    },\n    /**\n     * Returns true if any sibling of the given cell is selected.\n     */\n    isSiblingSelected(cell) {\n        const parent = cell.getParent();\n        const childCount = parent.getChildCount();\n        for (let i = 0; i < childCount; i += 1) {\n            const child = parent.getChildAt(i);\n            if (cell !== child && this.isCellSelected(child)) {\n                return true;\n            }\n        }\n        return false;\n    },\n    /*****************************************************************************\n     * Selection state\n     *****************************************************************************/\n    /**\n     * Returns the cells to be selected for the given array of changes.\n     *\n     * @param ignoreFn Optional function that takes a change and returns true if the\n     * change should be ignored.\n     */\n    getSelectionCellsForChanges(changes, ignoreFn = null) {\n        const dict = new Dictionary();\n        const cells = [];\n        const addCell = (cell) => {\n            if (!dict.get(cell) && this.getDataModel().contains(cell)) {\n                if (cell.isEdge() || cell.isVertex()) {\n                    dict.put(cell, true);\n                    cells.push(cell);\n                }\n                else {\n                    const childCount = cell.getChildCount();\n                    for (let i = 0; i < childCount; i += 1) {\n                        addCell(cell.getChildAt(i));\n                    }\n                }\n            }\n        };\n        for (let i = 0; i < changes.length; i += 1) {\n            const change = changes[i];\n            if (change.constructor !== RootChange && (!ignoreFn || !ignoreFn(change))) {\n                let cell = null;\n                if (change instanceof ChildChange) {\n                    cell = change.child;\n                }\n                else if (change.cell && change.cell instanceof Cell) {\n                    cell = change.cell;\n                }\n                if (cell) {\n                    addCell(cell);\n                }\n            }\n        }\n        return cells;\n    },\n    /**\n     * Removes selection cells that are not in the model from the selection.\n     */\n    updateSelection() {\n        const cells = this.getSelectionCells();\n        const removed = [];\n        for (const cell of cells) {\n            if (!this.getDataModel().contains(cell) || !cell.isVisible()) {\n                removed.push(cell);\n            }\n            else {\n                let par = cell.getParent();\n                while (par && par !== this.getView().currentRoot) {\n                    if (par.isCollapsed() || !par.isVisible()) {\n                        removed.push(cell);\n                        break;\n                    }\n                    par = par.getParent();\n                }\n            }\n        }\n        this.removeSelectionCells(removed);\n    },\n};\nmixInto(Graph)(SelectionMixin);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}