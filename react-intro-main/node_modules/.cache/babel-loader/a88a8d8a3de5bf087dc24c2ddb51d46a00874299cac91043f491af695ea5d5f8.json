{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Translations from '../../util/Translations';\nimport { isNode } from '../../util/domUtils';\nimport { Graph } from '../Graph';\nimport { mixInto } from '../../util/Utils';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst ValidationMixin = {\n  /*****************************************************************************\n   * Group: Validation\n   *****************************************************************************/\n  /**\n   * Displays the given validation error in a dialog. This implementation uses\n   * mxUtils.alert.\n   */\n  validationAlert(message) {\n    alert(message);\n  },\n  /**\n   * Checks if the return value of {@link getEdgeValidationError} for the given\n   * arguments is null.\n   *\n   * @param edge {@link mxCell} that represents the edge to validate.\n   * @param source {@link mxCell} that represents the source terminal.\n   * @param target {@link mxCell} that represents the target terminal.\n   */\n  isEdgeValid(edge, source, target) {\n    return !this.getEdgeValidationError(edge, source, target);\n  },\n  /**\n   * Returns the validation error message to be displayed when inserting or\n   * changing an edges' connectivity. A return value of null means the edge\n   * is valid, a return value of '' means it's not valid, but do not display\n   * an error message. Any other (non-empty) string returned from this method\n   * is displayed as an error message when trying to connect an edge to a\n   * source and target. This implementation uses the {@link multiplicities}, and\n   * checks {@link multigraph}, {@link allowDanglingEdges} and {@link allowLoops} to generate\n   * validation errors.\n   *\n   * For extending this method with specific checks for source/target cells,\n   * the method can be extended as follows. Returning an empty string means\n   * the edge is invalid with no error message, a non-null string specifies\n   * the error message, and null means the edge is valid.\n   *\n   * ```javascript\n   * graph.getEdgeValidationError = function(edge, source, target)\n   * {\n   *   if (source != null && target != null &&\n   *     this.model.getValue(source) != null &&\n   *     this.model.getValue(target) != null)\n   *   {\n   *     if (target is not valid for source)\n   *     {\n   *       return 'Invalid Target';\n   *     }\n   *   }\n   *\n   *   // \"Supercall\"\n   *   return getEdgeValidationError.apply(this, arguments);\n   * }\n   * ```\n   *\n   * @param edge {@link mxCell} that represents the edge to validate.\n   * @param source {@link mxCell} that represents the source terminal.\n   * @param target {@link mxCell} that represents the target terminal.\n   */\n  getEdgeValidationError(edge = null, source = null, target = null) {\n    if (edge && !this.isAllowDanglingEdges() && (!source || !target)) {\n      return '';\n    }\n    if (edge && !edge.getTerminal(true) && !edge.getTerminal(false)) {\n      return null;\n    }\n    // Checks if we're dealing with a loop\n    if (!this.isAllowLoops() && source === target && source) {\n      return '';\n    }\n    // Checks if the connection is generally allowed\n    if (!this.isValidConnection(source, target)) {\n      return '';\n    }\n    if (source && target) {\n      let error = '';\n      // Checks if the cells are already connected\n      // and adds an error message if required\n      if (!this.isMultigraph()) {\n        const tmp = this.getDataModel().getEdgesBetween(source, target, true);\n        // Checks if the source and target are not connected by another edge\n        if (tmp.length > 1 || tmp.length === 1 && tmp[0] !== edge) {\n          error += `${Translations.get(this.getAlreadyConnectedResource()) || this.getAlreadyConnectedResource()}\\n`;\n        }\n      }\n      // Gets the number of outgoing edges from the source\n      // and the number of incoming edges from the target\n      // without counting the edge being currently changed.\n      const sourceOut = source.getDirectedEdgeCount(true, edge);\n      const targetIn = target.getDirectedEdgeCount(false, edge);\n      // Checks the change against each multiplicity rule\n      for (const multiplicity of this.multiplicities) {\n        const err = multiplicity.check(this,\n        // needs to cast to Graph\n        edge, source, target, sourceOut, targetIn);\n        if (err != null) {\n          error += err;\n        }\n      }\n      // Validates the source and target terminals independently\n      const err = this.validateEdge(edge, source, target);\n      if (err != null) {\n        error += err;\n      }\n      return error.length > 0 ? error : null;\n    }\n    return this.isAllowDanglingEdges() ? null : '';\n  },\n  /**\n   * Hook method for subclassers to return an error message for the given\n   * edge and terminals. This implementation returns null.\n   *\n   * @param edge {@link mxCell} that represents the edge to validate.\n   * @param source {@link mxCell} that represents the source terminal.\n   * @param target {@link mxCell} that represents the target terminal.\n   */\n  validateEdge(edge = null, source = null, target = null) {\n    return null;\n  },\n  /**\n   * Validates the graph by validating each descendant of the given cell or\n   * the root of the model. Context is an object that contains the validation\n   * state for the complete validation run. The validation errors are\n   * attached to their cells using {@link setCellWarning}. Returns null in the case of\n   * successful validation or an array of strings (warnings) in the case of\n   * failed validations.\n   *\n   * Paramters:\n   *\n   * @param cell Optional {@link Cell} to start the validation recursion. Default is\n   * the graph root.\n   * @param context Object that represents the global validation state.\n   */\n  validateGraph(cell = null, context) {\n    cell = cell ?? this.getDataModel().getRoot();\n    if (!cell) {\n      return 'The root does not exist!';\n    }\n    context = context ?? {};\n    let isValid = true;\n    const childCount = cell.getChildCount();\n    for (let i = 0; i < childCount; i += 1) {\n      const tmp = cell.getChildAt(i);\n      let ctx = context;\n      if (this.isValidRoot(tmp)) {\n        ctx = {};\n      }\n      const warn = this.validateGraph(tmp, ctx);\n      if (warn) {\n        this.setCellWarning(tmp, warn.replace(/\\n/g, '<br>'));\n      } else {\n        this.setCellWarning(tmp, null);\n      }\n      isValid = isValid && warn == null;\n    }\n    let warning = '';\n    // Adds error for invalid children if collapsed (children invisible)\n    if (cell && cell.isCollapsed() && !isValid) {\n      warning += `${Translations.get(this.getContainsValidationErrorsResource()) || this.getContainsValidationErrorsResource()}\\n`;\n    }\n    // Checks edges and cells using the defined multiplicities\n    if (cell && cell.isEdge()) {\n      warning += this.getEdgeValidationError(cell, cell.getTerminal(true), cell.getTerminal(false)) || '';\n    } else {\n      warning += this.getCellValidationError(cell) || '';\n    }\n    // Checks custom validation rules\n    const err = this.validateCell(cell, context);\n    if (err != null) {\n      warning += err;\n    }\n    // Updates the display with the warning icons\n    // before any potential alerts are displayed.\n    // LATER: Move this into addCellOverlay. Redraw\n    // should check if overlay was added or removed.\n    if (cell.getParent() == null) {\n      this.getView().validate();\n    }\n    return warning.length > 0 || !isValid ? warning : null;\n  },\n  /**\n   * Checks all {@link multiplicities} that cannot be enforced while the graph is\n   * being modified, namely, all multiplicities that require a minimum of\n   * 1 edge.\n   *\n   * @param cell {@link mxCell} for which the multiplicities should be checked.\n   */\n  getCellValidationError(cell) {\n    const outCount = cell.getDirectedEdgeCount(true);\n    const inCount = cell.getDirectedEdgeCount(false);\n    const value = cell.getValue();\n    let error = '';\n    for (let i = 0; i < this.multiplicities.length; i += 1) {\n      const rule = this.multiplicities[i];\n      if (rule.source && isNode(value, rule.type, rule.attr, rule.value) && (outCount > rule.max || outCount < rule.min)) {\n        error += `${rule.countError}\\n`;\n      } else if (!rule.source && isNode(value, rule.type, rule.attr, rule.value) && (inCount > rule.max || inCount < rule.min)) {\n        error += `${rule.countError}\\n`;\n      }\n    }\n    return error.length > 0 ? error : null;\n  },\n  /**\n   * Hook method for subclassers to return an error message for the given\n   * cell and validation context. This implementation returns null. Any HTML\n   * breaks will be converted to linefeeds in the calling method.\n   *\n   * @param cell {@link mxCell} that represents the cell to validate.\n   * @param context Object that represents the global validation state.\n   */\n  validateCell(cell, context) {\n    return null;\n  }\n};\nmixInto(Graph)(ValidationMixin);","map":{"version":3,"names":["Translations","isNode","Graph","mixInto","ValidationMixin","validationAlert","message","alert","isEdgeValid","edge","source","target","getEdgeValidationError","isAllowDanglingEdges","getTerminal","isAllowLoops","isValidConnection","error","isMultigraph","tmp","getDataModel","getEdgesBetween","length","get","getAlreadyConnectedResource","sourceOut","getDirectedEdgeCount","targetIn","multiplicity","multiplicities","err","check","validateEdge","validateGraph","cell","context","getRoot","isValid","childCount","getChildCount","i","getChildAt","ctx","isValidRoot","warn","setCellWarning","replace","warning","isCollapsed","getContainsValidationErrorsResource","isEdge","getCellValidationError","validateCell","getParent","getView","validate","outCount","inCount","value","getValue","rule","type","attr","max","min","countError"],"sources":["D:/ospanel/domains/old/react/react-intro-main/node_modules/@maxgraph/core/dist/view/mixins/ValidationMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Translations from '../../util/Translations';\nimport { isNode } from '../../util/domUtils';\nimport { Graph } from '../Graph';\nimport { mixInto } from '../../util/Utils';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst ValidationMixin = {\n    /*****************************************************************************\n     * Group: Validation\n     *****************************************************************************/\n    /**\n     * Displays the given validation error in a dialog. This implementation uses\n     * mxUtils.alert.\n     */\n    validationAlert(message) {\n        alert(message);\n    },\n    /**\n     * Checks if the return value of {@link getEdgeValidationError} for the given\n     * arguments is null.\n     *\n     * @param edge {@link mxCell} that represents the edge to validate.\n     * @param source {@link mxCell} that represents the source terminal.\n     * @param target {@link mxCell} that represents the target terminal.\n     */\n    isEdgeValid(edge, source, target) {\n        return !this.getEdgeValidationError(edge, source, target);\n    },\n    /**\n     * Returns the validation error message to be displayed when inserting or\n     * changing an edges' connectivity. A return value of null means the edge\n     * is valid, a return value of '' means it's not valid, but do not display\n     * an error message. Any other (non-empty) string returned from this method\n     * is displayed as an error message when trying to connect an edge to a\n     * source and target. This implementation uses the {@link multiplicities}, and\n     * checks {@link multigraph}, {@link allowDanglingEdges} and {@link allowLoops} to generate\n     * validation errors.\n     *\n     * For extending this method with specific checks for source/target cells,\n     * the method can be extended as follows. Returning an empty string means\n     * the edge is invalid with no error message, a non-null string specifies\n     * the error message, and null means the edge is valid.\n     *\n     * ```javascript\n     * graph.getEdgeValidationError = function(edge, source, target)\n     * {\n     *   if (source != null && target != null &&\n     *     this.model.getValue(source) != null &&\n     *     this.model.getValue(target) != null)\n     *   {\n     *     if (target is not valid for source)\n     *     {\n     *       return 'Invalid Target';\n     *     }\n     *   }\n     *\n     *   // \"Supercall\"\n     *   return getEdgeValidationError.apply(this, arguments);\n     * }\n     * ```\n     *\n     * @param edge {@link mxCell} that represents the edge to validate.\n     * @param source {@link mxCell} that represents the source terminal.\n     * @param target {@link mxCell} that represents the target terminal.\n     */\n    getEdgeValidationError(edge = null, source = null, target = null) {\n        if (edge && !this.isAllowDanglingEdges() && (!source || !target)) {\n            return '';\n        }\n        if (edge && !edge.getTerminal(true) && !edge.getTerminal(false)) {\n            return null;\n        }\n        // Checks if we're dealing with a loop\n        if (!this.isAllowLoops() && source === target && source) {\n            return '';\n        }\n        // Checks if the connection is generally allowed\n        if (!this.isValidConnection(source, target)) {\n            return '';\n        }\n        if (source && target) {\n            let error = '';\n            // Checks if the cells are already connected\n            // and adds an error message if required\n            if (!this.isMultigraph()) {\n                const tmp = this.getDataModel().getEdgesBetween(source, target, true);\n                // Checks if the source and target are not connected by another edge\n                if (tmp.length > 1 || (tmp.length === 1 && tmp[0] !== edge)) {\n                    error += `${Translations.get(this.getAlreadyConnectedResource()) ||\n                        this.getAlreadyConnectedResource()}\\n`;\n                }\n            }\n            // Gets the number of outgoing edges from the source\n            // and the number of incoming edges from the target\n            // without counting the edge being currently changed.\n            const sourceOut = source.getDirectedEdgeCount(true, edge);\n            const targetIn = target.getDirectedEdgeCount(false, edge);\n            // Checks the change against each multiplicity rule\n            for (const multiplicity of this.multiplicities) {\n                const err = multiplicity.check(this, // needs to cast to Graph\n                edge, source, target, sourceOut, targetIn);\n                if (err != null) {\n                    error += err;\n                }\n            }\n            // Validates the source and target terminals independently\n            const err = this.validateEdge(edge, source, target);\n            if (err != null) {\n                error += err;\n            }\n            return error.length > 0 ? error : null;\n        }\n        return this.isAllowDanglingEdges() ? null : '';\n    },\n    /**\n     * Hook method for subclassers to return an error message for the given\n     * edge and terminals. This implementation returns null.\n     *\n     * @param edge {@link mxCell} that represents the edge to validate.\n     * @param source {@link mxCell} that represents the source terminal.\n     * @param target {@link mxCell} that represents the target terminal.\n     */\n    validateEdge(edge = null, source = null, target = null) {\n        return null;\n    },\n    /**\n     * Validates the graph by validating each descendant of the given cell or\n     * the root of the model. Context is an object that contains the validation\n     * state for the complete validation run. The validation errors are\n     * attached to their cells using {@link setCellWarning}. Returns null in the case of\n     * successful validation or an array of strings (warnings) in the case of\n     * failed validations.\n     *\n     * Paramters:\n     *\n     * @param cell Optional {@link Cell} to start the validation recursion. Default is\n     * the graph root.\n     * @param context Object that represents the global validation state.\n     */\n    validateGraph(cell = null, context) {\n        cell = cell ?? this.getDataModel().getRoot();\n        if (!cell) {\n            return 'The root does not exist!';\n        }\n        context = context ?? {};\n        let isValid = true;\n        const childCount = cell.getChildCount();\n        for (let i = 0; i < childCount; i += 1) {\n            const tmp = cell.getChildAt(i);\n            let ctx = context;\n            if (this.isValidRoot(tmp)) {\n                ctx = {};\n            }\n            const warn = this.validateGraph(tmp, ctx);\n            if (warn) {\n                this.setCellWarning(tmp, warn.replace(/\\n/g, '<br>'));\n            }\n            else {\n                this.setCellWarning(tmp, null);\n            }\n            isValid = isValid && warn == null;\n        }\n        let warning = '';\n        // Adds error for invalid children if collapsed (children invisible)\n        if (cell && cell.isCollapsed() && !isValid) {\n            warning += `${Translations.get(this.getContainsValidationErrorsResource()) ||\n                this.getContainsValidationErrorsResource()}\\n`;\n        }\n        // Checks edges and cells using the defined multiplicities\n        if (cell && cell.isEdge()) {\n            warning +=\n                this.getEdgeValidationError(cell, cell.getTerminal(true), cell.getTerminal(false)) || '';\n        }\n        else {\n            warning += this.getCellValidationError(cell) || '';\n        }\n        // Checks custom validation rules\n        const err = this.validateCell(cell, context);\n        if (err != null) {\n            warning += err;\n        }\n        // Updates the display with the warning icons\n        // before any potential alerts are displayed.\n        // LATER: Move this into addCellOverlay. Redraw\n        // should check if overlay was added or removed.\n        if (cell.getParent() == null) {\n            this.getView().validate();\n        }\n        return warning.length > 0 || !isValid ? warning : null;\n    },\n    /**\n     * Checks all {@link multiplicities} that cannot be enforced while the graph is\n     * being modified, namely, all multiplicities that require a minimum of\n     * 1 edge.\n     *\n     * @param cell {@link mxCell} for which the multiplicities should be checked.\n     */\n    getCellValidationError(cell) {\n        const outCount = cell.getDirectedEdgeCount(true);\n        const inCount = cell.getDirectedEdgeCount(false);\n        const value = cell.getValue();\n        let error = '';\n        for (let i = 0; i < this.multiplicities.length; i += 1) {\n            const rule = this.multiplicities[i];\n            if (rule.source &&\n                isNode(value, rule.type, rule.attr, rule.value) &&\n                (outCount > rule.max || outCount < rule.min)) {\n                error += `${rule.countError}\\n`;\n            }\n            else if (!rule.source &&\n                isNode(value, rule.type, rule.attr, rule.value) &&\n                (inCount > rule.max || inCount < rule.min)) {\n                error += `${rule.countError}\\n`;\n            }\n        }\n        return error.length > 0 ? error : null;\n    },\n    /**\n     * Hook method for subclassers to return an error message for the given\n     * cell and validation context. This implementation returns null. Any HTML\n     * breaks will be converted to linefeeds in the calling method.\n     *\n     * @param cell {@link mxCell} that represents the cell to validate.\n     * @param context Object that represents the global validation state.\n     */\n    validateCell(cell, context) {\n        return null;\n    },\n};\nmixInto(Graph)(ValidationMixin);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}