{"ast":null,"code":"var _Trace;\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { GlobalIdleValue } from '../../../base/common/async.js';\nimport { illegalState } from '../../../base/common/errors.js';\nimport { dispose, isDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { SyncDescriptor } from './descriptors.js';\nimport { Graph } from './graph.js';\nimport { IInstantiationService, _util } from './instantiation.js';\nimport { ServiceCollection } from './serviceCollection.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\n// TRACING\nconst _enableAllTracing = false;\nclass CyclicDependencyError extends Error {\n  constructor(graph) {\n    var _graph$findCycleSlow;\n    super('cyclic dependency between services');\n    this.message = (_graph$findCycleSlow = graph.findCycleSlow()) !== null && _graph$findCycleSlow !== void 0 ? _graph$findCycleSlow : \"UNABLE to detect cycle, dumping graph: \\n\".concat(graph.toString());\n  }\n}\nexport class InstantiationService {\n  constructor() {\n    var _parent$_globalGraph;\n    let _services = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new ServiceCollection();\n    let _strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let _parent = arguments.length > 2 ? arguments[2] : undefined;\n    let _enableTracing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _enableAllTracing;\n    this._services = _services;\n    this._strict = _strict;\n    this._parent = _parent;\n    this._enableTracing = _enableTracing;\n    this._isDisposed = false;\n    this._servicesToMaybeDispose = new Set();\n    this._children = new Set();\n    this._activeInstantiations = new Set();\n    this._services.set(IInstantiationService, this);\n    this._globalGraph = _enableTracing ? (_parent$_globalGraph = _parent === null || _parent === void 0 ? void 0 : _parent._globalGraph) !== null && _parent$_globalGraph !== void 0 ? _parent$_globalGraph : new Graph(e => e) : undefined;\n  }\n  dispose() {\n    if (!this._isDisposed) {\n      this._isDisposed = true;\n      // dispose all child services\n      dispose(this._children);\n      this._children.clear();\n      // dispose all services created by this service\n      for (const candidate of this._servicesToMaybeDispose) {\n        if (isDisposable(candidate)) {\n          candidate.dispose();\n        }\n      }\n      this._servicesToMaybeDispose.clear();\n    }\n  }\n  _throwIfDisposed() {\n    if (this._isDisposed) {\n      throw new Error('InstantiationService has been disposed');\n    }\n  }\n  createChild(services, store) {\n    this._throwIfDisposed();\n    const that = this;\n    const result = new class extends InstantiationService {\n      dispose() {\n        that._children.delete(result);\n        super.dispose();\n      }\n    }(services, this._strict, this, this._enableTracing);\n    this._children.add(result);\n    store === null || store === void 0 || store.add(result);\n    return result;\n  }\n  invokeFunction(fn) {\n    this._throwIfDisposed();\n    const _trace = Trace.traceInvocation(this._enableTracing, fn);\n    let _done = false;\n    try {\n      const accessor = {\n        get: id => {\n          if (_done) {\n            throw illegalState('service accessor is only valid during the invocation of its target method');\n          }\n          const result = this._getOrCreateServiceInstance(id, _trace);\n          if (!result) {\n            throw new Error(\"[invokeFunction] unknown service '\".concat(id, \"'\"));\n          }\n          return result;\n        }\n      };\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      return fn(accessor, ...args);\n    } finally {\n      _done = true;\n      _trace.stop();\n    }\n  }\n  createInstance(ctorOrDescriptor) {\n    this._throwIfDisposed();\n    let _trace;\n    let result;\n    for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      rest[_key2 - 1] = arguments[_key2];\n    }\n    if (ctorOrDescriptor instanceof SyncDescriptor) {\n      _trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor.ctor);\n      result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n    } else {\n      _trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor);\n      result = this._createInstance(ctorOrDescriptor, rest, _trace);\n    }\n    _trace.stop();\n    return result;\n  }\n  _createInstance(ctor) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let _trace = arguments.length > 2 ? arguments[2] : undefined;\n    // arguments defined by service decorators\n    const serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);\n    const serviceArgs = [];\n    for (const dependency of serviceDependencies) {\n      const service = this._getOrCreateServiceInstance(dependency.id, _trace);\n      if (!service) {\n        this._throwIfStrict(\"[createInstance] \".concat(ctor.name, \" depends on UNKNOWN service \").concat(dependency.id, \".\"), false);\n      }\n      serviceArgs.push(service);\n    }\n    const firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;\n    // check for argument mismatches, adjust static args if needed\n    if (args.length !== firstServiceArgPos) {\n      console.trace(\"[createInstance] First service dependency of \".concat(ctor.name, \" at position \").concat(firstServiceArgPos + 1, \" conflicts with \").concat(args.length, \" static arguments\"));\n      const delta = firstServiceArgPos - args.length;\n      if (delta > 0) {\n        args = args.concat(new Array(delta));\n      } else {\n        args = args.slice(0, firstServiceArgPos);\n      }\n    }\n    // now create the instance\n    return Reflect.construct(ctor, args.concat(serviceArgs));\n  }\n  _setCreatedServiceInstance(id, instance) {\n    if (this._services.get(id) instanceof SyncDescriptor) {\n      this._services.set(id, instance);\n    } else if (this._parent) {\n      this._parent._setCreatedServiceInstance(id, instance);\n    } else {\n      throw new Error('illegalState - setting UNKNOWN service instance');\n    }\n  }\n  _getServiceInstanceOrDescriptor(id) {\n    const instanceOrDesc = this._services.get(id);\n    if (!instanceOrDesc && this._parent) {\n      return this._parent._getServiceInstanceOrDescriptor(id);\n    } else {\n      return instanceOrDesc;\n    }\n  }\n  _getOrCreateServiceInstance(id, _trace) {\n    if (this._globalGraph && this._globalGraphImplicitDependency) {\n      this._globalGraph.insertEdge(this._globalGraphImplicitDependency, String(id));\n    }\n    const thing = this._getServiceInstanceOrDescriptor(id);\n    if (thing instanceof SyncDescriptor) {\n      return this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n    } else {\n      _trace.branch(id, false);\n      return thing;\n    }\n  }\n  _safeCreateAndCacheServiceInstance(id, desc, _trace) {\n    if (this._activeInstantiations.has(id)) {\n      throw new Error(\"illegal state - RECURSIVELY instantiating service '\".concat(id, \"'\"));\n    }\n    this._activeInstantiations.add(id);\n    try {\n      return this._createAndCacheServiceInstance(id, desc, _trace);\n    } finally {\n      this._activeInstantiations.delete(id);\n    }\n  }\n  _createAndCacheServiceInstance(id, desc, _trace) {\n    const graph = new Graph(data => data.id.toString());\n    let cycleCount = 0;\n    const stack = [{\n      id,\n      desc,\n      _trace\n    }];\n    const seen = new Set();\n    while (stack.length) {\n      const item = stack.pop();\n      if (seen.has(String(item.id))) {\n        continue;\n      }\n      seen.add(String(item.id));\n      graph.lookupOrInsertNode(item);\n      // a weak but working heuristic for cycle checks\n      if (cycleCount++ > 1000) {\n        throw new CyclicDependencyError(graph);\n      }\n      // check all dependencies for existence and if they need to be created first\n      for (const dependency of _util.getServiceDependencies(item.desc.ctor)) {\n        var _this$_globalGraph;\n        const instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n        if (!instanceOrDesc) {\n          this._throwIfStrict(\"[createInstance] \".concat(id, \" depends on \").concat(dependency.id, \" which is NOT registered.\"), true);\n        }\n        // take note of all service dependencies\n        (_this$_globalGraph = this._globalGraph) === null || _this$_globalGraph === void 0 || _this$_globalGraph.insertEdge(String(item.id), String(dependency.id));\n        if (instanceOrDesc instanceof SyncDescriptor) {\n          const d = {\n            id: dependency.id,\n            desc: instanceOrDesc,\n            _trace: item._trace.branch(dependency.id, true)\n          };\n          graph.insertEdge(item, d);\n          stack.push(d);\n        }\n      }\n    }\n    while (true) {\n      const roots = graph.roots();\n      // if there is no more roots but still\n      // nodes in the graph we have a cycle\n      if (roots.length === 0) {\n        if (!graph.isEmpty()) {\n          throw new CyclicDependencyError(graph);\n        }\n        break;\n      }\n      for (const {\n        data\n      } of roots) {\n        // Repeat the check for this still being a service sync descriptor. That's because\n        // instantiating a dependency might have side-effect and recursively trigger instantiation\n        // so that some dependencies are now fullfilled already.\n        const instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);\n        if (instanceOrDesc instanceof SyncDescriptor) {\n          // create instance and overwrite the service collections\n          const instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n          this._setCreatedServiceInstance(data.id, instance);\n        }\n        graph.removeNode(data);\n      }\n    }\n    return this._getServiceInstanceOrDescriptor(id);\n  }\n  _createServiceInstanceWithOwner(id, ctor) {\n    let args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let supportsDelayedInstantiation = arguments.length > 3 ? arguments[3] : undefined;\n    let _trace = arguments.length > 4 ? arguments[4] : undefined;\n    if (this._services.get(id) instanceof SyncDescriptor) {\n      return this._createServiceInstance(id, ctor, args, supportsDelayedInstantiation, _trace, this._servicesToMaybeDispose);\n    } else if (this._parent) {\n      return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n    } else {\n      throw new Error(\"illegalState - creating UNKNOWN service instance \".concat(ctor.name));\n    }\n  }\n  _createServiceInstance(id, ctor) {\n    let args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let supportsDelayedInstantiation = arguments.length > 3 ? arguments[3] : undefined;\n    let _trace = arguments.length > 4 ? arguments[4] : undefined;\n    let disposeBucket = arguments.length > 5 ? arguments[5] : undefined;\n    if (!supportsDelayedInstantiation) {\n      // eager instantiation\n      const result = this._createInstance(ctor, args, _trace);\n      disposeBucket.add(result);\n      return result;\n    } else {\n      const child = new InstantiationService(undefined, this._strict, this, this._enableTracing);\n      child._globalGraphImplicitDependency = String(id);\n      // Return a proxy object that's backed by an idle value. That\n      // strategy is to instantiate services in our idle time or when actually\n      // needed but not when injected into a consumer\n      // return \"empty events\" when the service isn't instantiated yet\n      const earlyListeners = new Map();\n      const idle = new GlobalIdleValue(() => {\n        const result = child._createInstance(ctor, args, _trace);\n        // early listeners that we kept are now being subscribed to\n        // the real service\n        for (const [key, values] of earlyListeners) {\n          const candidate = result[key];\n          if (typeof candidate === 'function') {\n            for (const value of values) {\n              value.disposable = candidate.apply(result, value.listener);\n            }\n          }\n        }\n        earlyListeners.clear();\n        disposeBucket.add(result);\n        return result;\n      });\n      return new Proxy(Object.create(null), {\n        get(target, key) {\n          if (!idle.isInitialized) {\n            // looks like an event\n            if (typeof key === 'string' && (key.startsWith('onDid') || key.startsWith('onWill'))) {\n              let list = earlyListeners.get(key);\n              if (!list) {\n                list = new LinkedList();\n                earlyListeners.set(key, list);\n              }\n              const event = (callback, thisArg, disposables) => {\n                if (idle.isInitialized) {\n                  return idle.value[key](callback, thisArg, disposables);\n                } else {\n                  const entry = {\n                    listener: [callback, thisArg, disposables],\n                    disposable: undefined\n                  };\n                  const rm = list.push(entry);\n                  const result = toDisposable(() => {\n                    var _entry$disposable;\n                    rm();\n                    (_entry$disposable = entry.disposable) === null || _entry$disposable === void 0 || _entry$disposable.dispose();\n                  });\n                  return result;\n                }\n              };\n              return event;\n            }\n          }\n          // value already exists\n          if (key in target) {\n            return target[key];\n          }\n          // create value\n          const obj = idle.value;\n          let prop = obj[key];\n          if (typeof prop !== 'function') {\n            return prop;\n          }\n          prop = prop.bind(obj);\n          target[key] = prop;\n          return prop;\n        },\n        set(_target, p, value) {\n          idle.value[p] = value;\n          return true;\n        },\n        getPrototypeOf(_target) {\n          return ctor.prototype;\n        }\n      });\n    }\n  }\n  _throwIfStrict(msg, printWarning) {\n    if (printWarning) {\n      console.warn(msg);\n    }\n    if (this._strict) {\n      throw new Error(msg);\n    }\n  }\n}\nexport class Trace {\n  static traceInvocation(_enableTracing, ctor) {\n    return !_enableTracing ? Trace._None : new Trace(2 /* TraceType.Invocation */, ctor.name || new Error().stack.split('\\n').slice(3, 4).join('\\n'));\n  }\n  static traceCreation(_enableTracing, ctor) {\n    return !_enableTracing ? Trace._None : new Trace(1 /* TraceType.Creation */, ctor.name);\n  }\n  constructor(type, name) {\n    this.type = type;\n    this.name = name;\n    this._start = Date.now();\n    this._dep = [];\n  }\n  branch(id, first) {\n    const child = new Trace(3 /* TraceType.Branch */, id.toString());\n    this._dep.push([id, first, child]);\n    return child;\n  }\n  stop() {\n    const dur = Date.now() - this._start;\n    Trace._totals += dur;\n    let causedCreation = false;\n    function printChild(n, trace) {\n      const res = [];\n      const prefix = new Array(n + 1).join('\\t');\n      for (const [id, first, child] of trace._dep) {\n        if (first && child) {\n          causedCreation = true;\n          res.push(\"\".concat(prefix, \"CREATES -> \").concat(id));\n          const nested = printChild(n + 1, child);\n          if (nested) {\n            res.push(nested);\n          }\n        } else {\n          res.push(\"\".concat(prefix, \"uses -> \").concat(id));\n        }\n      }\n      return res.join('\\n');\n    }\n    const lines = [\"\".concat(this.type === 1 /* TraceType.Creation */ ? 'CREATE' : 'CALL', \" \").concat(this.name), \"\".concat(printChild(1, this)), \"DONE, took \".concat(dur.toFixed(2), \"ms (grand total \").concat(Trace._totals.toFixed(2), \"ms)\")];\n    if (dur > 2 || causedCreation) {\n      Trace.all.add(lines.join('\\n'));\n    }\n  }\n}\n//#endregion\n_Trace = Trace;\n_Trace.all = new Set();\n_Trace._None = new class extends _Trace {\n  constructor() {\n    super(0 /* TraceType.None */, null);\n  }\n  stop() {}\n  branch() {\n    return this;\n  }\n}();\n_Trace._totals = 0;","map":{"version":3,"names":["GlobalIdleValue","illegalState","dispose","isDisposable","toDisposable","SyncDescriptor","Graph","IInstantiationService","_util","ServiceCollection","LinkedList","_enableAllTracing","CyclicDependencyError","Error","constructor","graph","_graph$findCycleSlow","message","findCycleSlow","concat","toString","InstantiationService","_parent$_globalGraph","_services","arguments","length","undefined","_strict","_parent","_enableTracing","_isDisposed","_servicesToMaybeDispose","Set","_children","_activeInstantiations","set","_globalGraph","e","clear","candidate","_throwIfDisposed","createChild","services","store","that","result","delete","add","invokeFunction","fn","_trace","Trace","traceInvocation","_done","accessor","get","id","_getOrCreateServiceInstance","_len","args","Array","_key","stop","createInstance","ctorOrDescriptor","_len2","rest","_key2","traceCreation","ctor","_createInstance","staticArguments","serviceDependencies","getServiceDependencies","sort","a","b","index","serviceArgs","dependency","service","_throwIfStrict","name","push","firstServiceArgPos","console","trace","delta","slice","Reflect","construct","_setCreatedServiceInstance","instance","_getServiceInstanceOrDescriptor","instanceOrDesc","_globalGraphImplicitDependency","insertEdge","String","thing","_safeCreateAndCacheServiceInstance","branch","desc","has","_createAndCacheServiceInstance","data","cycleCount","stack","seen","item","pop","lookupOrInsertNode","_this$_globalGraph","d","roots","isEmpty","_createServiceInstanceWithOwner","supportsDelayedInstantiation","removeNode","_createServiceInstance","disposeBucket","child","earlyListeners","Map","idle","key","values","value","disposable","apply","listener","Proxy","Object","create","target","isInitialized","startsWith","list","event","callback","thisArg","disposables","entry","rm","_entry$disposable","obj","prop","bind","_target","p","getPrototypeOf","prototype","msg","printWarning","warn","_None","split","join","type","_start","Date","now","_dep","first","dur","_totals","causedCreation","printChild","n","res","prefix","nested","lines","toFixed","all","_Trace"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiationService.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { GlobalIdleValue } from '../../../base/common/async.js';\nimport { illegalState } from '../../../base/common/errors.js';\nimport { dispose, isDisposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { SyncDescriptor } from './descriptors.js';\nimport { Graph } from './graph.js';\nimport { IInstantiationService, _util } from './instantiation.js';\nimport { ServiceCollection } from './serviceCollection.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\n// TRACING\nconst _enableAllTracing = false;\nclass CyclicDependencyError extends Error {\n    constructor(graph) {\n        super('cyclic dependency between services');\n        this.message = graph.findCycleSlow() ?? `UNABLE to detect cycle, dumping graph: \\n${graph.toString()}`;\n    }\n}\nexport class InstantiationService {\n    constructor(_services = new ServiceCollection(), _strict = false, _parent, _enableTracing = _enableAllTracing) {\n        this._services = _services;\n        this._strict = _strict;\n        this._parent = _parent;\n        this._enableTracing = _enableTracing;\n        this._isDisposed = false;\n        this._servicesToMaybeDispose = new Set();\n        this._children = new Set();\n        this._activeInstantiations = new Set();\n        this._services.set(IInstantiationService, this);\n        this._globalGraph = _enableTracing ? _parent?._globalGraph ?? new Graph(e => e) : undefined;\n    }\n    dispose() {\n        if (!this._isDisposed) {\n            this._isDisposed = true;\n            // dispose all child services\n            dispose(this._children);\n            this._children.clear();\n            // dispose all services created by this service\n            for (const candidate of this._servicesToMaybeDispose) {\n                if (isDisposable(candidate)) {\n                    candidate.dispose();\n                }\n            }\n            this._servicesToMaybeDispose.clear();\n        }\n    }\n    _throwIfDisposed() {\n        if (this._isDisposed) {\n            throw new Error('InstantiationService has been disposed');\n        }\n    }\n    createChild(services, store) {\n        this._throwIfDisposed();\n        const that = this;\n        const result = new class extends InstantiationService {\n            dispose() {\n                that._children.delete(result);\n                super.dispose();\n            }\n        }(services, this._strict, this, this._enableTracing);\n        this._children.add(result);\n        store?.add(result);\n        return result;\n    }\n    invokeFunction(fn, ...args) {\n        this._throwIfDisposed();\n        const _trace = Trace.traceInvocation(this._enableTracing, fn);\n        let _done = false;\n        try {\n            const accessor = {\n                get: (id) => {\n                    if (_done) {\n                        throw illegalState('service accessor is only valid during the invocation of its target method');\n                    }\n                    const result = this._getOrCreateServiceInstance(id, _trace);\n                    if (!result) {\n                        throw new Error(`[invokeFunction] unknown service '${id}'`);\n                    }\n                    return result;\n                }\n            };\n            return fn(accessor, ...args);\n        }\n        finally {\n            _done = true;\n            _trace.stop();\n        }\n    }\n    createInstance(ctorOrDescriptor, ...rest) {\n        this._throwIfDisposed();\n        let _trace;\n        let result;\n        if (ctorOrDescriptor instanceof SyncDescriptor) {\n            _trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor.ctor);\n            result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n        }\n        else {\n            _trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor);\n            result = this._createInstance(ctorOrDescriptor, rest, _trace);\n        }\n        _trace.stop();\n        return result;\n    }\n    _createInstance(ctor, args = [], _trace) {\n        // arguments defined by service decorators\n        const serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);\n        const serviceArgs = [];\n        for (const dependency of serviceDependencies) {\n            const service = this._getOrCreateServiceInstance(dependency.id, _trace);\n            if (!service) {\n                this._throwIfStrict(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`, false);\n            }\n            serviceArgs.push(service);\n        }\n        const firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;\n        // check for argument mismatches, adjust static args if needed\n        if (args.length !== firstServiceArgPos) {\n            console.trace(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);\n            const delta = firstServiceArgPos - args.length;\n            if (delta > 0) {\n                args = args.concat(new Array(delta));\n            }\n            else {\n                args = args.slice(0, firstServiceArgPos);\n            }\n        }\n        // now create the instance\n        return Reflect.construct(ctor, args.concat(serviceArgs));\n    }\n    _setCreatedServiceInstance(id, instance) {\n        if (this._services.get(id) instanceof SyncDescriptor) {\n            this._services.set(id, instance);\n        }\n        else if (this._parent) {\n            this._parent._setCreatedServiceInstance(id, instance);\n        }\n        else {\n            throw new Error('illegalState - setting UNKNOWN service instance');\n        }\n    }\n    _getServiceInstanceOrDescriptor(id) {\n        const instanceOrDesc = this._services.get(id);\n        if (!instanceOrDesc && this._parent) {\n            return this._parent._getServiceInstanceOrDescriptor(id);\n        }\n        else {\n            return instanceOrDesc;\n        }\n    }\n    _getOrCreateServiceInstance(id, _trace) {\n        if (this._globalGraph && this._globalGraphImplicitDependency) {\n            this._globalGraph.insertEdge(this._globalGraphImplicitDependency, String(id));\n        }\n        const thing = this._getServiceInstanceOrDescriptor(id);\n        if (thing instanceof SyncDescriptor) {\n            return this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n        }\n        else {\n            _trace.branch(id, false);\n            return thing;\n        }\n    }\n    _safeCreateAndCacheServiceInstance(id, desc, _trace) {\n        if (this._activeInstantiations.has(id)) {\n            throw new Error(`illegal state - RECURSIVELY instantiating service '${id}'`);\n        }\n        this._activeInstantiations.add(id);\n        try {\n            return this._createAndCacheServiceInstance(id, desc, _trace);\n        }\n        finally {\n            this._activeInstantiations.delete(id);\n        }\n    }\n    _createAndCacheServiceInstance(id, desc, _trace) {\n        const graph = new Graph(data => data.id.toString());\n        let cycleCount = 0;\n        const stack = [{ id, desc, _trace }];\n        const seen = new Set();\n        while (stack.length) {\n            const item = stack.pop();\n            if (seen.has(String(item.id))) {\n                continue;\n            }\n            seen.add(String(item.id));\n            graph.lookupOrInsertNode(item);\n            // a weak but working heuristic for cycle checks\n            if (cycleCount++ > 1000) {\n                throw new CyclicDependencyError(graph);\n            }\n            // check all dependencies for existence and if they need to be created first\n            for (const dependency of _util.getServiceDependencies(item.desc.ctor)) {\n                const instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n                if (!instanceOrDesc) {\n                    this._throwIfStrict(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`, true);\n                }\n                // take note of all service dependencies\n                this._globalGraph?.insertEdge(String(item.id), String(dependency.id));\n                if (instanceOrDesc instanceof SyncDescriptor) {\n                    const d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };\n                    graph.insertEdge(item, d);\n                    stack.push(d);\n                }\n            }\n        }\n        while (true) {\n            const roots = graph.roots();\n            // if there is no more roots but still\n            // nodes in the graph we have a cycle\n            if (roots.length === 0) {\n                if (!graph.isEmpty()) {\n                    throw new CyclicDependencyError(graph);\n                }\n                break;\n            }\n            for (const { data } of roots) {\n                // Repeat the check for this still being a service sync descriptor. That's because\n                // instantiating a dependency might have side-effect and recursively trigger instantiation\n                // so that some dependencies are now fullfilled already.\n                const instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);\n                if (instanceOrDesc instanceof SyncDescriptor) {\n                    // create instance and overwrite the service collections\n                    const instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n                    this._setCreatedServiceInstance(data.id, instance);\n                }\n                graph.removeNode(data);\n            }\n        }\n        return this._getServiceInstanceOrDescriptor(id);\n    }\n    _createServiceInstanceWithOwner(id, ctor, args = [], supportsDelayedInstantiation, _trace) {\n        if (this._services.get(id) instanceof SyncDescriptor) {\n            return this._createServiceInstance(id, ctor, args, supportsDelayedInstantiation, _trace, this._servicesToMaybeDispose);\n        }\n        else if (this._parent) {\n            return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n        }\n        else {\n            throw new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);\n        }\n    }\n    _createServiceInstance(id, ctor, args = [], supportsDelayedInstantiation, _trace, disposeBucket) {\n        if (!supportsDelayedInstantiation) {\n            // eager instantiation\n            const result = this._createInstance(ctor, args, _trace);\n            disposeBucket.add(result);\n            return result;\n        }\n        else {\n            const child = new InstantiationService(undefined, this._strict, this, this._enableTracing);\n            child._globalGraphImplicitDependency = String(id);\n            // Return a proxy object that's backed by an idle value. That\n            // strategy is to instantiate services in our idle time or when actually\n            // needed but not when injected into a consumer\n            // return \"empty events\" when the service isn't instantiated yet\n            const earlyListeners = new Map();\n            const idle = new GlobalIdleValue(() => {\n                const result = child._createInstance(ctor, args, _trace);\n                // early listeners that we kept are now being subscribed to\n                // the real service\n                for (const [key, values] of earlyListeners) {\n                    const candidate = result[key];\n                    if (typeof candidate === 'function') {\n                        for (const value of values) {\n                            value.disposable = candidate.apply(result, value.listener);\n                        }\n                    }\n                }\n                earlyListeners.clear();\n                disposeBucket.add(result);\n                return result;\n            });\n            return new Proxy(Object.create(null), {\n                get(target, key) {\n                    if (!idle.isInitialized) {\n                        // looks like an event\n                        if (typeof key === 'string' && (key.startsWith('onDid') || key.startsWith('onWill'))) {\n                            let list = earlyListeners.get(key);\n                            if (!list) {\n                                list = new LinkedList();\n                                earlyListeners.set(key, list);\n                            }\n                            const event = (callback, thisArg, disposables) => {\n                                if (idle.isInitialized) {\n                                    return idle.value[key](callback, thisArg, disposables);\n                                }\n                                else {\n                                    const entry = { listener: [callback, thisArg, disposables], disposable: undefined };\n                                    const rm = list.push(entry);\n                                    const result = toDisposable(() => {\n                                        rm();\n                                        entry.disposable?.dispose();\n                                    });\n                                    return result;\n                                }\n                            };\n                            return event;\n                        }\n                    }\n                    // value already exists\n                    if (key in target) {\n                        return target[key];\n                    }\n                    // create value\n                    const obj = idle.value;\n                    let prop = obj[key];\n                    if (typeof prop !== 'function') {\n                        return prop;\n                    }\n                    prop = prop.bind(obj);\n                    target[key] = prop;\n                    return prop;\n                },\n                set(_target, p, value) {\n                    idle.value[p] = value;\n                    return true;\n                },\n                getPrototypeOf(_target) {\n                    return ctor.prototype;\n                }\n            });\n        }\n    }\n    _throwIfStrict(msg, printWarning) {\n        if (printWarning) {\n            console.warn(msg);\n        }\n        if (this._strict) {\n            throw new Error(msg);\n        }\n    }\n}\nexport class Trace {\n    static { this.all = new Set(); }\n    static { this._None = new class extends Trace {\n        constructor() { super(0 /* TraceType.None */, null); }\n        stop() { }\n        branch() { return this; }\n    }; }\n    static traceInvocation(_enableTracing, ctor) {\n        return !_enableTracing ? Trace._None : new Trace(2 /* TraceType.Invocation */, ctor.name || new Error().stack.split('\\n').slice(3, 4).join('\\n'));\n    }\n    static traceCreation(_enableTracing, ctor) {\n        return !_enableTracing ? Trace._None : new Trace(1 /* TraceType.Creation */, ctor.name);\n    }\n    static { this._totals = 0; }\n    constructor(type, name) {\n        this.type = type;\n        this.name = name;\n        this._start = Date.now();\n        this._dep = [];\n    }\n    branch(id, first) {\n        const child = new Trace(3 /* TraceType.Branch */, id.toString());\n        this._dep.push([id, first, child]);\n        return child;\n    }\n    stop() {\n        const dur = Date.now() - this._start;\n        Trace._totals += dur;\n        let causedCreation = false;\n        function printChild(n, trace) {\n            const res = [];\n            const prefix = new Array(n + 1).join('\\t');\n            for (const [id, first, child] of trace._dep) {\n                if (first && child) {\n                    causedCreation = true;\n                    res.push(`${prefix}CREATES -> ${id}`);\n                    const nested = printChild(n + 1, child);\n                    if (nested) {\n                        res.push(nested);\n                    }\n                }\n                else {\n                    res.push(`${prefix}uses -> ${id}`);\n                }\n            }\n            return res.join('\\n');\n        }\n        const lines = [\n            `${this.type === 1 /* TraceType.Creation */ ? 'CREATE' : 'CALL'} ${this.name}`,\n            `${printChild(1, this)}`,\n            `DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`\n        ];\n        if (dur > 2 || causedCreation) {\n            Trace.all.add(lines.join('\\n'));\n        }\n    }\n}\n//#endregion\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}