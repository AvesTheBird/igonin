{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ConnectionConstraint from '../../other/ConnectionConstraint';\nimport Rectangle from '../Rectangle';\nimport Shape from '../Shape';\nimport Translations from '../../../util/Translations';\nimport { getValue, isNotNullish } from '../../../util/Utils';\nimport { ALIGN, DIRECTION, NODETYPE, NONE, RECTANGLE_ROUNDING_FACTOR, TEXT_DIRECTION } from '../../../util/Constants';\nimport StencilShapeRegistry from './StencilShapeRegistry';\nimport { getChildNodes, getTextContent } from '../../../util/domUtils';\nimport Point from '../Point';\nimport { getNumber } from '../../../util/StringUtils';\n/**\n * Implements a generic shape which is based on a XML node as a description.\n *\n * @class StencilShape\n */\nclass StencilShape extends Shape {\n  constructor(desc) {\n    super();\n    /**\n     * Holds an array of {@link ConnectionConstraints} as defined in the shape.\n     */\n    this.constraints = [];\n    /**\n     * Holds the aspect of the shape. Default is 'auto'.\n     */\n    this.aspect = 'auto';\n    /**\n     * Holds the width of the shape. Default is 100.\n     */\n    this.w0 = 100;\n    /**\n     * Holds the height of the shape. Default is 100.\n     */\n    this.h0 = 100;\n    /**\n     * Holds the XML node with the stencil description.\n     */\n    // bgNode: Element;\n    this.bgNode = null;\n    /**\n     * Holds the XML node with the stencil description.\n     */\n    this.fgNode = null;\n    /**\n     * Holds the strokewidth direction from the description.\n     */\n    this.strokeWidthValue = null;\n    this.desc = desc;\n    this.parseDescription();\n    this.parseConstraints();\n  }\n  /**\n   * Reads <w0>, <h0>, <aspect>, <bgNodes> and <fgNodes> from <desc>.\n   */\n  parseDescription() {\n    // LATER: Preprocess nodes for faster painting\n    this.fgNode = this.desc.getElementsByTagName('foreground')[0];\n    this.bgNode = this.desc.getElementsByTagName('background')[0];\n    this.w0 = Number(this.desc.getAttribute('w') || 100);\n    this.h0 = Number(this.desc.getAttribute('h') || 100);\n    // Possible values for aspect are: variable and fixed where\n    // variable means fill the available space and fixed means\n    // use w0 and h0 to compute the aspect.\n    const aspect = this.desc.getAttribute('aspect');\n    this.aspect = aspect ?? 'variable';\n    // Possible values for strokewidth are all numbers and \"inherit\"\n    // where the inherit means take the value from the style (ie. the\n    // user-defined stroke-width). Note that the strokewidth is scaled\n    // by the minimum scaling that is used to draw the shape (sx, sy).\n    const sw = this.desc.getAttribute('strokewidth');\n    this.strokeWidthValue = isNotNullish(sw) ? sw : '1';\n  }\n  /**\n   * Reads the constraints from <desc> into <constraints> using\n   * <parseConstraint>.\n   */\n  parseConstraints() {\n    const conns = this.desc.getElementsByTagName('connections')[0];\n    if (conns) {\n      const tmp = getChildNodes(conns);\n      if (tmp.length > 0) {\n        this.constraints = [];\n        for (let i = 0; i < tmp.length; i += 1) {\n          this.constraints.push(this.parseConstraint(tmp[i]));\n        }\n      }\n    }\n  }\n  /**\n   * Parses the given XML node and returns its {@link ConnectionConstraint}.\n   */\n  parseConstraint(node) {\n    const x = Number(node.getAttribute('x'));\n    const y = Number(node.getAttribute('y'));\n    const perimeter = node.getAttribute('perimeter') === '1';\n    const name = node.getAttribute('name');\n    return new ConnectionConstraint(new Point(x, y), perimeter, name);\n  }\n  /**\n   * Gets the given attribute as a text. The return value from <evaluateAttribute>\n   * is used as a key to {@link Resources#get} if the localized attribute in the text\n   * node is 1 or if <defaultLocalized> is true.\n   */\n  evaluateTextAttribute(node, attribute, shape) {\n    let result = this.evaluateAttribute(node, attribute, shape);\n    const loc = node.getAttribute('localized');\n    if (StencilShape.defaultLocalized && !loc || loc === '1') {\n      result = Translations.get(result);\n    }\n    return result;\n  }\n  /**\n   * Gets the attribute for the given name from the given node. If the attribute\n   * does not exist then the text content of the node is evaluated and if it is\n   * a function it is invoked with <shape> as the only argument and the return\n   * value is used as the attribute value to be returned.\n   */\n  evaluateAttribute(node, attribute, shape) {\n    let result = node.getAttribute(attribute);\n    if (!result) {\n      const text = getTextContent(node);\n      if (text && StencilShape.allowEval) {\n        const funct = eval(text);\n        if (typeof funct === 'function') {\n          result = funct(shape);\n        }\n      }\n    }\n    return result;\n  }\n  /**\n   * Draws this stencil inside the given bounds.\n   */\n  drawShape(canvas, shape, x, y, w, h) {\n    const stack = canvas.states.slice();\n    // TODO: Internal structure (array of special structs?), relative and absolute\n    // coordinates (eg. note shape, process vs star, actor etc.), text rendering\n    // and non-proportional scaling, how to implement pluggable edge shapes\n    // (start, segment, end blocks), pluggable markers, how to implement\n    // swimlanes (title area) with this API, add icon, horizontal/vertical\n    // label, indicator for all shapes, rotation\n    const direction = getValue(shape.style, 'direction', null);\n    const aspect = this.computeAspect(shape, x, y, w, h, direction);\n    const minScale = Math.min(aspect.width, aspect.height);\n    const sw = this.strokeWidthValue === 'inherit' ? Number(getNumber(shape.style, 'strokeWidth', 1)) : Number(this.strokeWidthValue) * minScale;\n    canvas.setStrokeWidth(sw);\n    // Draws a transparent rectangle for catching events\n    if (shape.style?.pointerEvents ?? false) {\n      canvas.setStrokeColor(NONE);\n      canvas.rect(x, y, w, h);\n      canvas.stroke();\n      canvas.setStrokeColor(shape.stroke);\n    }\n    this.drawChildren(canvas, shape, x, y, w, h, this.bgNode, aspect, false, true);\n    this.drawChildren(canvas, shape, x, y, w, h, this.fgNode, aspect, true, !shape.outline || shape.style == null || !(shape.style.backgroundOutline ?? false));\n    // Restores stack for unequal count of save/restore calls\n    if (canvas.states.length != stack.length) {\n      canvas.states = stack;\n    }\n  }\n  /**\n   * Draws this stencil inside the given bounds.\n   */\n  drawChildren(canvas, shape, x, y, w, h, node, aspect, disableShadow, paint) {\n    if (node && w > 0 && h > 0) {\n      let tmp = node.firstChild;\n      while (tmp) {\n        if (tmp.nodeType === NODETYPE.ELEMENT) {\n          this.drawNode(canvas, shape, tmp, aspect, disableShadow, paint);\n        }\n        tmp = tmp.nextSibling;\n      }\n    }\n  }\n  /**\n   * Returns a rectangle that contains the offset in x and y and the horizontal\n   * and vertical scale in width and height used to draw this shape inside the\n   * given {@link Rectangle}.\n   *\n   * @param shape {@link Shape} to be drawn.\n   * @param bounds {@link Rectangle} that should contain the stencil.\n   * @param direction Optional direction of the shape to be darwn.\n   */\n  computeAspect(shape = null, x, y, w, h, direction) {\n    let x0 = x;\n    let y0 = y;\n    let sx = w / this.w0;\n    let sy = h / this.h0;\n    const inverse = direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH;\n    if (inverse) {\n      sy = w / this.h0;\n      sx = h / this.w0;\n      const delta = (w - h) / 2;\n      x0 += delta;\n      y0 -= delta;\n    }\n    if (this.aspect === 'fixed') {\n      sy = Math.min(sx, sy);\n      sx = sy;\n      // Centers the shape inside the available space\n      if (inverse) {\n        x0 += (h - this.w0 * sx) / 2;\n        y0 += (w - this.h0 * sy) / 2;\n      } else {\n        x0 += (w - this.w0 * sx) / 2;\n        y0 += (h - this.h0 * sy) / 2;\n      }\n    }\n    return new Rectangle(x0, y0, sx, sy);\n  }\n  /**\n   * Draws this stencil inside the given bounds.\n   */\n  drawNode(canvas, shape, node, aspect, disableShadow, paint) {\n    const name = node.nodeName;\n    const x0 = aspect.x;\n    const y0 = aspect.y;\n    const sx = aspect.width;\n    const sy = aspect.height;\n    const minScale = Math.min(sx, sy);\n    if (name === 'save') {\n      canvas.save();\n    } else if (name === 'restore') {\n      canvas.restore();\n    } else if (paint) {\n      if (name === 'path') {\n        canvas.begin();\n        let parseRegularly = true;\n        if (node.getAttribute('rounded') == '1') {\n          parseRegularly = false;\n          const arcSize = Number(node.getAttribute('arcSize'));\n          let pointCount = 0;\n          const segs = [];\n          // Renders the elements inside the given path\n          let childNode = node.firstChild;\n          while (childNode != null) {\n            if (childNode.nodeType === NODETYPE.ELEMENT) {\n              const childName = childNode.nodeName;\n              if (childName === 'move' || childName === 'line') {\n                if (childName === 'move' || segs.length === 0) {\n                  segs.push([]);\n                }\n                segs[segs.length - 1].push(new Point(x0 + Number(childNode.getAttribute('x')) * sx, y0 + Number(childNode.getAttribute('y')) * sy));\n                pointCount++;\n              } else {\n                // We only support move and line for rounded corners\n                parseRegularly = true;\n                break;\n              }\n            }\n            childNode = childNode.nextSibling;\n          }\n          if (!parseRegularly && pointCount > 0) {\n            for (let i = 0; i < segs.length; i += 1) {\n              let close = false;\n              const ps = segs[i][0];\n              const pe = segs[i][segs[i].length - 1];\n              if (ps.x === pe.x && ps.y === pe.y) {\n                segs[i].pop();\n                close = true;\n              }\n              this.addPoints(canvas, segs[i], true, arcSize, close);\n            }\n          } else {\n            parseRegularly = true;\n          }\n        }\n        if (parseRegularly) {\n          // Renders the elements inside the given path\n          let childNode = node.firstChild;\n          while (childNode) {\n            if (childNode.nodeType === NODETYPE.ELEMENT) {\n              this.drawNode(canvas, shape, childNode, aspect, disableShadow, paint);\n            }\n            childNode = childNode.nextSibling;\n          }\n        }\n      } else if (name === 'close') {\n        canvas.close();\n      } else if (name === 'move') {\n        canvas.moveTo(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy);\n      } else if (name === 'line') {\n        canvas.lineTo(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy);\n      } else if (name === 'quad') {\n        canvas.quadTo(x0 + Number(node.getAttribute('x1')) * sx, y0 + Number(node.getAttribute('y1')) * sy, x0 + Number(node.getAttribute('x2')) * sx, y0 + Number(node.getAttribute('y2')) * sy);\n      } else if (name === 'curve') {\n        canvas.curveTo(x0 + Number(node.getAttribute('x1')) * sx, y0 + Number(node.getAttribute('y1')) * sy, x0 + Number(node.getAttribute('x2')) * sx, y0 + Number(node.getAttribute('y2')) * sy, x0 + Number(node.getAttribute('x3')) * sx, y0 + Number(node.getAttribute('y3')) * sy);\n      } else if (name === 'arc') {\n        canvas.arcTo(Number(node.getAttribute('rx')) * sx, Number(node.getAttribute('ry')) * sy, Number(node.getAttribute('x-axis-rotation')), Boolean(node.getAttribute('large-arc-flag')), Boolean(node.getAttribute('sweep-flag')), x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy);\n      } else if (name === 'rect') {\n        canvas.rect(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy, Number(node.getAttribute('w')) * sx, Number(node.getAttribute('h')) * sy);\n      } else if (name === 'roundrect') {\n        let arcsize = Number(node.getAttribute('arcsize'));\n        if (arcsize === 0) {\n          arcsize = RECTANGLE_ROUNDING_FACTOR * 100;\n        }\n        const w = Number(node.getAttribute('w')) * sx;\n        const h = Number(node.getAttribute('h')) * sy;\n        const factor = Number(arcsize) / 100;\n        const r = Math.min(w * factor, h * factor);\n        canvas.roundrect(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy, w, h, r, r);\n      } else if (name === 'ellipse') {\n        canvas.ellipse(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy, Number(node.getAttribute('w')) * sx, Number(node.getAttribute('h')) * sy);\n      } else if (name === 'image') {\n        if (!shape.outline) {\n          const src = this.evaluateAttribute(node, 'src', shape);\n          canvas.image(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy, Number(node.getAttribute('w')) * sx, Number(node.getAttribute('h')) * sy, src, false, node.getAttribute('flipH') === '1', node.getAttribute('flipV') === '1');\n        }\n      } else if (name === 'text') {\n        if (!shape.outline) {\n          const str = this.evaluateTextAttribute(node, 'str', shape);\n          let rotation = node.getAttribute('vertical') == '1' ? -90 : 0;\n          if (node.getAttribute('align-shape') === '0') {\n            const dr = shape.rotation;\n            // Depends on flipping\n            const flipH = getValue(shape.style, 'flipH', 0) == 1;\n            const flipV = getValue(shape.style, 'flipV', 0) == 1;\n            if (flipH && flipV) {\n              rotation -= dr;\n            } else if (flipH || flipV) {\n              rotation += dr;\n            } else {\n              rotation -= dr;\n            }\n          }\n          rotation -= Number(node.getAttribute('rotation'));\n          canvas.text(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy, 0, 0, str, node.getAttribute('align') || ALIGN.LEFT, node.getAttribute('valign') || ALIGN.TOP, false, '', 'auto', false, rotation, TEXT_DIRECTION.AUTO);\n        }\n      } else if (name === 'include-shape') {\n        const stencil = StencilShapeRegistry.getStencil(node.getAttribute('name'));\n        if (stencil) {\n          const x = x0 + Number(node.getAttribute('x')) * sx;\n          const y = y0 + Number(node.getAttribute('y')) * sy;\n          const w = Number(node.getAttribute('w')) * sx;\n          const h = Number(node.getAttribute('h')) * sy;\n          stencil.drawShape(canvas, shape, x, y, w, h);\n        }\n      } else if (name === 'fillstroke') {\n        canvas.fillAndStroke();\n      } else if (name === 'fill') {\n        canvas.fill();\n      } else if (name === 'stroke') {\n        canvas.stroke();\n      } else if (name === 'strokewidth') {\n        const s = node.getAttribute('fixed') === '1' ? 1 : minScale;\n        canvas.setStrokeWidth(Number(node.getAttribute('width')) * s);\n      } else if (name === 'dashed') {\n        canvas.setDashed(node.getAttribute('dashed') === '1');\n      } else if (name === 'dashpattern') {\n        let value = node.getAttribute('pattern');\n        if (value != null) {\n          const tmp = value.split(' ');\n          const pat = [];\n          for (let i = 0; i < tmp.length; i += 1) {\n            if (tmp[i].length > 0) {\n              pat.push(Number(tmp[i]) * minScale);\n            }\n          }\n          value = pat.join(' ');\n          canvas.setDashPattern(value);\n        }\n      } else if (name === 'strokecolor') {\n        canvas.setStrokeColor(node.getAttribute('color'));\n      } else if (name === 'linecap') {\n        canvas.setLineCap(node.getAttribute('cap'));\n      } else if (name === 'linejoin') {\n        canvas.setLineJoin(node.getAttribute('join'));\n      } else if (name === 'miterlimit') {\n        canvas.setMiterLimit(Number(node.getAttribute('limit')));\n      } else if (name === 'fillcolor') {\n        canvas.setFillColor(node.getAttribute('color'));\n      } else if (name === 'alpha') {\n        canvas.setAlpha(Number(node.getAttribute('alpha')));\n      } else if (name === 'fillalpha') {\n        canvas.setAlpha(Number(node.getAttribute('alpha')));\n      } else if (name === 'strokealpha') {\n        canvas.setAlpha(Number(node.getAttribute('alpha')));\n      } else if (name === 'fontcolor') {\n        canvas.setFontColor(node.getAttribute('color'));\n      } else if (name === 'fontstyle') {\n        canvas.setFontStyle(Number(node.getAttribute('style')));\n      } else if (name === 'fontfamily') {\n        canvas.setFontFamily(node.getAttribute('family'));\n      } else if (name === 'fontsize') {\n        canvas.setFontSize(Number(node.getAttribute('size')) * minScale);\n      }\n      if (disableShadow && (name === 'fillstroke' || name === 'fill' || name === 'stroke')) {\n        disableShadow = false;\n        canvas.setShadow(false);\n      }\n    }\n  }\n}\n/**\n * Static global variable that specifies the default value for the localized\n * attribute of the text element. Default is false.\n */\nStencilShape.defaultLocalized = false;\n/**\n * Static global switch that specifies if the use of eval is allowed for\n * evaluating text content and images. Default is false. Set this to true\n * if stencils can not contain user input.\n */\nStencilShape.allowEval = false;\nexport default StencilShape;","map":{"version":3,"names":["ConnectionConstraint","Rectangle","Shape","Translations","getValue","isNotNullish","ALIGN","DIRECTION","NODETYPE","NONE","RECTANGLE_ROUNDING_FACTOR","TEXT_DIRECTION","StencilShapeRegistry","getChildNodes","getTextContent","Point","getNumber","StencilShape","constructor","desc","constraints","aspect","w0","h0","bgNode","fgNode","strokeWidthValue","parseDescription","parseConstraints","getElementsByTagName","Number","getAttribute","sw","conns","tmp","length","i","push","parseConstraint","node","x","y","perimeter","name","evaluateTextAttribute","attribute","shape","result","evaluateAttribute","loc","defaultLocalized","get","text","allowEval","funct","eval","drawShape","canvas","w","h","stack","states","slice","direction","style","computeAspect","minScale","Math","min","width","height","setStrokeWidth","pointerEvents","setStrokeColor","rect","stroke","drawChildren","outline","backgroundOutline","disableShadow","paint","firstChild","nodeType","ELEMENT","drawNode","nextSibling","x0","y0","sx","sy","inverse","NORTH","SOUTH","delta","nodeName","save","restore","begin","parseRegularly","arcSize","pointCount","segs","childNode","childName","close","ps","pe","pop","addPoints","moveTo","lineTo","quadTo","curveTo","arcTo","Boolean","arcsize","factor","r","roundrect","ellipse","src","image","str","rotation","dr","flipH","flipV","LEFT","TOP","AUTO","stencil","getStencil","fillAndStroke","fill","s","setDashed","value","split","pat","join","setDashPattern","setLineCap","setLineJoin","setMiterLimit","setFillColor","setAlpha","setFontColor","setFontStyle","setFontFamily","setFontSize","setShadow"],"sources":["D:/OSPanel/domains/old/react/react-intro/node_modules/@maxgraph/core/dist/view/geometry/node/StencilShape.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ConnectionConstraint from '../../other/ConnectionConstraint';\nimport Rectangle from '../Rectangle';\nimport Shape from '../Shape';\nimport Translations from '../../../util/Translations';\nimport { getValue, isNotNullish } from '../../../util/Utils';\nimport { ALIGN, DIRECTION, NODETYPE, NONE, RECTANGLE_ROUNDING_FACTOR, TEXT_DIRECTION, } from '../../../util/Constants';\nimport StencilShapeRegistry from './StencilShapeRegistry';\nimport { getChildNodes, getTextContent } from '../../../util/domUtils';\nimport Point from '../Point';\nimport { getNumber } from '../../../util/StringUtils';\n/**\n * Implements a generic shape which is based on a XML node as a description.\n *\n * @class StencilShape\n */\nclass StencilShape extends Shape {\n    constructor(desc) {\n        super();\n        /**\n         * Holds an array of {@link ConnectionConstraints} as defined in the shape.\n         */\n        this.constraints = [];\n        /**\n         * Holds the aspect of the shape. Default is 'auto'.\n         */\n        this.aspect = 'auto';\n        /**\n         * Holds the width of the shape. Default is 100.\n         */\n        this.w0 = 100;\n        /**\n         * Holds the height of the shape. Default is 100.\n         */\n        this.h0 = 100;\n        /**\n         * Holds the XML node with the stencil description.\n         */\n        // bgNode: Element;\n        this.bgNode = null;\n        /**\n         * Holds the XML node with the stencil description.\n         */\n        this.fgNode = null;\n        /**\n         * Holds the strokewidth direction from the description.\n         */\n        this.strokeWidthValue = null;\n        this.desc = desc;\n        this.parseDescription();\n        this.parseConstraints();\n    }\n    /**\n     * Reads <w0>, <h0>, <aspect>, <bgNodes> and <fgNodes> from <desc>.\n     */\n    parseDescription() {\n        // LATER: Preprocess nodes for faster painting\n        this.fgNode = this.desc.getElementsByTagName('foreground')[0];\n        this.bgNode = this.desc.getElementsByTagName('background')[0];\n        this.w0 = Number(this.desc.getAttribute('w') || 100);\n        this.h0 = Number(this.desc.getAttribute('h') || 100);\n        // Possible values for aspect are: variable and fixed where\n        // variable means fill the available space and fixed means\n        // use w0 and h0 to compute the aspect.\n        const aspect = this.desc.getAttribute('aspect');\n        this.aspect = aspect ?? 'variable';\n        // Possible values for strokewidth are all numbers and \"inherit\"\n        // where the inherit means take the value from the style (ie. the\n        // user-defined stroke-width). Note that the strokewidth is scaled\n        // by the minimum scaling that is used to draw the shape (sx, sy).\n        const sw = this.desc.getAttribute('strokewidth');\n        this.strokeWidthValue = isNotNullish(sw) ? sw : '1';\n    }\n    /**\n     * Reads the constraints from <desc> into <constraints> using\n     * <parseConstraint>.\n     */\n    parseConstraints() {\n        const conns = this.desc.getElementsByTagName('connections')[0];\n        if (conns) {\n            const tmp = getChildNodes(conns);\n            if (tmp.length > 0) {\n                this.constraints = [];\n                for (let i = 0; i < tmp.length; i += 1) {\n                    this.constraints.push(this.parseConstraint(tmp[i]));\n                }\n            }\n        }\n    }\n    /**\n     * Parses the given XML node and returns its {@link ConnectionConstraint}.\n     */\n    parseConstraint(node) {\n        const x = Number(node.getAttribute('x'));\n        const y = Number(node.getAttribute('y'));\n        const perimeter = node.getAttribute('perimeter') === '1';\n        const name = node.getAttribute('name');\n        return new ConnectionConstraint(new Point(x, y), perimeter, name);\n    }\n    /**\n     * Gets the given attribute as a text. The return value from <evaluateAttribute>\n     * is used as a key to {@link Resources#get} if the localized attribute in the text\n     * node is 1 or if <defaultLocalized> is true.\n     */\n    evaluateTextAttribute(node, attribute, shape) {\n        let result = this.evaluateAttribute(node, attribute, shape);\n        const loc = node.getAttribute('localized');\n        if ((StencilShape.defaultLocalized && !loc) || loc === '1') {\n            result = Translations.get(result);\n        }\n        return result;\n    }\n    /**\n     * Gets the attribute for the given name from the given node. If the attribute\n     * does not exist then the text content of the node is evaluated and if it is\n     * a function it is invoked with <shape> as the only argument and the return\n     * value is used as the attribute value to be returned.\n     */\n    evaluateAttribute(node, attribute, shape) {\n        let result = node.getAttribute(attribute);\n        if (!result) {\n            const text = getTextContent(node);\n            if (text && StencilShape.allowEval) {\n                const funct = eval(text);\n                if (typeof funct === 'function') {\n                    result = funct(shape);\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Draws this stencil inside the given bounds.\n     */\n    drawShape(canvas, shape, x, y, w, h) {\n        const stack = canvas.states.slice();\n        // TODO: Internal structure (array of special structs?), relative and absolute\n        // coordinates (eg. note shape, process vs star, actor etc.), text rendering\n        // and non-proportional scaling, how to implement pluggable edge shapes\n        // (start, segment, end blocks), pluggable markers, how to implement\n        // swimlanes (title area) with this API, add icon, horizontal/vertical\n        // label, indicator for all shapes, rotation\n        const direction = getValue(shape.style, 'direction', null);\n        const aspect = this.computeAspect(shape, x, y, w, h, direction);\n        const minScale = Math.min(aspect.width, aspect.height);\n        const sw = this.strokeWidthValue === 'inherit'\n            ? Number(getNumber(shape.style, 'strokeWidth', 1))\n            : Number(this.strokeWidthValue) * minScale;\n        canvas.setStrokeWidth(sw);\n        // Draws a transparent rectangle for catching events\n        if (shape.style?.pointerEvents ?? false) {\n            canvas.setStrokeColor(NONE);\n            canvas.rect(x, y, w, h);\n            canvas.stroke();\n            canvas.setStrokeColor(shape.stroke);\n        }\n        this.drawChildren(canvas, shape, x, y, w, h, this.bgNode, aspect, false, true);\n        this.drawChildren(canvas, shape, x, y, w, h, this.fgNode, aspect, true, !shape.outline || shape.style == null || !(shape.style.backgroundOutline ?? false));\n        // Restores stack for unequal count of save/restore calls\n        if (canvas.states.length != stack.length) {\n            canvas.states = stack;\n        }\n    }\n    /**\n     * Draws this stencil inside the given bounds.\n     */\n    drawChildren(canvas, shape, x, y, w, h, node, aspect, disableShadow, paint) {\n        if (node && w > 0 && h > 0) {\n            let tmp = node.firstChild;\n            while (tmp) {\n                if (tmp.nodeType === NODETYPE.ELEMENT) {\n                    this.drawNode(canvas, shape, tmp, aspect, disableShadow, paint);\n                }\n                tmp = tmp.nextSibling;\n            }\n        }\n    }\n    /**\n     * Returns a rectangle that contains the offset in x and y and the horizontal\n     * and vertical scale in width and height used to draw this shape inside the\n     * given {@link Rectangle}.\n     *\n     * @param shape {@link Shape} to be drawn.\n     * @param bounds {@link Rectangle} that should contain the stencil.\n     * @param direction Optional direction of the shape to be darwn.\n     */\n    computeAspect(shape = null, x, y, w, h, direction) {\n        let x0 = x;\n        let y0 = y;\n        let sx = w / this.w0;\n        let sy = h / this.h0;\n        const inverse = direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH;\n        if (inverse) {\n            sy = w / this.h0;\n            sx = h / this.w0;\n            const delta = (w - h) / 2;\n            x0 += delta;\n            y0 -= delta;\n        }\n        if (this.aspect === 'fixed') {\n            sy = Math.min(sx, sy);\n            sx = sy;\n            // Centers the shape inside the available space\n            if (inverse) {\n                x0 += (h - this.w0 * sx) / 2;\n                y0 += (w - this.h0 * sy) / 2;\n            }\n            else {\n                x0 += (w - this.w0 * sx) / 2;\n                y0 += (h - this.h0 * sy) / 2;\n            }\n        }\n        return new Rectangle(x0, y0, sx, sy);\n    }\n    /**\n     * Draws this stencil inside the given bounds.\n     */\n    drawNode(canvas, shape, node, aspect, disableShadow, paint) {\n        const name = node.nodeName;\n        const x0 = aspect.x;\n        const y0 = aspect.y;\n        const sx = aspect.width;\n        const sy = aspect.height;\n        const minScale = Math.min(sx, sy);\n        if (name === 'save') {\n            canvas.save();\n        }\n        else if (name === 'restore') {\n            canvas.restore();\n        }\n        else if (paint) {\n            if (name === 'path') {\n                canvas.begin();\n                let parseRegularly = true;\n                if (node.getAttribute('rounded') == '1') {\n                    parseRegularly = false;\n                    const arcSize = Number(node.getAttribute('arcSize'));\n                    let pointCount = 0;\n                    const segs = [];\n                    // Renders the elements inside the given path\n                    let childNode = node.firstChild;\n                    while (childNode != null) {\n                        if (childNode.nodeType === NODETYPE.ELEMENT) {\n                            const childName = childNode.nodeName;\n                            if (childName === 'move' || childName === 'line') {\n                                if (childName === 'move' || segs.length === 0) {\n                                    segs.push([]);\n                                }\n                                segs[segs.length - 1].push(new Point(x0 + Number(childNode.getAttribute('x')) * sx, y0 + Number(childNode.getAttribute('y')) * sy));\n                                pointCount++;\n                            }\n                            else {\n                                // We only support move and line for rounded corners\n                                parseRegularly = true;\n                                break;\n                            }\n                        }\n                        childNode = childNode.nextSibling;\n                    }\n                    if (!parseRegularly && pointCount > 0) {\n                        for (let i = 0; i < segs.length; i += 1) {\n                            let close = false;\n                            const ps = segs[i][0];\n                            const pe = segs[i][segs[i].length - 1];\n                            if (ps.x === pe.x && ps.y === pe.y) {\n                                segs[i].pop();\n                                close = true;\n                            }\n                            this.addPoints(canvas, segs[i], true, arcSize, close);\n                        }\n                    }\n                    else {\n                        parseRegularly = true;\n                    }\n                }\n                if (parseRegularly) {\n                    // Renders the elements inside the given path\n                    let childNode = node.firstChild;\n                    while (childNode) {\n                        if (childNode.nodeType === NODETYPE.ELEMENT) {\n                            this.drawNode(canvas, shape, childNode, aspect, disableShadow, paint);\n                        }\n                        childNode = childNode.nextSibling;\n                    }\n                }\n            }\n            else if (name === 'close') {\n                canvas.close();\n            }\n            else if (name === 'move') {\n                canvas.moveTo(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy);\n            }\n            else if (name === 'line') {\n                canvas.lineTo(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy);\n            }\n            else if (name === 'quad') {\n                canvas.quadTo(x0 + Number(node.getAttribute('x1')) * sx, y0 + Number(node.getAttribute('y1')) * sy, x0 + Number(node.getAttribute('x2')) * sx, y0 + Number(node.getAttribute('y2')) * sy);\n            }\n            else if (name === 'curve') {\n                canvas.curveTo(x0 + Number(node.getAttribute('x1')) * sx, y0 + Number(node.getAttribute('y1')) * sy, x0 + Number(node.getAttribute('x2')) * sx, y0 + Number(node.getAttribute('y2')) * sy, x0 + Number(node.getAttribute('x3')) * sx, y0 + Number(node.getAttribute('y3')) * sy);\n            }\n            else if (name === 'arc') {\n                canvas.arcTo(Number(node.getAttribute('rx')) * sx, Number(node.getAttribute('ry')) * sy, Number(node.getAttribute('x-axis-rotation')), Boolean(node.getAttribute('large-arc-flag')), Boolean(node.getAttribute('sweep-flag')), x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy);\n            }\n            else if (name === 'rect') {\n                canvas.rect(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy, Number(node.getAttribute('w')) * sx, Number(node.getAttribute('h')) * sy);\n            }\n            else if (name === 'roundrect') {\n                let arcsize = Number(node.getAttribute('arcsize'));\n                if (arcsize === 0) {\n                    arcsize = RECTANGLE_ROUNDING_FACTOR * 100;\n                }\n                const w = Number(node.getAttribute('w')) * sx;\n                const h = Number(node.getAttribute('h')) * sy;\n                const factor = Number(arcsize) / 100;\n                const r = Math.min(w * factor, h * factor);\n                canvas.roundrect(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy, w, h, r, r);\n            }\n            else if (name === 'ellipse') {\n                canvas.ellipse(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy, Number(node.getAttribute('w')) * sx, Number(node.getAttribute('h')) * sy);\n            }\n            else if (name === 'image') {\n                if (!shape.outline) {\n                    const src = this.evaluateAttribute(node, 'src', shape);\n                    canvas.image(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy, Number(node.getAttribute('w')) * sx, Number(node.getAttribute('h')) * sy, src, false, node.getAttribute('flipH') === '1', node.getAttribute('flipV') === '1');\n                }\n            }\n            else if (name === 'text') {\n                if (!shape.outline) {\n                    const str = this.evaluateTextAttribute(node, 'str', shape);\n                    let rotation = node.getAttribute('vertical') == '1' ? -90 : 0;\n                    if (node.getAttribute('align-shape') === '0') {\n                        const dr = shape.rotation;\n                        // Depends on flipping\n                        const flipH = getValue(shape.style, 'flipH', 0) == 1;\n                        const flipV = getValue(shape.style, 'flipV', 0) == 1;\n                        if (flipH && flipV) {\n                            rotation -= dr;\n                        }\n                        else if (flipH || flipV) {\n                            rotation += dr;\n                        }\n                        else {\n                            rotation -= dr;\n                        }\n                    }\n                    rotation -= Number(node.getAttribute('rotation'));\n                    canvas.text(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy, 0, 0, str, node.getAttribute('align') || ALIGN.LEFT, node.getAttribute('valign') || ALIGN.TOP, false, '', 'auto', false, rotation, TEXT_DIRECTION.AUTO);\n                }\n            }\n            else if (name === 'include-shape') {\n                const stencil = StencilShapeRegistry.getStencil(node.getAttribute('name'));\n                if (stencil) {\n                    const x = x0 + Number(node.getAttribute('x')) * sx;\n                    const y = y0 + Number(node.getAttribute('y')) * sy;\n                    const w = Number(node.getAttribute('w')) * sx;\n                    const h = Number(node.getAttribute('h')) * sy;\n                    stencil.drawShape(canvas, shape, x, y, w, h);\n                }\n            }\n            else if (name === 'fillstroke') {\n                canvas.fillAndStroke();\n            }\n            else if (name === 'fill') {\n                canvas.fill();\n            }\n            else if (name === 'stroke') {\n                canvas.stroke();\n            }\n            else if (name === 'strokewidth') {\n                const s = node.getAttribute('fixed') === '1' ? 1 : minScale;\n                canvas.setStrokeWidth(Number(node.getAttribute('width')) * s);\n            }\n            else if (name === 'dashed') {\n                canvas.setDashed(node.getAttribute('dashed') === '1');\n            }\n            else if (name === 'dashpattern') {\n                let value = node.getAttribute('pattern');\n                if (value != null) {\n                    const tmp = value.split(' ');\n                    const pat = [];\n                    for (let i = 0; i < tmp.length; i += 1) {\n                        if (tmp[i].length > 0) {\n                            pat.push(Number(tmp[i]) * minScale);\n                        }\n                    }\n                    value = pat.join(' ');\n                    canvas.setDashPattern(value);\n                }\n            }\n            else if (name === 'strokecolor') {\n                canvas.setStrokeColor(node.getAttribute('color'));\n            }\n            else if (name === 'linecap') {\n                canvas.setLineCap(node.getAttribute('cap'));\n            }\n            else if (name === 'linejoin') {\n                canvas.setLineJoin(node.getAttribute('join'));\n            }\n            else if (name === 'miterlimit') {\n                canvas.setMiterLimit(Number(node.getAttribute('limit')));\n            }\n            else if (name === 'fillcolor') {\n                canvas.setFillColor(node.getAttribute('color'));\n            }\n            else if (name === 'alpha') {\n                canvas.setAlpha(Number(node.getAttribute('alpha')));\n            }\n            else if (name === 'fillalpha') {\n                canvas.setAlpha(Number(node.getAttribute('alpha')));\n            }\n            else if (name === 'strokealpha') {\n                canvas.setAlpha(Number(node.getAttribute('alpha')));\n            }\n            else if (name === 'fontcolor') {\n                canvas.setFontColor(node.getAttribute('color'));\n            }\n            else if (name === 'fontstyle') {\n                canvas.setFontStyle(Number(node.getAttribute('style')));\n            }\n            else if (name === 'fontfamily') {\n                canvas.setFontFamily(node.getAttribute('family'));\n            }\n            else if (name === 'fontsize') {\n                canvas.setFontSize(Number(node.getAttribute('size')) * minScale);\n            }\n            if (disableShadow &&\n                (name === 'fillstroke' || name === 'fill' || name === 'stroke')) {\n                disableShadow = false;\n                canvas.setShadow(false);\n            }\n        }\n    }\n}\n/**\n * Static global variable that specifies the default value for the localized\n * attribute of the text element. Default is false.\n */\nStencilShape.defaultLocalized = false;\n/**\n * Static global switch that specifies if the use of eval is allowed for\n * evaluating text content and images. Default is false. Set this to true\n * if stencils can not contain user input.\n */\nStencilShape.allowEval = false;\nexport default StencilShape;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}