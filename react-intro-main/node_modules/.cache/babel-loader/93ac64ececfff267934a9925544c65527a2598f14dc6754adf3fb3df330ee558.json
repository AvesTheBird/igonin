{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Dictionary from '../../util/Dictionary';\nimport { Graph } from '../Graph';\nimport { mixInto } from '../../util/Utils';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst TerminalMixin = {\n  /*****************************************************************************\n   * Group: Graph behaviour\n   *****************************************************************************/\n  /**\n   * Returns true if the given terminal point is movable. This is independent\n   * from {@link isCellConnectable} and {@link isCellDisconnectable} and controls if terminal\n   * points can be moved in the graph if the edge is not connected. Note that it\n   * is required for this to return true to connect unconnected edges. This\n   * implementation returns true.\n   *\n   * @param cell {@link mxCell} whose terminal point should be moved.\n   * @param source Boolean indicating if the source or target terminal should be moved.\n   */\n  isTerminalPointMovable(cell, source) {\n    return true;\n  },\n  /*****************************************************************************\n   * Group: Cell retrieval\n   *****************************************************************************/\n  /**\n   * Returns all distinct visible opposite cells for the specified terminal\n   * on the given edges.\n   *\n   * @param edges Array of {@link Cell} that contains the edges whose opposite\n   * terminals should be returned.\n   * @param terminal Terminal that specifies the end whose opposite should be\n   * returned.\n   * @param sources Optional boolean that specifies if source terminals should be\n   * included in the result. Default is `true`.\n   * @param targets Optional boolean that specifies if targer terminals should be\n   * included in the result. Default is `true`.\n   */\n  getOpposites(edges) {\n    let terminal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let sources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let targets = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    const terminals = [];\n    // Fast lookup to avoid duplicates in terminals array\n    const dict = new Dictionary();\n    for (let i = 0; i < edges.length; i += 1) {\n      const state = this.getView().getState(edges[i]);\n      const source = state ? state.getVisibleTerminal(true) : this.getView().getVisibleTerminal(edges[i], true);\n      const target = state ? state.getVisibleTerminal(false) : this.getView().getVisibleTerminal(edges[i], false);\n      // Checks if the terminal is the source of the edge and if the\n      // target should be stored in the result\n      if (source === terminal && target && target !== terminal && targets) {\n        if (!dict.get(target)) {\n          dict.put(target, true);\n          terminals.push(target);\n        }\n      }\n      // Checks if the terminal is the taget of the edge and if the\n      // source should be stored in the result\n      else if (target === terminal && source && source !== terminal && sources) {\n        if (!dict.get(source)) {\n          dict.put(source, true);\n          terminals.push(source);\n        }\n      }\n    }\n    return terminals;\n  }\n};\nmixInto(Graph)(TerminalMixin);","map":{"version":3,"names":["Dictionary","Graph","mixInto","TerminalMixin","isTerminalPointMovable","cell","source","getOpposites","edges","terminal","arguments","length","undefined","sources","targets","terminals","dict","i","state","getView","getState","getVisibleTerminal","target","get","put","push"],"sources":["D:/OSPanel/domains/old/react/react-intro/node_modules/@maxgraph/core/dist/view/mixins/TerminalMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Dictionary from '../../util/Dictionary';\nimport { Graph } from '../Graph';\nimport { mixInto } from '../../util/Utils';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst TerminalMixin = {\n    /*****************************************************************************\n     * Group: Graph behaviour\n     *****************************************************************************/\n    /**\n     * Returns true if the given terminal point is movable. This is independent\n     * from {@link isCellConnectable} and {@link isCellDisconnectable} and controls if terminal\n     * points can be moved in the graph if the edge is not connected. Note that it\n     * is required for this to return true to connect unconnected edges. This\n     * implementation returns true.\n     *\n     * @param cell {@link mxCell} whose terminal point should be moved.\n     * @param source Boolean indicating if the source or target terminal should be moved.\n     */\n    isTerminalPointMovable(cell, source) {\n        return true;\n    },\n    /*****************************************************************************\n     * Group: Cell retrieval\n     *****************************************************************************/\n    /**\n     * Returns all distinct visible opposite cells for the specified terminal\n     * on the given edges.\n     *\n     * @param edges Array of {@link Cell} that contains the edges whose opposite\n     * terminals should be returned.\n     * @param terminal Terminal that specifies the end whose opposite should be\n     * returned.\n     * @param sources Optional boolean that specifies if source terminals should be\n     * included in the result. Default is `true`.\n     * @param targets Optional boolean that specifies if targer terminals should be\n     * included in the result. Default is `true`.\n     */\n    getOpposites(edges, terminal = null, sources = true, targets = true) {\n        const terminals = [];\n        // Fast lookup to avoid duplicates in terminals array\n        const dict = new Dictionary();\n        for (let i = 0; i < edges.length; i += 1) {\n            const state = this.getView().getState(edges[i]);\n            const source = state\n                ? state.getVisibleTerminal(true)\n                : this.getView().getVisibleTerminal(edges[i], true);\n            const target = state\n                ? state.getVisibleTerminal(false)\n                : this.getView().getVisibleTerminal(edges[i], false);\n            // Checks if the terminal is the source of the edge and if the\n            // target should be stored in the result\n            if (source === terminal && target && target !== terminal && targets) {\n                if (!dict.get(target)) {\n                    dict.put(target, true);\n                    terminals.push(target);\n                }\n            }\n            // Checks if the terminal is the taget of the edge and if the\n            // source should be stored in the result\n            else if (target === terminal && source && source !== terminal && sources) {\n                if (!dict.get(source)) {\n                    dict.put(source, true);\n                    terminals.push(source);\n                }\n            }\n        }\n        return terminals;\n    },\n};\nmixInto(Graph)(TerminalMixin);\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,UAAU,MAAM,uBAAuB;AAC9C,SAASC,KAAK,QAAQ,UAAU;AAChC,SAASC,OAAO,QAAQ,kBAAkB;AAC1C;AACA,MAAMC,aAAa,GAAG;EAClB;AACJ;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,sBAAsBA,CAACC,IAAI,EAAEC,MAAM,EAAE;IACjC,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,YAAYA,CAACC,KAAK,EAAmD;IAAA,IAAjDC,QAAQ,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;IAAA,IAAEG,OAAO,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;IAAA,IAAEI,OAAO,GAAAJ,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;IAC/D,MAAMK,SAAS,GAAG,EAAE;IACpB;IACA,MAAMC,IAAI,GAAG,IAAIhB,UAAU,CAAC,CAAC;IAC7B,KAAK,IAAIiB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,KAAK,CAACG,MAAM,EAAEM,CAAC,IAAI,CAAC,EAAE;MACtC,MAAMC,KAAK,GAAG,IAAI,CAACC,OAAO,CAAC,CAAC,CAACC,QAAQ,CAACZ,KAAK,CAACS,CAAC,CAAC,CAAC;MAC/C,MAAMX,MAAM,GAAGY,KAAK,GACdA,KAAK,CAACG,kBAAkB,CAAC,IAAI,CAAC,GAC9B,IAAI,CAACF,OAAO,CAAC,CAAC,CAACE,kBAAkB,CAACb,KAAK,CAACS,CAAC,CAAC,EAAE,IAAI,CAAC;MACvD,MAAMK,MAAM,GAAGJ,KAAK,GACdA,KAAK,CAACG,kBAAkB,CAAC,KAAK,CAAC,GAC/B,IAAI,CAACF,OAAO,CAAC,CAAC,CAACE,kBAAkB,CAACb,KAAK,CAACS,CAAC,CAAC,EAAE,KAAK,CAAC;MACxD;MACA;MACA,IAAIX,MAAM,KAAKG,QAAQ,IAAIa,MAAM,IAAIA,MAAM,KAAKb,QAAQ,IAAIK,OAAO,EAAE;QACjE,IAAI,CAACE,IAAI,CAACO,GAAG,CAACD,MAAM,CAAC,EAAE;UACnBN,IAAI,CAACQ,GAAG,CAACF,MAAM,EAAE,IAAI,CAAC;UACtBP,SAAS,CAACU,IAAI,CAACH,MAAM,CAAC;QAC1B;MACJ;MACA;MACA;MAAA,KACK,IAAIA,MAAM,KAAKb,QAAQ,IAAIH,MAAM,IAAIA,MAAM,KAAKG,QAAQ,IAAII,OAAO,EAAE;QACtE,IAAI,CAACG,IAAI,CAACO,GAAG,CAACjB,MAAM,CAAC,EAAE;UACnBU,IAAI,CAACQ,GAAG,CAAClB,MAAM,EAAE,IAAI,CAAC;UACtBS,SAAS,CAACU,IAAI,CAACnB,MAAM,CAAC;QAC1B;MACJ;IACJ;IACA,OAAOS,SAAS;EACpB;AACJ,CAAC;AACDb,OAAO,CAACD,KAAK,CAAC,CAACE,aAAa,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}