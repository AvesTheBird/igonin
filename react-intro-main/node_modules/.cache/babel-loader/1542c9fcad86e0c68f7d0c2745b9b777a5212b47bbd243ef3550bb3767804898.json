{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Cell from '../cell/Cell';\nimport { mixInto } from '../../util/Utils';\nimport { sortCells } from '../../util/styleUtils';\nimport Geometry from '../geometry/Geometry';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport Rectangle from '../geometry/Rectangle';\nimport { Graph } from '../Graph';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst GroupingMixin = {\n  /*****************************************************************************\n   * Group: Grouping\n   *****************************************************************************/\n  /**\n   * Adds the cells into the given group. The change is carried out using\n   * {@link cellsAdded}, {@link cellsMoved} and {@link cellsResized}. This method fires\n   * {@link InternalEvent.GROUP_CELLS} while the transaction is in progress. Returns the\n   * new group. A group is only created if there is at least one entry in the\n   * given array of cells.\n   *\n   * @param group {@link mxCell} that represents the target group. If `null` is specified\n   * then a new group is created using {@link createGroupCell}.\n   * @param border Optional integer that specifies the border between the child\n   * area and the group bounds. Default is `0`.\n   * @param cells Optional array of {@link Cell} to be grouped. If `null` is specified\n   * then the selection cells are used.\n   */\n  groupCells(group) {\n    let border = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let cells = arguments.length > 2 ? arguments[2] : undefined;\n    if (!cells) cells = sortCells(this.getSelectionCells(), true);\n    if (!cells) cells = this.getCellsForGroup(cells);\n    if (group == null) {\n      group = this.createGroupCell(cells);\n    }\n    const bounds = this.getBoundsForGroup(group, cells, border);\n    if (cells.length > 1 && bounds != null) {\n      // Uses parent of group or previous parent of first child\n      let parent = group.getParent();\n      if (parent == null) {\n        parent = cells[0].getParent();\n      }\n      this.batchUpdate(() => {\n        // Checks if the group has a geometry and\n        // creates one if one does not exist\n        if (group.getGeometry() == null) {\n          this.getDataModel().setGeometry(group, new Geometry());\n        }\n        // Adds the group into the parent\n        let index = parent.getChildCount();\n        this.cellsAdded([group], parent, index, null, null, false, false, false);\n        // Adds the children into the group and moves\n        index = group.getChildCount();\n        this.cellsAdded(cells, group, index, null, null, false, false, false);\n        this.cellsMoved(cells, -bounds.x, -bounds.y, false, false, false);\n        // Resizes the group\n        this.cellsResized([group], [bounds], false);\n        this.fireEvent(new EventObject(InternalEvent.GROUP_CELLS, {\n          group,\n          border,\n          cells\n        }));\n      });\n    }\n    return group;\n  },\n  /**\n   * Returns the cells with the same parent as the first cell\n   * in the given array.\n   */\n  getCellsForGroup(cells) {\n    const result = [];\n    if (cells != null && cells.length > 0) {\n      const parent = cells[0].getParent();\n      result.push(cells[0]);\n      // Filters selection cells with the same parent\n      for (let i = 1; i < cells.length; i += 1) {\n        if (cells[i].getParent() === parent) {\n          result.push(cells[i]);\n        }\n      }\n    }\n    return result;\n  },\n  /**\n   * Returns the bounds to be used for the given group and children.\n   */\n  getBoundsForGroup(group, children, border) {\n    const result = this.getBoundingBoxFromGeometry(children, true);\n    if (result != null) {\n      if (this.isSwimlane(group)) {\n        const size = this.getStartSize(group);\n        result.x -= size.width;\n        result.y -= size.height;\n        result.width += size.width;\n        result.height += size.height;\n      }\n      // Adds the border\n      if (border != null) {\n        result.x -= border;\n        result.y -= border;\n        result.width += 2 * border;\n        result.height += 2 * border;\n      }\n    }\n    return result;\n  },\n  /**\n   * Hook for creating the group cell to hold the given array of {@link Cell} if\n   * no group cell was given to the {@link group} function.\n   *\n   * The following code can be used to set the style of new group cells.\n   *\n   * ```javascript\n   * var graphCreateGroupCell = graph.createGroupCell;\n   * graph.createGroupCell = function(cells)\n   * {\n   *   var group = graphCreateGroupCell.apply(this, arguments);\n   *   group.setStyle('group');\n   *\n   *   return group;\n   * };\n   */\n  createGroupCell(cells) {\n    const group = new Cell('');\n    group.setVertex(true);\n    group.setConnectable(false);\n    return group;\n  },\n  /**\n   * Ungroups the given cells by moving the children the children to their\n   * parents parent and removing the empty groups. Returns the children that\n   * have been removed from the groups.\n   *\n   * @param cells Array of cells to be ungrouped. If null is specified then the\n   * selection cells are used.\n   */\n  ungroupCells(cells) {\n    let result = [];\n    if (cells == null) {\n      cells = this.getCellsForUngroup();\n    }\n    if (cells != null && cells.length > 0) {\n      this.batchUpdate(() => {\n        const _cells = cells;\n        for (let i = 0; i < _cells.length; i += 1) {\n          let children = _cells[i].getChildren();\n          if (children != null && children.length > 0) {\n            children = children.slice();\n            const parent = _cells[i].getParent();\n            const index = parent.getChildCount();\n            this.cellsAdded(children, parent, index, null, null, true);\n            result = result.concat(children);\n            // Fix relative child cells\n            for (const child of children) {\n              const state = this.getView().getState(child);\n              let geo = child.getGeometry();\n              if (state != null && geo != null && geo.relative) {\n                geo = geo.clone();\n                geo.x = state.origin.x;\n                geo.y = state.origin.y;\n                geo.relative = false;\n                this.getDataModel().setGeometry(child, geo);\n              }\n            }\n          }\n        }\n        this.removeCellsAfterUngroup(_cells);\n        this.fireEvent(new EventObject(InternalEvent.UNGROUP_CELLS, {\n          cells\n        }));\n      });\n    }\n    return result;\n  },\n  /**\n   * Returns the selection cells that can be ungrouped.\n   */\n  getCellsForUngroup() {\n    const cells = this.getSelectionCells();\n    // Finds the cells with children\n    const tmp = [];\n    for (let i = 0; i < cells.length; i += 1) {\n      if (cells[i].isVertex() && cells[i].getChildCount() > 0) {\n        tmp.push(cells[i]);\n      }\n    }\n    return tmp;\n  },\n  /**\n   * Hook to remove the groups after {@link ungroupCells}.\n   *\n   * @param cells Array of {@link Cell} that were ungrouped.\n   */\n  removeCellsAfterUngroup(cells) {\n    this.cellsRemoved(this.addAllEdges(cells));\n  },\n  /**\n   * Removes the specified cells from their parents and adds them to the\n   * default parent. Returns the cells that were removed from their parents.\n   *\n   * @param cells Array of {@link Cell} to be removed from their parents.\n   */\n  removeCellsFromParent(cells) {\n    if (cells == null) {\n      cells = this.getSelectionCells();\n    }\n    this.batchUpdate(() => {\n      const parent = this.getDefaultParent();\n      const index = parent.getChildCount();\n      this.cellsAdded(cells, parent, index, null, null, true);\n      this.fireEvent(new EventObject(InternalEvent.REMOVE_CELLS_FROM_PARENT, {\n        cells\n      }));\n    });\n    return cells;\n  },\n  /**\n   * Updates the bounds of the given groups to include all children and returns\n   * the passed-in cells. Call this with the groups in parent to child order,\n   * top-most group first, the cells are processed in reverse order and cells\n   * with no children are ignored.\n   *\n   * @param cells The groups whose bounds should be updated. If this is null, then\n   * the selection cells are used.\n   * @param border Optional border to be added in the group. Default is 0.\n   * @param moveGroup Optional boolean that allows the group to be moved. Default\n   * is false.\n   * @param topBorder Optional top border to be added in the group. Default is 0.\n   * @param rightBorder Optional top border to be added in the group. Default is 0.\n   * @param bottomBorder Optional top border to be added in the group. Default is 0.\n   * @param leftBorder Optional top border to be added in the group. Default is 0.\n   */\n  updateGroupBounds(cells) {\n    let border = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let moveGroup = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let topBorder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    let rightBorder = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    let bottomBorder = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    let leftBorder = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n    if (cells == null) {\n      cells = this.getSelectionCells();\n    }\n    border = border != null ? border : 0;\n    moveGroup = moveGroup != null ? moveGroup : false;\n    topBorder = topBorder != null ? topBorder : 0;\n    rightBorder = rightBorder != null ? rightBorder : 0;\n    bottomBorder = bottomBorder != null ? bottomBorder : 0;\n    leftBorder = leftBorder != null ? leftBorder : 0;\n    this.batchUpdate(() => {\n      for (let i = cells.length - 1; i >= 0; i--) {\n        let geo = cells[i].getGeometry();\n        if (geo == null) {\n          continue;\n        }\n        const children = this.getChildCells(cells[i]);\n        if (children != null && children.length > 0) {\n          const bounds = this.getBoundingBoxFromGeometry(children, true);\n          if (bounds != null && bounds.width > 0 && bounds.height > 0) {\n            // Adds the size of the title area for swimlanes\n            const size = this.isSwimlane(cells[i]) ? this.getActualStartSize(cells[i], true) : new Rectangle();\n            geo = geo.clone();\n            if (moveGroup) {\n              geo.x = Math.round(geo.x + bounds.x - border - size.x - leftBorder);\n              geo.y = Math.round(geo.y + bounds.y - border - size.y - topBorder);\n            }\n            geo.width = Math.round(bounds.width + 2 * border + size.x + leftBorder + rightBorder + size.width);\n            geo.height = Math.round(bounds.height + 2 * border + size.y + topBorder + bottomBorder + size.height);\n            this.getDataModel().setGeometry(cells[i], geo);\n            this.moveCells(children, border + size.x - bounds.x + leftBorder, border + size.y - bounds.y + topBorder);\n          }\n        }\n      }\n    });\n    return cells;\n  },\n  /*****************************************************************************\n   * Group: Drilldown\n   *****************************************************************************/\n  /**\n   * Uses the given cell as the root of the displayed cell hierarchy. If no\n   * cell is specified then the selection cell is used. The cell is only used\n   * if {@link isValidRoot} returns true.\n   *\n   * @param cell Optional {@link Cell} to be used as the new root. Default is the\n   * selection cell.\n   */\n  enterGroup(cell) {\n    cell = cell || this.getSelectionCell();\n    if (cell != null && this.isValidRoot(cell)) {\n      this.getView().setCurrentRoot(cell);\n      this.clearSelection();\n    }\n  },\n  /**\n   * Changes the current root to the next valid root in the displayed cell\n   * hierarchy.\n   */\n  exitGroup() {\n    const root = this.getDataModel().getRoot();\n    const current = this.getCurrentRoot();\n    if (current != null) {\n      let next = current.getParent();\n      // Finds the next valid root in the hierarchy\n      while (next !== root && !this.isValidRoot(next) && next.getParent() !== root) {\n        next = next.getParent();\n      }\n      // Clears the current root if the new root is\n      // the model's root or one of the layers.\n      if (next === root || next.getParent() === root) {\n        this.getView().setCurrentRoot(null);\n      } else {\n        this.getView().setCurrentRoot(next);\n      }\n      const state = this.getView().getState(current);\n      // Selects the previous root in the graph\n      if (state != null) {\n        this.setSelectionCell(current);\n      }\n    }\n  }\n};\nmixInto(Graph)(GroupingMixin);","map":{"version":3,"names":["Cell","mixInto","sortCells","Geometry","EventObject","InternalEvent","Rectangle","Graph","GroupingMixin","groupCells","group","border","arguments","length","undefined","cells","getSelectionCells","getCellsForGroup","createGroupCell","bounds","getBoundsForGroup","parent","getParent","batchUpdate","getGeometry","getDataModel","setGeometry","index","getChildCount","cellsAdded","cellsMoved","x","y","cellsResized","fireEvent","GROUP_CELLS","result","push","i","children","getBoundingBoxFromGeometry","isSwimlane","size","getStartSize","width","height","setVertex","setConnectable","ungroupCells","getCellsForUngroup","_cells","getChildren","slice","concat","child","state","getView","getState","geo","relative","clone","origin","removeCellsAfterUngroup","UNGROUP_CELLS","tmp","isVertex","cellsRemoved","addAllEdges","removeCellsFromParent","getDefaultParent","REMOVE_CELLS_FROM_PARENT","updateGroupBounds","moveGroup","topBorder","rightBorder","bottomBorder","leftBorder","getChildCells","getActualStartSize","Math","round","moveCells","enterGroup","cell","getSelectionCell","isValidRoot","setCurrentRoot","clearSelection","exitGroup","root","getRoot","current","getCurrentRoot","next","setSelectionCell"],"sources":["D:/ospanel/domains/old/react/react-intro/node_modules/@maxgraph/core/dist/view/mixins/GroupingMixin.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Cell from '../cell/Cell';\nimport { mixInto } from '../../util/Utils';\nimport { sortCells } from '../../util/styleUtils';\nimport Geometry from '../geometry/Geometry';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport Rectangle from '../geometry/Rectangle';\nimport { Graph } from '../Graph';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nconst GroupingMixin = {\n    /*****************************************************************************\n     * Group: Grouping\n     *****************************************************************************/\n    /**\n     * Adds the cells into the given group. The change is carried out using\n     * {@link cellsAdded}, {@link cellsMoved} and {@link cellsResized}. This method fires\n     * {@link InternalEvent.GROUP_CELLS} while the transaction is in progress. Returns the\n     * new group. A group is only created if there is at least one entry in the\n     * given array of cells.\n     *\n     * @param group {@link mxCell} that represents the target group. If `null` is specified\n     * then a new group is created using {@link createGroupCell}.\n     * @param border Optional integer that specifies the border between the child\n     * area and the group bounds. Default is `0`.\n     * @param cells Optional array of {@link Cell} to be grouped. If `null` is specified\n     * then the selection cells are used.\n     */\n    groupCells(group, border = 0, cells) {\n        if (!cells)\n            cells = sortCells(this.getSelectionCells(), true);\n        if (!cells)\n            cells = this.getCellsForGroup(cells);\n        if (group == null) {\n            group = this.createGroupCell(cells);\n        }\n        const bounds = this.getBoundsForGroup(group, cells, border);\n        if (cells.length > 1 && bounds != null) {\n            // Uses parent of group or previous parent of first child\n            let parent = group.getParent();\n            if (parent == null) {\n                parent = cells[0].getParent();\n            }\n            this.batchUpdate(() => {\n                // Checks if the group has a geometry and\n                // creates one if one does not exist\n                if (group.getGeometry() == null) {\n                    this.getDataModel().setGeometry(group, new Geometry());\n                }\n                // Adds the group into the parent\n                let index = parent.getChildCount();\n                this.cellsAdded([group], parent, index, null, null, false, false, false);\n                // Adds the children into the group and moves\n                index = group.getChildCount();\n                this.cellsAdded(cells, group, index, null, null, false, false, false);\n                this.cellsMoved(cells, -bounds.x, -bounds.y, false, false, false);\n                // Resizes the group\n                this.cellsResized([group], [bounds], false);\n                this.fireEvent(new EventObject(InternalEvent.GROUP_CELLS, { group, border, cells }));\n            });\n        }\n        return group;\n    },\n    /**\n     * Returns the cells with the same parent as the first cell\n     * in the given array.\n     */\n    getCellsForGroup(cells) {\n        const result = [];\n        if (cells != null && cells.length > 0) {\n            const parent = cells[0].getParent();\n            result.push(cells[0]);\n            // Filters selection cells with the same parent\n            for (let i = 1; i < cells.length; i += 1) {\n                if (cells[i].getParent() === parent) {\n                    result.push(cells[i]);\n                }\n            }\n        }\n        return result;\n    },\n    /**\n     * Returns the bounds to be used for the given group and children.\n     */\n    getBoundsForGroup(group, children, border) {\n        const result = this.getBoundingBoxFromGeometry(children, true);\n        if (result != null) {\n            if (this.isSwimlane(group)) {\n                const size = this.getStartSize(group);\n                result.x -= size.width;\n                result.y -= size.height;\n                result.width += size.width;\n                result.height += size.height;\n            }\n            // Adds the border\n            if (border != null) {\n                result.x -= border;\n                result.y -= border;\n                result.width += 2 * border;\n                result.height += 2 * border;\n            }\n        }\n        return result;\n    },\n    /**\n     * Hook for creating the group cell to hold the given array of {@link Cell} if\n     * no group cell was given to the {@link group} function.\n     *\n     * The following code can be used to set the style of new group cells.\n     *\n     * ```javascript\n     * var graphCreateGroupCell = graph.createGroupCell;\n     * graph.createGroupCell = function(cells)\n     * {\n     *   var group = graphCreateGroupCell.apply(this, arguments);\n     *   group.setStyle('group');\n     *\n     *   return group;\n     * };\n     */\n    createGroupCell(cells) {\n        const group = new Cell('');\n        group.setVertex(true);\n        group.setConnectable(false);\n        return group;\n    },\n    /**\n     * Ungroups the given cells by moving the children the children to their\n     * parents parent and removing the empty groups. Returns the children that\n     * have been removed from the groups.\n     *\n     * @param cells Array of cells to be ungrouped. If null is specified then the\n     * selection cells are used.\n     */\n    ungroupCells(cells) {\n        let result = [];\n        if (cells == null) {\n            cells = this.getCellsForUngroup();\n        }\n        if (cells != null && cells.length > 0) {\n            this.batchUpdate(() => {\n                const _cells = cells;\n                for (let i = 0; i < _cells.length; i += 1) {\n                    let children = _cells[i].getChildren();\n                    if (children != null && children.length > 0) {\n                        children = children.slice();\n                        const parent = _cells[i].getParent();\n                        const index = parent.getChildCount();\n                        this.cellsAdded(children, parent, index, null, null, true);\n                        result = result.concat(children);\n                        // Fix relative child cells\n                        for (const child of children) {\n                            const state = this.getView().getState(child);\n                            let geo = child.getGeometry();\n                            if (state != null && geo != null && geo.relative) {\n                                geo = geo.clone();\n                                geo.x = state.origin.x;\n                                geo.y = state.origin.y;\n                                geo.relative = false;\n                                this.getDataModel().setGeometry(child, geo);\n                            }\n                        }\n                    }\n                }\n                this.removeCellsAfterUngroup(_cells);\n                this.fireEvent(new EventObject(InternalEvent.UNGROUP_CELLS, { cells }));\n            });\n        }\n        return result;\n    },\n    /**\n     * Returns the selection cells that can be ungrouped.\n     */\n    getCellsForUngroup() {\n        const cells = this.getSelectionCells();\n        // Finds the cells with children\n        const tmp = [];\n        for (let i = 0; i < cells.length; i += 1) {\n            if (cells[i].isVertex() && cells[i].getChildCount() > 0) {\n                tmp.push(cells[i]);\n            }\n        }\n        return tmp;\n    },\n    /**\n     * Hook to remove the groups after {@link ungroupCells}.\n     *\n     * @param cells Array of {@link Cell} that were ungrouped.\n     */\n    removeCellsAfterUngroup(cells) {\n        this.cellsRemoved(this.addAllEdges(cells));\n    },\n    /**\n     * Removes the specified cells from their parents and adds them to the\n     * default parent. Returns the cells that were removed from their parents.\n     *\n     * @param cells Array of {@link Cell} to be removed from their parents.\n     */\n    removeCellsFromParent(cells) {\n        if (cells == null) {\n            cells = this.getSelectionCells();\n        }\n        this.batchUpdate(() => {\n            const parent = this.getDefaultParent();\n            const index = parent.getChildCount();\n            this.cellsAdded(cells, parent, index, null, null, true);\n            this.fireEvent(new EventObject(InternalEvent.REMOVE_CELLS_FROM_PARENT, { cells }));\n        });\n        return cells;\n    },\n    /**\n     * Updates the bounds of the given groups to include all children and returns\n     * the passed-in cells. Call this with the groups in parent to child order,\n     * top-most group first, the cells are processed in reverse order and cells\n     * with no children are ignored.\n     *\n     * @param cells The groups whose bounds should be updated. If this is null, then\n     * the selection cells are used.\n     * @param border Optional border to be added in the group. Default is 0.\n     * @param moveGroup Optional boolean that allows the group to be moved. Default\n     * is false.\n     * @param topBorder Optional top border to be added in the group. Default is 0.\n     * @param rightBorder Optional top border to be added in the group. Default is 0.\n     * @param bottomBorder Optional top border to be added in the group. Default is 0.\n     * @param leftBorder Optional top border to be added in the group. Default is 0.\n     */\n    updateGroupBounds(cells, border = 0, moveGroup = false, topBorder = 0, rightBorder = 0, bottomBorder = 0, leftBorder = 0) {\n        if (cells == null) {\n            cells = this.getSelectionCells();\n        }\n        border = border != null ? border : 0;\n        moveGroup = moveGroup != null ? moveGroup : false;\n        topBorder = topBorder != null ? topBorder : 0;\n        rightBorder = rightBorder != null ? rightBorder : 0;\n        bottomBorder = bottomBorder != null ? bottomBorder : 0;\n        leftBorder = leftBorder != null ? leftBorder : 0;\n        this.batchUpdate(() => {\n            for (let i = cells.length - 1; i >= 0; i--) {\n                let geo = cells[i].getGeometry();\n                if (geo == null) {\n                    continue;\n                }\n                const children = this.getChildCells(cells[i]);\n                if (children != null && children.length > 0) {\n                    const bounds = this.getBoundingBoxFromGeometry(children, true);\n                    if (bounds != null && bounds.width > 0 && bounds.height > 0) {\n                        // Adds the size of the title area for swimlanes\n                        const size = ((this.isSwimlane(cells[i])\n                            ? this.getActualStartSize(cells[i], true)\n                            : new Rectangle()));\n                        geo = geo.clone();\n                        if (moveGroup) {\n                            geo.x = Math.round(geo.x + bounds.x - border - size.x - leftBorder);\n                            geo.y = Math.round(geo.y + bounds.y - border - size.y - topBorder);\n                        }\n                        geo.width = Math.round(bounds.width + 2 * border + size.x + leftBorder + rightBorder + size.width);\n                        geo.height = Math.round(bounds.height + 2 * border + size.y + topBorder + bottomBorder + size.height);\n                        this.getDataModel().setGeometry(cells[i], geo);\n                        this.moveCells(children, border + size.x - bounds.x + leftBorder, border + size.y - bounds.y + topBorder);\n                    }\n                }\n            }\n        });\n        return cells;\n    },\n    /*****************************************************************************\n     * Group: Drilldown\n     *****************************************************************************/\n    /**\n     * Uses the given cell as the root of the displayed cell hierarchy. If no\n     * cell is specified then the selection cell is used. The cell is only used\n     * if {@link isValidRoot} returns true.\n     *\n     * @param cell Optional {@link Cell} to be used as the new root. Default is the\n     * selection cell.\n     */\n    enterGroup(cell) {\n        cell = cell || this.getSelectionCell();\n        if (cell != null && this.isValidRoot(cell)) {\n            this.getView().setCurrentRoot(cell);\n            this.clearSelection();\n        }\n    },\n    /**\n     * Changes the current root to the next valid root in the displayed cell\n     * hierarchy.\n     */\n    exitGroup() {\n        const root = this.getDataModel().getRoot();\n        const current = this.getCurrentRoot();\n        if (current != null) {\n            let next = current.getParent();\n            // Finds the next valid root in the hierarchy\n            while (next !== root && !this.isValidRoot(next) && next.getParent() !== root) {\n                next = next.getParent();\n            }\n            // Clears the current root if the new root is\n            // the model's root or one of the layers.\n            if (next === root || next.getParent() === root) {\n                this.getView().setCurrentRoot(null);\n            }\n            else {\n                this.getView().setCurrentRoot(next);\n            }\n            const state = this.getView().getState(current);\n            // Selects the previous root in the graph\n            if (state != null) {\n                this.setSelectionCell(current);\n            }\n        }\n    },\n};\nmixInto(Graph)(GroupingMixin);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}