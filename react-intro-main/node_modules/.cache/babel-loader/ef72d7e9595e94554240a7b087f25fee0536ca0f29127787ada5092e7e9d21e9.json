{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport EventSource from '../event/EventSource';\nimport InternalEvent from '../event/InternalEvent';\nimport Rectangle from '../geometry/Rectangle';\n/**\n * @class SwimlaneManager\n * @extends EventSource\n *\n * Manager for swimlanes and nested swimlanes that sets the size of newly added\n * swimlanes to that of their siblings, and propagates changes to the size of a\n * swimlane to its siblings, if {@link siblings} is true, and its ancestors, if\n * {@link bubbling} is true.\n */\nclass SwimlaneManager extends EventSource {\n  constructor(graph, horizontal = true, addEnabled = true, resizeEnabled = true) {\n    super();\n    /**\n     * Specifies if event handling is enabled.\n     * @default true\n     */\n    this.enabled = true;\n    /**\n     * Specifies the orientation of the swimlanes.\n     * @default true\n     */\n    this.horizontal = true;\n    /**\n     * Specifies if newly added cells should be resized to match the size of their\n     * existing siblings.\n     * @default true\n     */\n    this.addEnabled = true;\n    /**\n     * Specifies if resizing of swimlanes should be handled.\n     * @default true\n     */\n    this.resizeEnabled = true;\n    this.horizontal = horizontal;\n    this.addEnabled = addEnabled;\n    this.resizeEnabled = resizeEnabled;\n    this.addHandler = (sender, evt) => {\n      if (this.isEnabled() && this.isAddEnabled()) {\n        this.cellsAdded(evt.getProperty('cells'));\n      }\n    };\n    this.resizeHandler = (sender, evt) => {\n      if (this.isEnabled() && this.isResizeEnabled()) {\n        this.cellsResized(evt.getProperty('cells'));\n      }\n    };\n    this.setGraph(graph);\n  }\n  /**\n   * Returns true if events are handled. This implementation\n   * returns {@link enabled}.\n   */\n  isEnabled() {\n    return this.enabled;\n  }\n  /**\n   * Enables or disables event handling. This implementation\n   * updates {@link enabled}.\n   *\n   * @param enabled Boolean that specifies the new enabled state.\n   */\n  setEnabled(value) {\n    this.enabled = value;\n  }\n  /**\n   * Returns {@link horizontal}.\n   */\n  isHorizontal() {\n    return this.horizontal;\n  }\n  /**\n   * Sets {@link horizontal}.\n   */\n  setHorizontal(value) {\n    this.horizontal = value;\n  }\n  /**\n   * Returns {@link addEnabled}.\n   */\n  isAddEnabled() {\n    return this.addEnabled;\n  }\n  /**\n   * Sets {@link addEnabled}.\n   */\n  setAddEnabled(value) {\n    this.addEnabled = value;\n  }\n  /**\n   * Returns {@link resizeEnabled}.\n   */\n  isResizeEnabled() {\n    return this.resizeEnabled;\n  }\n  /**\n   * Sets {@link resizeEnabled}.\n   */\n  setResizeEnabled(value) {\n    this.resizeEnabled = value;\n  }\n  /**\n   * Returns the graph that this manager operates on.\n   */\n  getGraph() {\n    return this.graph;\n  }\n  /**\n   * Sets the graph that the manager operates on.\n   */\n  setGraph(graph) {\n    if (this.graph) {\n      this.graph.removeListener(this.addHandler);\n      this.graph.removeListener(this.resizeHandler);\n    }\n    // @ts-expect-error this.graph can be null only when it is being destroyed.\n    this.graph = graph;\n    if (this.graph) {\n      this.graph.addListener(InternalEvent.ADD_CELLS, this.addHandler);\n      this.graph.addListener(InternalEvent.CELLS_RESIZED, this.resizeHandler);\n    }\n  }\n  /**\n   * Returns true if the given swimlane should be ignored.\n   */\n  isSwimlaneIgnored(swimlane) {\n    return !this.getGraph().isSwimlane(swimlane);\n  }\n  /**\n   * Returns true if the given cell is horizontal. If the given cell is not a\n   * swimlane, then the global orientation is returned.\n   */\n  isCellHorizontal(cell) {\n    if (this.graph.isSwimlane(cell)) {\n      const style = this.graph.getCellStyle(cell);\n      return style.horizontal ?? true;\n    }\n    return !this.isHorizontal();\n  }\n  /**\n   * Called if any cells have been added.\n   *\n   * @param cell Array of {@link Cell} that have been added.\n   */\n  cellsAdded(cells) {\n    if (cells.length > 0) {\n      this.graph.batchUpdate(() => {\n        for (const cell of cells) {\n          if (!this.isSwimlaneIgnored(cell)) {\n            this.swimlaneAdded(cell);\n          }\n        }\n      });\n    }\n  }\n  /**\n   * Updates the size of the given swimlane to match that of any existing\n   * siblings swimlanes.\n   *\n   * @param swimlane {@link mxCell} that represents the new swimlane.\n   */\n  swimlaneAdded(swimlane) {\n    const parent = swimlane.getParent();\n    const childCount = parent.getChildCount();\n    let geo = null;\n    // Finds the first valid sibling swimlane as reference\n    for (let i = 0; i < childCount; i += 1) {\n      const child = parent.getChildAt(i);\n      if (child !== swimlane && !this.isSwimlaneIgnored(child)) {\n        geo = child.getGeometry();\n        if (geo) {\n          break;\n        }\n      }\n    }\n    // Applies the size of the refernece to the newly added swimlane\n    if (geo) {\n      const parentHorizontal = parent ? this.isCellHorizontal(parent) : this.horizontal;\n      this.resizeSwimlane(swimlane, geo.width, geo.height, parentHorizontal);\n    }\n  }\n  /**\n   * Called if any cells have been resizes. Calls {@link swimlaneResized} for all\n   * swimlanes where {@link isSwimlaneIgnored} returns false.\n   *\n   * @param cells Array of {@link Cell} whose size was changed.\n   */\n  cellsResized(cells) {\n    if (cells.length > 0) {\n      this.graph.batchUpdate(() => {\n        // Finds the top-level swimlanes and adds offsets\n        for (const cell of cells) {\n          if (!this.isSwimlaneIgnored(cell)) {\n            const geo = cell.getGeometry();\n            if (geo) {\n              const size = new Rectangle(0, 0, geo.width, geo.height);\n              let top = cell;\n              let current = top;\n              while (current) {\n                top = current;\n                current = current.getParent();\n                const tmp = this.graph.isSwimlane(current) ? this.graph.getStartSize(current) : new Rectangle();\n                size.width += tmp.width;\n                size.height += tmp.height;\n              }\n              const parentHorizontal = current ? this.isCellHorizontal(current) : this.horizontal;\n              this.resizeSwimlane(top, size.width, size.height, parentHorizontal);\n            }\n          }\n        }\n      });\n    }\n  }\n  /**\n   * Called from {@link cellsResized} for all swimlanes that are not ignored to update\n   * the size of the siblings and the size of the parent swimlanes, recursively,\n   * if {@link bubbling} is true.\n   *\n   * @param swimlane {@link mxCell} whose size has changed.\n   */\n  resizeSwimlane(swimlane, w, h, parentHorizontal) {\n    const model = this.graph.getDataModel();\n    model.batchUpdate(() => {\n      const horizontal = this.isCellHorizontal(swimlane);\n      if (!this.isSwimlaneIgnored(swimlane)) {\n        let geo = swimlane.getGeometry();\n        if (geo) {\n          if (parentHorizontal && geo.height !== h || !parentHorizontal && geo.width !== w) {\n            geo = geo.clone();\n            if (parentHorizontal) {\n              geo.height = h;\n            } else {\n              geo.width = w;\n            }\n            model.setGeometry(swimlane, geo);\n          }\n        }\n      }\n      const tmp = this.graph.isSwimlane(swimlane) ? this.graph.getStartSize(swimlane) : new Rectangle();\n      w -= tmp.width;\n      h -= tmp.height;\n      const childCount = swimlane.getChildCount();\n      for (let i = 0; i < childCount; i += 1) {\n        const child = swimlane.getChildAt(i);\n        this.resizeSwimlane(child, w, h, horizontal);\n      }\n    });\n  }\n  /**\n   * Removes all handlers from the {@link graph} and deletes the reference to it.\n   */\n  destroy() {\n    this.setGraph(null);\n  }\n}\nexport default SwimlaneManager;","map":{"version":3,"names":["EventSource","InternalEvent","Rectangle","SwimlaneManager","constructor","graph","horizontal","addEnabled","resizeEnabled","enabled","addHandler","sender","evt","isEnabled","isAddEnabled","cellsAdded","getProperty","resizeHandler","isResizeEnabled","cellsResized","setGraph","setEnabled","value","isHorizontal","setHorizontal","setAddEnabled","setResizeEnabled","getGraph","removeListener","addListener","ADD_CELLS","CELLS_RESIZED","isSwimlaneIgnored","swimlane","isSwimlane","isCellHorizontal","cell","style","getCellStyle","cells","length","batchUpdate","swimlaneAdded","parent","getParent","childCount","getChildCount","geo","i","child","getChildAt","getGeometry","parentHorizontal","resizeSwimlane","width","height","size","top","current","tmp","getStartSize","w","h","model","getDataModel","clone","setGeometry","destroy"],"sources":["D:/ospanel/domains/проекты open server/old/react/react-intro-main/node_modules/@maxgraph/core/dist/view/layout/SwimlaneManager.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport EventSource from '../event/EventSource';\nimport InternalEvent from '../event/InternalEvent';\nimport Rectangle from '../geometry/Rectangle';\n/**\n * @class SwimlaneManager\n * @extends EventSource\n *\n * Manager for swimlanes and nested swimlanes that sets the size of newly added\n * swimlanes to that of their siblings, and propagates changes to the size of a\n * swimlane to its siblings, if {@link siblings} is true, and its ancestors, if\n * {@link bubbling} is true.\n */\nclass SwimlaneManager extends EventSource {\n    constructor(graph, horizontal = true, addEnabled = true, resizeEnabled = true) {\n        super();\n        /**\n         * Specifies if event handling is enabled.\n         * @default true\n         */\n        this.enabled = true;\n        /**\n         * Specifies the orientation of the swimlanes.\n         * @default true\n         */\n        this.horizontal = true;\n        /**\n         * Specifies if newly added cells should be resized to match the size of their\n         * existing siblings.\n         * @default true\n         */\n        this.addEnabled = true;\n        /**\n         * Specifies if resizing of swimlanes should be handled.\n         * @default true\n         */\n        this.resizeEnabled = true;\n        this.horizontal = horizontal;\n        this.addEnabled = addEnabled;\n        this.resizeEnabled = resizeEnabled;\n        this.addHandler = (sender, evt) => {\n            if (this.isEnabled() && this.isAddEnabled()) {\n                this.cellsAdded(evt.getProperty('cells'));\n            }\n        };\n        this.resizeHandler = (sender, evt) => {\n            if (this.isEnabled() && this.isResizeEnabled()) {\n                this.cellsResized(evt.getProperty('cells'));\n            }\n        };\n        this.setGraph(graph);\n    }\n    /**\n     * Returns true if events are handled. This implementation\n     * returns {@link enabled}.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Enables or disables event handling. This implementation\n     * updates {@link enabled}.\n     *\n     * @param enabled Boolean that specifies the new enabled state.\n     */\n    setEnabled(value) {\n        this.enabled = value;\n    }\n    /**\n     * Returns {@link horizontal}.\n     */\n    isHorizontal() {\n        return this.horizontal;\n    }\n    /**\n     * Sets {@link horizontal}.\n     */\n    setHorizontal(value) {\n        this.horizontal = value;\n    }\n    /**\n     * Returns {@link addEnabled}.\n     */\n    isAddEnabled() {\n        return this.addEnabled;\n    }\n    /**\n     * Sets {@link addEnabled}.\n     */\n    setAddEnabled(value) {\n        this.addEnabled = value;\n    }\n    /**\n     * Returns {@link resizeEnabled}.\n     */\n    isResizeEnabled() {\n        return this.resizeEnabled;\n    }\n    /**\n     * Sets {@link resizeEnabled}.\n     */\n    setResizeEnabled(value) {\n        this.resizeEnabled = value;\n    }\n    /**\n     * Returns the graph that this manager operates on.\n     */\n    getGraph() {\n        return this.graph;\n    }\n    /**\n     * Sets the graph that the manager operates on.\n     */\n    setGraph(graph) {\n        if (this.graph) {\n            this.graph.removeListener(this.addHandler);\n            this.graph.removeListener(this.resizeHandler);\n        }\n        // @ts-expect-error this.graph can be null only when it is being destroyed.\n        this.graph = graph;\n        if (this.graph) {\n            this.graph.addListener(InternalEvent.ADD_CELLS, this.addHandler);\n            this.graph.addListener(InternalEvent.CELLS_RESIZED, this.resizeHandler);\n        }\n    }\n    /**\n     * Returns true if the given swimlane should be ignored.\n     */\n    isSwimlaneIgnored(swimlane) {\n        return !this.getGraph().isSwimlane(swimlane);\n    }\n    /**\n     * Returns true if the given cell is horizontal. If the given cell is not a\n     * swimlane, then the global orientation is returned.\n     */\n    isCellHorizontal(cell) {\n        if (this.graph.isSwimlane(cell)) {\n            const style = this.graph.getCellStyle(cell);\n            return style.horizontal ?? true;\n        }\n        return !this.isHorizontal();\n    }\n    /**\n     * Called if any cells have been added.\n     *\n     * @param cell Array of {@link Cell} that have been added.\n     */\n    cellsAdded(cells) {\n        if (cells.length > 0) {\n            this.graph.batchUpdate(() => {\n                for (const cell of cells) {\n                    if (!this.isSwimlaneIgnored(cell)) {\n                        this.swimlaneAdded(cell);\n                    }\n                }\n            });\n        }\n    }\n    /**\n     * Updates the size of the given swimlane to match that of any existing\n     * siblings swimlanes.\n     *\n     * @param swimlane {@link mxCell} that represents the new swimlane.\n     */\n    swimlaneAdded(swimlane) {\n        const parent = swimlane.getParent();\n        const childCount = parent.getChildCount();\n        let geo = null;\n        // Finds the first valid sibling swimlane as reference\n        for (let i = 0; i < childCount; i += 1) {\n            const child = parent.getChildAt(i);\n            if (child !== swimlane && !this.isSwimlaneIgnored(child)) {\n                geo = child.getGeometry();\n                if (geo) {\n                    break;\n                }\n            }\n        }\n        // Applies the size of the refernece to the newly added swimlane\n        if (geo) {\n            const parentHorizontal = parent ? this.isCellHorizontal(parent) : this.horizontal;\n            this.resizeSwimlane(swimlane, geo.width, geo.height, parentHorizontal);\n        }\n    }\n    /**\n     * Called if any cells have been resizes. Calls {@link swimlaneResized} for all\n     * swimlanes where {@link isSwimlaneIgnored} returns false.\n     *\n     * @param cells Array of {@link Cell} whose size was changed.\n     */\n    cellsResized(cells) {\n        if (cells.length > 0) {\n            this.graph.batchUpdate(() => {\n                // Finds the top-level swimlanes and adds offsets\n                for (const cell of cells) {\n                    if (!this.isSwimlaneIgnored(cell)) {\n                        const geo = cell.getGeometry();\n                        if (geo) {\n                            const size = new Rectangle(0, 0, geo.width, geo.height);\n                            let top = cell;\n                            let current = top;\n                            while (current) {\n                                top = current;\n                                current = current.getParent();\n                                const tmp = this.graph.isSwimlane(current)\n                                    ? this.graph.getStartSize(current)\n                                    : new Rectangle();\n                                size.width += tmp.width;\n                                size.height += tmp.height;\n                            }\n                            const parentHorizontal = current\n                                ? this.isCellHorizontal(current)\n                                : this.horizontal;\n                            this.resizeSwimlane(top, size.width, size.height, parentHorizontal);\n                        }\n                    }\n                }\n            });\n        }\n    }\n    /**\n     * Called from {@link cellsResized} for all swimlanes that are not ignored to update\n     * the size of the siblings and the size of the parent swimlanes, recursively,\n     * if {@link bubbling} is true.\n     *\n     * @param swimlane {@link mxCell} whose size has changed.\n     */\n    resizeSwimlane(swimlane, w, h, parentHorizontal) {\n        const model = this.graph.getDataModel();\n        model.batchUpdate(() => {\n            const horizontal = this.isCellHorizontal(swimlane);\n            if (!this.isSwimlaneIgnored(swimlane)) {\n                let geo = swimlane.getGeometry();\n                if (geo) {\n                    if ((parentHorizontal && geo.height !== h) ||\n                        (!parentHorizontal && geo.width !== w)) {\n                        geo = geo.clone();\n                        if (parentHorizontal) {\n                            geo.height = h;\n                        }\n                        else {\n                            geo.width = w;\n                        }\n                        model.setGeometry(swimlane, geo);\n                    }\n                }\n            }\n            const tmp = this.graph.isSwimlane(swimlane)\n                ? this.graph.getStartSize(swimlane)\n                : new Rectangle();\n            w -= tmp.width;\n            h -= tmp.height;\n            const childCount = swimlane.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                const child = swimlane.getChildAt(i);\n                this.resizeSwimlane(child, w, h, horizontal);\n            }\n        });\n    }\n    /**\n     * Removes all handlers from the {@link graph} and deletes the reference to it.\n     */\n    destroy() {\n        this.setGraph(null);\n    }\n}\nexport default SwimlaneManager;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}