{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2017, JGraph Ltd\nCopyright (c) 2006-2017, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from '../geometry/Rectangle';\nimport Dictionary from '../../util/Dictionary';\n/**\n * Creates a temporary set of cell states.\n */\nclass TemporaryCellStates {\n  constructor(view, scale = 1, cells, isCellVisibleFn = null, getLinkForCellState = null) {\n    this.view = view;\n    // Stores the previous state\n    this.oldValidateCellState = view.validateCellState;\n    this.oldBounds = view.getGraphBounds();\n    this.oldStates = view.getStates();\n    this.oldScale = view.getScale();\n    this.oldDoRedrawShape = view.graph.cellRenderer.doRedrawShape;\n    const self = this;\n    // Overrides doRedrawShape and paint shape to add links on shapes\n    if (getLinkForCellState != null) {\n      view.graph.cellRenderer.doRedrawShape = state => {\n        const shape = state?.shape;\n        const oldPaint = shape.paint;\n        shape.paint = c => {\n          const link = getLinkForCellState(state);\n          if (link != null) {\n            c.setLink(link);\n          }\n          oldPaint.apply(this, [c]);\n          if (link != null) {\n            c.setLink(null);\n          }\n        };\n        self.oldDoRedrawShape.apply(view.graph.cellRenderer, [state]);\n        shape.paint = oldPaint;\n      };\n    }\n    // Overrides validateCellState to ignore invisible cells\n    view.validateCellState = (cell, recurse) => {\n      if (cell == null || isCellVisibleFn == null || isCellVisibleFn(cell)) {\n        return self.oldDoRedrawShape.apply(view, [cell, recurse]);\n      }\n      return null;\n    };\n    // Creates space for new states\n    view.setStates(new Dictionary());\n    view.setScale(scale);\n    view.resetValidationState();\n    let bbox = null;\n    // Validates the vertices and edges without adding them to\n    // the model so that the original cells are not modified\n    for (const cell of cells) {\n      const bounds = view.getBoundingBox(view.validateCellState(view.validateCell(cell)));\n      if (bbox == null) {\n        bbox = bounds;\n      } else {\n        bbox.add(bounds);\n      }\n    }\n    view.setGraphBounds(bbox || new Rectangle());\n  }\n  destroy() {\n    const view = this.view;\n    view.setScale(this.oldScale);\n    view.setStates(this.oldStates);\n    view.setGraphBounds(this.oldBounds);\n    // @ts-ignore\n    view.validateCellState = this.oldValidateCellState;\n    // @ts-ignore\n    view.graph.cellRenderer.doRedrawShape = this.oldDoRedrawShape;\n  }\n}\nexport default TemporaryCellStates;","map":{"version":3,"names":["Rectangle","Dictionary","TemporaryCellStates","constructor","view","scale","cells","isCellVisibleFn","getLinkForCellState","oldValidateCellState","validateCellState","oldBounds","getGraphBounds","oldStates","getStates","oldScale","getScale","oldDoRedrawShape","graph","cellRenderer","doRedrawShape","self","state","shape","oldPaint","paint","c","link","setLink","apply","cell","recurse","setStates","setScale","resetValidationState","bbox","bounds","getBoundingBox","validateCell","add","setGraphBounds","destroy"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/@maxgraph/core/dist/view/cell/TemporaryCellStates.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2017, JGraph Ltd\nCopyright (c) 2006-2017, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from '../geometry/Rectangle';\nimport Dictionary from '../../util/Dictionary';\n/**\n * Creates a temporary set of cell states.\n */\nclass TemporaryCellStates {\n    constructor(view, scale = 1, cells, isCellVisibleFn = null, getLinkForCellState = null) {\n        this.view = view;\n        // Stores the previous state\n        this.oldValidateCellState = view.validateCellState;\n        this.oldBounds = view.getGraphBounds();\n        this.oldStates = view.getStates();\n        this.oldScale = view.getScale();\n        this.oldDoRedrawShape = view.graph.cellRenderer.doRedrawShape;\n        const self = this;\n        // Overrides doRedrawShape and paint shape to add links on shapes\n        if (getLinkForCellState != null) {\n            view.graph.cellRenderer.doRedrawShape = (state) => {\n                const shape = state?.shape;\n                const oldPaint = shape.paint;\n                shape.paint = (c) => {\n                    const link = getLinkForCellState(state);\n                    if (link != null) {\n                        c.setLink(link);\n                    }\n                    oldPaint.apply(this, [c]);\n                    if (link != null) {\n                        c.setLink(null);\n                    }\n                };\n                self.oldDoRedrawShape.apply(view.graph.cellRenderer, [\n                    state,\n                ]);\n                shape.paint = oldPaint;\n            };\n        }\n        // Overrides validateCellState to ignore invisible cells\n        view.validateCellState = (cell, recurse) => {\n            if (cell == null || isCellVisibleFn == null || isCellVisibleFn(cell)) {\n                return self.oldDoRedrawShape.apply(view, [cell, recurse]);\n            }\n            return null;\n        };\n        // Creates space for new states\n        view.setStates(new Dictionary());\n        view.setScale(scale);\n        view.resetValidationState();\n        let bbox = null;\n        // Validates the vertices and edges without adding them to\n        // the model so that the original cells are not modified\n        for (const cell of cells) {\n            const bounds = view.getBoundingBox(view.validateCellState(view.validateCell(cell)));\n            if (bbox == null) {\n                bbox = bounds;\n            }\n            else {\n                bbox.add(bounds);\n            }\n        }\n        view.setGraphBounds(bbox || new Rectangle());\n    }\n    destroy() {\n        const view = this.view;\n        view.setScale(this.oldScale);\n        view.setStates(this.oldStates);\n        view.setGraphBounds(this.oldBounds);\n        // @ts-ignore\n        view.validateCellState = this.oldValidateCellState;\n        // @ts-ignore\n        view.graph.cellRenderer.doRedrawShape = this.oldDoRedrawShape;\n    }\n}\nexport default TemporaryCellStates;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}