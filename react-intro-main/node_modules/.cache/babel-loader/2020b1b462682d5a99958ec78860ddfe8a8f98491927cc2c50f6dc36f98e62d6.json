{"ast":null,"code":"'use strict';\n\nconst genFirstWaveBrick = require('./gen-first-wave-brick.js');\nconst genWaveBrick = require('./gen-wave-brick.js');\nconst findLaneMarkers = require('./find-lane-markers.js');\n\n// src is the wave member of the signal object\n// extra = hscale-1 ( padding )\n// lane is an object containing all properties for this waveform\nfunction parseWaveLane(src, extra, lane) {\n  const Stack = src.split('');\n  let Next = Stack.shift();\n  let Repeats = 1;\n  while (Stack[0] === '.' || Stack[0] === '|') {\n    // repeaters parser\n    Stack.shift();\n    Repeats += 1;\n  }\n  let R = [];\n  R = R.concat(genFirstWaveBrick(Next, extra, Repeats));\n  let Top;\n  let subCycle = false;\n  while (Stack.length) {\n    Top = Next;\n    Next = Stack.shift();\n    if (Next === '<') {\n      // sub-cycles on\n      subCycle = true;\n      Next = Stack.shift();\n    }\n    if (Next === '>') {\n      // sub-cycles off\n      subCycle = false;\n      Next = Stack.shift();\n    }\n    Repeats = 1;\n    while (Stack[0] === '.' || Stack[0] === '|') {\n      // repeaters parser\n      Stack.shift();\n      Repeats += 1;\n    }\n    if (subCycle) {\n      R = R.concat(genWaveBrick(Top + Next, 0, Repeats - lane.period));\n    } else {\n      R = R.concat(genWaveBrick(Top + Next, extra, Repeats));\n    }\n  }\n  // shift out unseen bricks due to phase shift, and save them in\n  const unseen_bricks = [];\n  for (let i = 0; i < lane.phase; i += 1) {\n    unseen_bricks.push(R.shift());\n  }\n  let num_unseen_markers;\n  if (unseen_bricks.length > 0) {\n    num_unseen_markers = findLaneMarkers(unseen_bricks).length;\n    // if end of unseen_bricks and start of R both have a marker,\n    //  then one less unseen marker\n    if (findLaneMarkers([unseen_bricks[unseen_bricks.length - 1]]).length == 1 && findLaneMarkers([R[0]]).length == 1) {\n      num_unseen_markers -= 1;\n    }\n  } else {\n    num_unseen_markers = 0;\n  }\n\n  // R is array of half brick types, each is item is string\n  // num_unseen_markers is how many markers are now unseen due to phase\n  return [R, num_unseen_markers];\n}\nmodule.exports = parseWaveLane;","map":{"version":3,"names":["genFirstWaveBrick","require","genWaveBrick","findLaneMarkers","parseWaveLane","src","extra","lane","Stack","split","Next","shift","Repeats","R","concat","Top","subCycle","length","period","unseen_bricks","i","phase","push","num_unseen_markers","module","exports"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/wavedrom/lib/parse-wave-lane.js"],"sourcesContent":["'use strict';\n\nconst genFirstWaveBrick = require('./gen-first-wave-brick.js');\nconst genWaveBrick = require('./gen-wave-brick.js');\nconst findLaneMarkers = require('./find-lane-markers.js');\n\n// src is the wave member of the signal object\n// extra = hscale-1 ( padding )\n// lane is an object containing all properties for this waveform\nfunction parseWaveLane (src, extra, lane) {\n    const Stack = src.split('');\n    let Next  = Stack.shift();\n\n    let Repeats = 1;\n    while (Stack[0] === '.' || Stack[0] === '|') { // repeaters parser\n        Stack.shift();\n        Repeats += 1;\n    }\n    let R = [];\n    R = R.concat(genFirstWaveBrick(Next, extra, Repeats));\n\n    let Top;\n    let subCycle = false;\n    while (Stack.length) {\n        Top = Next;\n        Next = Stack.shift();\n        if (Next === '<') { // sub-cycles on\n            subCycle = true;\n            Next = Stack.shift();\n        }\n        if (Next === '>') { // sub-cycles off\n            subCycle = false;\n            Next = Stack.shift();\n        }\n        Repeats = 1;\n        while (Stack[0] === '.' || Stack[0] === '|') { // repeaters parser\n            Stack.shift();\n            Repeats += 1;\n        }\n        if (subCycle) {\n            R = R.concat(genWaveBrick((Top + Next), 0, Repeats - lane.period));\n        } else {\n            R = R.concat(genWaveBrick((Top + Next), extra, Repeats));\n        }\n    }\n    // shift out unseen bricks due to phase shift, and save them in\n    const unseen_bricks = [];\n    for (let i = 0; i < lane.phase; i += 1) {\n        unseen_bricks.push(R.shift());\n    }\n\n    let num_unseen_markers;\n    if (unseen_bricks.length > 0) {\n        num_unseen_markers = findLaneMarkers( unseen_bricks ).length;\n        // if end of unseen_bricks and start of R both have a marker,\n        //  then one less unseen marker\n        if (findLaneMarkers( [unseen_bricks[unseen_bricks.length-1]] ).length == 1 &&\n            findLaneMarkers( [R[0]] ).length == 1\n        ) {\n            num_unseen_markers -= 1;\n        }\n    } else {\n        num_unseen_markers = 0;\n    }\n\n    // R is array of half brick types, each is item is string\n    // num_unseen_markers is how many markers are now unseen due to phase\n    return [R, num_unseen_markers];\n}\n\nmodule.exports = parseWaveLane;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}