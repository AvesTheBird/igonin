{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Shape from '../Shape';\nimport { ARROW_SIZE, ARROW_SPACING, ARROW_WIDTH, NONE } from '../../../util/Constants';\nimport { relativeCcw } from '../../../util/mathUtils';\n/**\n * Extends {@link Shape} to implement an new rounded arrow shape with support for waypoints and double arrows. The\n * shape is used to represent edges, not vertices.\n *\n * This shape is registered under {@link mxConstants.SHAPE_ARROW_CONNECTOR} in {@link mxCellRenderer}.\n */\nclass ArrowConnectorShape extends Shape {\n  constructor(points, fill, stroke, strokeWidth = 1, arrowWidth = ARROW_WIDTH, spacing = ARROW_SPACING, endSize = ARROW_SIZE / 5) {\n    super();\n    /**\n     * Allows to use the SVG bounding box in SVG.\n     * @defaultValue `false` for performance reasons.\n     */\n    this.useSvgBoundingBox = true;\n    this.points = points;\n    this.fill = fill;\n    this.stroke = stroke;\n    this.strokeWidth = strokeWidth;\n    this.arrowWidth = arrowWidth;\n    this.arrowSpacing = spacing;\n    this.startSize = ARROW_SIZE / 5;\n    this.endSize = endSize;\n  }\n  /**\n   * Hook for subclassers.\n   */\n  isRoundable() {\n    return true;\n  }\n  /**\n   * Overrides mxShape to reset spacing.\n   */\n  resetStyles() {\n    super.resetStyles();\n    this.arrowSpacing = ARROW_SPACING;\n  }\n  /**\n   * Overrides apply to get smooth transition from default start- and endsize.\n   */\n  apply(state) {\n    super.apply(state);\n    if (this.style && this.style.startSize != null && this.style.endSize != null) {\n      this.startSize = this.style.startSize * 3;\n      this.endSize = this.style.endSize * 3;\n    }\n  }\n  /**\n   * Augments the bounding box with the edge width and markers.\n   */\n  augmentBoundingBox(bbox) {\n    super.augmentBoundingBox(bbox);\n    let w = this.getEdgeWidth();\n    if (this.isMarkerStart()) {\n      w = Math.max(w, this.getStartArrowWidth());\n    }\n    if (this.isMarkerEnd()) {\n      w = Math.max(w, this.getEndArrowWidth());\n    }\n    bbox.grow((w / 2 + this.strokeWidth) * this.scale);\n  }\n  /**\n   * Paints the line shape.\n   */\n  paintEdgeShape(c, pts) {\n    // Geometry of arrow\n    let strokeWidth = this.strokeWidth;\n    if (this.outline) {\n      strokeWidth = Math.max(1, this.style?.strokeWidth ?? 0);\n    }\n    const startWidth = this.getStartArrowWidth() + strokeWidth;\n    const endWidth = this.getEndArrowWidth() + strokeWidth;\n    const edgeWidth = this.outline ? this.getEdgeWidth() + strokeWidth : this.getEdgeWidth();\n    const openEnded = this.isOpenEnded();\n    const markerStart = this.isMarkerStart();\n    const markerEnd = this.isMarkerEnd();\n    const spacing = openEnded ? 0 : this.arrowSpacing + strokeWidth / 2;\n    const startSize = this.startSize + strokeWidth;\n    const endSize = this.endSize + strokeWidth;\n    const isRounded = this.isArrowRounded();\n    // Base vector (between first points)\n    const pe = pts[pts.length - 1];\n    // Finds first non-overlapping point\n    let i0 = 1;\n    while (i0 < pts.length - 1 && pts[i0].x === pts[0].x && pts[i0].y === pts[0].y) {\n      i0++;\n    }\n    const dx = pts[i0].x - pts[0].x;\n    const dy = pts[i0].y - pts[0].y;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n    if (dist === 0) {\n      return;\n    }\n    // Computes the norm and the inverse norm\n    let nx = dx / dist;\n    let nx2;\n    let nx1 = nx;\n    let ny = dy / dist;\n    let ny2;\n    let ny1 = ny;\n    let orthx = edgeWidth * ny;\n    let orthy = -edgeWidth * nx;\n    // Stores the inbound function calls in reverse order in fns\n    const fns = [];\n    if (isRounded) {\n      c.setLineJoin('round');\n    } else if (pts.length > 2) {\n      // Only mitre if there are waypoints\n      c.setMiterLimit(1.42);\n    }\n    c.begin();\n    const startNx = nx;\n    const startNy = ny;\n    if (markerStart && !openEnded) {\n      this.paintMarker(c, pts[0].x, pts[0].y, nx, ny, startSize, startWidth, edgeWidth, spacing, true);\n    } else {\n      const outStartX = pts[0].x + orthx / 2 + spacing * nx;\n      const outStartY = pts[0].y + orthy / 2 + spacing * ny;\n      const inEndX = pts[0].x - orthx / 2 + spacing * nx;\n      const inEndY = pts[0].y - orthy / 2 + spacing * ny;\n      if (openEnded) {\n        c.moveTo(outStartX, outStartY);\n        fns.push(() => {\n          c.lineTo(inEndX, inEndY);\n        });\n      } else {\n        c.moveTo(inEndX, inEndY);\n        c.lineTo(outStartX, outStartY);\n      }\n    }\n    let dx1 = 0;\n    let dy1 = 0;\n    let dist1 = 0;\n    for (let i = 0; i < pts.length - 2; i += 1) {\n      // Work out in which direction the line is bending\n      const pos = relativeCcw(pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y, pts[i + 2].x, pts[i + 2].y);\n      dx1 = pts[i + 2].x - pts[i + 1].x;\n      dy1 = pts[i + 2].y - pts[i + 1].y;\n      dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n      if (dist1 !== 0) {\n        nx1 = dx1 / dist1;\n        ny1 = dy1 / dist1;\n        const tmp1 = nx * nx1 + ny * ny1;\n        const tmp = Math.max(Math.sqrt((tmp1 + 1) / 2), 0.04);\n        // Work out the normal orthogonal to the line through the control point and the edge sides intersection\n        nx2 = nx + nx1;\n        ny2 = ny + ny1;\n        const dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);\n        if (dist2 !== 0) {\n          nx2 /= dist2;\n          ny2 /= dist2;\n          // Higher strokewidths require a larger minimum bend, 0.35 covers all but the most extreme cases\n          const strokeWidthFactor = Math.max(tmp, Math.min(this.strokeWidth / 200 + 0.04, 0.35));\n          const angleFactor = pos !== 0 && isRounded ? Math.max(0.1, strokeWidthFactor) : Math.max(tmp, 0.06);\n          const outX = pts[i + 1].x + ny2 * edgeWidth / 2 / angleFactor;\n          const outY = pts[i + 1].y - nx2 * edgeWidth / 2 / angleFactor;\n          const inX = pts[i + 1].x - ny2 * edgeWidth / 2 / angleFactor;\n          const inY = pts[i + 1].y + nx2 * edgeWidth / 2 / angleFactor;\n          if (pos === 0 || !isRounded) {\n            // If the two segments are aligned, or if we're not drawing curved sections between segments\n            // just draw straight to the intersection point\n            c.lineTo(outX, outY);\n            ((x, y) => {\n              fns.push(() => {\n                c.lineTo(x, y);\n              });\n            })(inX, inY);\n          } else if (pos === -1) {\n            const c1x = inX + ny * edgeWidth;\n            const c1y = inY - nx * edgeWidth;\n            const c2x = inX + ny1 * edgeWidth;\n            const c2y = inY - nx1 * edgeWidth;\n            c.lineTo(c1x, c1y);\n            c.quadTo(outX, outY, c2x, c2y);\n            ((x, y) => {\n              fns.push(() => {\n                c.lineTo(x, y);\n              });\n            })(inX, inY);\n          } else {\n            c.lineTo(outX, outY);\n            ((x, y) => {\n              const c1x = outX - ny * edgeWidth;\n              const c1y = outY + nx * edgeWidth;\n              const c2x = outX - ny1 * edgeWidth;\n              const c2y = outY + nx1 * edgeWidth;\n              fns.push(() => {\n                c.quadTo(x, y, c1x, c1y);\n              });\n              fns.push(() => {\n                c.lineTo(c2x, c2y);\n              });\n            })(inX, inY);\n          }\n          nx = nx1;\n          ny = ny1;\n        }\n      }\n    }\n    orthx = edgeWidth * ny1;\n    orthy = -edgeWidth * nx1;\n    if (markerEnd && !openEnded) {\n      this.paintMarker(c, pe.x, pe.y, -nx, -ny, endSize, endWidth, edgeWidth, spacing, false);\n    } else {\n      c.lineTo(pe.x - spacing * nx1 + orthx / 2, pe.y - spacing * ny1 + orthy / 2);\n      const inStartX = pe.x - spacing * nx1 - orthx / 2;\n      const inStartY = pe.y - spacing * ny1 - orthy / 2;\n      if (!openEnded) {\n        c.lineTo(inStartX, inStartY);\n      } else {\n        c.moveTo(inStartX, inStartY);\n        fns.splice(0, 0, () => {\n          c.moveTo(inStartX, inStartY);\n        });\n      }\n    }\n    for (let i = fns.length - 1; i >= 0; i--) {\n      fns[i]();\n    }\n    if (openEnded) {\n      c.end();\n      c.stroke();\n    } else {\n      c.close();\n      c.fillAndStroke();\n    }\n    // Workaround for shadow on top of base arrow\n    c.setShadow(false);\n    // Need to redraw the markers without the low miter limit\n    c.setMiterLimit(4);\n    if (isRounded) {\n      c.setLineJoin('flat');\n    }\n    if (pts.length > 2) {\n      // Only to repaint markers if no waypoints\n      // Need to redraw the markers without the low miter limit\n      c.setMiterLimit(4);\n      if (markerStart && !openEnded) {\n        c.begin();\n        this.paintMarker(c, pts[0].x, pts[0].y, startNx, startNy, startSize, startWidth, edgeWidth, spacing, true);\n        c.stroke();\n        c.end();\n      }\n      if (markerEnd && !openEnded) {\n        c.begin();\n        this.paintMarker(c, pe.x, pe.y, -nx, -ny, endSize, endWidth, edgeWidth, spacing, true);\n        c.stroke();\n        c.end();\n      }\n    }\n  }\n  /**\n   * Paints the marker.\n   */\n  paintMarker(c, ptX, ptY, nx, ny, size, arrowWidth, edgeWidth, spacing, initialMove) {\n    const widthArrowRatio = edgeWidth / arrowWidth;\n    const orthx = edgeWidth * ny / 2;\n    const orthy = -edgeWidth * nx / 2;\n    const spaceX = (spacing + size) * nx;\n    const spaceY = (spacing + size) * ny;\n    if (initialMove) {\n      c.moveTo(ptX - orthx + spaceX, ptY - orthy + spaceY);\n    } else {\n      c.lineTo(ptX - orthx + spaceX, ptY - orthy + spaceY);\n    }\n    c.lineTo(ptX - orthx / widthArrowRatio + spaceX, ptY - orthy / widthArrowRatio + spaceY);\n    c.lineTo(ptX + spacing * nx, ptY + spacing * ny);\n    c.lineTo(ptX + orthx / widthArrowRatio + spaceX, ptY + orthy / widthArrowRatio + spaceY);\n    c.lineTo(ptX + orthx + spaceX, ptY + orthy + spaceY);\n  }\n  /**\n   * @returns whether the arrow is rounded\n   */\n  isArrowRounded() {\n    return this.isRounded;\n  }\n  /**\n   * @returns the width of the start arrow\n   */\n  getStartArrowWidth() {\n    return ARROW_WIDTH;\n  }\n  /**\n   * @returns the width of the end arrow\n   */\n  getEndArrowWidth() {\n    return ARROW_WIDTH;\n  }\n  /**\n   * @returns the width of the body of the edge\n   */\n  getEdgeWidth() {\n    return ARROW_WIDTH / 3;\n  }\n  /**\n   * @returns whether the ends of the shape are drawn\n   */\n  isOpenEnded() {\n    return false;\n  }\n  /**\n   * @returns whether the start marker is drawn\n   */\n  isMarkerStart() {\n    return (this.style?.startArrow ?? NONE) !== NONE;\n  }\n  /**\n   * @returns whether the end marker is drawn\n   */\n  isMarkerEnd() {\n    return (this.style?.endArrow ?? NONE) !== NONE;\n  }\n}\nexport default ArrowConnectorShape;","map":{"version":3,"names":["Shape","ARROW_SIZE","ARROW_SPACING","ARROW_WIDTH","NONE","relativeCcw","ArrowConnectorShape","constructor","points","fill","stroke","strokeWidth","arrowWidth","spacing","endSize","useSvgBoundingBox","arrowSpacing","startSize","isRoundable","resetStyles","apply","state","style","augmentBoundingBox","bbox","w","getEdgeWidth","isMarkerStart","Math","max","getStartArrowWidth","isMarkerEnd","getEndArrowWidth","grow","scale","paintEdgeShape","c","pts","outline","startWidth","endWidth","edgeWidth","openEnded","isOpenEnded","markerStart","markerEnd","isRounded","isArrowRounded","pe","length","i0","x","y","dx","dy","dist","sqrt","nx","nx2","nx1","ny","ny2","ny1","orthx","orthy","fns","setLineJoin","setMiterLimit","begin","startNx","startNy","paintMarker","outStartX","outStartY","inEndX","inEndY","moveTo","push","lineTo","dx1","dy1","dist1","i","pos","tmp1","tmp","dist2","strokeWidthFactor","min","angleFactor","outX","outY","inX","inY","c1x","c1y","c2x","c2y","quadTo","inStartX","inStartY","splice","end","close","fillAndStroke","setShadow","ptX","ptY","size","initialMove","widthArrowRatio","spaceX","spaceY","startArrow","endArrow"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/@maxgraph/core/dist/view/geometry/edge/ArrowConnectorShape.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Shape from '../Shape';\nimport { ARROW_SIZE, ARROW_SPACING, ARROW_WIDTH, NONE } from '../../../util/Constants';\nimport { relativeCcw } from '../../../util/mathUtils';\n/**\n * Extends {@link Shape} to implement an new rounded arrow shape with support for waypoints and double arrows. The\n * shape is used to represent edges, not vertices.\n *\n * This shape is registered under {@link mxConstants.SHAPE_ARROW_CONNECTOR} in {@link mxCellRenderer}.\n */\nclass ArrowConnectorShape extends Shape {\n    constructor(points, fill, stroke, strokeWidth = 1, arrowWidth = ARROW_WIDTH, spacing = ARROW_SPACING, endSize = ARROW_SIZE / 5) {\n        super();\n        /**\n         * Allows to use the SVG bounding box in SVG.\n         * @defaultValue `false` for performance reasons.\n         */\n        this.useSvgBoundingBox = true;\n        this.points = points;\n        this.fill = fill;\n        this.stroke = stroke;\n        this.strokeWidth = strokeWidth;\n        this.arrowWidth = arrowWidth;\n        this.arrowSpacing = spacing;\n        this.startSize = ARROW_SIZE / 5;\n        this.endSize = endSize;\n    }\n    /**\n     * Hook for subclassers.\n     */\n    isRoundable() {\n        return true;\n    }\n    /**\n     * Overrides mxShape to reset spacing.\n     */\n    resetStyles() {\n        super.resetStyles();\n        this.arrowSpacing = ARROW_SPACING;\n    }\n    /**\n     * Overrides apply to get smooth transition from default start- and endsize.\n     */\n    apply(state) {\n        super.apply(state);\n        if (this.style && this.style.startSize != null && this.style.endSize != null) {\n            this.startSize = this.style.startSize * 3;\n            this.endSize = this.style.endSize * 3;\n        }\n    }\n    /**\n     * Augments the bounding box with the edge width and markers.\n     */\n    augmentBoundingBox(bbox) {\n        super.augmentBoundingBox(bbox);\n        let w = this.getEdgeWidth();\n        if (this.isMarkerStart()) {\n            w = Math.max(w, this.getStartArrowWidth());\n        }\n        if (this.isMarkerEnd()) {\n            w = Math.max(w, this.getEndArrowWidth());\n        }\n        bbox.grow((w / 2 + this.strokeWidth) * this.scale);\n    }\n    /**\n     * Paints the line shape.\n     */\n    paintEdgeShape(c, pts) {\n        // Geometry of arrow\n        let strokeWidth = this.strokeWidth;\n        if (this.outline) {\n            strokeWidth = Math.max(1, this.style?.strokeWidth ?? 0);\n        }\n        const startWidth = this.getStartArrowWidth() + strokeWidth;\n        const endWidth = this.getEndArrowWidth() + strokeWidth;\n        const edgeWidth = this.outline\n            ? this.getEdgeWidth() + strokeWidth\n            : this.getEdgeWidth();\n        const openEnded = this.isOpenEnded();\n        const markerStart = this.isMarkerStart();\n        const markerEnd = this.isMarkerEnd();\n        const spacing = openEnded ? 0 : this.arrowSpacing + strokeWidth / 2;\n        const startSize = this.startSize + strokeWidth;\n        const endSize = this.endSize + strokeWidth;\n        const isRounded = this.isArrowRounded();\n        // Base vector (between first points)\n        const pe = pts[pts.length - 1];\n        // Finds first non-overlapping point\n        let i0 = 1;\n        while (i0 < pts.length - 1 && pts[i0].x === pts[0].x && pts[i0].y === pts[0].y) {\n            i0++;\n        }\n        const dx = pts[i0].x - pts[0].x;\n        const dy = pts[i0].y - pts[0].y;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        if (dist === 0) {\n            return;\n        }\n        // Computes the norm and the inverse norm\n        let nx = dx / dist;\n        let nx2;\n        let nx1 = nx;\n        let ny = dy / dist;\n        let ny2;\n        let ny1 = ny;\n        let orthx = edgeWidth * ny;\n        let orthy = -edgeWidth * nx;\n        // Stores the inbound function calls in reverse order in fns\n        const fns = [];\n        if (isRounded) {\n            c.setLineJoin('round');\n        }\n        else if (pts.length > 2) {\n            // Only mitre if there are waypoints\n            c.setMiterLimit(1.42);\n        }\n        c.begin();\n        const startNx = nx;\n        const startNy = ny;\n        if (markerStart && !openEnded) {\n            this.paintMarker(c, pts[0].x, pts[0].y, nx, ny, startSize, startWidth, edgeWidth, spacing, true);\n        }\n        else {\n            const outStartX = pts[0].x + orthx / 2 + spacing * nx;\n            const outStartY = pts[0].y + orthy / 2 + spacing * ny;\n            const inEndX = pts[0].x - orthx / 2 + spacing * nx;\n            const inEndY = pts[0].y - orthy / 2 + spacing * ny;\n            if (openEnded) {\n                c.moveTo(outStartX, outStartY);\n                fns.push(() => {\n                    c.lineTo(inEndX, inEndY);\n                });\n            }\n            else {\n                c.moveTo(inEndX, inEndY);\n                c.lineTo(outStartX, outStartY);\n            }\n        }\n        let dx1 = 0;\n        let dy1 = 0;\n        let dist1 = 0;\n        for (let i = 0; i < pts.length - 2; i += 1) {\n            // Work out in which direction the line is bending\n            const pos = relativeCcw(pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y, pts[i + 2].x, pts[i + 2].y);\n            dx1 = pts[i + 2].x - pts[i + 1].x;\n            dy1 = pts[i + 2].y - pts[i + 1].y;\n            dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n            if (dist1 !== 0) {\n                nx1 = dx1 / dist1;\n                ny1 = dy1 / dist1;\n                const tmp1 = nx * nx1 + ny * ny1;\n                const tmp = Math.max(Math.sqrt((tmp1 + 1) / 2), 0.04);\n                // Work out the normal orthogonal to the line through the control point and the edge sides intersection\n                nx2 = nx + nx1;\n                ny2 = ny + ny1;\n                const dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);\n                if (dist2 !== 0) {\n                    nx2 /= dist2;\n                    ny2 /= dist2;\n                    // Higher strokewidths require a larger minimum bend, 0.35 covers all but the most extreme cases\n                    const strokeWidthFactor = Math.max(tmp, Math.min(this.strokeWidth / 200 + 0.04, 0.35));\n                    const angleFactor = pos !== 0 && isRounded\n                        ? Math.max(0.1, strokeWidthFactor)\n                        : Math.max(tmp, 0.06);\n                    const outX = pts[i + 1].x + (ny2 * edgeWidth) / 2 / angleFactor;\n                    const outY = pts[i + 1].y - (nx2 * edgeWidth) / 2 / angleFactor;\n                    const inX = pts[i + 1].x - (ny2 * edgeWidth) / 2 / angleFactor;\n                    const inY = pts[i + 1].y + (nx2 * edgeWidth) / 2 / angleFactor;\n                    if (pos === 0 || !isRounded) {\n                        // If the two segments are aligned, or if we're not drawing curved sections between segments\n                        // just draw straight to the intersection point\n                        c.lineTo(outX, outY);\n                        ((x, y) => {\n                            fns.push(() => {\n                                c.lineTo(x, y);\n                            });\n                        })(inX, inY);\n                    }\n                    else if (pos === -1) {\n                        const c1x = inX + ny * edgeWidth;\n                        const c1y = inY - nx * edgeWidth;\n                        const c2x = inX + ny1 * edgeWidth;\n                        const c2y = inY - nx1 * edgeWidth;\n                        c.lineTo(c1x, c1y);\n                        c.quadTo(outX, outY, c2x, c2y);\n                        ((x, y) => {\n                            fns.push(() => {\n                                c.lineTo(x, y);\n                            });\n                        })(inX, inY);\n                    }\n                    else {\n                        c.lineTo(outX, outY);\n                        ((x, y) => {\n                            const c1x = outX - ny * edgeWidth;\n                            const c1y = outY + nx * edgeWidth;\n                            const c2x = outX - ny1 * edgeWidth;\n                            const c2y = outY + nx1 * edgeWidth;\n                            fns.push(() => {\n                                c.quadTo(x, y, c1x, c1y);\n                            });\n                            fns.push(() => {\n                                c.lineTo(c2x, c2y);\n                            });\n                        })(inX, inY);\n                    }\n                    nx = nx1;\n                    ny = ny1;\n                }\n            }\n        }\n        orthx = edgeWidth * ny1;\n        orthy = -edgeWidth * nx1;\n        if (markerEnd && !openEnded) {\n            this.paintMarker(c, pe.x, pe.y, -nx, -ny, endSize, endWidth, edgeWidth, spacing, false);\n        }\n        else {\n            c.lineTo(pe.x - spacing * nx1 + orthx / 2, pe.y - spacing * ny1 + orthy / 2);\n            const inStartX = pe.x - spacing * nx1 - orthx / 2;\n            const inStartY = pe.y - spacing * ny1 - orthy / 2;\n            if (!openEnded) {\n                c.lineTo(inStartX, inStartY);\n            }\n            else {\n                c.moveTo(inStartX, inStartY);\n                fns.splice(0, 0, () => {\n                    c.moveTo(inStartX, inStartY);\n                });\n            }\n        }\n        for (let i = fns.length - 1; i >= 0; i--) {\n            fns[i]();\n        }\n        if (openEnded) {\n            c.end();\n            c.stroke();\n        }\n        else {\n            c.close();\n            c.fillAndStroke();\n        }\n        // Workaround for shadow on top of base arrow\n        c.setShadow(false);\n        // Need to redraw the markers without the low miter limit\n        c.setMiterLimit(4);\n        if (isRounded) {\n            c.setLineJoin('flat');\n        }\n        if (pts.length > 2) {\n            // Only to repaint markers if no waypoints\n            // Need to redraw the markers without the low miter limit\n            c.setMiterLimit(4);\n            if (markerStart && !openEnded) {\n                c.begin();\n                this.paintMarker(c, pts[0].x, pts[0].y, startNx, startNy, startSize, startWidth, edgeWidth, spacing, true);\n                c.stroke();\n                c.end();\n            }\n            if (markerEnd && !openEnded) {\n                c.begin();\n                this.paintMarker(c, pe.x, pe.y, -nx, -ny, endSize, endWidth, edgeWidth, spacing, true);\n                c.stroke();\n                c.end();\n            }\n        }\n    }\n    /**\n     * Paints the marker.\n     */\n    paintMarker(c, ptX, ptY, nx, ny, size, arrowWidth, edgeWidth, spacing, initialMove) {\n        const widthArrowRatio = edgeWidth / arrowWidth;\n        const orthx = (edgeWidth * ny) / 2;\n        const orthy = (-edgeWidth * nx) / 2;\n        const spaceX = (spacing + size) * nx;\n        const spaceY = (spacing + size) * ny;\n        if (initialMove) {\n            c.moveTo(ptX - orthx + spaceX, ptY - orthy + spaceY);\n        }\n        else {\n            c.lineTo(ptX - orthx + spaceX, ptY - orthy + spaceY);\n        }\n        c.lineTo(ptX - orthx / widthArrowRatio + spaceX, ptY - orthy / widthArrowRatio + spaceY);\n        c.lineTo(ptX + spacing * nx, ptY + spacing * ny);\n        c.lineTo(ptX + orthx / widthArrowRatio + spaceX, ptY + orthy / widthArrowRatio + spaceY);\n        c.lineTo(ptX + orthx + spaceX, ptY + orthy + spaceY);\n    }\n    /**\n     * @returns whether the arrow is rounded\n     */\n    isArrowRounded() {\n        return this.isRounded;\n    }\n    /**\n     * @returns the width of the start arrow\n     */\n    getStartArrowWidth() {\n        return ARROW_WIDTH;\n    }\n    /**\n     * @returns the width of the end arrow\n     */\n    getEndArrowWidth() {\n        return ARROW_WIDTH;\n    }\n    /**\n     * @returns the width of the body of the edge\n     */\n    getEdgeWidth() {\n        return ARROW_WIDTH / 3;\n    }\n    /**\n     * @returns whether the ends of the shape are drawn\n     */\n    isOpenEnded() {\n        return false;\n    }\n    /**\n     * @returns whether the start marker is drawn\n     */\n    isMarkerStart() {\n        return (this.style?.startArrow ?? NONE) !== NONE;\n    }\n    /**\n     * @returns whether the end marker is drawn\n     */\n    isMarkerEnd() {\n        return (this.style?.endArrow ?? NONE) !== NONE;\n    }\n}\nexport default ArrowConnectorShape;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}