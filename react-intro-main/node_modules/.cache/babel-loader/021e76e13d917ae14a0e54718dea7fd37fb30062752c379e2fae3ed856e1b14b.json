{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectIdentity from '../../util/ObjectIdentity';\nimport GraphLayout from './GraphLayout';\n/**\n * Extends {@link GraphLayout} to implement a fast organic layout algorithm.\n * The vertices need to be connected for this layout to work, vertices\n * with no connections are ignored.\n *\n * Example:\n *\n * ```javascript\n * let layout = new mxFastOrganicLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * ```\n *\n * Constructor: mxCompactTreeLayout\n *\n * Constructs a new fast organic layout for the specified graph.\n */\nclass MxFastOrganicLayout extends GraphLayout {\n  constructor(graph) {\n    super(graph);\n    /**\n     * Specifies if the top left corner of the input cells should be the origin of the layout result.  Default is true.\n     */\n    this.useInputOrigin = true;\n    /**\n     * Specifies if all edge points of traversed edges should be removed.  Default is true.\n     */\n    this.resetEdges = true;\n    /**\n     * Specifies if the STYLE_NOEDGESTYLE flag should be set on edges that are modified by the result.  Default is true.\n     */\n    this.disableEdgeStyle = true;\n    /**\n     * The force constant by which the attractive forces are divided and the replusive forces are multiple by the square of.  The value equates to the average radius there is of free space around each node.  Default is 50.\n     */\n    this.forceConstant = 50;\n    /**\n     * Cache of <forceConstant>^2 for performance.\n     */\n    this.forceConstantSquared = 0;\n    /**\n     * Minimal distance limit.  Default is 2.  Prevents of dividing by zero.\n     */\n    this.minDistanceLimit = 2;\n    /**\n     * Maximal distance limit. Default is 500. Prevents of\n     * dividing by zero.\n     */\n    this.maxDistanceLimit = 500;\n    /**\n     * Cached version of minDistanceLimit squared.\n     */\n    this.minDistanceLimitSquared = 4;\n    /**\n     * Start value of temperature. Default is 200.\n     */\n    this.initialTemp = 200;\n    /**\n     * Temperature to limit displacement at later stages of layout.\n     */\n    this.temperature = 0;\n    /**\n     * Total number of iterations to run the layout though.\n     */\n    this.maxIterations = 0;\n    /**\n     * Current iteration count.\n     */\n    this.iteration = 0;\n    /**\n     * An array of all vertices to be laid out.\n     */\n    this.vertexArray = [];\n    /**\n     * An array of locally stored X co-ordinate displacements for the vertices.\n     */\n    this.dispX = [];\n    /**\n     * An array of locally stored Y co-ordinate displacements for the vertices.\n     */\n    this.dispY = [];\n    /**\n     * An array of locally stored co-ordinate positions for the vertices.\n     */\n    this.cellLocation = [];\n    /**\n     * The approximate radius of each cell, nodes only.\n     */\n    this.radius = [];\n    /**\n     * The approximate radius squared of each cell, nodes only.\n     */\n    this.radiusSquared = [];\n    /**\n     * Array of booleans representing the movable states of the vertices.\n     */\n    this.isMoveable = [];\n    /**\n     * Local copy of cell neighbours.\n     */\n    this.neighbours = {};\n    /**\n     * Hashtable from cells to local indices.\n     */\n    this.indices = {};\n    /**\n     * Boolean flag that specifies if the layout is allowed to run. If this is\n     * set to false, then the layout exits in the following iteration.\n     */\n    this.allowedToRun = true;\n  }\n  /**\n   * Returns a boolean indicating if the given <Cell> should be ignored as a\n   * vertex. This returns true if the cell has no connections.\n   *\n   * @param vertex <Cell> whose ignored state should be returned.\n   */\n  isVertexIgnored(vertex) {\n    return super.isVertexIgnored(vertex) || this.graph.getConnections(vertex).length === 0;\n  }\n  /**\n   * Implements {@link GraphLayout#execute}. This operates on all children of the\n   * given parent where <isVertexIgnored> returns false.\n   */\n  execute(parent) {\n    this.vertexArray = [];\n    let cells = this.graph.getChildVertices(parent);\n    for (let i = 0; i < cells.length; i += 1) {\n      if (!this.isVertexIgnored(cells[i])) {\n        this.vertexArray.push(cells[i]);\n      }\n    }\n    const initialBounds = this.useInputOrigin ? this.graph.getBoundingBoxFromGeometry(this.vertexArray) : null;\n    const n = this.vertexArray.length;\n    this.indices = {};\n    this.dispX = [];\n    this.dispY = [];\n    this.cellLocation = [];\n    this.isMoveable = [];\n    this.neighbours = {};\n    this.radius = [];\n    this.radiusSquared = [];\n    if (this.forceConstant < 0.001) {\n      this.forceConstant = 0.001;\n    }\n    this.forceConstantSquared = this.forceConstant * this.forceConstant;\n    // Create a map of vertices first. This is required for the array of\n    // arrays called neighbours which holds, for each vertex, a list of\n    // ints which represents the neighbours cells to that vertex as\n    // the indices into vertexArray\n    for (let i = 0; i < this.vertexArray.length; i += 1) {\n      const vertex = this.vertexArray[i];\n      this.cellLocation[i] = [];\n      // Set up the mapping from array indices to cells\n      const id = ObjectIdentity.get(vertex);\n      this.indices[id] = i;\n      const bounds = this.getVertexBounds(vertex);\n      // Set the X,Y value of the internal version of the cell to\n      // the center point of the vertex for better positioning\n      const {\n        width\n      } = bounds;\n      const {\n        height\n      } = bounds;\n      // Randomize (0, 0) locations\n      const {\n        x\n      } = bounds;\n      const {\n        y\n      } = bounds;\n      this.cellLocation[i][0] = x + width / 2.0;\n      this.cellLocation[i][1] = y + height / 2.0;\n      this.radius[i] = Math.min(width, height);\n      this.radiusSquared[i] = this.radius[i] * this.radius[i];\n    }\n    // Moves cell location back to top-left from center locations used in\n    // algorithm, resetting the edge points is part of the transaction\n    this.graph.batchUpdate(() => {\n      for (let i = 0; i < n; i += 1) {\n        this.dispX[i] = 0;\n        this.dispY[i] = 0;\n        this.isMoveable[i] = this.isVertexMovable(this.vertexArray[i]);\n        // Get lists of neighbours to all vertices, translate the cells\n        // obtained in indices into vertexArray and store as an array\n        // against the orginial cell index\n        const edges = this.graph.getConnections(this.vertexArray[i], parent);\n        cells = this.graph.getOpposites(edges, this.vertexArray[i]);\n        this.neighbours[i] = [];\n        for (let j = 0; j < cells.length; j += 1) {\n          // Resets the points on the traversed edge\n          if (this.resetEdges) {\n            this.graph.resetEdge(edges[j]);\n          }\n          if (this.disableEdgeStyle) {\n            this.setEdgeStyleEnabled(edges[j], false);\n          }\n          // Looks the cell up in the indices dictionary\n          const id = ObjectIdentity.get(cells[j]);\n          const index = this.indices[id];\n          // Check the connected cell in part of the vertex list to be\n          // acted on by this layout\n          if (index != null) {\n            this.neighbours[i][j] = index;\n          }\n          // Else if index of the other cell doesn't correspond to\n          // any cell listed to be acted upon in this layout. Set\n          // the index to the value of this vertex (a dummy self-loop)\n          // so the attraction force of the edge is not calculated\n          else {\n            this.neighbours[i][j] = i;\n          }\n        }\n      }\n      this.temperature = this.initialTemp;\n      // If max number of iterations has not been set, guess it\n      if (this.maxIterations === 0) {\n        this.maxIterations = 20 * Math.sqrt(n);\n      }\n      // Main iteration loop\n      for (this.iteration = 0; this.iteration < this.maxIterations; this.iteration += 1) {\n        if (!this.allowedToRun) {\n          return;\n        }\n        // Calculate repulsive forces on all vertices\n        this.calcRepulsion();\n        // Calculate attractive forces through edges\n        this.calcAttraction();\n        this.calcPositions();\n        this.reduceTemperature();\n      }\n      let minx = null;\n      let miny = null;\n      for (let i = 0; i < this.vertexArray.length; i += 1) {\n        const vertex = this.vertexArray[i];\n        if (this.isVertexMovable(vertex)) {\n          const bounds = this.getVertexBounds(vertex);\n          if (bounds != null) {\n            this.cellLocation[i][0] -= bounds.width / 2.0;\n            this.cellLocation[i][1] -= bounds.height / 2.0;\n            const x = this.graph.snap(Math.round(this.cellLocation[i][0]));\n            const y = this.graph.snap(Math.round(this.cellLocation[i][1]));\n            this.setVertexLocation(vertex, x, y);\n            if (minx == null) {\n              minx = x;\n            } else {\n              minx = Math.min(minx, x);\n            }\n            if (miny == null) {\n              miny = y;\n            } else {\n              miny = Math.min(miny, y);\n            }\n          }\n        }\n      }\n      // Modifies the cloned geometries in-place. Not needed\n      // to clone the geometries again as we're in the same\n      // undoable change.\n      let dx = -(minx || 0) + 1;\n      let dy = -(miny || 0) + 1;\n      if (initialBounds != null) {\n        dx += initialBounds.x;\n        dy += initialBounds.y;\n      }\n      this.graph.moveCells(this.vertexArray, dx, dy);\n    });\n  }\n  /**\n   * Takes the displacements calculated for each cell and applies them to the\n   * local cache of cell positions. Limits the displacement to the current\n   * temperature.\n   */\n  calcPositions() {\n    for (let index = 0; index < this.vertexArray.length; index += 1) {\n      if (this.isMoveable[index]) {\n        // Get the distance of displacement for this node for this\n        // iteration\n        let deltaLength = Math.sqrt(this.dispX[index] * this.dispX[index] + this.dispY[index] * this.dispY[index]);\n        if (deltaLength < 0.001) {\n          deltaLength = 0.001;\n        }\n        // Scale down by the current temperature if less than the\n        // displacement distance\n        const newXDisp = this.dispX[index] / deltaLength * Math.min(deltaLength, this.temperature);\n        const newYDisp = this.dispY[index] / deltaLength * Math.min(deltaLength, this.temperature);\n        // reset displacements\n        this.dispX[index] = 0;\n        this.dispY[index] = 0;\n        // Update the cached cell locations\n        this.cellLocation[index][0] += newXDisp;\n        this.cellLocation[index][1] += newYDisp;\n      }\n    }\n  }\n  /**\n   * Calculates the attractive forces between all laid out nodes linked by\n   * edges\n   */\n  calcAttraction() {\n    // Check the neighbours of each vertex and calculate the attractive\n    // force of the edge connecting them\n    for (let i = 0; i < this.vertexArray.length; i += 1) {\n      for (let k = 0; k < this.neighbours[i].length; k += 1) {\n        // Get the index of the othe cell in the vertex array\n        const j = this.neighbours[i][k];\n        // Do not proceed self-loops\n        if (i !== j && this.isMoveable[i] && this.isMoveable[j]) {\n          const xDelta = this.cellLocation[i][0] - this.cellLocation[j][0];\n          const yDelta = this.cellLocation[i][1] - this.cellLocation[j][1];\n          // The distance between the nodes\n          let deltaLengthSquared = xDelta * xDelta + yDelta * yDelta - this.radiusSquared[i] - this.radiusSquared[j];\n          if (deltaLengthSquared < this.minDistanceLimitSquared) {\n            deltaLengthSquared = this.minDistanceLimitSquared;\n          }\n          const deltaLength = Math.sqrt(deltaLengthSquared);\n          const force = deltaLengthSquared / this.forceConstant;\n          const displacementX = xDelta / deltaLength * force;\n          const displacementY = yDelta / deltaLength * force;\n          this.dispX[i] -= displacementX;\n          this.dispY[i] -= displacementY;\n          this.dispX[j] += displacementX;\n          this.dispY[j] += displacementY;\n        }\n      }\n    }\n  }\n  /**\n   * Calculates the repulsive forces between all laid out nodes\n   */\n  calcRepulsion() {\n    const vertexCount = this.vertexArray.length;\n    for (let i = 0; i < vertexCount; i += 1) {\n      for (let j = i; j < vertexCount; j += 1) {\n        // Exits if the layout is no longer allowed to run\n        if (!this.allowedToRun) {\n          return;\n        }\n        if (j !== i && this.isMoveable[i] && this.isMoveable[j]) {\n          let xDelta = this.cellLocation[i][0] - this.cellLocation[j][0];\n          let yDelta = this.cellLocation[i][1] - this.cellLocation[j][1];\n          if (xDelta === 0) {\n            xDelta = 0.01 + Math.random();\n          }\n          if (yDelta === 0) {\n            yDelta = 0.01 + Math.random();\n          }\n          // Distance between nodes\n          const deltaLength = Math.sqrt(xDelta * xDelta + yDelta * yDelta);\n          let deltaLengthWithRadius = deltaLength - this.radius[i] - this.radius[j];\n          if (deltaLengthWithRadius > this.maxDistanceLimit) {\n            // Ignore vertices too far apart\n            continue;\n          }\n          if (deltaLengthWithRadius < this.minDistanceLimit) {\n            deltaLengthWithRadius = this.minDistanceLimit;\n          }\n          const force = this.forceConstantSquared / deltaLengthWithRadius;\n          const displacementX = xDelta / deltaLength * force;\n          const displacementY = yDelta / deltaLength * force;\n          this.dispX[i] += displacementX;\n          this.dispY[i] += displacementY;\n          this.dispX[j] -= displacementX;\n          this.dispY[j] -= displacementY;\n        }\n      }\n    }\n  }\n  /**\n   * Reduces the temperature of the layout from an initial setting in a linear\n   * fashion to zero.\n   */\n  reduceTemperature() {\n    this.temperature = this.initialTemp * (1.0 - this.iteration / this.maxIterations);\n  }\n}\nexport default MxFastOrganicLayout;","map":{"version":3,"names":["ObjectIdentity","GraphLayout","MxFastOrganicLayout","constructor","graph","useInputOrigin","resetEdges","disableEdgeStyle","forceConstant","forceConstantSquared","minDistanceLimit","maxDistanceLimit","minDistanceLimitSquared","initialTemp","temperature","maxIterations","iteration","vertexArray","dispX","dispY","cellLocation","radius","radiusSquared","isMoveable","neighbours","indices","allowedToRun","isVertexIgnored","vertex","getConnections","length","execute","parent","cells","getChildVertices","i","push","initialBounds","getBoundingBoxFromGeometry","n","id","get","bounds","getVertexBounds","width","height","x","y","Math","min","batchUpdate","isVertexMovable","edges","getOpposites","j","resetEdge","setEdgeStyleEnabled","index","sqrt","calcRepulsion","calcAttraction","calcPositions","reduceTemperature","minx","miny","snap","round","setVertexLocation","dx","dy","moveCells","deltaLength","newXDisp","newYDisp","k","xDelta","yDelta","deltaLengthSquared","force","displacementX","displacementY","vertexCount","random","deltaLengthWithRadius"],"sources":["D:/ospanel/domains/old/react/react-intro-main/node_modules/@maxgraph/core/dist/view/layout/FastOrganicLayout.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectIdentity from '../../util/ObjectIdentity';\nimport GraphLayout from './GraphLayout';\n/**\n * Extends {@link GraphLayout} to implement a fast organic layout algorithm.\n * The vertices need to be connected for this layout to work, vertices\n * with no connections are ignored.\n *\n * Example:\n *\n * ```javascript\n * let layout = new mxFastOrganicLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * ```\n *\n * Constructor: mxCompactTreeLayout\n *\n * Constructs a new fast organic layout for the specified graph.\n */\nclass MxFastOrganicLayout extends GraphLayout {\n    constructor(graph) {\n        super(graph);\n        /**\n         * Specifies if the top left corner of the input cells should be the origin of the layout result.  Default is true.\n         */\n        this.useInputOrigin = true;\n        /**\n         * Specifies if all edge points of traversed edges should be removed.  Default is true.\n         */\n        this.resetEdges = true;\n        /**\n         * Specifies if the STYLE_NOEDGESTYLE flag should be set on edges that are modified by the result.  Default is true.\n         */\n        this.disableEdgeStyle = true;\n        /**\n         * The force constant by which the attractive forces are divided and the replusive forces are multiple by the square of.  The value equates to the average radius there is of free space around each node.  Default is 50.\n         */\n        this.forceConstant = 50;\n        /**\n         * Cache of <forceConstant>^2 for performance.\n         */\n        this.forceConstantSquared = 0;\n        /**\n         * Minimal distance limit.  Default is 2.  Prevents of dividing by zero.\n         */\n        this.minDistanceLimit = 2;\n        /**\n         * Maximal distance limit. Default is 500. Prevents of\n         * dividing by zero.\n         */\n        this.maxDistanceLimit = 500;\n        /**\n         * Cached version of minDistanceLimit squared.\n         */\n        this.minDistanceLimitSquared = 4;\n        /**\n         * Start value of temperature. Default is 200.\n         */\n        this.initialTemp = 200;\n        /**\n         * Temperature to limit displacement at later stages of layout.\n         */\n        this.temperature = 0;\n        /**\n         * Total number of iterations to run the layout though.\n         */\n        this.maxIterations = 0;\n        /**\n         * Current iteration count.\n         */\n        this.iteration = 0;\n        /**\n         * An array of all vertices to be laid out.\n         */\n        this.vertexArray = [];\n        /**\n         * An array of locally stored X co-ordinate displacements for the vertices.\n         */\n        this.dispX = [];\n        /**\n         * An array of locally stored Y co-ordinate displacements for the vertices.\n         */\n        this.dispY = [];\n        /**\n         * An array of locally stored co-ordinate positions for the vertices.\n         */\n        this.cellLocation = [];\n        /**\n         * The approximate radius of each cell, nodes only.\n         */\n        this.radius = [];\n        /**\n         * The approximate radius squared of each cell, nodes only.\n         */\n        this.radiusSquared = [];\n        /**\n         * Array of booleans representing the movable states of the vertices.\n         */\n        this.isMoveable = [];\n        /**\n         * Local copy of cell neighbours.\n         */\n        this.neighbours = {};\n        /**\n         * Hashtable from cells to local indices.\n         */\n        this.indices = {};\n        /**\n         * Boolean flag that specifies if the layout is allowed to run. If this is\n         * set to false, then the layout exits in the following iteration.\n         */\n        this.allowedToRun = true;\n    }\n    /**\n     * Returns a boolean indicating if the given <Cell> should be ignored as a\n     * vertex. This returns true if the cell has no connections.\n     *\n     * @param vertex <Cell> whose ignored state should be returned.\n     */\n    isVertexIgnored(vertex) {\n        return (super.isVertexIgnored(vertex) || this.graph.getConnections(vertex).length === 0);\n    }\n    /**\n     * Implements {@link GraphLayout#execute}. This operates on all children of the\n     * given parent where <isVertexIgnored> returns false.\n     */\n    execute(parent) {\n        this.vertexArray = [];\n        let cells = this.graph.getChildVertices(parent);\n        for (let i = 0; i < cells.length; i += 1) {\n            if (!this.isVertexIgnored(cells[i])) {\n                this.vertexArray.push(cells[i]);\n            }\n        }\n        const initialBounds = this.useInputOrigin\n            ? this.graph.getBoundingBoxFromGeometry(this.vertexArray)\n            : null;\n        const n = this.vertexArray.length;\n        this.indices = {};\n        this.dispX = [];\n        this.dispY = [];\n        this.cellLocation = [];\n        this.isMoveable = [];\n        this.neighbours = {};\n        this.radius = [];\n        this.radiusSquared = [];\n        if (this.forceConstant < 0.001) {\n            this.forceConstant = 0.001;\n        }\n        this.forceConstantSquared = this.forceConstant * this.forceConstant;\n        // Create a map of vertices first. This is required for the array of\n        // arrays called neighbours which holds, for each vertex, a list of\n        // ints which represents the neighbours cells to that vertex as\n        // the indices into vertexArray\n        for (let i = 0; i < this.vertexArray.length; i += 1) {\n            const vertex = this.vertexArray[i];\n            this.cellLocation[i] = [];\n            // Set up the mapping from array indices to cells\n            const id = ObjectIdentity.get(vertex);\n            this.indices[id] = i;\n            const bounds = this.getVertexBounds(vertex);\n            // Set the X,Y value of the internal version of the cell to\n            // the center point of the vertex for better positioning\n            const { width } = bounds;\n            const { height } = bounds;\n            // Randomize (0, 0) locations\n            const { x } = bounds;\n            const { y } = bounds;\n            this.cellLocation[i][0] = x + width / 2.0;\n            this.cellLocation[i][1] = y + height / 2.0;\n            this.radius[i] = Math.min(width, height);\n            this.radiusSquared[i] = this.radius[i] * this.radius[i];\n        }\n        // Moves cell location back to top-left from center locations used in\n        // algorithm, resetting the edge points is part of the transaction\n        this.graph.batchUpdate(() => {\n            for (let i = 0; i < n; i += 1) {\n                this.dispX[i] = 0;\n                this.dispY[i] = 0;\n                this.isMoveable[i] = this.isVertexMovable(this.vertexArray[i]);\n                // Get lists of neighbours to all vertices, translate the cells\n                // obtained in indices into vertexArray and store as an array\n                // against the orginial cell index\n                const edges = this.graph.getConnections(this.vertexArray[i], parent);\n                cells = this.graph.getOpposites(edges, this.vertexArray[i]);\n                this.neighbours[i] = [];\n                for (let j = 0; j < cells.length; j += 1) {\n                    // Resets the points on the traversed edge\n                    if (this.resetEdges) {\n                        this.graph.resetEdge(edges[j]);\n                    }\n                    if (this.disableEdgeStyle) {\n                        this.setEdgeStyleEnabled(edges[j], false);\n                    }\n                    // Looks the cell up in the indices dictionary\n                    const id = ObjectIdentity.get(cells[j]);\n                    const index = this.indices[id];\n                    // Check the connected cell in part of the vertex list to be\n                    // acted on by this layout\n                    if (index != null) {\n                        this.neighbours[i][j] = index;\n                    }\n                    // Else if index of the other cell doesn't correspond to\n                    // any cell listed to be acted upon in this layout. Set\n                    // the index to the value of this vertex (a dummy self-loop)\n                    // so the attraction force of the edge is not calculated\n                    else {\n                        this.neighbours[i][j] = i;\n                    }\n                }\n            }\n            this.temperature = this.initialTemp;\n            // If max number of iterations has not been set, guess it\n            if (this.maxIterations === 0) {\n                this.maxIterations = 20 * Math.sqrt(n);\n            }\n            // Main iteration loop\n            for (this.iteration = 0; this.iteration < this.maxIterations; this.iteration += 1) {\n                if (!this.allowedToRun) {\n                    return;\n                }\n                // Calculate repulsive forces on all vertices\n                this.calcRepulsion();\n                // Calculate attractive forces through edges\n                this.calcAttraction();\n                this.calcPositions();\n                this.reduceTemperature();\n            }\n            let minx = null;\n            let miny = null;\n            for (let i = 0; i < this.vertexArray.length; i += 1) {\n                const vertex = this.vertexArray[i];\n                if (this.isVertexMovable(vertex)) {\n                    const bounds = this.getVertexBounds(vertex);\n                    if (bounds != null) {\n                        this.cellLocation[i][0] -= bounds.width / 2.0;\n                        this.cellLocation[i][1] -= bounds.height / 2.0;\n                        const x = this.graph.snap(Math.round(this.cellLocation[i][0]));\n                        const y = this.graph.snap(Math.round(this.cellLocation[i][1]));\n                        this.setVertexLocation(vertex, x, y);\n                        if (minx == null) {\n                            minx = x;\n                        }\n                        else {\n                            minx = Math.min(minx, x);\n                        }\n                        if (miny == null) {\n                            miny = y;\n                        }\n                        else {\n                            miny = Math.min(miny, y);\n                        }\n                    }\n                }\n            }\n            // Modifies the cloned geometries in-place. Not needed\n            // to clone the geometries again as we're in the same\n            // undoable change.\n            let dx = -(minx || 0) + 1;\n            let dy = -(miny || 0) + 1;\n            if (initialBounds != null) {\n                dx += initialBounds.x;\n                dy += initialBounds.y;\n            }\n            this.graph.moveCells(this.vertexArray, dx, dy);\n        });\n    }\n    /**\n     * Takes the displacements calculated for each cell and applies them to the\n     * local cache of cell positions. Limits the displacement to the current\n     * temperature.\n     */\n    calcPositions() {\n        for (let index = 0; index < this.vertexArray.length; index += 1) {\n            if (this.isMoveable[index]) {\n                // Get the distance of displacement for this node for this\n                // iteration\n                let deltaLength = Math.sqrt(this.dispX[index] * this.dispX[index] + this.dispY[index] * this.dispY[index]);\n                if (deltaLength < 0.001) {\n                    deltaLength = 0.001;\n                }\n                // Scale down by the current temperature if less than the\n                // displacement distance\n                const newXDisp = (this.dispX[index] / deltaLength) * Math.min(deltaLength, this.temperature);\n                const newYDisp = (this.dispY[index] / deltaLength) * Math.min(deltaLength, this.temperature);\n                // reset displacements\n                this.dispX[index] = 0;\n                this.dispY[index] = 0;\n                // Update the cached cell locations\n                this.cellLocation[index][0] += newXDisp;\n                this.cellLocation[index][1] += newYDisp;\n            }\n        }\n    }\n    /**\n     * Calculates the attractive forces between all laid out nodes linked by\n     * edges\n     */\n    calcAttraction() {\n        // Check the neighbours of each vertex and calculate the attractive\n        // force of the edge connecting them\n        for (let i = 0; i < this.vertexArray.length; i += 1) {\n            for (let k = 0; k < this.neighbours[i].length; k += 1) {\n                // Get the index of the othe cell in the vertex array\n                const j = this.neighbours[i][k];\n                // Do not proceed self-loops\n                if (i !== j && this.isMoveable[i] && this.isMoveable[j]) {\n                    const xDelta = this.cellLocation[i][0] - this.cellLocation[j][0];\n                    const yDelta = this.cellLocation[i][1] - this.cellLocation[j][1];\n                    // The distance between the nodes\n                    let deltaLengthSquared = xDelta * xDelta +\n                        yDelta * yDelta -\n                        this.radiusSquared[i] -\n                        this.radiusSquared[j];\n                    if (deltaLengthSquared < this.minDistanceLimitSquared) {\n                        deltaLengthSquared = this.minDistanceLimitSquared;\n                    }\n                    const deltaLength = Math.sqrt(deltaLengthSquared);\n                    const force = deltaLengthSquared / this.forceConstant;\n                    const displacementX = (xDelta / deltaLength) * force;\n                    const displacementY = (yDelta / deltaLength) * force;\n                    this.dispX[i] -= displacementX;\n                    this.dispY[i] -= displacementY;\n                    this.dispX[j] += displacementX;\n                    this.dispY[j] += displacementY;\n                }\n            }\n        }\n    }\n    /**\n     * Calculates the repulsive forces between all laid out nodes\n     */\n    calcRepulsion() {\n        const vertexCount = this.vertexArray.length;\n        for (let i = 0; i < vertexCount; i += 1) {\n            for (let j = i; j < vertexCount; j += 1) {\n                // Exits if the layout is no longer allowed to run\n                if (!this.allowedToRun) {\n                    return;\n                }\n                if (j !== i && this.isMoveable[i] && this.isMoveable[j]) {\n                    let xDelta = this.cellLocation[i][0] - this.cellLocation[j][0];\n                    let yDelta = this.cellLocation[i][1] - this.cellLocation[j][1];\n                    if (xDelta === 0) {\n                        xDelta = 0.01 + Math.random();\n                    }\n                    if (yDelta === 0) {\n                        yDelta = 0.01 + Math.random();\n                    }\n                    // Distance between nodes\n                    const deltaLength = Math.sqrt(xDelta * xDelta + yDelta * yDelta);\n                    let deltaLengthWithRadius = deltaLength - this.radius[i] - this.radius[j];\n                    if (deltaLengthWithRadius > this.maxDistanceLimit) {\n                        // Ignore vertices too far apart\n                        continue;\n                    }\n                    if (deltaLengthWithRadius < this.minDistanceLimit) {\n                        deltaLengthWithRadius = this.minDistanceLimit;\n                    }\n                    const force = this.forceConstantSquared / deltaLengthWithRadius;\n                    const displacementX = (xDelta / deltaLength) * force;\n                    const displacementY = (yDelta / deltaLength) * force;\n                    this.dispX[i] += displacementX;\n                    this.dispY[i] += displacementY;\n                    this.dispX[j] -= displacementX;\n                    this.dispY[j] -= displacementY;\n                }\n            }\n        }\n    }\n    /**\n     * Reduces the temperature of the layout from an initial setting in a linear\n     * fashion to zero.\n     */\n    reduceTemperature() {\n        this.temperature = this.initialTemp * (1.0 - this.iteration / this.maxIterations);\n    }\n}\nexport default MxFastOrganicLayout;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,cAAc,MAAM,2BAA2B;AACtD,OAAOC,WAAW,MAAM,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,mBAAmB,SAASD,WAAW,CAAC;EAC1CE,WAAWA,CAACC,KAAK,EAAE;IACf,KAAK,CAACA,KAAK,CAAC;IACZ;AACR;AACA;IACQ,IAAI,CAACC,cAAc,GAAG,IAAI;IAC1B;AACR;AACA;IACQ,IAAI,CAACC,UAAU,GAAG,IAAI;IACtB;AACR;AACA;IACQ,IAAI,CAACC,gBAAgB,GAAG,IAAI;IAC5B;AACR;AACA;IACQ,IAAI,CAACC,aAAa,GAAG,EAAE;IACvB;AACR;AACA;IACQ,IAAI,CAACC,oBAAoB,GAAG,CAAC;IAC7B;AACR;AACA;IACQ,IAAI,CAACC,gBAAgB,GAAG,CAAC;IACzB;AACR;AACA;AACA;IACQ,IAAI,CAACC,gBAAgB,GAAG,GAAG;IAC3B;AACR;AACA;IACQ,IAAI,CAACC,uBAAuB,GAAG,CAAC;IAChC;AACR;AACA;IACQ,IAAI,CAACC,WAAW,GAAG,GAAG;IACtB;AACR;AACA;IACQ,IAAI,CAACC,WAAW,GAAG,CAAC;IACpB;AACR;AACA;IACQ,IAAI,CAACC,aAAa,GAAG,CAAC;IACtB;AACR;AACA;IACQ,IAAI,CAACC,SAAS,GAAG,CAAC;IAClB;AACR;AACA;IACQ,IAAI,CAACC,WAAW,GAAG,EAAE;IACrB;AACR;AACA;IACQ,IAAI,CAACC,KAAK,GAAG,EAAE;IACf;AACR;AACA;IACQ,IAAI,CAACC,KAAK,GAAG,EAAE;IACf;AACR;AACA;IACQ,IAAI,CAACC,YAAY,GAAG,EAAE;IACtB;AACR;AACA;IACQ,IAAI,CAACC,MAAM,GAAG,EAAE;IAChB;AACR;AACA;IACQ,IAAI,CAACC,aAAa,GAAG,EAAE;IACvB;AACR;AACA;IACQ,IAAI,CAACC,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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}