{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport HierarchicalLayoutStage from './HierarchicalLayoutStage';\nimport MedianCellSorter from '../util/MedianCellSorter';\n/**\n * Sets the horizontal locations of node and edge dummy nodes on each layer.\n * Uses median down and up weighings as well heuristic to straighten edges as\n * far as possible.\n *\n * Constructor: mxMedianHybridCrossingReduction\n *\n * Creates a coordinate assignment.\n *\n * Arguments:\n *\n * intraCellSpacing - the minimum buffer between cells on the same rank\n * interRankCellSpacing - the minimum distance between cells on adjacent ranks\n * orientation - the position of the root node(s) relative to the graph\n * initialX - the leftmost coordinate node placement starts at\n */\nclass MedianHybridCrossingReduction extends HierarchicalLayoutStage {\n  constructor(layout) {\n    super();\n    /**\n     * The maximum number of iterations to perform whilst reducing edge\n     * crossings. Default is 24.\n     */\n    this.maxIterations = 24;\n    /**\n     * Stores each rank as a collection of cells in the best order found for\n     * each layer so far\n     */\n    this.nestedBestRanks = null;\n    /**\n     * The total number of crossings found in the best configuration so far\n     */\n    this.currentBestCrossings = 0;\n    /**\n     * The total number of crossings found in the best configuration so far\n     */\n    this.iterationsWithoutImprovement = 0;\n    /**\n     * The total number of crossings found in the best configuration so far\n     */\n    this.maxNoImprovementIterations = 2;\n    this.layout = layout;\n  }\n  /**\n   * Performs a vertex ordering within ranks as described by Gansner et al\n   * 1993\n   */\n  execute(parent) {\n    const model = this.layout.getDataModel();\n    let ranks = model.ranks;\n    // Stores initial ordering as being the best one found so far\n    this.nestedBestRanks = [];\n    for (let i = 0; i < ranks.length; i += 1) {\n      this.nestedBestRanks[i] = ranks[i].slice();\n    }\n    let iterationsWithoutImprovement = 0;\n    let currentBestCrossings = this.calculateCrossings(model);\n    for (let i = 0; i < this.maxIterations && iterationsWithoutImprovement < this.maxNoImprovementIterations; i++) {\n      this.weightedMedian(i, model);\n      this.transpose(i, model);\n      const candidateCrossings = this.calculateCrossings(model);\n      if (candidateCrossings < currentBestCrossings) {\n        currentBestCrossings = candidateCrossings;\n        iterationsWithoutImprovement = 0;\n        // Store the current rankings as the best ones\n        for (let j = 0; j < this.nestedBestRanks.length; j += 1) {\n          const rank = ranks[j];\n          for (let k = 0; k < rank.length; k += 1) {\n            const cell = rank[k];\n            this.nestedBestRanks[j][cell.getGeneralPurposeVariable(j)] = cell;\n          }\n        }\n      } else {\n        // Increase count of iterations where we haven't improved the\n        // layout\n        iterationsWithoutImprovement += 1;\n        // Restore the best values to the cells\n        for (let j = 0; j < this.nestedBestRanks.length; j += 1) {\n          const rank = ranks[j];\n          for (let k = 0; k < rank.length; k += 1) {\n            const cell = rank[k];\n            cell.setGeneralPurposeVariable(j, k);\n          }\n        }\n      }\n      if (currentBestCrossings === 0) {\n        // Do nothing further\n        break;\n      }\n    }\n    // Store the best rankings but in the model\n    ranks = [];\n    const rankList = [];\n    for (let i = 0; i < model.maxRank + 1; i += 1) {\n      rankList[i] = [];\n      ranks[i] = rankList[i];\n    }\n    for (let i = 0; i < this.nestedBestRanks.length; i += 1) {\n      for (let j = 0; j < this.nestedBestRanks[i].length; j += 1) {\n        rankList[i].push(this.nestedBestRanks[i][j]);\n      }\n    }\n    model.ranks = ranks;\n  }\n  /**\n   * Calculates the total number of edge crossing in the current graph.\n   * Returns the current number of edge crossings in the hierarchy graph\n   * model in the current candidate layout\n   *\n   * @param model the internal model describing the hierarchy\n   */\n  calculateCrossings(model) {\n    const ranks = model.ranks;\n    const numRanks = ranks.length;\n    let totalCrossings = 0;\n    for (let i = 1; i < numRanks; i += 1) {\n      totalCrossings += this.calculateRankCrossing(i, model);\n    }\n    return totalCrossings;\n  }\n  /**\n   * Calculates the number of edges crossings between the specified rank and\n   * the rank below it. Returns the number of edges crossings with the rank\n   * beneath\n   *\n   * @param i  the topmost rank of the pair ( higher rank value )\n   * @param model the internal model describing the hierarchy\n   */\n  calculateRankCrossing(i, model) {\n    let totalCrossings = 0;\n    const ranks = model.ranks;\n    const rank = ranks[i];\n    const previousRank = ranks[i - 1];\n    const tmpIndices = [];\n    // Iterate over the top rank and fill in the connection information\n    for (let j = 0; j < rank.length; j += 1) {\n      const node = rank[j];\n      const rankPosition = node.getGeneralPurposeVariable(i);\n      const connectedCells = node.getPreviousLayerConnectedCells(i);\n      const nodeIndices = [];\n      for (let k = 0; k < connectedCells.length; k += 1) {\n        const connectedNode = connectedCells[k];\n        const otherCellRankPosition = connectedNode.getGeneralPurposeVariable(i - 1);\n        nodeIndices.push(otherCellRankPosition);\n      }\n      nodeIndices.sort((x, y) => {\n        return x - y;\n      });\n      tmpIndices[rankPosition] = nodeIndices;\n    }\n    let indices = [];\n    for (let j = 0; j < tmpIndices.length; j++) {\n      indices = indices.concat(tmpIndices[j]);\n    }\n    let firstIndex = 1;\n    while (firstIndex < previousRank.length) {\n      firstIndex <<= 1;\n    }\n    const treeSize = 2 * firstIndex - 1;\n    firstIndex -= 1;\n    const tree = [];\n    for (let j = 0; j < treeSize; ++j) {\n      tree[j] = 0;\n    }\n    for (let j = 0; j < indices.length; j += 1) {\n      const index = indices[j];\n      let treeIndex = index + firstIndex;\n      ++tree[treeIndex];\n      while (treeIndex > 0) {\n        if (treeIndex % 2) {\n          totalCrossings += tree[treeIndex + 1];\n        }\n        treeIndex = treeIndex - 1 >> 1;\n        ++tree[treeIndex];\n      }\n    }\n    return totalCrossings;\n  }\n  /**\n   * Takes each possible adjacent cell pair on each rank and checks if\n   * swapping them around reduces the number of crossing\n   *\n   * @param mainLoopIteration the iteration number of the main loop\n   * @param model the internal model describing the hierarchy\n   */\n  transpose(mainLoopIteration, model) {\n    let improved = true;\n    // Track the number of iterations in case of looping\n    let count = 0;\n    const maxCount = 10;\n    while (improved && count++ < maxCount) {\n      // On certain iterations allow allow swapping of cell pairs with\n      // equal edge crossings switched or not switched. This help to\n      // nudge a stuck layout into a lower crossing total.\n      const nudge = mainLoopIteration % 2 === 1 && count % 2 === 1;\n      improved = false;\n      const ranks = model.ranks;\n      for (let i = 0; i < ranks.length; i += 1) {\n        const rank = ranks[i];\n        const orderedCells = [];\n        for (let j = 0; j < rank.length; j++) {\n          const cell = rank[j];\n          let tempRank = cell.getGeneralPurposeVariable(i);\n          // FIXME: Workaround to avoid negative tempRanks\n          if (tempRank < 0) {\n            tempRank = j;\n          }\n          orderedCells[tempRank] = cell;\n        }\n        let leftCellAboveConnections = null;\n        let leftCellBelowConnections = null;\n        let rightCellAboveConnections = null;\n        let rightCellBelowConnections = null;\n        let leftAbovePositions = null;\n        let leftBelowPositions = null;\n        let rightAbovePositions = null;\n        let rightBelowPositions = null;\n        let leftCell = null;\n        let rightCell = null;\n        for (let j = 0; j < rank.length - 1; j++) {\n          // For each intra-rank adjacent pair of cells\n          // see if swapping them around would reduce the\n          // number of edges crossing they cause in total\n          // On every cell pair except the first on each rank, we\n          // can save processing using the previous values for the\n          // right cell on the new left cell\n          if (j === 0) {\n            leftCell = orderedCells[j];\n            leftCellAboveConnections = leftCell.getNextLayerConnectedCells(i);\n            leftCellBelowConnections = leftCell.getPreviousLayerConnectedCells(i);\n            leftAbovePositions = [];\n            leftBelowPositions = [];\n            for (let k = 0; k < leftCellAboveConnections.length; k++) {\n              leftAbovePositions[k] = leftCellAboveConnections[k].getGeneralPurposeVariable(i + 1);\n            }\n            for (let k = 0; k < leftCellBelowConnections.length; k++) {\n              leftBelowPositions[k] = leftCellBelowConnections[k].getGeneralPurposeVariable(i - 1);\n            }\n          } else {\n            leftCellAboveConnections = rightCellAboveConnections;\n            leftCellBelowConnections = rightCellBelowConnections;\n            leftAbovePositions = rightAbovePositions;\n            leftBelowPositions = rightBelowPositions;\n            leftCell = rightCell;\n          }\n          rightCell = orderedCells[j + 1];\n          rightCellAboveConnections = rightCell.getNextLayerConnectedCells(i);\n          rightCellBelowConnections = rightCell.getPreviousLayerConnectedCells(i);\n          rightAbovePositions = [];\n          rightBelowPositions = [];\n          for (let k = 0; k < rightCellAboveConnections.length; k++) {\n            rightAbovePositions[k] = rightCellAboveConnections[k].getGeneralPurposeVariable(i + 1);\n          }\n          for (let k = 0; k < rightCellBelowConnections.length; k++) {\n            rightBelowPositions[k] = rightCellBelowConnections[k].getGeneralPurposeVariable(i - 1);\n          }\n          let totalCurrentCrossings = 0;\n          let totalSwitchedCrossings = 0;\n          for (let k = 0; k < leftAbovePositions.length; k += 1) {\n            for (let ik = 0; ik < rightAbovePositions.length; ik += 1) {\n              if (leftAbovePositions[k] > rightAbovePositions[ik]) {\n                totalCurrentCrossings += 1;\n              }\n              if (leftAbovePositions[k] < rightAbovePositions[ik]) {\n                totalSwitchedCrossings += 1;\n              }\n            }\n          }\n          for (let k = 0; k < leftBelowPositions.length; k += 1) {\n            for (let ik = 0; ik < rightBelowPositions.length; ik += 1) {\n              if (leftBelowPositions[k] > rightBelowPositions[ik]) {\n                totalCurrentCrossings += 1;\n              }\n              if (leftBelowPositions[k] < rightBelowPositions[ik]) {\n                totalSwitchedCrossings += 1;\n              }\n            }\n          }\n          if (totalSwitchedCrossings < totalCurrentCrossings || totalSwitchedCrossings === totalCurrentCrossings && nudge) {\n            const temp = leftCell.getGeneralPurposeVariable(i);\n            leftCell.setGeneralPurposeVariable(i, rightCell.getGeneralPurposeVariable(i));\n            rightCell.setGeneralPurposeVariable(i, temp);\n            // With this pair exchanged we have to switch all of\n            // values for the left cell to the right cell so the\n            // next iteration for this rank uses it as the left\n            // cell again\n            rightCellAboveConnections = leftCellAboveConnections;\n            rightCellBelowConnections = leftCellBelowConnections;\n            rightAbovePositions = leftAbovePositions;\n            rightBelowPositions = leftBelowPositions;\n            rightCell = leftCell;\n            if (!nudge) {\n              // Don't count nudges as improvement or we'll end\n              // up stuck in two combinations and not finishing\n              // as early as we should\n              improved = true;\n            }\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Sweeps up or down the layout attempting to minimise the median placement\n   * of connected cells on adjacent ranks\n   *\n   * @param iteration the iteration number of the main loop\n   * @param model the internal model describing the hierarchy\n   */\n  weightedMedian(iteration, model) {\n    // Reverse sweep direction each time through this method\n    const downwardSweep = iteration % 2 === 0;\n    if (downwardSweep) {\n      for (let j = model.maxRank - 1; j >= 0; j -= 1) {\n        this.medianRank(j, downwardSweep);\n      }\n    } else {\n      for (let j = 1; j < model.maxRank; j += 1) {\n        this.medianRank(j, downwardSweep);\n      }\n    }\n  }\n  /**\n   * Attempts to minimise the median placement of connected cells on this rank\n   * and one of the adjacent ranks\n   *\n   * @param rankValue the layer number of this rank\n   * @param downwardSweep whether or not this is a downward sweep through the graph\n   */\n  medianRank(rankValue, downwardSweep) {\n    const nestedBestRanks = this.nestedBestRanks;\n    const numCellsForRank = nestedBestRanks[rankValue].length;\n    const medianValues = [];\n    const reservedPositions = {};\n    for (let i = 0; i < numCellsForRank; i += 1) {\n      const cell = nestedBestRanks[rankValue][i];\n      const sorterEntry = new MedianCellSorter();\n      sorterEntry.cell = cell;\n      // Flip whether or not equal medians are flipped on up and down\n      // sweeps\n      // TODO re-implement some kind of nudge\n      // medianValues[i].nudge = !downwardSweep;\n      const nextLevelConnectedCells = downwardSweep ? cell.getNextLayerConnectedCells(rankValue) : cell.getPreviousLayerConnectedCells(rankValue);\n      const nextRankValue = downwardSweep ? rankValue + 1 : rankValue - 1;\n      if (nextLevelConnectedCells != null && nextLevelConnectedCells.length !== 0) {\n        sorterEntry.medianValue = this.medianValue(nextLevelConnectedCells, nextRankValue);\n        medianValues.push(sorterEntry);\n      } else {\n        // Nodes with no adjacent vertices are flagged in the reserved array\n        // to indicate they should be left in their current position.\n        reservedPositions[cell.getGeneralPurposeVariable(rankValue)] = true;\n      }\n    }\n    medianValues.sort(new MedianCellSorter().compare);\n    // Set the new position of each node within the rank using\n    // its temp variable\n    for (let i = 0; i < numCellsForRank; i += 1) {\n      if (reservedPositions[i] == null) {\n        const cell = medianValues.shift().cell;\n        cell.setGeneralPurposeVariable(rankValue, i);\n      }\n    }\n  }\n  /**\n   * Calculates the median rank order positioning for the specified cell using\n   * the connected cells on the specified rank. Returns the median rank\n   * ordering value of the connected cells\n   *\n   * @param connectedCells the cells on the specified rank connected to the\n   * specified cell\n   * @param rankValue the rank that the connected cell lie upon\n   */\n  medianValue(connectedCells, rankValue) {\n    const medianValues = [];\n    let arrayCount = 0;\n    for (let i = 0; i < connectedCells.length; i += 1) {\n      const cell = connectedCells[i];\n      medianValues[arrayCount++] = cell.getGeneralPurposeVariable(rankValue);\n    }\n    // Sort() sorts lexicographically by default (i.e. 11 before 9) so force\n    // numerical order sort\n    medianValues.sort((a, b) => {\n      return a - b;\n    });\n    if (arrayCount % 2 === 1) {\n      // For odd numbers of adjacent vertices return the median\n      return medianValues[Math.floor(arrayCount / 2)];\n    }\n    if (arrayCount === 2) {\n      return (medianValues[0] + medianValues[1]) / 2.0;\n    }\n    const medianPoint = arrayCount / 2;\n    const leftMedian = medianValues[medianPoint - 1] - medianValues[0];\n    const rightMedian = medianValues[arrayCount - 1] - medianValues[medianPoint];\n    return (medianValues[medianPoint - 1] * rightMedian + medianValues[medianPoint] * leftMedian) / (leftMedian + rightMedian);\n  }\n}\nexport default MedianHybridCrossingReduction;","map":{"version":3,"names":["HierarchicalLayoutStage","MedianCellSorter","MedianHybridCrossingReduction","constructor","layout","maxIterations","nestedBestRanks","currentBestCrossings","iterationsWithoutImprovement","maxNoImprovementIterations","execute","parent","model","getDataModel","ranks","i","length","slice","calculateCrossings","weightedMedian","transpose","candidateCrossings","j","rank","k","cell","getGeneralPurposeVariable","setGeneralPurposeVariable","rankList","maxRank","push","numRanks","totalCrossings","calculateRankCrossing","previousRank","tmpIndices","node","rankPosition","connectedCells","getPreviousLayerConnectedCells","nodeIndices","connectedNode","otherCellRankPosition","sort","x","y","indices","concat","firstIndex","treeSize","tree","index","treeIndex","mainLoopIteration","improved","count","maxCount","nudge","orderedCells","tempRank","leftCellAboveConnections","leftCellBelowConnections","rightCellAboveConnections","rightCellBelowConnections","leftAbovePositions","leftBelowPositions","rightAbovePositions","rightBelowPositions","leftCell","rightCell","getNextLayerConnectedCells","totalCurrentCrossings","totalSwitchedCrossings","ik","temp","iteration","downwardSweep","medianRank","rankValue","numCellsForRank","medianValues","reservedPositions","sorterEntry","nextLevelConnectedCells","nextRankValue","medianValue","compare","shift","arrayCount","a","b","Math","floor","medianPoint","leftMedian","rightMedian"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/@maxgraph/core/dist/view/layout/hierarchical/MedianHybridCrossingReduction.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport HierarchicalLayoutStage from './HierarchicalLayoutStage';\nimport MedianCellSorter from '../util/MedianCellSorter';\n/**\n * Sets the horizontal locations of node and edge dummy nodes on each layer.\n * Uses median down and up weighings as well heuristic to straighten edges as\n * far as possible.\n *\n * Constructor: mxMedianHybridCrossingReduction\n *\n * Creates a coordinate assignment.\n *\n * Arguments:\n *\n * intraCellSpacing - the minimum buffer between cells on the same rank\n * interRankCellSpacing - the minimum distance between cells on adjacent ranks\n * orientation - the position of the root node(s) relative to the graph\n * initialX - the leftmost coordinate node placement starts at\n */\nclass MedianHybridCrossingReduction extends HierarchicalLayoutStage {\n    constructor(layout) {\n        super();\n        /**\n         * The maximum number of iterations to perform whilst reducing edge\n         * crossings. Default is 24.\n         */\n        this.maxIterations = 24;\n        /**\n         * Stores each rank as a collection of cells in the best order found for\n         * each layer so far\n         */\n        this.nestedBestRanks = null;\n        /**\n         * The total number of crossings found in the best configuration so far\n         */\n        this.currentBestCrossings = 0;\n        /**\n         * The total number of crossings found in the best configuration so far\n         */\n        this.iterationsWithoutImprovement = 0;\n        /**\n         * The total number of crossings found in the best configuration so far\n         */\n        this.maxNoImprovementIterations = 2;\n        this.layout = layout;\n    }\n    /**\n     * Performs a vertex ordering within ranks as described by Gansner et al\n     * 1993\n     */\n    execute(parent) {\n        const model = this.layout.getDataModel();\n        let ranks = model.ranks;\n        // Stores initial ordering as being the best one found so far\n        this.nestedBestRanks = [];\n        for (let i = 0; i < ranks.length; i += 1) {\n            this.nestedBestRanks[i] = ranks[i].slice();\n        }\n        let iterationsWithoutImprovement = 0;\n        let currentBestCrossings = this.calculateCrossings(model);\n        for (let i = 0; i < this.maxIterations &&\n            iterationsWithoutImprovement < this.maxNoImprovementIterations; i++) {\n            this.weightedMedian(i, model);\n            this.transpose(i, model);\n            const candidateCrossings = this.calculateCrossings(model);\n            if (candidateCrossings < currentBestCrossings) {\n                currentBestCrossings = candidateCrossings;\n                iterationsWithoutImprovement = 0;\n                // Store the current rankings as the best ones\n                for (let j = 0; j < this.nestedBestRanks.length; j += 1) {\n                    const rank = ranks[j];\n                    for (let k = 0; k < rank.length; k += 1) {\n                        const cell = rank[k];\n                        this.nestedBestRanks[j][cell.getGeneralPurposeVariable(j)] = cell;\n                    }\n                }\n            }\n            else {\n                // Increase count of iterations where we haven't improved the\n                // layout\n                iterationsWithoutImprovement += 1;\n                // Restore the best values to the cells\n                for (let j = 0; j < this.nestedBestRanks.length; j += 1) {\n                    const rank = ranks[j];\n                    for (let k = 0; k < rank.length; k += 1) {\n                        const cell = rank[k];\n                        cell.setGeneralPurposeVariable(j, k);\n                    }\n                }\n            }\n            if (currentBestCrossings === 0) {\n                // Do nothing further\n                break;\n            }\n        }\n        // Store the best rankings but in the model\n        ranks = [];\n        const rankList = [];\n        for (let i = 0; i < model.maxRank + 1; i += 1) {\n            rankList[i] = [];\n            ranks[i] = rankList[i];\n        }\n        for (let i = 0; i < this.nestedBestRanks.length; i += 1) {\n            for (let j = 0; j < this.nestedBestRanks[i].length; j += 1) {\n                rankList[i].push(this.nestedBestRanks[i][j]);\n            }\n        }\n        model.ranks = ranks;\n    }\n    /**\n     * Calculates the total number of edge crossing in the current graph.\n     * Returns the current number of edge crossings in the hierarchy graph\n     * model in the current candidate layout\n     *\n     * @param model the internal model describing the hierarchy\n     */\n    calculateCrossings(model) {\n        const ranks = model.ranks;\n        const numRanks = ranks.length;\n        let totalCrossings = 0;\n        for (let i = 1; i < numRanks; i += 1) {\n            totalCrossings += this.calculateRankCrossing(i, model);\n        }\n        return totalCrossings;\n    }\n    /**\n     * Calculates the number of edges crossings between the specified rank and\n     * the rank below it. Returns the number of edges crossings with the rank\n     * beneath\n     *\n     * @param i  the topmost rank of the pair ( higher rank value )\n     * @param model the internal model describing the hierarchy\n     */\n    calculateRankCrossing(i, model) {\n        let totalCrossings = 0;\n        const ranks = model.ranks;\n        const rank = ranks[i];\n        const previousRank = ranks[i - 1];\n        const tmpIndices = [];\n        // Iterate over the top rank and fill in the connection information\n        for (let j = 0; j < rank.length; j += 1) {\n            const node = rank[j];\n            const rankPosition = node.getGeneralPurposeVariable(i);\n            const connectedCells = (node.getPreviousLayerConnectedCells(i));\n            const nodeIndices = [];\n            for (let k = 0; k < connectedCells.length; k += 1) {\n                const connectedNode = connectedCells[k];\n                const otherCellRankPosition = (connectedNode.getGeneralPurposeVariable(i - 1));\n                nodeIndices.push(otherCellRankPosition);\n            }\n            nodeIndices.sort((x, y) => {\n                return x - y;\n            });\n            tmpIndices[rankPosition] = nodeIndices;\n        }\n        let indices = [];\n        for (let j = 0; j < tmpIndices.length; j++) {\n            indices = indices.concat(tmpIndices[j]);\n        }\n        let firstIndex = 1;\n        while (firstIndex < previousRank.length) {\n            firstIndex <<= 1;\n        }\n        const treeSize = 2 * firstIndex - 1;\n        firstIndex -= 1;\n        const tree = [];\n        for (let j = 0; j < treeSize; ++j) {\n            tree[j] = 0;\n        }\n        for (let j = 0; j < indices.length; j += 1) {\n            const index = indices[j];\n            let treeIndex = index + firstIndex;\n            ++tree[treeIndex];\n            while (treeIndex > 0) {\n                if (treeIndex % 2) {\n                    totalCrossings += tree[treeIndex + 1];\n                }\n                treeIndex = (treeIndex - 1) >> 1;\n                ++tree[treeIndex];\n            }\n        }\n        return totalCrossings;\n    }\n    /**\n     * Takes each possible adjacent cell pair on each rank and checks if\n     * swapping them around reduces the number of crossing\n     *\n     * @param mainLoopIteration the iteration number of the main loop\n     * @param model the internal model describing the hierarchy\n     */\n    transpose(mainLoopIteration, model) {\n        let improved = true;\n        // Track the number of iterations in case of looping\n        let count = 0;\n        const maxCount = 10;\n        while (improved && count++ < maxCount) {\n            // On certain iterations allow allow swapping of cell pairs with\n            // equal edge crossings switched or not switched. This help to\n            // nudge a stuck layout into a lower crossing total.\n            const nudge = mainLoopIteration % 2 === 1 && count % 2 === 1;\n            improved = false;\n            const ranks = model.ranks;\n            for (let i = 0; i < ranks.length; i += 1) {\n                const rank = ranks[i];\n                const orderedCells = [];\n                for (let j = 0; j < rank.length; j++) {\n                    const cell = rank[j];\n                    let tempRank = cell.getGeneralPurposeVariable(i);\n                    // FIXME: Workaround to avoid negative tempRanks\n                    if (tempRank < 0) {\n                        tempRank = j;\n                    }\n                    orderedCells[tempRank] = cell;\n                }\n                let leftCellAboveConnections = null;\n                let leftCellBelowConnections = null;\n                let rightCellAboveConnections = null;\n                let rightCellBelowConnections = null;\n                let leftAbovePositions = null;\n                let leftBelowPositions = null;\n                let rightAbovePositions = null;\n                let rightBelowPositions = null;\n                let leftCell = null;\n                let rightCell = null;\n                for (let j = 0; j < rank.length - 1; j++) {\n                    // For each intra-rank adjacent pair of cells\n                    // see if swapping them around would reduce the\n                    // number of edges crossing they cause in total\n                    // On every cell pair except the first on each rank, we\n                    // can save processing using the previous values for the\n                    // right cell on the new left cell\n                    if (j === 0) {\n                        leftCell = orderedCells[j];\n                        leftCellAboveConnections = (leftCell.getNextLayerConnectedCells(i));\n                        leftCellBelowConnections = (leftCell.getPreviousLayerConnectedCells(i));\n                        leftAbovePositions = [];\n                        leftBelowPositions = [];\n                        for (let k = 0; k < leftCellAboveConnections.length; k++) {\n                            leftAbovePositions[k] = (leftCellAboveConnections[k].getGeneralPurposeVariable(i + 1));\n                        }\n                        for (let k = 0; k < leftCellBelowConnections.length; k++) {\n                            leftBelowPositions[k] = (leftCellBelowConnections[k].getGeneralPurposeVariable(i - 1));\n                        }\n                    }\n                    else {\n                        leftCellAboveConnections = rightCellAboveConnections;\n                        leftCellBelowConnections = rightCellBelowConnections;\n                        leftAbovePositions = rightAbovePositions;\n                        leftBelowPositions = rightBelowPositions;\n                        leftCell = rightCell;\n                    }\n                    rightCell = orderedCells[j + 1];\n                    rightCellAboveConnections = (rightCell.getNextLayerConnectedCells(i));\n                    rightCellBelowConnections = (rightCell.getPreviousLayerConnectedCells(i));\n                    rightAbovePositions = [];\n                    rightBelowPositions = [];\n                    for (let k = 0; k < rightCellAboveConnections.length; k++) {\n                        rightAbovePositions[k] = (rightCellAboveConnections[k].getGeneralPurposeVariable(i + 1));\n                    }\n                    for (let k = 0; k < rightCellBelowConnections.length; k++) {\n                        rightBelowPositions[k] = (rightCellBelowConnections[k].getGeneralPurposeVariable(i - 1));\n                    }\n                    let totalCurrentCrossings = 0;\n                    let totalSwitchedCrossings = 0;\n                    for (let k = 0; k < leftAbovePositions.length; k += 1) {\n                        for (let ik = 0; ik < rightAbovePositions.length; ik += 1) {\n                            if (leftAbovePositions[k] > rightAbovePositions[ik]) {\n                                totalCurrentCrossings += 1;\n                            }\n                            if (leftAbovePositions[k] < rightAbovePositions[ik]) {\n                                totalSwitchedCrossings += 1;\n                            }\n                        }\n                    }\n                    for (let k = 0; k < leftBelowPositions.length; k += 1) {\n                        for (let ik = 0; ik < rightBelowPositions.length; ik += 1) {\n                            if (leftBelowPositions[k] > rightBelowPositions[ik]) {\n                                totalCurrentCrossings += 1;\n                            }\n                            if (leftBelowPositions[k] < rightBelowPositions[ik]) {\n                                totalSwitchedCrossings += 1;\n                            }\n                        }\n                    }\n                    if (totalSwitchedCrossings < totalCurrentCrossings ||\n                        (totalSwitchedCrossings === totalCurrentCrossings && nudge)) {\n                        const temp = (leftCell.getGeneralPurposeVariable(i));\n                        leftCell.setGeneralPurposeVariable(i, rightCell.getGeneralPurposeVariable(i));\n                        rightCell.setGeneralPurposeVariable(i, temp);\n                        // With this pair exchanged we have to switch all of\n                        // values for the left cell to the right cell so the\n                        // next iteration for this rank uses it as the left\n                        // cell again\n                        rightCellAboveConnections = leftCellAboveConnections;\n                        rightCellBelowConnections = leftCellBelowConnections;\n                        rightAbovePositions = leftAbovePositions;\n                        rightBelowPositions = leftBelowPositions;\n                        rightCell = leftCell;\n                        if (!nudge) {\n                            // Don't count nudges as improvement or we'll end\n                            // up stuck in two combinations and not finishing\n                            // as early as we should\n                            improved = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Sweeps up or down the layout attempting to minimise the median placement\n     * of connected cells on adjacent ranks\n     *\n     * @param iteration the iteration number of the main loop\n     * @param model the internal model describing the hierarchy\n     */\n    weightedMedian(iteration, model) {\n        // Reverse sweep direction each time through this method\n        const downwardSweep = iteration % 2 === 0;\n        if (downwardSweep) {\n            for (let j = model.maxRank - 1; j >= 0; j -= 1) {\n                this.medianRank(j, downwardSweep);\n            }\n        }\n        else {\n            for (let j = 1; j < model.maxRank; j += 1) {\n                this.medianRank(j, downwardSweep);\n            }\n        }\n    }\n    /**\n     * Attempts to minimise the median placement of connected cells on this rank\n     * and one of the adjacent ranks\n     *\n     * @param rankValue the layer number of this rank\n     * @param downwardSweep whether or not this is a downward sweep through the graph\n     */\n    medianRank(rankValue, downwardSweep) {\n        const nestedBestRanks = (this.nestedBestRanks);\n        const numCellsForRank = nestedBestRanks[rankValue].length;\n        const medianValues = [];\n        const reservedPositions = {};\n        for (let i = 0; i < numCellsForRank; i += 1) {\n            const cell = nestedBestRanks[rankValue][i];\n            const sorterEntry = new MedianCellSorter();\n            sorterEntry.cell = cell;\n            // Flip whether or not equal medians are flipped on up and down\n            // sweeps\n            // TODO re-implement some kind of nudge\n            // medianValues[i].nudge = !downwardSweep;\n            const nextLevelConnectedCells = downwardSweep\n                ? cell.getNextLayerConnectedCells(rankValue)\n                : cell.getPreviousLayerConnectedCells(rankValue);\n            const nextRankValue = downwardSweep ? rankValue + 1 : rankValue - 1;\n            if (nextLevelConnectedCells != null && nextLevelConnectedCells.length !== 0) {\n                sorterEntry.medianValue = this.medianValue(nextLevelConnectedCells, nextRankValue);\n                medianValues.push(sorterEntry);\n            }\n            else {\n                // Nodes with no adjacent vertices are flagged in the reserved array\n                // to indicate they should be left in their current position.\n                reservedPositions[cell.getGeneralPurposeVariable(rankValue)] = true;\n            }\n        }\n        medianValues.sort(new MedianCellSorter().compare);\n        // Set the new position of each node within the rank using\n        // its temp variable\n        for (let i = 0; i < numCellsForRank; i += 1) {\n            if (reservedPositions[i] == null) {\n                const cell = (medianValues.shift().cell);\n                cell.setGeneralPurposeVariable(rankValue, i);\n            }\n        }\n    }\n    /**\n     * Calculates the median rank order positioning for the specified cell using\n     * the connected cells on the specified rank. Returns the median rank\n     * ordering value of the connected cells\n     *\n     * @param connectedCells the cells on the specified rank connected to the\n     * specified cell\n     * @param rankValue the rank that the connected cell lie upon\n     */\n    medianValue(connectedCells, rankValue) {\n        const medianValues = [];\n        let arrayCount = 0;\n        for (let i = 0; i < connectedCells.length; i += 1) {\n            const cell = connectedCells[i];\n            medianValues[arrayCount++] = cell.getGeneralPurposeVariable(rankValue);\n        }\n        // Sort() sorts lexicographically by default (i.e. 11 before 9) so force\n        // numerical order sort\n        medianValues.sort((a, b) => {\n            return a - b;\n        });\n        if (arrayCount % 2 === 1) {\n            // For odd numbers of adjacent vertices return the median\n            return medianValues[Math.floor(arrayCount / 2)];\n        }\n        if (arrayCount === 2) {\n            return (medianValues[0] + medianValues[1]) / 2.0;\n        }\n        const medianPoint = arrayCount / 2;\n        const leftMedian = medianValues[medianPoint - 1] - medianValues[0];\n        const rightMedian = medianValues[arrayCount - 1] - medianValues[medianPoint];\n        return ((medianValues[medianPoint - 1] * rightMedian +\n            medianValues[medianPoint] * leftMedian) /\n            (leftMedian + rightMedian));\n    }\n}\nexport default MedianHybridCrossingReduction;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}