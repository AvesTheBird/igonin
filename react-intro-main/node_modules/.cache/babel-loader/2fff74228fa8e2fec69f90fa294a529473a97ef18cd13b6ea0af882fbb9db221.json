{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../geometry/Point';\nimport GraphLayout from './GraphLayout';\nimport { intersects } from '../../util/mathUtils';\n/**\n * Extends {@link GraphLayout} to implement an edge label layout. This layout\n * makes use of cell states, which means the graph must be validated in\n * a graph view (so that the label bounds are available) before this layout\n * can be executed.\n *\n * ```javascript\n * var layout = new mxEdgeLabelLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * ```\n */\nclass EdgeLabelLayout extends GraphLayout {\n  constructor(graph, radius) {\n    super(graph);\n  }\n  /**\n   * Implements {@link GraphLayout.execute}\n   */\n  execute(parent) {\n    const {\n      view\n    } = this.graph;\n    const model = this.graph.getDataModel();\n    // Gets all vertices and edges inside the parent\n    const edges = [];\n    const vertices = [];\n    const childCount = parent.getChildCount();\n    for (let i = 0; i < childCount; i += 1) {\n      const cell = parent.getChildAt(i);\n      const state = view.getState(cell);\n      if (state != null) {\n        if (!this.isVertexIgnored(cell)) {\n          vertices.push(state);\n        } else if (!this.isEdgeIgnored(cell)) {\n          edges.push(state);\n        }\n      }\n    }\n    this.placeLabels(vertices, edges);\n  }\n  /**\n   * Places the labels of the given edges.\n   *\n   * @param v   vertexes\n   * @param e   edges\n   */\n  placeLabels(v, e) {\n    // Moves the vertices to build a circle. Makes sure the\n    // radius is large enough for the vertices to not\n    // overlap\n    this.graph.batchUpdate(() => {\n      for (let i = 0; i < e.length; i += 1) {\n        const edge = e[i];\n        if (edge != null && edge.text != null && edge.text.boundingBox != null) {\n          for (let j = 0; j < v.length; j += 1) {\n            const vertex = v[j];\n            if (vertex != null) {\n              this.avoid(edge, vertex);\n            }\n          }\n        }\n      }\n    });\n  }\n  /**\n   * Places the labels of the given edges.\n   */\n  avoid(edge, vertex) {\n    const model = this.graph.getDataModel();\n    const labRect = edge.text.boundingBox;\n    if (intersects(labRect, vertex)) {\n      const dy1 = -labRect.y - labRect.height + vertex.y;\n      const dy2 = -labRect.y + vertex.y + vertex.height;\n      let dy = Math.abs(dy1) < Math.abs(dy2) ? dy1 : dy2;\n      const dx1 = -labRect.x - labRect.width + vertex.x;\n      const dx2 = -labRect.x + vertex.x + vertex.width;\n      let dx = Math.abs(dx1) < Math.abs(dx2) ? dx1 : dx2;\n      if (Math.abs(dx) < Math.abs(dy)) {\n        dy = 0;\n      } else {\n        dx = 0;\n      }\n      let g = edge.cell.getGeometry();\n      if (g != null) {\n        g = g.clone();\n        if (g.offset != null) {\n          g.offset.x += dx;\n          g.offset.y += dy;\n        } else {\n          g.offset = new Point(dx, dy);\n        }\n        model.setGeometry(edge.cell, g);\n      }\n    }\n  }\n}\nexport default EdgeLabelLayout;","map":{"version":3,"names":["Point","GraphLayout","intersects","EdgeLabelLayout","constructor","graph","radius","execute","parent","view","model","getDataModel","edges","vertices","childCount","getChildCount","i","cell","getChildAt","state","getState","isVertexIgnored","push","isEdgeIgnored","placeLabels","v","e","batchUpdate","length","edge","text","boundingBox","j","vertex","avoid","labRect","dy1","y","height","dy2","dy","Math","abs","dx1","x","width","dx2","dx","g","getGeometry","clone","offset","setGeometry"],"sources":["D:/ospanel/domains/проекты open server/old/react/react-intro-main/node_modules/@maxgraph/core/dist/view/layout/EdgeLabelLayout.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../geometry/Point';\nimport GraphLayout from './GraphLayout';\nimport { intersects } from '../../util/mathUtils';\n/**\n * Extends {@link GraphLayout} to implement an edge label layout. This layout\n * makes use of cell states, which means the graph must be validated in\n * a graph view (so that the label bounds are available) before this layout\n * can be executed.\n *\n * ```javascript\n * var layout = new mxEdgeLabelLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * ```\n */\nclass EdgeLabelLayout extends GraphLayout {\n    constructor(graph, radius) {\n        super(graph);\n    }\n    /**\n     * Implements {@link GraphLayout.execute}\n     */\n    execute(parent) {\n        const { view } = this.graph;\n        const model = this.graph.getDataModel();\n        // Gets all vertices and edges inside the parent\n        const edges = [];\n        const vertices = [];\n        const childCount = parent.getChildCount();\n        for (let i = 0; i < childCount; i += 1) {\n            const cell = parent.getChildAt(i);\n            const state = view.getState(cell);\n            if (state != null) {\n                if (!this.isVertexIgnored(cell)) {\n                    vertices.push(state);\n                }\n                else if (!this.isEdgeIgnored(cell)) {\n                    edges.push(state);\n                }\n            }\n        }\n        this.placeLabels(vertices, edges);\n    }\n    /**\n     * Places the labels of the given edges.\n     *\n     * @param v   vertexes\n     * @param e   edges\n     */\n    placeLabels(v, e) {\n        // Moves the vertices to build a circle. Makes sure the\n        // radius is large enough for the vertices to not\n        // overlap\n        this.graph.batchUpdate(() => {\n            for (let i = 0; i < e.length; i += 1) {\n                const edge = e[i];\n                if (edge != null && edge.text != null && edge.text.boundingBox != null) {\n                    for (let j = 0; j < v.length; j += 1) {\n                        const vertex = v[j];\n                        if (vertex != null) {\n                            this.avoid(edge, vertex);\n                        }\n                    }\n                }\n            }\n        });\n    }\n    /**\n     * Places the labels of the given edges.\n     */\n    avoid(edge, vertex) {\n        const model = this.graph.getDataModel();\n        const labRect = edge.text.boundingBox;\n        if (intersects(labRect, vertex)) {\n            const dy1 = -labRect.y - labRect.height + vertex.y;\n            const dy2 = -labRect.y + vertex.y + vertex.height;\n            let dy = Math.abs(dy1) < Math.abs(dy2) ? dy1 : dy2;\n            const dx1 = -labRect.x - labRect.width + vertex.x;\n            const dx2 = -labRect.x + vertex.x + vertex.width;\n            let dx = Math.abs(dx1) < Math.abs(dx2) ? dx1 : dx2;\n            if (Math.abs(dx) < Math.abs(dy)) {\n                dy = 0;\n            }\n            else {\n                dx = 0;\n            }\n            let g = edge.cell.getGeometry();\n            if (g != null) {\n                g = g.clone();\n                if (g.offset != null) {\n                    g.offset.x += dx;\n                    g.offset.y += dy;\n                }\n                else {\n                    g.offset = new Point(dx, dy);\n                }\n                model.setGeometry(edge.cell, g);\n            }\n        }\n    }\n}\nexport default EdgeLabelLayout;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}