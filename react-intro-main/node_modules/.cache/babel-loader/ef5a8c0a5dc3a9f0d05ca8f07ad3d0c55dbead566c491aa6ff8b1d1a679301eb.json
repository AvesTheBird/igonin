{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Client from '../Client';\nimport EventSource from '../view/event/EventSource';\nimport SelectionChange from './undoable_changes/SelectionChange';\nimport UndoableEdit from './undoable_changes/UndoableEdit';\nimport EventObject from './event/EventObject';\nimport InternalEvent from './event/InternalEvent';\n/**\n * Class: mxGraphSelectionModel\n *\n * Implements the selection model for a graph. Here is a listener that handles\n * all removed selection cells.\n *\n * (code)\n * graph.getSelectionModel().addListener(mxEvent.CHANGE, function(sender, evt)\n * {\n *   var cells = evt.getProperty('added');\n *\n *   for (var i = 0; i < cells.length; i++)\n *   {\n *     // Handle cells[i]...\n *   }\n * });\n * (end)\n *\n * Event: mxEvent.UNDO\n *\n * Fires after the selection was changed in <changeSelection>. The\n * <code>edit</code> property contains the {@link UndoableEdit} which contains the\n * {@link SelectionChange}.\n *\n * Event: mxEvent.CHANGE\n *\n * Fires after the selection changes by executing an {@link SelectionChange}. The\n * <code>added</code> and <code>removed</code> properties contain arrays of\n * cells that have been added to or removed from the selection, respectively.\n * The names are inverted due to historic reasons. This cannot be changed.\n *\n * Constructor: mxGraphSelectionModel\n *\n * Constructs a new graph selection model for the given {@link Graph}.\n *\n * Parameters:\n *\n * graph - Reference to the enclosing {@link Graph}.\n */\nclass GraphSelectionModel extends EventSource {\n  constructor(graph) {\n    super();\n    /**\n     * Specifies the resource key for the status message after a long operation.\n     * If the resource for this key does not exist then the value is used as\n     * the status message. Default is 'done'.\n     */\n    this.doneResource = Client.language !== 'none' ? 'done' : '';\n    /**\n     * Specifies the resource key for the status message while the selection is\n     * being updated. If the resource for this key does not exist then the\n     * value is used as the status message. Default is 'updatingSelection'.\n     */\n    this.updatingSelectionResource = Client.language !== 'none' ? 'updatingSelection' : '';\n    /**\n     * Specifies if only one selected item at a time is allowed.\n     * Default is false.\n     */\n    this.singleSelection = false;\n    this.graph = graph;\n    this.cells = [];\n  }\n  /**\n   * Returns {@link singleSelection} as a boolean.\n   */\n  isSingleSelection() {\n    return this.singleSelection;\n  }\n  /**\n   * Sets the {@link singleSelection} flag.\n   *\n   * @param {boolean} singleSelection Boolean that specifies the new value for\n   * {@link singleSelection}.\n   */\n  setSingleSelection(singleSelection) {\n    this.singleSelection = singleSelection;\n  }\n  /**\n   * Returns true if the given {@link Cell} is selected.\n   */\n  isSelected(cell) {\n    return this.cells.indexOf(cell) >= 0;\n  }\n  /**\n   * Returns true if no cells are currently selected.\n   */\n  isEmpty() {\n    return this.cells.length === 0;\n  }\n  /**\n   * Clears the selection and fires a {@link change} event if the selection was not\n   * empty.\n   */\n  clear() {\n    this.changeSelection(null, this.cells);\n  }\n  /**\n   * Selects the specified {@link Cell} using {@link setCells}.\n   *\n   * @param cell {@link mxCell} to be selected.\n   */\n  setCell(cell) {\n    this.setCells(cell ? [cell] : []);\n  }\n  /**\n   * Selects the given array of {@link Cell} and fires a {@link change} event.\n   *\n   * @param cells Array of {@link Cell} to be selected.\n   */\n  setCells(cells) {\n    if (this.singleSelection) {\n      cells = [this.getFirstSelectableCell(cells)];\n    }\n    const tmp = [];\n    for (let i = 0; i < cells.length; i += 1) {\n      if (this.graph.isCellSelectable(cells[i])) {\n        tmp.push(cells[i]);\n      }\n    }\n    this.changeSelection(tmp, this.cells);\n  }\n  /**\n   * Returns the first selectable cell in the given array of cells.\n   */\n  getFirstSelectableCell(cells) {\n    for (let i = 0; i < cells.length; i += 1) {\n      if (this.graph.isCellSelectable(cells[i])) {\n        return cells[i];\n      }\n    }\n    return null;\n  }\n  /**\n   * Adds the given {@link Cell} to the selection and fires a {@link select} event.\n   *\n   * @param cell {@link mxCell} to add to the selection.\n   */\n  addCell(cell) {\n    this.addCells([cell]);\n  }\n  /**\n   * Adds the given array of {@link Cell} to the selection and fires a {@link select}\n   * event.\n   *\n   * @param cells Array of {@link Cell} to add to the selection.\n   */\n  addCells(cells) {\n    let remove = null;\n    if (this.singleSelection) {\n      remove = this.cells;\n      const selectableCell = this.getFirstSelectableCell(cells);\n      cells = selectableCell ? [selectableCell] : [];\n    }\n    const tmp = [];\n    for (let i = 0; i < cells.length; i += 1) {\n      if (!this.isSelected(cells[i]) && this.graph.isCellSelectable(cells[i])) {\n        tmp.push(cells[i]);\n      }\n    }\n    this.changeSelection(tmp, remove);\n  }\n  /**\n   * Removes the specified {@link Cell} from the selection and fires a {@link select}\n   * event for the remaining cells.\n   *\n   * @param cell {@link mxCell} to remove from the selection.\n   */\n  removeCell(cell) {\n    this.removeCells([cell]);\n  }\n  /**\n   * Removes the specified {@link Cell} from the selection and fires a {@link select}\n   * event for the remaining cells.\n   *\n   * @param cells {@link mxCell}s to remove from the selection.\n   */\n  removeCells(cells) {\n    const tmp = [];\n    for (let i = 0; i < cells.length; i += 1) {\n      if (this.isSelected(cells[i])) {\n        tmp.push(cells[i]);\n      }\n    }\n    this.changeSelection(null, tmp);\n  }\n  /**\n   * Adds/removes the specified arrays of {@link Cell} to/from the selection.\n   *\n   * @param added Array of {@link Cell} to add to the selection.\n   * @param remove Array of {@link Cell} to remove from the selection.\n   */\n  changeSelection() {\n    let added = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let removed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (added && added.length > 0 && added[0] || removed && removed.length > 0 && removed[0]) {\n      const change = new SelectionChange(this.graph, added || [], removed || []);\n      change.execute();\n      const edit = new UndoableEdit(this.graph, false);\n      edit.add(change);\n      this.fireEvent(new EventObject(InternalEvent.UNDO, {\n        edit\n      }));\n    }\n  }\n  /**\n   * Inner callback to add the specified {@link Cell} to the selection. No event\n   * is fired in this implementation.\n   *\n   * Paramters:\n   *\n   * @param cell {@link mxCell} to add to the selection.\n   */\n  cellAdded(cell) {\n    if (!this.isSelected(cell)) {\n      this.cells.push(cell);\n    }\n  }\n  /**\n   * Inner callback to remove the specified {@link Cell} from the selection. No\n   * event is fired in this implementation.\n   *\n   * @param cell {@link mxCell} to remove from the selection.\n   */\n  cellRemoved(cell) {\n    const index = this.cells.indexOf(cell);\n    if (index >= 0) {\n      this.cells.splice(index, 1);\n    }\n  }\n}\nexport default GraphSelectionModel;","map":{"version":3,"names":["Client","EventSource","SelectionChange","UndoableEdit","EventObject","InternalEvent","GraphSelectionModel","constructor","graph","doneResource","language","updatingSelectionResource","singleSelection","cells","isSingleSelection","setSingleSelection","isSelected","cell","indexOf","isEmpty","length","clear","changeSelection","setCell","setCells","getFirstSelectableCell","tmp","i","isCellSelectable","push","addCell","addCells","remove","selectableCell","removeCell","removeCells","added","arguments","undefined","removed","change","execute","edit","add","fireEvent","UNDO","cellAdded","cellRemoved","index","splice"],"sources":["D:/ospanel/domains/проекты open server/old/react/react-intro-main/node_modules/@maxgraph/core/dist/view/GraphSelectionModel.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Client from '../Client';\nimport EventSource from '../view/event/EventSource';\nimport SelectionChange from './undoable_changes/SelectionChange';\nimport UndoableEdit from './undoable_changes/UndoableEdit';\nimport EventObject from './event/EventObject';\nimport InternalEvent from './event/InternalEvent';\n/**\n * Class: mxGraphSelectionModel\n *\n * Implements the selection model for a graph. Here is a listener that handles\n * all removed selection cells.\n *\n * (code)\n * graph.getSelectionModel().addListener(mxEvent.CHANGE, function(sender, evt)\n * {\n *   var cells = evt.getProperty('added');\n *\n *   for (var i = 0; i < cells.length; i++)\n *   {\n *     // Handle cells[i]...\n *   }\n * });\n * (end)\n *\n * Event: mxEvent.UNDO\n *\n * Fires after the selection was changed in <changeSelection>. The\n * <code>edit</code> property contains the {@link UndoableEdit} which contains the\n * {@link SelectionChange}.\n *\n * Event: mxEvent.CHANGE\n *\n * Fires after the selection changes by executing an {@link SelectionChange}. The\n * <code>added</code> and <code>removed</code> properties contain arrays of\n * cells that have been added to or removed from the selection, respectively.\n * The names are inverted due to historic reasons. This cannot be changed.\n *\n * Constructor: mxGraphSelectionModel\n *\n * Constructs a new graph selection model for the given {@link Graph}.\n *\n * Parameters:\n *\n * graph - Reference to the enclosing {@link Graph}.\n */\nclass GraphSelectionModel extends EventSource {\n    constructor(graph) {\n        super();\n        /**\n         * Specifies the resource key for the status message after a long operation.\n         * If the resource for this key does not exist then the value is used as\n         * the status message. Default is 'done'.\n         */\n        this.doneResource = Client.language !== 'none' ? 'done' : '';\n        /**\n         * Specifies the resource key for the status message while the selection is\n         * being updated. If the resource for this key does not exist then the\n         * value is used as the status message. Default is 'updatingSelection'.\n         */\n        this.updatingSelectionResource = Client.language !== 'none' ? 'updatingSelection' : '';\n        /**\n         * Specifies if only one selected item at a time is allowed.\n         * Default is false.\n         */\n        this.singleSelection = false;\n        this.graph = graph;\n        this.cells = [];\n    }\n    /**\n     * Returns {@link singleSelection} as a boolean.\n     */\n    isSingleSelection() {\n        return this.singleSelection;\n    }\n    /**\n     * Sets the {@link singleSelection} flag.\n     *\n     * @param {boolean} singleSelection Boolean that specifies the new value for\n     * {@link singleSelection}.\n     */\n    setSingleSelection(singleSelection) {\n        this.singleSelection = singleSelection;\n    }\n    /**\n     * Returns true if the given {@link Cell} is selected.\n     */\n    isSelected(cell) {\n        return this.cells.indexOf(cell) >= 0;\n    }\n    /**\n     * Returns true if no cells are currently selected.\n     */\n    isEmpty() {\n        return this.cells.length === 0;\n    }\n    /**\n     * Clears the selection and fires a {@link change} event if the selection was not\n     * empty.\n     */\n    clear() {\n        this.changeSelection(null, this.cells);\n    }\n    /**\n     * Selects the specified {@link Cell} using {@link setCells}.\n     *\n     * @param cell {@link mxCell} to be selected.\n     */\n    setCell(cell) {\n        this.setCells(cell ? [cell] : []);\n    }\n    /**\n     * Selects the given array of {@link Cell} and fires a {@link change} event.\n     *\n     * @param cells Array of {@link Cell} to be selected.\n     */\n    setCells(cells) {\n        if (this.singleSelection) {\n            cells = [this.getFirstSelectableCell(cells)];\n        }\n        const tmp = [];\n        for (let i = 0; i < cells.length; i += 1) {\n            if (this.graph.isCellSelectable(cells[i])) {\n                tmp.push(cells[i]);\n            }\n        }\n        this.changeSelection(tmp, this.cells);\n    }\n    /**\n     * Returns the first selectable cell in the given array of cells.\n     */\n    getFirstSelectableCell(cells) {\n        for (let i = 0; i < cells.length; i += 1) {\n            if (this.graph.isCellSelectable(cells[i])) {\n                return cells[i];\n            }\n        }\n        return null;\n    }\n    /**\n     * Adds the given {@link Cell} to the selection and fires a {@link select} event.\n     *\n     * @param cell {@link mxCell} to add to the selection.\n     */\n    addCell(cell) {\n        this.addCells([cell]);\n    }\n    /**\n     * Adds the given array of {@link Cell} to the selection and fires a {@link select}\n     * event.\n     *\n     * @param cells Array of {@link Cell} to add to the selection.\n     */\n    addCells(cells) {\n        let remove = null;\n        if (this.singleSelection) {\n            remove = this.cells;\n            const selectableCell = this.getFirstSelectableCell(cells);\n            cells = selectableCell ? [selectableCell] : [];\n        }\n        const tmp = [];\n        for (let i = 0; i < cells.length; i += 1) {\n            if (!this.isSelected(cells[i]) && this.graph.isCellSelectable(cells[i])) {\n                tmp.push(cells[i]);\n            }\n        }\n        this.changeSelection(tmp, remove);\n    }\n    /**\n     * Removes the specified {@link Cell} from the selection and fires a {@link select}\n     * event for the remaining cells.\n     *\n     * @param cell {@link mxCell} to remove from the selection.\n     */\n    removeCell(cell) {\n        this.removeCells([cell]);\n    }\n    /**\n     * Removes the specified {@link Cell} from the selection and fires a {@link select}\n     * event for the remaining cells.\n     *\n     * @param cells {@link mxCell}s to remove from the selection.\n     */\n    removeCells(cells) {\n        const tmp = [];\n        for (let i = 0; i < cells.length; i += 1) {\n            if (this.isSelected(cells[i])) {\n                tmp.push(cells[i]);\n            }\n        }\n        this.changeSelection(null, tmp);\n    }\n    /**\n     * Adds/removes the specified arrays of {@link Cell} to/from the selection.\n     *\n     * @param added Array of {@link Cell} to add to the selection.\n     * @param remove Array of {@link Cell} to remove from the selection.\n     */\n    changeSelection(added = null, removed = null) {\n        if ((added && added.length > 0 && added[0]) ||\n            (removed && removed.length > 0 && removed[0])) {\n            const change = new SelectionChange(this.graph, added || [], removed || []);\n            change.execute();\n            const edit = new UndoableEdit(this.graph, false);\n            edit.add(change);\n            this.fireEvent(new EventObject(InternalEvent.UNDO, { edit }));\n        }\n    }\n    /**\n     * Inner callback to add the specified {@link Cell} to the selection. No event\n     * is fired in this implementation.\n     *\n     * Paramters:\n     *\n     * @param cell {@link mxCell} to add to the selection.\n     */\n    cellAdded(cell) {\n        if (!this.isSelected(cell)) {\n            this.cells.push(cell);\n        }\n    }\n    /**\n     * Inner callback to remove the specified {@link Cell} from the selection. No\n     * event is fired in this implementation.\n     *\n     * @param cell {@link mxCell} to remove from the selection.\n     */\n    cellRemoved(cell) {\n        const index = this.cells.indexOf(cell);\n        if (index >= 0) {\n            this.cells.splice(index, 1);\n        }\n    }\n}\nexport default GraphSelectionModel;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}