{"ast":null,"code":"'use strict';\n\nconst parseWaveLane = require('./parse-wave-lane.js');\nfunction data_extract(e, num_unseen_markers) {\n  let ret_data = e.data;\n  if (ret_data === undefined) {\n    return null;\n  }\n  if (typeof ret_data === 'string') {\n    ret_data = ret_data.trim().split(/\\s+/);\n  }\n  // slice data array after unseen markers\n  ret_data = ret_data.slice(num_unseen_markers);\n  return ret_data;\n}\nfunction parseWaveLanes(sig, lane) {\n  const content = [];\n  const tmp0 = [];\n  sig.map(function (sigx) {\n    const current = [];\n    content.push(current);\n    lane.period = sigx.period || 1;\n    // xmin_cfg is min. brick of hbounds, add to lane.phase of all signals\n    lane.phase = (sigx.phase ? sigx.phase * 2 : 0) + lane.xmin_cfg;\n    tmp0[0] = sigx.name || ' ';\n    // xmin_cfg is min. brick of hbounds, add 1/2 to sigx.phase of all sigs\n    tmp0[1] = (sigx.phase || 0) + lane.xmin_cfg / 2;\n    let content_wave = null;\n    let num_unseen_markers;\n    if (typeof sigx.wave === 'string') {\n      const parsed_wave_lane = parseWaveLane(sigx.wave, lane.period * lane.hscale - 1, lane);\n      content_wave = parsed_wave_lane[0];\n      num_unseen_markers = parsed_wave_lane[1];\n    }\n    current.push(tmp0.slice(0), content_wave, data_extract(sigx, num_unseen_markers), sigx);\n  });\n  // content is an array of arrays, representing the list of signals using\n  //  the same order:\n  // content[0] = [ [name,phase], parsedwavelaneobj, dataextracted ]\n  return content;\n}\nmodule.exports = parseWaveLanes;","map":{"version":3,"names":["parseWaveLane","require","data_extract","e","num_unseen_markers","ret_data","data","undefined","trim","split","slice","parseWaveLanes","sig","lane","content","tmp0","map","sigx","current","push","period","phase","xmin_cfg","name","content_wave","wave","parsed_wave_lane","hscale","module","exports"],"sources":["D:/ospanel/domains/react/react-intro-main/node_modules/wavedrom/lib/parse-wave-lanes.js"],"sourcesContent":["'use strict';\n\nconst parseWaveLane = require('./parse-wave-lane.js');\n\nfunction data_extract (e, num_unseen_markers) {\n    let ret_data = e.data;\n    if (ret_data === undefined) { return null; }\n    if (typeof (ret_data) === 'string') {\n        ret_data = ret_data.trim().split(/\\s+/);\n    }\n    // slice data array after unseen markers\n    ret_data = ret_data.slice( num_unseen_markers );\n    return ret_data;\n}\n\nfunction parseWaveLanes (sig, lane) {\n    const content = [];\n    const tmp0 = [];\n\n    sig.map(function (sigx) {\n        const current = [];\n        content.push(current);\n\n        lane.period = sigx.period || 1;\n        // xmin_cfg is min. brick of hbounds, add to lane.phase of all signals\n        lane.phase = (sigx.phase ? sigx.phase * 2 : 0) + lane.xmin_cfg;\n        tmp0[0] = sigx.name || ' ';\n        // xmin_cfg is min. brick of hbounds, add 1/2 to sigx.phase of all sigs\n        tmp0[1] = (sigx.phase || 0) + lane.xmin_cfg/2;\n\n        let content_wave = null;\n        let num_unseen_markers;\n        if (typeof sigx.wave === 'string') {\n            const parsed_wave_lane = parseWaveLane(sigx.wave, lane.period * lane.hscale - 1, lane);\n            content_wave = parsed_wave_lane[0] ;\n            num_unseen_markers = parsed_wave_lane[1];\n        }\n        current.push(\n            tmp0.slice(0),\n            content_wave,\n            data_extract(sigx, num_unseen_markers),\n            sigx\n        );\n    });\n    // content is an array of arrays, representing the list of signals using\n    //  the same order:\n    // content[0] = [ [name,phase], parsedwavelaneobj, dataextracted ]\n    return content;\n}\n\nmodule.exports = parseWaveLanes;\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,aAAa,GAAGC,OAAO,CAAC,sBAAsB,CAAC;AAErD,SAASC,YAAYA,CAAEC,CAAC,EAAEC,kBAAkB,EAAE;EAC1C,IAAIC,QAAQ,GAAGF,CAAC,CAACG,IAAI;EACrB,IAAID,QAAQ,KAAKE,SAAS,EAAE;IAAE,OAAO,IAAI;EAAE;EAC3C,IAAI,OAAQF,QAAS,KAAK,QAAQ,EAAE;IAChCA,QAAQ,GAAGA,QAAQ,CAACG,IAAI,CAAC,CAAC,CAACC,KAAK,CAAC,KAAK,CAAC;EAC3C;EACA;EACAJ,QAAQ,GAAGA,QAAQ,CAACK,KAAK,CAAEN,kBAAmB,CAAC;EAC/C,OAAOC,QAAQ;AACnB;AAEA,SAASM,cAAcA,CAAEC,GAAG,EAAEC,IAAI,EAAE;EAChC,MAAMC,OAAO,GAAG,EAAE;EAClB,MAAMC,IAAI,GAAG,EAAE;EAEfH,GAAG,CAACI,GAAG,CAAC,UAAUC,IAAI,EAAE;IACpB,MAAMC,OAAO,GAAG,EAAE;IAClBJ,OAAO,CAACK,IAAI,CAACD,OAAO,CAAC;IAErBL,IAAI,CAACO,MAAM,GAAGH,IAAI,CAACG,MAAM,IAAI,CAAC;IAC9B;IACAP,IAAI,CAACQ,KAAK,GAAG,CAACJ,IAAI,CAACI,KAAK,GAAGJ,IAAI,CAACI,KAAK,GAAG,CAAC,GAAG,CAAC,IAAIR,IAAI,CAACS,QAAQ;IAC9DP,IAAI,CAAC,CAAC,CAAC,GAAGE,IAAI,CAACM,IAAI,IAAI,GAAG;IAC1B;IACAR,IAAI,CAAC,CAAC,CAAC,GAAG,CAACE,IAAI,CAACI,KAAK,IAAI,CAAC,IAAIR,IAAI,CAACS,QAAQ,GAAC,CAAC;IAE7C,IAAIE,YAAY,GAAG,IAAI;IACvB,IAAIpB,kBAAkB;IACtB,IAAI,OAAOa,IAAI,CAACQ,IAAI,KAAK,QAAQ,EAAE;MAC/B,MAAMC,gBAAgB,GAAG1B,aAAa,CAACiB,IAAI,CAACQ,IAAI,EAAEZ,IAAI,CAACO,MAAM,GAAGP,IAAI,CAACc,MAAM,GAAG,CAAC,EAAEd,IAAI,CAAC;MACtFW,YAAY,GAAGE,gBAAgB,CAAC,CAAC,CAAC;MAClCtB,kBAAkB,GAAGsB,gBAAgB,CAAC,CAAC,CAAC;IAC5C;IACAR,OAAO,CAACC,IAAI,CACRJ,IAAI,CAACL,KAAK,CAAC,CAAC,CAAC,EACbc,YAAY,EACZtB,YAAY,CAACe,IAAI,EAAEb,kBAAkB,CAAC,EACtCa,IACJ,CAAC;EACL,CAAC,CAAC;EACF;EACA;EACA;EACA,OAAOH,OAAO;AAClB;AAEAc,MAAM,CAACC,OAAO,GAAGlB,cAAc","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}