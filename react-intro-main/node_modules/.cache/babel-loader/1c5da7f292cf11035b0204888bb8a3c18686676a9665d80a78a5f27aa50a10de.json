{"ast":null,"code":"/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Client from '../Client';\nimport { ALIGN, DEFAULT_FONTFAMILY, DEFAULT_FONTSIZE, FONT, LINE_HEIGHT } from './Constants';\nimport Point from '../view/geometry/Point';\nimport Dictionary from './Dictionary';\nimport CellPath from '../view/cell/CellPath';\nimport Rectangle from '../view/geometry/Rectangle';\n/**\n * Removes the cursors from the style of the given DOM node and its\n * descendants.\n *\n * @param element DOM node to remove the cursor style from.\n */\nexport const removeCursors = element => {\n  if (element.style) {\n    element.style.cursor = '';\n  }\n  const children = element.children;\n  if (children) {\n    const childCount = children.length;\n    for (let i = 0; i < childCount; i += 1) {\n      removeCursors(children[i]);\n    }\n  }\n};\n/**\n * Returns the current style of the specified element.\n *\n * @param element DOM node whose current style should be returned.\n */\nexport const getCurrentStyle = element => {\n  return !element || element.toString() === '[object ShadowRoot]' ? null : window.getComputedStyle(element, '');\n};\n/**\n * Function: parseCssNumber\n *\n * Parses the given CSS numeric value adding handling for the values thin,\n * medium and thick (2, 4 and 6).\n */\nexport const parseCssNumber = value => {\n  if (value === 'thin') {\n    value = '2';\n  } else if (value === 'medium') {\n    value = '4';\n  } else if (value === 'thick') {\n    value = '6';\n  }\n  let n = parseFloat(value);\n  if (Number.isNaN(n)) {\n    n = 0;\n  }\n  return n;\n};\n/**\n * Function: setPrefixedStyle\n *\n * Adds the given style with the standard name and an optional vendor prefix for the current\n * browser.\n *\n * ```javascript\n * mxUtils.setPrefixedStyle(node.style, 'transformOrigin', '0% 0%');\n * ```\n */\nexport const setPrefixedStyle = (style, name, value) => {\n  let prefix = null;\n  if (Client.IS_SF || Client.IS_GC) {\n    prefix = 'Webkit';\n  } else if (Client.IS_MT) {\n    prefix = 'Moz';\n  }\n  style.setProperty(name, value);\n  if (prefix !== null && name.length > 0) {\n    name = prefix + name.substring(0, 1).toUpperCase() + name.substring(1);\n    style.setProperty(name, value);\n  }\n};\n/**\n * Function: hasScrollbars\n *\n * Returns true if the overflow CSS property of the given node is either\n * scroll or auto.\n *\n * @param node DOM node whose style should be checked for scrollbars.\n */\nexport const hasScrollbars = node => {\n  const style = getCurrentStyle(node);\n  return !!style && (style.overflow === 'scroll' || style.overflow === 'auto');\n};\n/**\n * Returns the client size for the current document as an {@link Rectangle}.\n */\nexport const getDocumentSize = () => {\n  const b = document.body;\n  const d = document.documentElement;\n  try {\n    return new Rectangle(0, 0, b.clientWidth ?? d.clientWidth, Math.max(b.clientHeight ?? 0, d.clientHeight));\n  } catch (e) {\n    return new Rectangle();\n  }\n};\n/**\n * Makes sure the given node is inside the visible area of the window. This\n * is done by setting the left and top in the style.\n */\nexport const fit = node => {\n  const ds = getDocumentSize();\n  const left = node.offsetLeft;\n  const width = node.offsetWidth;\n  const offset = getDocumentScrollOrigin(node.ownerDocument);\n  const sl = offset.x;\n  const st = offset.y;\n  const right = sl + ds.width;\n  if (left + width > right) {\n    node.style.left = `${Math.max(sl, right - width)}px`;\n  }\n  const top = node.offsetTop;\n  const height = node.offsetHeight;\n  const bottom = st + ds.height;\n  if (top + height > bottom) {\n    node.style.top = `${Math.max(st, bottom - height)}px`;\n  }\n};\n/**\n * Returns the offset for the specified container as an {@link Point}. The\n * offset is the distance from the top left corner of the container to the\n * top left corner of the document.\n *\n * @param container DOM node to return the offset for.\n * @param scollOffset Optional boolean to add the scroll offset of the document.\n * Default is false.\n */\nexport const getOffset = (container, scrollOffset = false) => {\n  let offsetLeft = 0;\n  let offsetTop = 0;\n  // Ignores document scroll origin for fixed elements\n  let fixed = false;\n  let node = container;\n  const b = document.body;\n  const d = document.documentElement;\n  while (node != null && node != b && node != d && !fixed) {\n    const style = getCurrentStyle(node);\n    if (style != null) {\n      fixed = fixed || style.position == 'fixed';\n    }\n    node = node.parentNode;\n  }\n  if (!scrollOffset && !fixed) {\n    const offset = getDocumentScrollOrigin(container.ownerDocument);\n    offsetLeft += offset.x;\n    offsetTop += offset.y;\n  }\n  const r = container.getBoundingClientRect();\n  if (r != null) {\n    offsetLeft += r.left;\n    offsetTop += r.top;\n  }\n  return new Point(offsetLeft, offsetTop);\n};\n/**\n * Returns the scroll origin of the given document or the current document\n * if no document is given.\n */\nexport const getDocumentScrollOrigin = doc => {\n  // @ts-ignore 'parentWindow' is an unknown property.\n  const wnd = doc.defaultView || doc.parentWindow;\n  const x = wnd != null && window.pageXOffset !== undefined ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;\n  const y = wnd != null && window.pageYOffset !== undefined ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;\n  return new Point(x, y);\n};\n/**\n * Returns the top, left corner of the viewrect as an {@link Point}.\n *\n * @param node DOM node whose scroll origin should be returned.\n * @param includeAncestors Whether the scroll origin of the ancestors should be\n * included. Default is false.\n * @param includeDocument Whether the scroll origin of the document should be\n * included. Default is true.\n */\nexport const getScrollOrigin = (node = null, includeAncestors = false, includeDocument = true) => {\n  const doc = node != null ? node.ownerDocument : document;\n  const b = doc.body;\n  const d = doc.documentElement;\n  const result = new Point();\n  let fixed = false;\n  while (node != null && node != b && node != d) {\n    if (!Number.isNaN(node.scrollLeft) && !Number.isNaN(node.scrollTop)) {\n      result.x += node.scrollLeft;\n      result.y += node.scrollTop;\n    }\n    const style = getCurrentStyle(node);\n    if (style != null) {\n      fixed = fixed || style.position == 'fixed';\n    }\n    node = includeAncestors ? node.parentNode : null;\n  }\n  if (!fixed && includeDocument) {\n    const origin = getDocumentScrollOrigin(doc);\n    result.x += origin.x;\n    result.y += origin.y;\n  }\n  return result;\n};\n/**\n * Converts the specified point (x, y) using the offset of the specified\n * container and returns a new {@link Point} with the result.\n *\n * ```javascript\n * let pt = mxUtils.convertPoint(graph.container,\n *   mxEvent.getClientX(evt), mxEvent.getClientY(evt));\n * ```\n *\n * @param container DOM node to use for the offset.\n * @param x X-coordinate of the point to be converted.\n * @param y Y-coordinate of the point to be converted.\n */\nexport const convertPoint = (container, x, y) => {\n  const origin = getScrollOrigin(container, false);\n  const offset = getOffset(container);\n  offset.x -= origin.x;\n  offset.y -= origin.y;\n  return new Point(x - offset.x, y - offset.y);\n};\n/**\n * Assigns the value for the given key in the styles of the given cells, or\n * removes the key from the styles if the value is null.\n *\n * @param model <Transactions> to execute the transaction in.\n * @param cells Array of {@link Cells} to be updated.\n * @param key Key of the style to be changed.\n * @param value New value for the given key.\n */\nexport const setCellStyles = (model, cells, key, value) => {\n  if (cells.length > 0) {\n    model.batchUpdate(() => {\n      for (let i = 0; i < cells.length; i += 1) {\n        const cell = cells[i];\n        if (cell) {\n          const style = cell.getStyle();\n          style[key] = value;\n          model.setStyle(cell, style);\n        }\n      }\n    });\n  }\n};\n/**\n * Sets or toggles the flag bit for the given key in the cell's styles.\n * If value is null then the flag is toggled.\n *\n * Example:\n *\n * ```javascript\n * let cells = graph.getSelectionCells();\n * mxUtils.setCellStyleFlags(graph.model,\n *       cells,\n *       mxConstants.STYLE_FONTSTYLE,\n *       mxConstants.FONT_BOLD);\n * ```\n *\n * Toggles the bold font style.\n *\n * @param model <Transactions> that contains the cells.\n * @param cells Array of {@link Cells} to change the style for.\n * @param key Key of the style to be changed.\n * @param flag Integer for the bit to be changed.\n * @param value Optional boolean value for the flag.\n */\nexport const setCellStyleFlags = (model, cells, key, flag, value) => {\n  if (cells.length > 0) {\n    model.batchUpdate(() => {\n      for (let i = 0; i < cells.length; i += 1) {\n        const cell = cells[i];\n        if (cell) {\n          const style = setStyleFlag(cell.getStyle(), key, flag, value);\n          model.setStyle(cell, style);\n        }\n      }\n    });\n  }\n};\n/**\n * Sets or removes the given key from the specified style and returns the\n * new style. If value is null then the flag is toggled.\n *\n * @param style The style of the Cell.\n * @param key Key of the style to be changed.\n * @param flag Integer for the bit to be changed.\n * @param value Optional boolean value for the given flag.\n */\nexport const setStyleFlag = (style, key, flag, value) => {\n  const v = style[key];\n  if (v === undefined) {\n    style[key] = value === undefined ? flag : 0;\n  } else {\n    if (value === undefined) {\n      style[key] = v ^ flag;\n    } else if (value) {\n      style[key] = v | flag;\n    } else {\n      style[key] = v & ~flag;\n    }\n  }\n  return style;\n};\n/**\n * Sets the opacity of the specified DOM node to the given value in %.\n *\n * @param node DOM node to set the opacity for.\n * @param value Opacity in %. Possible values are between 0 and 100.\n */\nexport const setOpacity = (node, value) => {\n  node.style.opacity = String(value / 100);\n};\n/**\n * @param value the value to check.\n * @param mask the binary mask to apply.\n * @returns `true` if the value matches the binary mask.\n * @private Subject to change prior being part of the public API.\n */\nexport const matchBinaryMask = (value, mask) => {\n  return (value & mask) === mask;\n};\n/**\n * Returns an {@link Rectangle} with the size (width and height in pixels) of\n * the given string. The string may contain HTML markup. Newlines should be\n * converted to <br> before calling this method. The caller is responsible\n * for sanitizing the HTML markup.\n *\n * Example:\n *\n * ```javascript\n * let label = graph.getLabel(cell).replace(/\\n/g, \"<br>\");\n * let size = graph.getSizeForString(label);\n * ```\n *\n * @param text String whose size should be returned.\n * @param fontSize Integer that specifies the font size in pixels. Default is\n * {@link Constants#DEFAULT_FONTSIZE}.\n * @param fontFamily String that specifies the name of the font family. Default\n * is {@link Constants#DEFAULT_FONTFAMILY}.\n * @param textWidth Optional width for text wrapping.\n * @param fontStyle Optional font style.\n */\nexport const getSizeForString = (text, fontSize = DEFAULT_FONTSIZE, fontFamily = DEFAULT_FONTFAMILY, textWidth = null, fontStyle = null) => {\n  const div = document.createElement('div');\n  // Sets the font size and family\n  div.style.fontFamily = fontFamily;\n  div.style.fontSize = `${Math.round(fontSize)}px`;\n  div.style.lineHeight = `${Math.round(fontSize * LINE_HEIGHT)}px`;\n  // Sets the font style\n  if (fontStyle !== null) {\n    matchBinaryMask(fontStyle, FONT.BOLD) && (div.style.fontWeight = 'bold');\n    matchBinaryMask(fontStyle, FONT.ITALIC) && (div.style.fontWeight = 'italic');\n    const txtDecor = [];\n    matchBinaryMask(fontStyle, FONT.UNDERLINE) && txtDecor.push('underline');\n    matchBinaryMask(fontStyle, FONT.STRIKETHROUGH) && txtDecor.push('line-through');\n    txtDecor.length > 0 && (div.style.textDecoration = txtDecor.join(' '));\n  }\n  // Disables block layout and outside wrapping and hides the div\n  div.style.position = 'absolute';\n  div.style.visibility = 'hidden';\n  div.style.display = 'inline-block';\n  if (textWidth !== null) {\n    div.style.width = `${textWidth}px`;\n    div.style.whiteSpace = 'normal';\n  } else {\n    div.style.whiteSpace = 'nowrap';\n  }\n  // Adds the text and inserts into DOM for updating of size\n  div.innerHTML = text;\n  document.body.appendChild(div);\n  // Gets the size and removes from DOM\n  const size = new Rectangle(0, 0, div.offsetWidth, div.offsetHeight);\n  document.body.removeChild(div);\n  return size;\n};\n/**\n * Sorts the given cells according to the order in the cell hierarchy.\n * Ascending is optional and defaults to true.\n */\nexport const sortCells = (cells, ascending = true) => {\n  const lookup = new Dictionary();\n  cells.sort((o1, o2) => {\n    let p1 = lookup.get(o1);\n    if (p1 == null) {\n      p1 = CellPath.create(o1).split(CellPath.PATH_SEPARATOR);\n      lookup.put(o1, p1);\n    }\n    let p2 = lookup.get(o2);\n    if (p2 == null) {\n      p2 = CellPath.create(o2).split(CellPath.PATH_SEPARATOR);\n      lookup.put(o2, p2);\n    }\n    const comp = CellPath.compare(p1, p2);\n    return comp == 0 ? 0 : comp > 0 == ascending ? 1 : -1;\n  });\n  return cells;\n};\n/**\n * Returns an {@link Point} that represents the horizontal and vertical alignment\n * for numeric computations. X is -0.5 for center, -1 for right and 0 for\n * left alignment. Y is -0.5 for middle, -1 for bottom and 0 for top\n * alignment. Default values for missing arguments is top, left.\n */\nexport const getAlignmentAsPoint = (align, valign) => {\n  let dx = -0.5;\n  let dy = -0.5;\n  // Horizontal alignment\n  if (align === ALIGN.LEFT) {\n    dx = 0;\n  } else if (align === ALIGN.RIGHT) {\n    dx = -1;\n  }\n  // Vertical alignment\n  if (valign === ALIGN.TOP) {\n    dy = 0;\n  } else if (valign === ALIGN.BOTTOM) {\n    dy = -1;\n  }\n  return new Point(dx, dy);\n};","map":{"version":3,"names":["Client","ALIGN","DEFAULT_FONTFAMILY","DEFAULT_FONTSIZE","FONT","LINE_HEIGHT","Point","Dictionary","CellPath","Rectangle","removeCursors","element","style","cursor","children","childCount","length","i","getCurrentStyle","toString","window","getComputedStyle","parseCssNumber","value","n","parseFloat","Number","isNaN","setPrefixedStyle","name","prefix","IS_SF","IS_GC","IS_MT","setProperty","substring","toUpperCase","hasScrollbars","node","overflow","getDocumentSize","b","document","body","d","documentElement","clientWidth","Math","max","clientHeight","e","fit","ds","left","offsetLeft","width","offsetWidth","offset","getDocumentScrollOrigin","ownerDocument","sl","x","st","y","right","top","offsetTop","height","offsetHeight","bottom","getOffset","container","scrollOffset","fixed","position","parentNode","r","getBoundingClientRect","doc","wnd","defaultView","parentWindow","pageXOffset","undefined","scrollLeft","pageYOffset","scrollTop","getScrollOrigin","includeAncestors","includeDocument","result","origin","convertPoint","setCellStyles","model","cells","key","batchUpdate","cell","getStyle","setStyle","setCellStyleFlags","flag","setStyleFlag","v","setOpacity","opacity","String","matchBinaryMask","mask","getSizeForString","text","fontSize","fontFamily","textWidth","fontStyle","div","createElement","round","lineHeight","BOLD","fontWeight","ITALIC","txtDecor","UNDERLINE","push","STRIKETHROUGH","textDecoration","join","visibility","display","whiteSpace","innerHTML","appendChild","size","removeChild","sortCells","ascending","lookup","sort","o1","o2","p1","get","create","split","PATH_SEPARATOR","put","p2","comp","compare","getAlignmentAsPoint","align","valign","dx","dy","LEFT","RIGHT","TOP","BOTTOM"],"sources":["D:/ospanel/domains/old/react/react-intro-main/node_modules/@maxgraph/core/dist/util/styleUtils.js"],"sourcesContent":["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Client from '../Client';\nimport { ALIGN, DEFAULT_FONTFAMILY, DEFAULT_FONTSIZE, FONT, LINE_HEIGHT, } from './Constants';\nimport Point from '../view/geometry/Point';\nimport Dictionary from './Dictionary';\nimport CellPath from '../view/cell/CellPath';\nimport Rectangle from '../view/geometry/Rectangle';\n/**\n * Removes the cursors from the style of the given DOM node and its\n * descendants.\n *\n * @param element DOM node to remove the cursor style from.\n */\nexport const removeCursors = (element) => {\n    if (element.style) {\n        element.style.cursor = '';\n    }\n    const children = element.children;\n    if (children) {\n        const childCount = children.length;\n        for (let i = 0; i < childCount; i += 1) {\n            removeCursors(children[i]);\n        }\n    }\n};\n/**\n * Returns the current style of the specified element.\n *\n * @param element DOM node whose current style should be returned.\n */\nexport const getCurrentStyle = (element) => {\n    return !element || element.toString() === '[object ShadowRoot]' ? null : window.getComputedStyle(element, '');\n};\n/**\n * Function: parseCssNumber\n *\n * Parses the given CSS numeric value adding handling for the values thin,\n * medium and thick (2, 4 and 6).\n */\nexport const parseCssNumber = (value) => {\n    if (value === 'thin') {\n        value = '2';\n    }\n    else if (value === 'medium') {\n        value = '4';\n    }\n    else if (value === 'thick') {\n        value = '6';\n    }\n    let n = parseFloat(value);\n    if (Number.isNaN(n)) {\n        n = 0;\n    }\n    return n;\n};\n/**\n * Function: setPrefixedStyle\n *\n * Adds the given style with the standard name and an optional vendor prefix for the current\n * browser.\n *\n * ```javascript\n * mxUtils.setPrefixedStyle(node.style, 'transformOrigin', '0% 0%');\n * ```\n */\nexport const setPrefixedStyle = (style, name, value) => {\n    let prefix = null;\n    if (Client.IS_SF || Client.IS_GC) {\n        prefix = 'Webkit';\n    }\n    else if (Client.IS_MT) {\n        prefix = 'Moz';\n    }\n    style.setProperty(name, value);\n    if (prefix !== null && name.length > 0) {\n        name = prefix + name.substring(0, 1).toUpperCase() + name.substring(1);\n        style.setProperty(name, value);\n    }\n};\n/**\n * Function: hasScrollbars\n *\n * Returns true if the overflow CSS property of the given node is either\n * scroll or auto.\n *\n * @param node DOM node whose style should be checked for scrollbars.\n */\nexport const hasScrollbars = (node) => {\n    const style = getCurrentStyle(node);\n    return !!style && (style.overflow === 'scroll' || style.overflow === 'auto');\n};\n/**\n * Returns the client size for the current document as an {@link Rectangle}.\n */\nexport const getDocumentSize = () => {\n    const b = document.body;\n    const d = document.documentElement;\n    try {\n        return new Rectangle(0, 0, b.clientWidth ?? d.clientWidth, Math.max(b.clientHeight ?? 0, d.clientHeight));\n    }\n    catch (e) {\n        return new Rectangle();\n    }\n};\n/**\n * Makes sure the given node is inside the visible area of the window. This\n * is done by setting the left and top in the style.\n */\nexport const fit = (node) => {\n    const ds = getDocumentSize();\n    const left = node.offsetLeft;\n    const width = node.offsetWidth;\n    const offset = getDocumentScrollOrigin(node.ownerDocument);\n    const sl = offset.x;\n    const st = offset.y;\n    const right = sl + ds.width;\n    if (left + width > right) {\n        node.style.left = `${Math.max(sl, right - width)}px`;\n    }\n    const top = node.offsetTop;\n    const height = node.offsetHeight;\n    const bottom = st + ds.height;\n    if (top + height > bottom) {\n        node.style.top = `${Math.max(st, bottom - height)}px`;\n    }\n};\n/**\n * Returns the offset for the specified container as an {@link Point}. The\n * offset is the distance from the top left corner of the container to the\n * top left corner of the document.\n *\n * @param container DOM node to return the offset for.\n * @param scollOffset Optional boolean to add the scroll offset of the document.\n * Default is false.\n */\nexport const getOffset = (container, scrollOffset = false) => {\n    let offsetLeft = 0;\n    let offsetTop = 0;\n    // Ignores document scroll origin for fixed elements\n    let fixed = false;\n    let node = container;\n    const b = document.body;\n    const d = document.documentElement;\n    while (node != null && node != b && node != d && !fixed) {\n        const style = getCurrentStyle(node);\n        if (style != null) {\n            fixed = fixed || style.position == 'fixed';\n        }\n        node = node.parentNode;\n    }\n    if (!scrollOffset && !fixed) {\n        const offset = getDocumentScrollOrigin(container.ownerDocument);\n        offsetLeft += offset.x;\n        offsetTop += offset.y;\n    }\n    const r = container.getBoundingClientRect();\n    if (r != null) {\n        offsetLeft += r.left;\n        offsetTop += r.top;\n    }\n    return new Point(offsetLeft, offsetTop);\n};\n/**\n * Returns the scroll origin of the given document or the current document\n * if no document is given.\n */\nexport const getDocumentScrollOrigin = (doc) => {\n    // @ts-ignore 'parentWindow' is an unknown property.\n    const wnd = doc.defaultView || doc.parentWindow;\n    const x = wnd != null && window.pageXOffset !== undefined\n        ? window.pageXOffset\n        : (document.documentElement || document.body.parentNode || document.body)\n            .scrollLeft;\n    const y = wnd != null && window.pageYOffset !== undefined\n        ? window.pageYOffset\n        : (document.documentElement || document.body.parentNode || document.body).scrollTop;\n    return new Point(x, y);\n};\n/**\n * Returns the top, left corner of the viewrect as an {@link Point}.\n *\n * @param node DOM node whose scroll origin should be returned.\n * @param includeAncestors Whether the scroll origin of the ancestors should be\n * included. Default is false.\n * @param includeDocument Whether the scroll origin of the document should be\n * included. Default is true.\n */\nexport const getScrollOrigin = (node = null, includeAncestors = false, includeDocument = true) => {\n    const doc = node != null ? node.ownerDocument : document;\n    const b = doc.body;\n    const d = doc.documentElement;\n    const result = new Point();\n    let fixed = false;\n    while (node != null && node != b && node != d) {\n        if (!Number.isNaN(node.scrollLeft) && !Number.isNaN(node.scrollTop)) {\n            result.x += node.scrollLeft;\n            result.y += node.scrollTop;\n        }\n        const style = getCurrentStyle(node);\n        if (style != null) {\n            fixed = fixed || style.position == 'fixed';\n        }\n        node = includeAncestors ? node.parentNode : null;\n    }\n    if (!fixed && includeDocument) {\n        const origin = getDocumentScrollOrigin(doc);\n        result.x += origin.x;\n        result.y += origin.y;\n    }\n    return result;\n};\n/**\n * Converts the specified point (x, y) using the offset of the specified\n * container and returns a new {@link Point} with the result.\n *\n * ```javascript\n * let pt = mxUtils.convertPoint(graph.container,\n *   mxEvent.getClientX(evt), mxEvent.getClientY(evt));\n * ```\n *\n * @param container DOM node to use for the offset.\n * @param x X-coordinate of the point to be converted.\n * @param y Y-coordinate of the point to be converted.\n */\nexport const convertPoint = (container, x, y) => {\n    const origin = getScrollOrigin(container, false);\n    const offset = getOffset(container);\n    offset.x -= origin.x;\n    offset.y -= origin.y;\n    return new Point(x - offset.x, y - offset.y);\n};\n/**\n * Assigns the value for the given key in the styles of the given cells, or\n * removes the key from the styles if the value is null.\n *\n * @param model <Transactions> to execute the transaction in.\n * @param cells Array of {@link Cells} to be updated.\n * @param key Key of the style to be changed.\n * @param value New value for the given key.\n */\nexport const setCellStyles = (model, cells, key, value) => {\n    if (cells.length > 0) {\n        model.batchUpdate(() => {\n            for (let i = 0; i < cells.length; i += 1) {\n                const cell = cells[i];\n                if (cell) {\n                    const style = cell.getStyle();\n                    style[key] = value;\n                    model.setStyle(cell, style);\n                }\n            }\n        });\n    }\n};\n/**\n * Sets or toggles the flag bit for the given key in the cell's styles.\n * If value is null then the flag is toggled.\n *\n * Example:\n *\n * ```javascript\n * let cells = graph.getSelectionCells();\n * mxUtils.setCellStyleFlags(graph.model,\n *       cells,\n *       mxConstants.STYLE_FONTSTYLE,\n *       mxConstants.FONT_BOLD);\n * ```\n *\n * Toggles the bold font style.\n *\n * @param model <Transactions> that contains the cells.\n * @param cells Array of {@link Cells} to change the style for.\n * @param key Key of the style to be changed.\n * @param flag Integer for the bit to be changed.\n * @param value Optional boolean value for the flag.\n */\nexport const setCellStyleFlags = (model, cells, key, flag, value) => {\n    if (cells.length > 0) {\n        model.batchUpdate(() => {\n            for (let i = 0; i < cells.length; i += 1) {\n                const cell = cells[i];\n                if (cell) {\n                    const style = setStyleFlag(cell.getStyle(), key, flag, value);\n                    model.setStyle(cell, style);\n                }\n            }\n        });\n    }\n};\n/**\n * Sets or removes the given key from the specified style and returns the\n * new style. If value is null then the flag is toggled.\n *\n * @param style The style of the Cell.\n * @param key Key of the style to be changed.\n * @param flag Integer for the bit to be changed.\n * @param value Optional boolean value for the given flag.\n */\nexport const setStyleFlag = (style, key, flag, value) => {\n    const v = style[key];\n    if (v === undefined) {\n        style[key] = value === undefined ? flag : 0;\n    }\n    else {\n        if (value === undefined) {\n            style[key] = v ^ flag;\n        }\n        else if (value) {\n            style[key] = v | flag;\n        }\n        else {\n            style[key] = v & ~flag;\n        }\n    }\n    return style;\n};\n/**\n * Sets the opacity of the specified DOM node to the given value in %.\n *\n * @param node DOM node to set the opacity for.\n * @param value Opacity in %. Possible values are between 0 and 100.\n */\nexport const setOpacity = (node, value) => {\n    node.style.opacity = String(value / 100);\n};\n/**\n * @param value the value to check.\n * @param mask the binary mask to apply.\n * @returns `true` if the value matches the binary mask.\n * @private Subject to change prior being part of the public API.\n */\nexport const matchBinaryMask = (value, mask) => {\n    return (value & mask) === mask;\n};\n/**\n * Returns an {@link Rectangle} with the size (width and height in pixels) of\n * the given string. The string may contain HTML markup. Newlines should be\n * converted to <br> before calling this method. The caller is responsible\n * for sanitizing the HTML markup.\n *\n * Example:\n *\n * ```javascript\n * let label = graph.getLabel(cell).replace(/\\n/g, \"<br>\");\n * let size = graph.getSizeForString(label);\n * ```\n *\n * @param text String whose size should be returned.\n * @param fontSize Integer that specifies the font size in pixels. Default is\n * {@link Constants#DEFAULT_FONTSIZE}.\n * @param fontFamily String that specifies the name of the font family. Default\n * is {@link Constants#DEFAULT_FONTFAMILY}.\n * @param textWidth Optional width for text wrapping.\n * @param fontStyle Optional font style.\n */\nexport const getSizeForString = (text, fontSize = DEFAULT_FONTSIZE, fontFamily = DEFAULT_FONTFAMILY, textWidth = null, fontStyle = null) => {\n    const div = document.createElement('div');\n    // Sets the font size and family\n    div.style.fontFamily = fontFamily;\n    div.style.fontSize = `${Math.round(fontSize)}px`;\n    div.style.lineHeight = `${Math.round(fontSize * LINE_HEIGHT)}px`;\n    // Sets the font style\n    if (fontStyle !== null) {\n        matchBinaryMask(fontStyle, FONT.BOLD) && (div.style.fontWeight = 'bold');\n        matchBinaryMask(fontStyle, FONT.ITALIC) && (div.style.fontWeight = 'italic');\n        const txtDecor = [];\n        matchBinaryMask(fontStyle, FONT.UNDERLINE) && txtDecor.push('underline');\n        matchBinaryMask(fontStyle, FONT.STRIKETHROUGH) && txtDecor.push('line-through');\n        txtDecor.length > 0 && (div.style.textDecoration = txtDecor.join(' '));\n    }\n    // Disables block layout and outside wrapping and hides the div\n    div.style.position = 'absolute';\n    div.style.visibility = 'hidden';\n    div.style.display = 'inline-block';\n    if (textWidth !== null) {\n        div.style.width = `${textWidth}px`;\n        div.style.whiteSpace = 'normal';\n    }\n    else {\n        div.style.whiteSpace = 'nowrap';\n    }\n    // Adds the text and inserts into DOM for updating of size\n    div.innerHTML = text;\n    document.body.appendChild(div);\n    // Gets the size and removes from DOM\n    const size = new Rectangle(0, 0, div.offsetWidth, div.offsetHeight);\n    document.body.removeChild(div);\n    return size;\n};\n/**\n * Sorts the given cells according to the order in the cell hierarchy.\n * Ascending is optional and defaults to true.\n */\nexport const sortCells = (cells, ascending = true) => {\n    const lookup = new Dictionary();\n    cells.sort((o1, o2) => {\n        let p1 = lookup.get(o1);\n        if (p1 == null) {\n            p1 = CellPath.create(o1).split(CellPath.PATH_SEPARATOR);\n            lookup.put(o1, p1);\n        }\n        let p2 = lookup.get(o2);\n        if (p2 == null) {\n            p2 = CellPath.create(o2).split(CellPath.PATH_SEPARATOR);\n            lookup.put(o2, p2);\n        }\n        const comp = CellPath.compare(p1, p2);\n        return comp == 0 ? 0 : comp > 0 == ascending ? 1 : -1;\n    });\n    return cells;\n};\n/**\n * Returns an {@link Point} that represents the horizontal and vertical alignment\n * for numeric computations. X is -0.5 for center, -1 for right and 0 for\n * left alignment. Y is -0.5 for middle, -1 for bottom and 0 for top\n * alignment. Default values for missing arguments is top, left.\n */\nexport const getAlignmentAsPoint = (align, valign) => {\n    let dx = -0.5;\n    let dy = -0.5;\n    // Horizontal alignment\n    if (align === ALIGN.LEFT) {\n        dx = 0;\n    }\n    else if (align === ALIGN.RIGHT) {\n        dx = -1;\n    }\n    // Vertical alignment\n    if (valign === ALIGN.TOP) {\n        dy = 0;\n    }\n    else if (valign === ALIGN.BOTTOM) {\n        dy = -1;\n    }\n    return new Point(dx, dy);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}