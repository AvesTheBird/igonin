import Cell from '../cell/Cell';
import Geometry from '../geometry/Geometry';
import Rectangle from '../geometry/Rectangle';
import CellState from '../cell/CellState';
import { Graph } from '../Graph';
import type { CellStateStyle, CellStyle, NumericCellStateStyleKeys } from '../../types';
declare module '../Graph' {
    interface Graph {
        cellsResizable: boolean;
        cellsBendable: boolean;
        cellsSelectable: boolean;
        cellsDisconnectable: boolean;
        autoSizeCells: boolean;
        autoSizeCellsOnAdd: boolean;
        cellsLocked: boolean;
        cellsCloneable: boolean;
        cellsDeletable: boolean;
        cellsMovable: boolean;
        extendParents: boolean;
        extendParentsOnAdd: boolean;
        extendParentsOnMove: boolean;
        getBoundingBox: (cells: Cell[]) => Rectangle | null;
        removeStateForCell: (cell: Cell) => void;
        getCurrentCellStyle: (cell: Cell, ignoreState?: boolean) => CellStateStyle;
        getCellStyle: (cell: Cell) => CellStateStyle;
        postProcessCellStyle: (style: CellStateStyle) => CellStateStyle;
        setCellStyle: (style: CellStyle, cells: Cell[]) => void;
        toggleCellStyle: (key: keyof CellStateStyle, defaultValue: boolean, cell: Cell) => boolean | null;
        toggleCellStyles: (key: keyof CellStateStyle, defaultValue: boolean, cells: Cell[]) => boolean | null;
        setCellStyles: (key: keyof CellStateStyle, value: CellStateStyle[keyof CellStateStyle], cells?: Cell[]) => void;
        toggleCellStyleFlags: (key: NumericCellStateStyleKeys, flag: number, cells?: Cell[] | null) => void;
        setCellStyleFlags: (key: NumericCellStateStyleKeys, flag: number, value?: boolean | null, cells?: Cell[] | null) => void;
        alignCells: (align: string, cells?: Cell[], param?: number | null) => void;
        cloneCell: (cell: Cell, allowInvalidEdges?: boolean, mapping?: any, keepPosition?: boolean) => Cell;
        cloneCells: (cells: Cell[], allowInvalidEdges?: boolean, mapping?: any, keepPosition?: boolean) => Cell[];
        addCell: (cell: Cell, parent: Cell | null, index?: number | null, source?: Cell | null, target?: Cell | null) => Cell;
        addCells: (cells: Cell[], parent: Cell | null, index: number | null, source: Cell | null, target: Cell | null, absolute?: boolean) => Cell[];
        cellsAdded: (cells: Cell[], parent: Cell, index: number, source: Cell | null, target: Cell | null, absolute: boolean, constrain?: boolean, extend?: boolean) => void;
        autoSizeCell: (cell: Cell, recurse?: boolean) => void;
        removeCells: (cells?: Cell[] | null, includeEdges?: boolean | null) => Cell[];
        cellsRemoved: (cells: Cell[]) => void;
        toggleCells: (show: boolean, cells: Cell[], includeEdges: boolean) => Cell[];
        cellsToggled: (cells: Cell[], show: boolean) => void;
        updateCellSize: (cell: Cell, ignoreChildren?: boolean) => Cell;
        cellSizeUpdated: (cell: Cell, ignoreChildren: boolean) => void;
        getPreferredSizeForCell: (cell: Cell, textWidth?: number | null) => Rectangle | null;
        resizeCell: (cell: Cell, bounds: Rectangle, recurse?: boolean) => Cell;
        resizeCells: (cells: Cell[], bounds: Rectangle[], recurse: boolean) => Cell[];
        cellsResized: (cells: Cell[], bounds: Rectangle[], recurse: boolean) => void;
        cellResized: (cell: Cell, bounds: Rectangle, ignoreRelative: boolean, recurse: boolean) => Geometry | null;
        resizeChildCells: (cell: Cell, newGeo: Geometry) => void;
        constrainChildCells: (cell: Cell) => void;
        scaleCell: (cell: Cell, dx: number, dy: number, recurse: boolean) => void;
        extendParent: (cell: Cell) => void;
        /**
         * Clones and inserts the given cells into the graph using the move method and returns the inserted cells. This shortcut
         * is used if cells are inserted via data transfer.
         *
         * @param cells Array of {@link Cell} to be imported.
         * @param dx Integer that specifies the x-coordinate of the vector. Default is `0`.
         * @param dy Integer that specifies the y-coordinate of the vector. Default is `0`.
         * @param target {@link mxCell} that represents the new parent of the cells.
         * @param evt {@link MouseEvent} that triggered the invocation.
         * @param mapping Optional mapping for existing clones.
         * @returns the cells that were imported.
         */
        importCells: (cells: Cell[], dx?: number, dy?: number, target?: Cell | null, evt?: MouseEvent | null, mapping?: any) => Cell[];
        /**
         * Moves or clones the specified cells and moves the cells or clones by the given amount, adding them to the optional
         * target cell. The `evt` is the mouse event as the mouse was released. The change is carried out using {@link cellsMoved}.
         * This method fires {@link Event#MOVE_CELLS} while the transaction is in progress.
         *
         * Use the following code to move all cells in the graph.
         *
         * ```javascript
         * graph.moveCells(graph.getChildCells(null, true, true), 10, 10);
         * ```
         *
         * @param cells Array of {@link Cell} to be moved, cloned or added to the target.
         * @param dx Integer that specifies the x-coordinate of the vector. Default is `0`.
         * @param dy Integer that specifies the y-coordinate of the vector. Default is `0`.
         * @param clone Boolean indicating if the cells should be cloned. Default is `false`.
         * @param target {@link Cell} that represents the new parent of the cells.
         * @param evt {@link MouseEvent} that triggered the invocation.
         * @param mapping Optional mapping for existing clones.
         * @returns the cells that were moved.
         */
        moveCells: (cells: Cell[], dx?: number, dy?: number, clone?: boolean, target?: Cell | null, evt?: MouseEvent | null, mapping?: any) => Cell[];
        cellsMoved: (cells: Cell[], dx: number, dy: number, disconnect: boolean, constrain: boolean, extend?: boolean | null) => void;
        translateCell: (cell: Cell, dx: number, dy: number) => void;
        getCellContainmentArea: (cell: Cell) => Rectangle | null;
        constrainChild: (cell: Cell, sizeFirst?: boolean) => void;
        getChildCells: (parent?: Cell | null, vertices?: boolean, edges?: boolean) => Cell[];
        getCellAt: (x: number, y: number, parent?: Cell | null, vertices?: boolean | null, edges?: boolean | null, ignoreFn?: Function | null) => Cell | null;
        getCells: (x: number, y: number, width: number, height: number, parent?: Cell | null, result?: Cell[], intersection?: Rectangle | null, ignoreFn?: Function | null, includeDescendants?: boolean) => Cell[];
        getCellsBeyond: (x0: number, y0: number, parent: Cell | null, rightHalfpane: boolean, bottomHalfpane: boolean) => Cell[];
        intersects: (state: CellState, x: number, y: number) => boolean;
        isValidAncestor: (cell: Cell, parent: Cell, recurse: boolean) => boolean;
        isCellLocked: (cell: Cell) => boolean;
        isCellsLocked: () => boolean;
        setCellsLocked: (value: boolean) => void;
        getCloneableCells: (cells: Cell[]) => Cell[];
        isCellCloneable: (cell: Cell) => boolean;
        isCellsCloneable: () => boolean;
        setCellsCloneable: (value: boolean) => void;
        getExportableCells: (cells: Cell[]) => Cell[];
        canExportCell: (cell: Cell | null) => boolean;
        getImportableCells: (cells: Cell[]) => Cell[];
        canImportCell: (cell: Cell | null) => boolean;
        isCellSelectable: (cell: Cell) => boolean;
        isCellsSelectable: () => boolean;
        setCellsSelectable: (value: boolean) => void;
        getDeletableCells: (cells: Cell[]) => Cell[];
        isCellDeletable: (cell: Cell) => boolean;
        isCellsDeletable: () => boolean;
        setCellsDeletable: (value: boolean) => void;
        isCellRotatable: (cell: Cell) => boolean;
        getMovableCells: (cells: Cell[]) => Cell[];
        isCellMovable: (cell: Cell) => boolean;
        isCellsMovable: () => boolean;
        setCellsMovable: (value: boolean) => void;
        isCellResizable: (cell: Cell) => boolean;
        isCellsResizable: () => boolean;
        setCellsResizable: (value: boolean) => void;
        isCellBendable: (cell: Cell) => boolean;
        isCellsBendable: () => boolean;
        setCellsBendable: (value: boolean) => void;
        isAutoSizeCell: (cell: Cell) => boolean;
        isAutoSizeCells: () => boolean;
        setAutoSizeCells: (value: boolean) => void;
        isExtendParent: (cell: Cell) => boolean;
        isExtendParents: () => boolean;
        setExtendParents: (value: boolean) => void;
        isExtendParentsOnAdd: (cell: Cell) => boolean;
        setExtendParentsOnAdd: (value: boolean) => void;
        isExtendParentsOnMove: () => boolean;
        setExtendParentsOnMove: (value: boolean) => void;
        getCursorForCell: (cell: Cell) => string | null;
        getCellBounds: (cell: Cell, includeEdges?: boolean, includeDescendants?: boolean) => Rectangle | null;
        getBoundingBoxFromGeometry: (cells: Cell[], includeEdges?: boolean) => Rectangle | null;
    }
}
type PartialGraph = Pick<Graph, 'getView' | 'getStylesheet' | 'batchUpdate' | 'getDataModel' | 'fireEvent' | 'getDefaultParent' | 'getCurrentRoot' | 'getOverlap' | 'isRecursiveResize' | 'getCellRenderer' | 'getMaximumGraphBounds' | 'isExportEnabled' | 'isImportEnabled' | 'getImageFromBundles' | 'getSelectionCells' | 'getSelectionCell' | 'addAllEdges' | 'getAllEdges' | 'isCloneInvalidEdges' | 'isAllowDanglingEdges' | 'resetEdges' | 'isResetEdgesOnResize' | 'isResetEdgesOnMove' | 'isConstrainChild' | 'cellConnected' | 'isDisconnectOnMove' | 'isConstrainRelativeChildren' | 'disconnectGraph' | 'getEdgeValidationError' | 'getFoldingImage' | 'isHtmlLabel' | 'isGridEnabled' | 'snap' | 'getGridSize' | 'isAllowNegativeCoordinates' | 'setAllowNegativeCoordinates' | 'getEventTolerance' | 'isSwimlane' | 'getStartSize'>;
type PartialCells = Pick<Graph, 'cellsResizable' | 'cellsBendable' | 'cellsSelectable' | 'cellsDisconnectable' | 'autoSizeCells' | 'autoSizeCellsOnAdd' | 'cellsLocked' | 'cellsCloneable' | 'cellsDeletable' | 'cellsMovable' | 'extendParents' | 'extendParentsOnAdd' | 'extendParentsOnMove' | 'getBoundingBox' | 'removeStateForCell' | 'getCurrentCellStyle' | 'getCellStyle' | 'postProcessCellStyle' | 'setCellStyle' | 'toggleCellStyle' | 'toggleCellStyles' | 'setCellStyles' | 'toggleCellStyleFlags' | 'setCellStyleFlags' | 'alignCells' | 'cloneCell' | 'cloneCells' | 'addCell' | 'addCells' | 'cellsAdded' | 'autoSizeCell' | 'removeCells' | 'cellsRemoved' | 'toggleCells' | 'cellsToggled' | 'updateCellSize' | 'cellSizeUpdated' | 'getPreferredSizeForCell' | 'resizeCell' | 'resizeCells' | 'cellResized' | 'cellsResized' | 'resizeChildCells' | 'constrainChildCells' | 'scaleCell' | 'extendParent' | 'importCells' | 'moveCells' | 'cellsMoved' | 'translateCell' | 'getCellContainmentArea' | 'constrainChild' | 'getChildCells' | 'getCellAt' | 'getCells' | 'getCellsBeyond' | 'intersects' | 'isValidAncestor' | 'isCellLocked' | 'isCellsLocked' | 'setCellsLocked' | 'getCloneableCells' | 'isCellCloneable' | 'isCellsCloneable' | 'setCellsCloneable' | 'getExportableCells' | 'canExportCell' | 'getImportableCells' | 'canImportCell' | 'isCellSelectable' | 'isCellsSelectable' | 'setCellsSelectable' | 'getDeletableCells' | 'isCellDeletable' | 'isCellsDeletable' | 'setCellsDeletable' | 'isCellRotatable' | 'getMovableCells' | 'isCellMovable' | 'isCellsMovable' | 'setCellsMovable' | 'isCellResizable' | 'isCellsResizable' | 'setCellsResizable' | 'isCellBendable' | 'isCellsBendable' | 'setCellsBendable' | 'isAutoSizeCell' | 'isAutoSizeCells' | 'setAutoSizeCells' | 'isExtendParent' | 'isExtendParents' | 'setExtendParents' | 'isExtendParentsOnAdd' | 'setExtendParentsOnAdd' | 'isExtendParentsOnMove' | 'setExtendParentsOnMove' | 'getCursorForCell' | 'getCellBounds' | 'getBoundingBoxFromGeometry'>;
type PartialType = PartialGraph & PartialCells;
export declare const CellsMixin: PartialType;
export {};
